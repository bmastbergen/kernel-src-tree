iommu: Constify struct iommu_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] Constify struct iommu_ops (Myron Stowe) [1279620]
Rebuild_FUZZ: 87.72%
commit-author Thierry Reding <treding@nvidia.com>
commit b22f6434cf48af001330e370e9d781aeb668f98c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b22f6434.failed

This structure is read-only data and should never be modified.

	Signed-off-by: Thierry Reding <treding@nvidia.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit b22f6434cf48af001330e370e9d781aeb668f98c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/arm-smmu.c
#	drivers/iommu/exynos-iommu.c
#	drivers/iommu/fsl_pamu_domain.c
#	drivers/iommu/ipmmu-vmsa.c
#	drivers/iommu/omap-iommu.c
diff --cc drivers/iommu/exynos-iommu.c
index 3f32d64ab87a,d037e87a1fe5..000000000000
--- a/drivers/iommu/exynos-iommu.c
+++ b/drivers/iommu/exynos-iommu.c
@@@ -1054,14 -1144,42 +1054,53 @@@ static phys_addr_t exynos_iommu_iova_to
  	return phys;
  }
  
++<<<<<<< HEAD
 +static struct iommu_ops exynos_iommu_ops = {
 +	.domain_init = &exynos_iommu_domain_init,
 +	.domain_destroy = &exynos_iommu_domain_destroy,
 +	.attach_dev = &exynos_iommu_attach_device,
 +	.detach_dev = &exynos_iommu_detach_device,
 +	.map = &exynos_iommu_map,
 +	.unmap = &exynos_iommu_unmap,
 +	.iova_to_phys = &exynos_iommu_iova_to_phys,
++=======
+ static int exynos_iommu_add_device(struct device *dev)
+ {
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	group = iommu_group_get(dev);
+ 
+ 	if (!group) {
+ 		group = iommu_group_alloc();
+ 		if (IS_ERR(group)) {
+ 			dev_err(dev, "Failed to allocate IOMMU group\n");
+ 			return PTR_ERR(group);
+ 		}
+ 	}
+ 
+ 	ret = iommu_group_add_device(group, dev);
+ 	iommu_group_put(group);
+ 
+ 	return ret;
+ }
+ 
+ static void exynos_iommu_remove_device(struct device *dev)
+ {
+ 	iommu_group_remove_device(dev);
+ }
+ 
+ static const struct iommu_ops exynos_iommu_ops = {
+ 	.domain_init = exynos_iommu_domain_init,
+ 	.domain_destroy = exynos_iommu_domain_destroy,
+ 	.attach_dev = exynos_iommu_attach_device,
+ 	.detach_dev = exynos_iommu_detach_device,
+ 	.map = exynos_iommu_map,
+ 	.unmap = exynos_iommu_unmap,
+ 	.iova_to_phys = exynos_iommu_iova_to_phys,
+ 	.add_device = exynos_iommu_add_device,
+ 	.remove_device = exynos_iommu_remove_device,
++>>>>>>> b22f6434cf48 (iommu: Constify struct iommu_ops)
  	.pgsize_bitmap = SECT_SIZE | LPAGE_SIZE | SPAGE_SIZE,
  };
  
diff --cc drivers/iommu/omap-iommu.c
index e02e5d71745b,031b2476bcc4..000000000000
--- a/drivers/iommu/omap-iommu.c
+++ b/drivers/iommu/omap-iommu.c
@@@ -1254,7 -1253,45 +1254,22 @@@ static int omap_iommu_domain_has_cap(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct iommu_ops omap_iommu_ops = {
++=======
+ static void omap_iommu_remove_device(struct device *dev)
+ {
+ 	struct omap_iommu_arch_data *arch_data = dev->archdata.iommu;
+ 
+ 	if (!dev->of_node || !arch_data)
+ 		return;
+ 
+ 	kfree(arch_data->name);
+ 	kfree(arch_data);
+ }
+ 
+ static const struct iommu_ops omap_iommu_ops = {
++>>>>>>> b22f6434cf48 (iommu: Constify struct iommu_ops)
  	.domain_init	= omap_iommu_domain_init,
  	.domain_destroy	= omap_iommu_domain_destroy,
  	.attach_dev	= omap_iommu_attach_dev,
* Unmerged path drivers/iommu/arm-smmu.c
* Unmerged path drivers/iommu/fsl_pamu_domain.c
* Unmerged path drivers/iommu/ipmmu-vmsa.c
diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c
index 3e37eadef890..095f286acb97 100644
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@ -80,7 +80,7 @@ LIST_HEAD(hpet_map);
  */
 static struct protection_domain *pt_domain;
 
-static struct iommu_ops amd_iommu_ops;
+static const struct iommu_ops amd_iommu_ops;
 
 static ATOMIC_NOTIFIER_HEAD(ppr_notifier);
 int amd_iommu_max_glx_val = -1;
@@ -3396,7 +3396,7 @@ static int amd_iommu_domain_has_cap(struct iommu_domain *domain,
 	return 0;
 }
 
-static struct iommu_ops amd_iommu_ops = {
+static const struct iommu_ops amd_iommu_ops = {
 	.domain_init = amd_iommu_domain_init,
 	.domain_destroy = amd_iommu_domain_destroy,
 	.attach_dev = amd_iommu_attach_device,
* Unmerged path drivers/iommu/arm-smmu.c
* Unmerged path drivers/iommu/exynos-iommu.c
* Unmerged path drivers/iommu/fsl_pamu_domain.c
diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index dae8604bf9a7..a1bcd709784c 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -448,7 +448,7 @@ EXPORT_SYMBOL_GPL(intel_iommu_gfx_mapped);
 static DEFINE_SPINLOCK(device_domain_lock);
 static LIST_HEAD(device_domain_list);
 
-static struct iommu_ops intel_iommu_ops;
+static const struct iommu_ops intel_iommu_ops;
 
 static int __init intel_iommu_setup(char *str)
 {
@@ -4449,7 +4449,7 @@ static void intel_iommu_remove_device(struct device *dev)
 	iommu_device_unlink(iommu->iommu_dev, dev);
 }
 
-static struct iommu_ops intel_iommu_ops = {
+static const struct iommu_ops intel_iommu_ops = {
 	.domain_init	= intel_iommu_domain_init,
 	.domain_destroy = intel_iommu_domain_destroy,
 	.attach_dev	= intel_iommu_attach_device,
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index 8cff55fca58c..01d19097d03f 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -37,6 +37,10 @@ static struct kset *iommu_group_kset;
 static struct ida iommu_group_ida;
 static struct mutex iommu_group_mutex;
 
+struct iommu_callback_data {
+	const struct iommu_ops *ops;
+};
+
 struct iommu_group {
 	struct kobject kobj;
 	struct kobject *devices_kobj;
@@ -729,7 +733,8 @@ struct iommu_group *iommu_group_get_for_dev(struct device *dev)
 
 static int add_iommu_group(struct device *dev, void *data)
 {
-	struct iommu_ops *ops = data;
+	struct iommu_callback_data *cb = data;
+	const struct iommu_ops *ops = cb->ops;
 
 	if (!ops->add_device)
 		return -ENODEV;
@@ -745,7 +750,7 @@ static int iommu_bus_notifier(struct notifier_block *nb,
 			      unsigned long action, void *data)
 {
 	struct device *dev = data;
-	struct iommu_ops *ops = dev->bus->iommu_ops;
+	const struct iommu_ops *ops = dev->bus->iommu_ops;
 	struct iommu_group *group;
 	unsigned long group_action = 0;
 
@@ -798,10 +803,14 @@ static struct notifier_block iommu_bus_nb = {
 	.notifier_call = iommu_bus_notifier,
 };
 
-static void iommu_bus_init(struct bus_type *bus, struct iommu_ops *ops)
+static void iommu_bus_init(struct bus_type *bus, const struct iommu_ops *ops)
 {
+	struct iommu_callback_data cb = {
+		.ops = ops,
+	};
+
 	bus_register_notifier(bus, &iommu_bus_nb);
-	bus_for_each_dev(bus, NULL, ops, add_iommu_group);
+	bus_for_each_dev(bus, NULL, &cb, add_iommu_group);
 }
 
 /**
@@ -817,7 +826,7 @@ static void iommu_bus_init(struct bus_type *bus, struct iommu_ops *ops)
  * is set up. With this function the iommu-driver can set the iommu-ops
  * afterwards.
  */
-int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops)
+int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops)
 {
 	if (bus->iommu_ops != NULL)
 		return -EBUSY;
* Unmerged path drivers/iommu/ipmmu-vmsa.c
diff --git a/drivers/iommu/msm_iommu.c b/drivers/iommu/msm_iommu.c
index 8ab4f41090af..93a0103acec7 100644
--- a/drivers/iommu/msm_iommu.c
+++ b/drivers/iommu/msm_iommu.c
@@ -674,7 +674,7 @@ fail:
 	return 0;
 }
 
-static struct iommu_ops msm_iommu_ops = {
+static const struct iommu_ops msm_iommu_ops = {
 	.domain_init = msm_iommu_domain_init,
 	.domain_destroy = msm_iommu_domain_destroy,
 	.attach_dev = msm_iommu_attach_dev,
* Unmerged path drivers/iommu/omap-iommu.c
diff --git a/drivers/iommu/shmobile-iommu.c b/drivers/iommu/shmobile-iommu.c
index d572863dfccd..e3fb68750890 100644
--- a/drivers/iommu/shmobile-iommu.c
+++ b/drivers/iommu/shmobile-iommu.c
@@ -354,7 +354,7 @@ static int shmobile_iommu_add_device(struct device *dev)
 	return 0;
 }
 
-static struct iommu_ops shmobile_iommu_ops = {
+static const struct iommu_ops shmobile_iommu_ops = {
 	.domain_init = shmobile_iommu_domain_init,
 	.domain_destroy = shmobile_iommu_domain_destroy,
 	.attach_dev = shmobile_iommu_attach_device,
diff --git a/drivers/iommu/tegra-gart.c b/drivers/iommu/tegra-gart.c
index 108c0e9c24d9..56a68e76a5c2 100644
--- a/drivers/iommu/tegra-gart.c
+++ b/drivers/iommu/tegra-gart.c
@@ -309,7 +309,7 @@ static int gart_iommu_domain_has_cap(struct iommu_domain *domain,
 	return 0;
 }
 
-static struct iommu_ops gart_iommu_ops = {
+static const struct iommu_ops gart_iommu_ops = {
 	.domain_init	= gart_iommu_domain_init,
 	.domain_destroy	= gart_iommu_domain_destroy,
 	.attach_dev	= gart_iommu_attach_dev,
diff --git a/drivers/iommu/tegra-smmu.c b/drivers/iommu/tegra-smmu.c
index f6f120e25409..7549ba807200 100644
--- a/drivers/iommu/tegra-smmu.c
+++ b/drivers/iommu/tegra-smmu.c
@@ -947,7 +947,7 @@ static void smmu_iommu_domain_destroy(struct iommu_domain *domain)
 	dev_dbg(smmu->dev, "smmu_as@%p\n", as);
 }
 
-static struct iommu_ops smmu_iommu_ops = {
+static const struct iommu_ops smmu_iommu_ops = {
 	.domain_init	= smmu_iommu_domain_init,
 	.domain_destroy	= smmu_iommu_domain_destroy,
 	.attach_dev	= smmu_iommu_attach_dev,
diff --git a/include/linux/device.h b/include/linux/device.h
index bb0ccc13d33f..1dfe3d087e6d 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -129,7 +129,7 @@ struct bus_type {
 
 	const struct dev_pm_ops *pm;
 
-	struct iommu_ops *iommu_ops;
+	const struct iommu_ops *iommu_ops;
 
 	struct subsys_private *p;
 	struct lock_class_key lock_key;
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 6bab130af9c5..77f78da17e17 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -50,7 +50,7 @@ struct iommu_domain_geometry {
 };
 
 struct iommu_domain {
-	struct iommu_ops *ops;
+	const struct iommu_ops *ops;
 	void *priv;
 	iommu_fault_handler_t handler;
 	void *handler_token;
@@ -124,7 +124,7 @@ struct iommu_ops {
 #define IOMMU_GROUP_NOTIFY_UNBIND_DRIVER	5 /* Pre Driver unbind */
 #define IOMMU_GROUP_NOTIFY_UNBOUND_DRIVER	6 /* Post Driver unbind */
 
-extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
+extern int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops);
 extern bool iommu_present(struct bus_type *bus);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
 extern struct iommu_group *iommu_group_get_by_id(int id);
