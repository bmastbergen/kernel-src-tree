libnvdimm, pmem: allow nfit_test to override pmem_direct_access()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit f295e53b60eb93ee53ed5ac610374ed293caa57b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f295e53b.failed

Currently phys_to_pfn_t() is an exported symbol to allow nfit_test to
override it and indicate that nfit_test-pmem is not device-mapped.  Now,
we want to enable nfit_test to operate without DMA_CMA and the pmem it
provides will no longer be physically contiguous, i.e. won't be capable
of supporting direct_access requests larger than a page.  Make
pmem_direct_access() a weak symbol so that it can be replaced by the
tools/testing/nvdimm/ version, and move phys_to_pfn_t() to a static
inline now that it no longer needs to be overridden.

	Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit f295e53b60eb93ee53ed5ac610374ed293caa57b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/pmem.c
#	include/linux/pfn_t.h
#	kernel/memremap.c
#	tools/testing/nvdimm/Kbuild
#	tools/testing/nvdimm/test/iomap.c
#	tools/testing/nvdimm/test/nfit_test.h
diff --cc kernel/memremap.c
index 7a9076d005e6,852e5266124a..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -146,3 -168,258 +146,261 @@@ void devm_memunmap(struct device *dev, 
  				devm_memremap_match, addr));
  }
  EXPORT_SYMBOL(devm_memunmap);
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_ZONE_DEVICE
+ static DEFINE_MUTEX(pgmap_lock);
+ static RADIX_TREE(pgmap_radix, GFP_KERNEL);
+ #define SECTION_MASK ~((1UL << PA_SECTION_SHIFT) - 1)
+ #define SECTION_SIZE (1UL << PA_SECTION_SHIFT)
+ 
+ struct page_map {
+ 	struct resource res;
+ 	struct percpu_ref *ref;
+ 	struct dev_pagemap pgmap;
+ 	struct vmem_altmap altmap;
+ };
+ 
+ void get_zone_device_page(struct page *page)
+ {
+ 	percpu_ref_get(page->pgmap->ref);
+ }
+ EXPORT_SYMBOL(get_zone_device_page);
+ 
+ void put_zone_device_page(struct page *page)
+ {
+ 	put_dev_pagemap(page->pgmap);
+ }
+ EXPORT_SYMBOL(put_zone_device_page);
+ 
+ static void pgmap_radix_release(struct resource *res)
+ {
+ 	resource_size_t key, align_start, align_size, align_end;
+ 
+ 	align_start = res->start & ~(SECTION_SIZE - 1);
+ 	align_size = ALIGN(resource_size(res), SECTION_SIZE);
+ 	align_end = align_start + align_size - 1;
+ 
+ 	mutex_lock(&pgmap_lock);
+ 	for (key = res->start; key <= res->end; key += SECTION_SIZE)
+ 		radix_tree_delete(&pgmap_radix, key >> PA_SECTION_SHIFT);
+ 	mutex_unlock(&pgmap_lock);
+ }
+ 
+ static unsigned long pfn_first(struct page_map *page_map)
+ {
+ 	struct dev_pagemap *pgmap = &page_map->pgmap;
+ 	const struct resource *res = &page_map->res;
+ 	struct vmem_altmap *altmap = pgmap->altmap;
+ 	unsigned long pfn;
+ 
+ 	pfn = res->start >> PAGE_SHIFT;
+ 	if (altmap)
+ 		pfn += vmem_altmap_offset(altmap);
+ 	return pfn;
+ }
+ 
+ static unsigned long pfn_end(struct page_map *page_map)
+ {
+ 	const struct resource *res = &page_map->res;
+ 
+ 	return (res->start + resource_size(res)) >> PAGE_SHIFT;
+ }
+ 
+ #define for_each_device_pfn(pfn, map) \
+ 	for (pfn = pfn_first(map); pfn < pfn_end(map); pfn++)
+ 
+ static void devm_memremap_pages_release(struct device *dev, void *data)
+ {
+ 	struct page_map *page_map = data;
+ 	struct resource *res = &page_map->res;
+ 	resource_size_t align_start, align_size;
+ 	struct dev_pagemap *pgmap = &page_map->pgmap;
+ 
+ 	if (percpu_ref_tryget_live(pgmap->ref)) {
+ 		dev_WARN(dev, "%s: page mapping is still live!\n", __func__);
+ 		percpu_ref_put(pgmap->ref);
+ 	}
+ 
+ 	/* pages are dead and unused, undo the arch mapping */
+ 	align_start = res->start & ~(SECTION_SIZE - 1);
+ 	align_size = ALIGN(resource_size(res), SECTION_SIZE);
+ 	arch_remove_memory(align_start, align_size);
+ 	pgmap_radix_release(res);
+ 	dev_WARN_ONCE(dev, pgmap->altmap && pgmap->altmap->alloc,
+ 			"%s: failed to free all reserved pages\n", __func__);
+ }
+ 
+ /* assumes rcu_read_lock() held at entry */
+ struct dev_pagemap *find_dev_pagemap(resource_size_t phys)
+ {
+ 	struct page_map *page_map;
+ 
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 
+ 	page_map = radix_tree_lookup(&pgmap_radix, phys >> PA_SECTION_SHIFT);
+ 	return page_map ? &page_map->pgmap : NULL;
+ }
+ 
+ /**
+  * devm_memremap_pages - remap and provide memmap backing for the given resource
+  * @dev: hosting device for @res
+  * @res: "host memory" address range
+  * @ref: a live per-cpu reference count
+  * @altmap: optional descriptor for allocating the memmap from @res
+  *
+  * Notes:
+  * 1/ @ref must be 'live' on entry and 'dead' before devm_memunmap_pages() time
+  *    (or devm release event).
+  *
+  * 2/ @res is expected to be a host memory range that could feasibly be
+  *    treated as a "System RAM" range, i.e. not a device mmio range, but
+  *    this is not enforced.
+  */
+ void *devm_memremap_pages(struct device *dev, struct resource *res,
+ 		struct percpu_ref *ref, struct vmem_altmap *altmap)
+ {
+ 	resource_size_t key, align_start, align_size, align_end;
+ 	struct dev_pagemap *pgmap;
+ 	struct page_map *page_map;
+ 	int error, nid, is_ram;
+ 	unsigned long pfn;
+ 
+ 	align_start = res->start & ~(SECTION_SIZE - 1);
+ 	align_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)
+ 		- align_start;
+ 	is_ram = region_intersects(align_start, align_size,
+ 		IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);
+ 
+ 	if (is_ram == REGION_MIXED) {
+ 		WARN_ONCE(1, "%s attempted on mixed region %pr\n",
+ 				__func__, res);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 
+ 	if (is_ram == REGION_INTERSECTS)
+ 		return __va(res->start);
+ 
+ 	if (altmap && !IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP)) {
+ 		dev_err(dev, "%s: altmap requires CONFIG_SPARSEMEM_VMEMMAP=y\n",
+ 				__func__);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 
+ 	if (!ref)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	page_map = devres_alloc_node(devm_memremap_pages_release,
+ 			sizeof(*page_map), GFP_KERNEL, dev_to_node(dev));
+ 	if (!page_map)
+ 		return ERR_PTR(-ENOMEM);
+ 	pgmap = &page_map->pgmap;
+ 
+ 	memcpy(&page_map->res, res, sizeof(*res));
+ 
+ 	pgmap->dev = dev;
+ 	if (altmap) {
+ 		memcpy(&page_map->altmap, altmap, sizeof(*altmap));
+ 		pgmap->altmap = &page_map->altmap;
+ 	}
+ 	pgmap->ref = ref;
+ 	pgmap->res = &page_map->res;
+ 
+ 	mutex_lock(&pgmap_lock);
+ 	error = 0;
+ 	align_end = align_start + align_size - 1;
+ 	for (key = align_start; key <= align_end; key += SECTION_SIZE) {
+ 		struct dev_pagemap *dup;
+ 
+ 		rcu_read_lock();
+ 		dup = find_dev_pagemap(key);
+ 		rcu_read_unlock();
+ 		if (dup) {
+ 			dev_err(dev, "%s: %pr collides with mapping for %s\n",
+ 					__func__, res, dev_name(dup->dev));
+ 			error = -EBUSY;
+ 			break;
+ 		}
+ 		error = radix_tree_insert(&pgmap_radix, key >> PA_SECTION_SHIFT,
+ 				page_map);
+ 		if (error) {
+ 			dev_err(dev, "%s: failed: %d\n", __func__, error);
+ 			break;
+ 		}
+ 	}
+ 	mutex_unlock(&pgmap_lock);
+ 	if (error)
+ 		goto err_radix;
+ 
+ 	nid = dev_to_node(dev);
+ 	if (nid < 0)
+ 		nid = numa_mem_id();
+ 
+ 	error = arch_add_memory(nid, align_start, align_size, true);
+ 	if (error)
+ 		goto err_add_memory;
+ 
+ 	for_each_device_pfn(pfn, page_map) {
+ 		struct page *page = pfn_to_page(pfn);
+ 
+ 		/*
+ 		 * ZONE_DEVICE pages union ->lru with a ->pgmap back
+ 		 * pointer.  It is a bug if a ZONE_DEVICE page is ever
+ 		 * freed or placed on a driver-private list.  Seed the
+ 		 * storage with LIST_POISON* values.
+ 		 */
+ 		list_del(&page->lru);
+ 		page->pgmap = pgmap;
+ 	}
+ 	devres_add(dev, page_map);
+ 	return __va(res->start);
+ 
+  err_add_memory:
+  err_radix:
+ 	pgmap_radix_release(res);
+ 	devres_free(page_map);
+ 	return ERR_PTR(error);
+ }
+ EXPORT_SYMBOL(devm_memremap_pages);
+ 
+ unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)
+ {
+ 	/* number of pfns from base where pfn_to_page() is valid */
+ 	return altmap->reserve + altmap->free;
+ }
+ 
+ void vmem_altmap_free(struct vmem_altmap *altmap, unsigned long nr_pfns)
+ {
+ 	altmap->alloc -= nr_pfns;
+ }
+ 
+ #ifdef CONFIG_SPARSEMEM_VMEMMAP
+ struct vmem_altmap *to_vmem_altmap(unsigned long memmap_start)
+ {
+ 	/*
+ 	 * 'memmap_start' is the virtual address for the first "struct
+ 	 * page" in this range of the vmemmap array.  In the case of
+ 	 * CONFIG_SPARSEMEM_VMEMMAP a page_to_pfn conversion is simple
+ 	 * pointer arithmetic, so we can perform this to_vmem_altmap()
+ 	 * conversion without concern for the initialization state of
+ 	 * the struct page fields.
+ 	 */
+ 	struct page *page = (struct page *) memmap_start;
+ 	struct dev_pagemap *pgmap;
+ 
+ 	/*
+ 	 * Unconditionally retrieve a dev_pagemap associated with the
+ 	 * given physical address, this is only for use in the
+ 	 * arch_{add|remove}_memory() for setting up and tearing down
+ 	 * the memmap.
+ 	 */
+ 	rcu_read_lock();
+ 	pgmap = find_dev_pagemap(__pfn_to_phys(page_to_pfn(page)));
+ 	rcu_read_unlock();
+ 
+ 	return pgmap ? pgmap->altmap : NULL;
+ }
+ #endif /* CONFIG_SPARSEMEM_VMEMMAP */
+ #endif /* CONFIG_ZONE_DEVICE */
++>>>>>>> f295e53b60eb (libnvdimm, pmem: allow nfit_test to override pmem_direct_access())
* Unmerged path drivers/nvdimm/pmem.c
* Unmerged path include/linux/pfn_t.h
* Unmerged path tools/testing/nvdimm/Kbuild
* Unmerged path tools/testing/nvdimm/test/iomap.c
* Unmerged path tools/testing/nvdimm/test/nfit_test.h
* Unmerged path drivers/nvdimm/pmem.c
diff --git a/drivers/nvdimm/pmem.h b/drivers/nvdimm/pmem.h
new file mode 100644
index 000000000000..c48d4e3aa346
--- /dev/null
+++ b/drivers/nvdimm/pmem.h
@@ -0,0 +1,24 @@
+#ifndef __NVDIMM_PMEM_H__
+#define __NVDIMM_PMEM_H__
+#include <linux/badblocks.h>
+#include <linux/types.h>
+#include <linux/pfn_t.h>
+#include <linux/fs.h>
+
+long pmem_direct_access(struct block_device *bdev, sector_t sector,
+		      void __pmem **kaddr, pfn_t *pfn, long size);
+/* this definition is in it's own header for tools/testing/nvdimm to consume */
+struct pmem_device {
+	/* One contiguous memory region per device */
+	phys_addr_t		phys_addr;
+	/* when non-zero this device is hosting a 'pfn' instance */
+	phys_addr_t		data_offset;
+	u64			pfn_flags;
+	void __pmem		*virt_addr;
+	/* immutable base size of the namespace */
+	size_t			size;
+	/* trim size when namespace capacity has been section aligned */
+	u32			pfn_pad;
+	struct badblocks	bb;
+};
+#endif /* __NVDIMM_PMEM_H__ */
* Unmerged path include/linux/pfn_t.h
* Unmerged path kernel/memremap.c
* Unmerged path tools/testing/nvdimm/Kbuild
diff --git a/tools/testing/nvdimm/pmem-dax.c b/tools/testing/nvdimm/pmem-dax.c
new file mode 100644
index 000000000000..fdba77f2bb06
--- /dev/null
+++ b/tools/testing/nvdimm/pmem-dax.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2014-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#include "test/nfit_test.h"
+#include <linux/blkdev.h>
+#include <pmem.h>
+#include <nd.h>
+
+long pmem_direct_access(struct block_device *bdev, sector_t sector,
+		void __pmem **kaddr, pfn_t *pfn, long size)
+{
+	struct pmem_device *pmem = bdev->bd_queue->queuedata;
+	resource_size_t offset = sector * 512 + pmem->data_offset;
+
+	/* disable DAX for nfit_test pmem devices */
+	if (get_nfit_res(pmem->phys_addr + offset)) {
+		dev_info_once(pmem->bb.dev, "dax is disabled for nfit_test\n");
+		return -EIO;
+	}
+
+	if (unlikely(is_bad_pmem(&pmem->bb, sector, size)))
+		return -EIO;
+	*kaddr = pmem->virt_addr + offset;
+	*pfn = phys_to_pfn_t(pmem->phys_addr + offset, pmem->pfn_flags);
+
+	/*
+	 * If badblocks are present, limit known good range to the
+	 * requested range.
+	 */
+	if (unlikely(pmem->bb.count))
+		return size;
+	return pmem->size - pmem->pfn_pad - offset;
+}
* Unmerged path tools/testing/nvdimm/test/iomap.c
* Unmerged path tools/testing/nvdimm/test/nfit_test.h
