sctp: fix checkpatch errors with (foo*)|foo * bar|foo* bar

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author wangweidong <wangweidong1@huawei.com>
commit 26ac8e5fe1562831e68ccd9f7057aade37aab2a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/26ac8e5f.failed

fix checkpatch errors below:
ERROR: "(foo*)" should be "(foo *)"
ERROR: "foo * bar" should be "foo *bar"
ERROR: "foo* bar" should be "foo *bar"

	Signed-off-by: Wang Weidong <wangweidong1@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 26ac8e5fe1562831e68ccd9f7057aade37aab2a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/socket.c
diff --cc net/sctp/socket.c
index e59739bc9491,9f42c605bfa8..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -969,9 -952,9 +969,15 @@@ int sctp_asconf_mgmt(struct sctp_sock *
   *
   * Returns 0 if ok, <0 errno code on error.
   */
++<<<<<<< HEAD
 +SCTP_STATIC int sctp_setsockopt_bindx(struct sock* sk,
 +				      struct sockaddr __user *addrs,
 +				      int addrs_size, int op)
++=======
+ static int sctp_setsockopt_bindx(struct sock *sk,
+ 				 struct sockaddr __user *addrs,
+ 				 int addrs_size, int op)
++>>>>>>> 26ac8e5fe156 (sctp: fix checkpatch errors with (foo*)|foo * bar|foo* bar)
  {
  	struct sockaddr *kaddrs;
  	int err;
@@@ -1317,7 -1299,7 +1323,11 @@@ out_free
   *
   * Returns >=0 if ok, <0 errno code on error.
   */
++<<<<<<< HEAD
 +SCTP_STATIC int __sctp_setsockopt_connectx(struct sock* sk,
++=======
+ static int __sctp_setsockopt_connectx(struct sock *sk,
++>>>>>>> 26ac8e5fe156 (sctp: fix checkpatch errors with (foo*)|foo * bar|foo* bar)
  				      struct sockaddr __user *addrs,
  				      int addrs_size,
  				      sctp_assoc_t *assoc_id)
@@@ -1355,9 -1337,9 +1365,15 @@@
   * This is an older interface.  It's kept for backward compatibility
   * to the option that doesn't provide association id.
   */
++<<<<<<< HEAD
 +SCTP_STATIC int sctp_setsockopt_connectx_old(struct sock* sk,
 +				      struct sockaddr __user *addrs,
 +				      int addrs_size)
++=======
+ static int sctp_setsockopt_connectx_old(struct sock *sk,
+ 					struct sockaddr __user *addrs,
+ 					int addrs_size)
++>>>>>>> 26ac8e5fe156 (sctp: fix checkpatch errors with (foo*)|foo * bar|foo* bar)
  {
  	return __sctp_setsockopt_connectx(sk, addrs, addrs_size, NULL);
  }
@@@ -1368,9 -1350,9 +1384,15 @@@
   * indication to the call.  Error is always negative and association id is
   * always positive.
   */
++<<<<<<< HEAD
 +SCTP_STATIC int sctp_setsockopt_connectx(struct sock* sk,
 +				      struct sockaddr __user *addrs,
 +				      int addrs_size)
++=======
+ static int sctp_setsockopt_connectx(struct sock *sk,
+ 				    struct sockaddr __user *addrs,
+ 				    int addrs_size)
++>>>>>>> 26ac8e5fe156 (sctp: fix checkpatch errors with (foo*)|foo * bar|foo* bar)
  {
  	sctp_assoc_t assoc_id = 0;
  	int err = 0;
@@@ -1386,22 -1368,14 +1408,28 @@@
  /*
   * New (hopefully final) interface for the API.
   * We use the sctp_getaddrs_old structure so that use-space library
 - * can avoid any unnecessary allocations.   The only defferent part
 + * can avoid any unnecessary allocations. The only different part
   * is that we store the actual length of the address buffer into the
 - * addrs_num structure member.  That way we can re-use the existing
 + * addrs_num structure member. That way we can re-use the existing
   * code.
   */
++<<<<<<< HEAD
 +#ifdef CONFIG_COMPAT
 +struct compat_sctp_getaddrs_old {
 +	sctp_assoc_t	assoc_id;
 +	s32		addr_num;
 +	compat_uptr_t	addrs;		/* struct sockaddr * */
 +};
 +#endif
 +
 +SCTP_STATIC int sctp_getsockopt_connectx3(struct sock* sk, int len,
 +					char __user *optval,
 +					int __user *optlen)
++=======
+ static int sctp_getsockopt_connectx3(struct sock *sk, int len,
+ 				     char __user *optval,
+ 				     int __user *optlen)
++>>>>>>> 26ac8e5fe156 (sctp: fix checkpatch errors with (foo*)|foo * bar|foo* bar)
  {
  	struct sctp_getaddrs_old param;
  	sctp_assoc_t assoc_id = 0;
@@@ -5623,9 -5475,9 +5651,9 @@@ static int sctp_getsockopt_local_auth_c
  		return -EINVAL;
  
  	if (asoc)
- 		ch = (struct sctp_chunks_param*)asoc->c.auth_chunks;
+ 		ch = (struct sctp_chunks_param *)asoc->c.auth_chunks;
  	else
 -		ch = sctp_sk(sk)->ep->auth_chunk_list;
 +		ch = ep->auth_chunk_list;
  
  	if (!ch)
  		goto num;
diff --git a/net/sctp/auth.c b/net/sctp/auth.c
index 92c94f19b484..876b20598364 100644
--- a/net/sctp/auth.c
+++ b/net/sctp/auth.c
@@ -233,9 +233,9 @@ static struct sctp_auth_bytes *sctp_auth_make_local_vector(
 				    gfp_t gfp)
 {
 	return sctp_auth_make_key_vector(
-				    (sctp_random_param_t*)asoc->c.auth_random,
-				    (sctp_chunks_param_t*)asoc->c.auth_chunks,
-				    (sctp_hmac_algo_param_t*)asoc->c.auth_hmacs,
+				    (sctp_random_param_t *)asoc->c.auth_random,
+				    (sctp_chunks_param_t *)asoc->c.auth_chunks,
+				    (sctp_hmac_algo_param_t *)asoc->c.auth_hmacs,
 				    gfp);
 }
 
diff --git a/net/sctp/objcnt.c b/net/sctp/objcnt.c
index fe012c44f8df..0dc710364b13 100644
--- a/net/sctp/objcnt.c
+++ b/net/sctp/objcnt.c
@@ -103,7 +103,7 @@ static void sctp_objcnt_seq_stop(struct seq_file *seq, void *v)
 {
 }
 
-static void * sctp_objcnt_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+static void *sctp_objcnt_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
 	++*pos;
 	return (*pos >= ARRAY_SIZE(sctp_dbg_objcnt)) ? NULL : (void *)pos;
diff --git a/net/sctp/proc.c b/net/sctp/proc.c
index aaeecb033eeb..0ddd46d72f48 100644
--- a/net/sctp/proc.c
+++ b/net/sctp/proc.c
@@ -184,7 +184,7 @@ static void sctp_seq_dump_remote_addrs(struct seq_file *seq, struct sctp_associa
 	rcu_read_unlock();
 }
 
-static void * sctp_eps_seq_start(struct seq_file *seq, loff_t *pos)
+static void *sctp_eps_seq_start(struct seq_file *seq, loff_t *pos)
 {
 	if (*pos >= sctp_ep_hashsize)
 		return NULL;
@@ -203,7 +203,7 @@ static void sctp_eps_seq_stop(struct seq_file *seq, void *v)
 }
 
 
-static void * sctp_eps_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+static void *sctp_eps_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
 	if (++*pos >= sctp_ep_hashsize)
 		return NULL;
@@ -289,7 +289,7 @@ void sctp_eps_proc_exit(struct net *net)
 }
 
 
-static void * sctp_assocs_seq_start(struct seq_file *seq, loff_t *pos)
+static void *sctp_assocs_seq_start(struct seq_file *seq, loff_t *pos)
 {
 	if (*pos >= sctp_assoc_hashsize)
 		return NULL;
@@ -312,7 +312,7 @@ static void sctp_assocs_seq_stop(struct seq_file *seq, void *v)
 }
 
 
-static void * sctp_assocs_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+static void *sctp_assocs_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
 	if (++*pos >= sctp_assoc_hashsize)
 		return NULL;
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 226deffa4e7d..715bae0ae541 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -2237,7 +2237,7 @@ int sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,
 	 * VIOLATION error.  We build the ERROR chunk here and let the normal
 	 * error handling code build and send the packet.
 	 */
-	if (param.v != (void*)chunk->chunk_end)
+	if (param.v != (void *)chunk->chunk_end)
 		return sctp_process_inv_paramlength(asoc, param.p, chunk, errp);
 
 	/* The only missing mandatory param possible today is
diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index f79dd1fdf29d..66837d206fc1 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -4620,7 +4620,7 @@ sctp_disposition_t sctp_sf_do_prm_asoc(struct net *net,
 				       sctp_cmd_seq_t *commands)
 {
 	struct sctp_chunk *repl;
-	struct sctp_association* my_asoc;
+	struct sctp_association *my_asoc;
 
 	/* The comment below says that we enter COOKIE-WAIT AFTER
 	 * sending the INIT, but that doesn't actually work in our
* Unmerged path net/sctp/socket.c
diff --git a/net/sctp/sysctl.c b/net/sctp/sysctl.c
index 333973c8fc90..e2fc821d66e9 100644
--- a/net/sctp/sysctl.c
+++ b/net/sctp/sysctl.c
@@ -493,7 +493,7 @@ void sctp_sysctl_net_unregister(struct net *net)
 	kfree(table);
 }
 
-static struct ctl_table_header * sctp_sysctl_header;
+static struct ctl_table_header *sctp_sysctl_header;
 
 /* Sysctl registration.  */
 void sctp_sysctl_register(void)
diff --git a/net/sctp/ulpqueue.c b/net/sctp/ulpqueue.c
index 04e3d470f877..962f4c2faeff 100644
--- a/net/sctp/ulpqueue.c
+++ b/net/sctp/ulpqueue.c
@@ -50,9 +50,9 @@
 #include <net/sctp/sm.h>
 
 /* Forward declarations for internal helpers.  */
-static struct sctp_ulpevent * sctp_ulpq_reasm(struct sctp_ulpq *ulpq,
+static struct sctp_ulpevent *sctp_ulpq_reasm(struct sctp_ulpq *ulpq,
 					      struct sctp_ulpevent *);
-static struct sctp_ulpevent * sctp_ulpq_order(struct sctp_ulpq *,
+static struct sctp_ulpevent *sctp_ulpq_order(struct sctp_ulpq *,
 					      struct sctp_ulpevent *);
 static void sctp_ulpq_reasm_drain(struct sctp_ulpq *ulpq);
 
