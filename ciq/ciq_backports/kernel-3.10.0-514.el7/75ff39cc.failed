tcp: make challenge acks less predictable

jira LE-1907
cve CVE-2016-5696
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/75ff39cc.failed

Yue Cao claims that current host rate limiting of challenge ACKS
(RFC 5961) could leak enough information to allow a patient attacker
to hijack TCP sessions. He will soon provide details in an academic
paper.

This patch increases the default limit from 100 to 1000, and adds
some randomization so that the attacker can no longer hijack
sessions without spending a considerable amount of probes.

Based on initial analysis and patch from Linus.

Note that we also have per socket rate limiting, so it is tempting
to remove the host limit in the future.

v2: randomize the count of challenge acks per second, not the period.

Fixes: 282f23c6ee34 ("tcp: implement RFC 5961 3.2")
	Reported-by: Yue Cao <ycao009@ucr.edu>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Yuchung Cheng <ycheng@google.com>
	Cc: Neal Cardwell <ncardwell@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 75ff39ccc1bd5d3c455b6822ab09e533c551f758)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index a74414e9e6cd,91868bb17818..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -3319,14 -3466,19 +3319,24 @@@ static void tcp_send_challenge_ack(stru
  				 &tp->last_oow_ack_time))
  		return;
  
- 	/* Then check the check host-wide RFC 5961 rate limit. */
+ 	/* Then check host-wide RFC 5961 rate limit. */
  	now = jiffies / HZ;
  	if (now != challenge_timestamp) {
+ 		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;
+ 
  		challenge_timestamp = now;
- 		challenge_count = 0;
+ 		WRITE_ONCE(challenge_count, half +
+ 			   prandom_u32_max(sysctl_tcp_challenge_ack_limit));
  	}
++<<<<<<< HEAD
 +	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
 +		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
++=======
+ 	count = READ_ONCE(challenge_count);
+ 	if (count > 0) {
+ 		WRITE_ONCE(challenge_count, count - 1);
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
++>>>>>>> 75ff39ccc1bd (tcp: make challenge acks less predictable)
  		tcp_send_ack(sk);
  	}
  }
* Unmerged path net/ipv4/tcp_input.c
