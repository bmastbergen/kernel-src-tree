tpm_tis: Do not fall back to a hardcoded address for TPM2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit 4d627e672bd0e8af4e734fef93e806499d1e1277
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4d627e67.failed

If the ACPI tables do not declare a memory resource for the TPM2
then do not just fall back to the x86 default base address.

Also be stricter when checking the ancillary TPM2 ACPI data and error
out if any of this data is wrong rather than blindly assuming TPM1.

Fixes: 399235dc6e95 ("tpm, tpm_tis: fix tpm_tis ACPI detection issue with TPM 2.0")
	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Tested-by: Wilck, Martin <martin.wilck@ts.fujitsu.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit 4d627e672bd0e8af4e734fef93e806499d1e1277)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,2ccad8a8177f..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -92,26 -106,26 +92,45 @@@ struct priv_data 
  };
  
  #if defined(CONFIG_PNP) && defined(CONFIG_ACPI)
 -static int has_hid(struct acpi_device *dev, const char *hid)
 +static int is_itpm(struct pnp_dev *dev)
  {
 +	struct acpi_device *acpi = pnp_acpi_device(dev);
  	struct acpi_hardware_id *id;
  
++<<<<<<< HEAD
 +	if (!acpi)
 +		return 0;
 +
 +	list_for_each_entry(id, &acpi->pnp.ids, list) {
 +		if (!strcmp("INTC0102", id->id))
 +			return 1;
 +	}
 +
 +	return 0;
 +}
 +#else
 +static inline int is_itpm(struct pnp_dev *dev)
 +{
 +	return 0;
 +}
++=======
+ 	list_for_each_entry(id, &dev->pnp.ids, list)
+ 		if (!strcmp(hid, id->id))
+ 			return 1;
+ 
+ 	return 0;
+ }
+ 
+ static inline int is_itpm(struct acpi_device *dev)
+ {
+ 	return has_hid(dev, "INTC0102");
+ }
+ #else
+ static inline int is_itpm(struct acpi_device *dev)
+ {
+ 	return 0;
+ }
++>>>>>>> 4d627e672bd0 (tpm_tis: Do not fall back to a hardcoded address for TPM2)
  #endif
  
  /* Before we attempt to access the TPM we must see that the valid bit is set.
@@@ -929,6 -933,93 +948,96 @@@ module_param_string(hid, tpm_pnp_tbl[TI
  MODULE_PARM_DESC(hid, "Set additional specific HID for this driver to probe");
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ACPI
+ static int tpm_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct tpm_info *tpm_info = (struct tpm_info *) data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_interrupt(ares, 0, &res)) {
+ 		tpm_info->irq = res.start;
+ 	} else if (acpi_dev_resource_memory(ares, &res)) {
+ 		tpm_info->start = res.start;
+ 		tpm_info->len = resource_size(&res);
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static int tpm_tis_acpi_init(struct acpi_device *acpi_dev)
+ {
+ 	struct acpi_table_tpm2 *tbl;
+ 	acpi_status st;
+ 	struct list_head resources;
+ 	struct tpm_info tpm_info = {};
+ 	int ret;
+ 
+ 	st = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 			    (struct acpi_table_header **) &tbl);
+ 	if (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	tpm_info.irq = -1;
+ 	ret = acpi_dev_get_resources(acpi_dev, &resources, tpm_check_resource,
+ 				     &tpm_info);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (tpm_info.start == 0 && tpm_info.len == 0) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (is_itpm(acpi_dev))
+ 		itpm = true;
+ 
+ 	return tpm_tis_init(&acpi_dev->dev, &tpm_info, acpi_dev->handle);
+ }
+ 
+ static int tpm_tis_acpi_remove(struct acpi_device *dev)
+ {
+ 	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
+ 
+ 	tpm_chip_unregister(chip);
+ 	tpm_tis_remove(chip);
+ 
+ 	return 0;
+ }
+ 
+ static struct acpi_device_id tpm_acpi_tbl[] = {
+ 	{"MSFT0101", 0},	/* TPM 2.0 */
+ 	/* Add new here */
+ 	{"", 0},		/* User Specified */
+ 	{"", 0}			/* Terminator */
+ };
+ MODULE_DEVICE_TABLE(acpi, tpm_acpi_tbl);
+ 
+ static struct acpi_driver tis_acpi_driver = {
+ 	.name = "tpm_tis",
+ 	.ids = tpm_acpi_tbl,
+ 	.ops = {
+ 		.add = tpm_tis_acpi_init,
+ 		.remove = tpm_tis_acpi_remove,
+ 	},
+ 	.drv = {
+ 		.pm = &tpm_tis_pm,
+ 	},
+ };
+ #endif
+ 
++>>>>>>> 4d627e672bd0 (tpm_tis: Do not fall back to a hardcoded address for TPM2)
  static struct platform_driver tis_drv = {
  	.driver = {
  		.name		= "tpm_tis",
* Unmerged path drivers/char/tpm/tpm_tis.c
