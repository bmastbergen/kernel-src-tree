xfs: don't assert fail on non-async buffers on ioacct decrement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 4dd3fd7197303739094183b139bae3142a3d55e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4dd3fd71.failed

The buffer I/O accounting mechanism tracks async buffers under I/O.  As
an optimization, the buffer I/O count is incremented only once on the
first async I/O for a given hold cycle of a buffer and decremented once
the buffer is released to the LRU (or freed).

xfs_buf_ioacct_dec() has an ASSERT() check for an XBF_ASYNC buffer, but
we have one or two corner cases where a buffer can be submitted for I/O
multiple times via different methods in a single hold cycle. If an async
I/O occurs first, the I/O count is incremented. If a sync I/O occurs
before the hold count drops, XBF_ASYNC is cleared by the time the I/O
count is decremented.

Remove the async assert check from xfs_buf_ioacct_dec() as this is a
perfectly valid scenario. For the purposes of I/O accounting, we really
only care about the buffer async state at I/O submission time.

Discovered-and-analyzed-by: Dave Chinner <david@fromorbit.com>
	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 4dd3fd7197303739094183b139bae3142a3d55e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf.c
diff --cc fs/xfs/xfs_buf.c
index c8156d3de9e4,607cc29bba21..000000000000
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@@ -102,29 -105,18 +102,34 @@@ xfs_buf_lru_add
  }
  
  /*
 - * Clear the in-flight state on a buffer about to be released to the LRU or
 - * freed and unaccount from the buftarg.
 + * xfs_buf_lru_del - remove a buffer from the LRU
 + *
 + * The unlocked check is safe here because it only occurs when there are not
 + * b_lru_ref counts left on the inode under the pag->pag_buf_lock. it is there
 + * to optimise the shrinker removing the buffer from the LRU and calling
 + * xfs_buf_free(). i.e. it removes an unnecessary round trip on the
 + * bt_lru_lock.
   */
 -static inline void
 -xfs_buf_ioacct_dec(
 +STATIC void
 +xfs_buf_lru_del(
  	struct xfs_buf	*bp)
  {
 -	if (!(bp->b_flags & _XBF_IN_FLIGHT))
 +	struct xfs_buftarg *btp = bp->b_target;
 +
 +	if (list_empty(&bp->b_lru))
  		return;
  
++<<<<<<< HEAD
 +	spin_lock(&btp->bt_lru_lock);
 +	if (!list_empty(&bp->b_lru)) {
 +		list_del_init(&bp->b_lru);
 +		btp->bt_lru_nr--;
 +	}
 +	spin_unlock(&btp->bt_lru_lock);
++=======
+ 	bp->b_flags &= ~_XBF_IN_FLIGHT;
+ 	percpu_counter_dec(&bp->b_target->bt_io_count);
++>>>>>>> 4dd3fd719730 (xfs: don't assert fail on non-async buffers on ioacct decrement)
  }
  
  /*
* Unmerged path fs/xfs/xfs_buf.c
