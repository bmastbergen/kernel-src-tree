ipv6: update ip6_rt_last_gc every time GC is run

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Michal Kubeƒçek <mkubecek@suse.cz>
commit 49a18d86f66d33a20144ecb5a34bba0d1856b260
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/49a18d86.failed

As pointed out by Eric Dumazet, net->ipv6.ip6_rt_last_gc should
hold the last time garbage collector was run so that we should
update it whenever fib6_run_gc() calls fib6_clean_all(), not only
if we got there from ip6_dst_gc().

	Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 49a18d86f66d33a20144ecb5a34bba0d1856b260)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index 97a2ef837a1e,bff3d821c7eb..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -1703,7 -1647,9 +1705,13 @@@ void fib6_run_gc(unsigned long expires
  
  	gc_args.more = icmp6_dst_gc();
  
++<<<<<<< HEAD
 +	fib6_clean_all(net, fib6_age, NULL);
++=======
+ 	fib6_clean_all(net, fib6_age, 0, NULL);
+ 	now = jiffies;
+ 	net->ipv6.ip6_rt_last_gc = now;
++>>>>>>> 49a18d86f66d (ipv6: update ip6_rt_last_gc every time GC is run)
  
  	if (gc_args.more)
  		mod_timer(&net->ipv6.ip6_fib_timer,
* Unmerged path net/ipv6/ip6_fib.c
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 2d007c5e4494..d39e100816c7 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -1422,7 +1422,6 @@ static void icmp6_clean_all(int (*func)(struct rt6_info *rt, void *arg),
 
 static int ip6_dst_gc(struct dst_ops *ops)
 {
-	unsigned long now = jiffies;
 	struct net *net = container_of(ops, struct net, ipv6.ip6_dst_ops);
 	int rt_min_interval = net->ipv6.sysctl.ip6_rt_gc_min_interval;
 	int rt_max_size = net->ipv6.sysctl.ip6_rt_max_size;
@@ -1432,13 +1431,12 @@ static int ip6_dst_gc(struct dst_ops *ops)
 	int entries;
 
 	entries = dst_entries_get_fast(ops);
-	if (time_after(rt_last_gc + rt_min_interval, now) &&
+	if (time_after(rt_last_gc + rt_min_interval, jiffies) &&
 	    entries <= rt_max_size)
 		goto out;
 
 	net->ipv6.ip6_rt_gc_expire++;
 	fib6_run_gc(net->ipv6.ip6_rt_gc_expire, net, entries > rt_max_size);
-	net->ipv6.ip6_rt_last_gc = now;
 	entries = dst_entries_get_slow(ops);
 	if (entries < ops->gc_thresh)
 		net->ipv6.ip6_rt_gc_expire = rt_gc_timeout>>1;
