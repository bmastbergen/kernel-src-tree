rhashtable: optimize rhashtable_lookup routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ying Xue <ying.xue@windriver.com>
commit efb975a67ea7846b966080f999589de570686aa0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/efb975a6.failed

Define an internal compare function and relevant compare argument,
and then make use of rhashtable_lookup_compare() to lookup key in
hash table, reducing duplicated code between rhashtable_lookup()
and rhashtable_lookup_compare().

	Signed-off-by: Ying Xue <ying.xue@windriver.com>
	Cc: Thomas Graf <tgraf@suug.ch>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit efb975a67ea7846b966080f999589de570686aa0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/rhashtable.c
diff --cc lib/rhashtable.c
index be20e9720492,f2fdd7a7cb16..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -402,26 -636,18 +415,37 @@@ static bool rhashtable_compare(void *pt
   * This lookup function may only be used for fixed key hash table (key_len
   * paramter set). It will BUG() if used inappropriately.
   *
 - * Lookups may occur in parallel with hashtable mutations and resizing.
 + * Lookups may occur in parallel with hash mutations as long as the lookup is
 + * guarded by rcu_read_lock(). The caller must take care of this.
   */
 -void *rhashtable_lookup(struct rhashtable *ht, const void *key)
 +void *rhashtable_lookup(const struct rhashtable *ht, const void *key)
  {
++<<<<<<< HEAD
 +	const struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	struct rhash_head *he;
 +	u32 h;
 +
 +	BUG_ON(!ht->p.key_len);
 +
 +	h = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, h) {
 +		if (memcmp(rht_obj(ht, he) + ht->p.key_offset, key,
 +			   ht->p.key_len))
 +			continue;
 +		return rht_obj(ht, he);
 +	}
 +
 +	return NULL;
++=======
+ 	struct rhashtable_compare_arg arg = {
+ 		.ht = ht,
+ 		.key = key,
+ 	};
+ 
+ 	BUG_ON(!ht->p.key_len);
+ 
+ 	return rhashtable_lookup_compare(ht, key, &rhashtable_compare, &arg);
++>>>>>>> efb975a67ea7 (rhashtable: optimize rhashtable_lookup routine)
  }
  EXPORT_SYMBOL_GPL(rhashtable_lookup);
  
* Unmerged path lib/rhashtable.c
