clockevents: Simplify locking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 7126cac426137633e470167524e7bcb590fd49b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7126cac4.failed

Now that the notifier chain is gone there are no other users and it's
pointless to nest tick_device_lock inside of clockevents_lock because
there is no other use case.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: John Stultz <john.stultz@linaro.org>
	Cc: Magnus Damm <magnus.damm@gmail.com>
Link: http://lkml.kernel.org/r/20130425143436.162888472@linutronix.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 7126cac426137633e470167524e7bcb590fd49b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/tick-common.c
diff --cc kernel/time/tick-common.c
index b2f41b05d9e4,170a4bdfa99e..000000000000
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@@ -218,44 -204,9 +217,45 @@@ static void tick_setup_device(struct ti
  		tick_setup_oneshot(newdev, handler, next_event);
  }
  
 +static bool tick_check_percpu(struct clock_event_device *curdev,
 +			      struct clock_event_device *newdev, int cpu)
 +{
 +	if (!cpumask_test_cpu(cpu, newdev->cpumask))
 +		return false;
 +	if (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))
 +		return true;
 +	/* Check if irq affinity can be set */
 +	if (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))
 +		return false;
 +	/* Prefer an existing cpu local device */
 +	if (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))
 +		return false;
 +	return true;
 +}
 +
 +static bool tick_check_preferred(struct clock_event_device *curdev,
 +				 struct clock_event_device *newdev)
 +{
 +	/* Prefer oneshot capable device */
 +	if (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {
 +		if (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))
 +			return false;
 +		if (tick_oneshot_mode_active())
 +			return false;
 +	}
 +
 +	/*
 +	 * Use the higher rated one, but prefer a CPU local device with a lower
 +	 * rating than a non-CPU local device
 +	 */
 +	return !curdev ||
 +		newdev->rating > curdev->rating ||
 +	       !cpumask_equal(curdev->cpumask, newdev->cpumask);
 +}
 +
  /*
-  * Check, if the new registered device should be used.
+  * Check, if the new registered device should be used. Called with
+  * clockevents_lock held and interrupts disabled.
   */
  void tick_check_new_device(struct clock_event_device *newdev)
  {
@@@ -380,14 -342,10 +366,19 @@@ static void tick_resume(void
  }
  
  /*
++<<<<<<< HEAD
 + * tick_notify: notification about relevant events
 + * Returns 0 on success, any other value on error
 + */
 +int tick_notify(unsigned long reason, void *dev)
++=======
+  * Called with clockevents_lock held and interrupts disabled
+  */
+ void tick_notify(unsigned long reason, void *dev)
++>>>>>>> 7126cac42613 (clockevents: Simplify locking)
  {
 +	int ret = 0;
 +
  	switch (reason) {
  
  	case CLOCK_EVT_NOTIFY_BROADCAST_ON:
* Unmerged path kernel/time/tick-common.c
