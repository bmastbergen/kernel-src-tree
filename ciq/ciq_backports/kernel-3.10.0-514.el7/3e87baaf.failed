netfilter: nft_limit: add burst parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 3e87baafa4f476017b2453e52a1ca7308b4e6ad5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3e87baaf.failed

This patch adds the burst parameter. This burst indicates the number of packets
that can exceed the limit.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 3e87baafa4f476017b2453e52a1ca7308b4e6ad5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_limit.c
diff --cc net/netfilter/nft_limit.c
index 5301b69b3692,d8c5ff1bf7dd..000000000000
--- a/net/netfilter/nft_limit.c
+++ b/net/netfilter/nft_limit.c
@@@ -25,14 -25,12 +25,15 @@@ struct nft_limit 
  	u64		tokens_max;
  	u64		rate;
  	u64		nsecs;
+ 	u32		burst;
  };
  
 -static inline bool nft_limit_eval(struct nft_limit *limit, u64 cost)
 +static void nft_limit_eval(const struct nft_expr *expr,
 +			   struct nft_data data[NFT_REG_MAX + 1],
 +			   const struct nft_pktinfo *pkt)
  {
 -	u64 now, tokens;
 +	struct nft_limit *priv = nft_expr_priv(expr);
 +	u64 now, tokens, cost = div_u64(priv->nsecs, priv->rate);
  	s64 delta;
  
  	spin_lock_bh(&limit_lock);
@@@ -70,23 -60,37 +71,50 @@@ static int nft_limit_init(const struct 
  	    tb[NFTA_LIMIT_UNIT] == NULL)
  		return -EINVAL;
  
 -	limit->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));
 +	priv->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));
  	unit = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_UNIT]));
 -	limit->nsecs = unit * NSEC_PER_SEC;
 -	if (limit->rate == 0 || limit->nsecs < unit)
 +	priv->nsecs = unit * NSEC_PER_SEC;
 +	if (priv->rate == 0 || priv->nsecs < unit)
  		return -EOVERFLOW;
++<<<<<<< HEAD
 +	priv->tokens = priv->tokens_max = priv->nsecs;
 +	priv->last = ktime_get_ns();
++=======
+ 	limit->tokens = limit->tokens_max = limit->nsecs;
+ 
+ 	if (tb[NFTA_LIMIT_BURST]) {
+ 		u64 rate;
+ 
+ 		limit->burst = ntohl(nla_get_be32(tb[NFTA_LIMIT_BURST]));
+ 
+ 		rate = limit->rate + limit->burst;
+ 		if (rate < limit->rate)
+ 			return -EOVERFLOW;
+ 
+ 		limit->rate = rate;
+ 	}
+ 	limit->last = ktime_get_ns();
+ 
++>>>>>>> 3e87baafa4f4 (netfilter: nft_limit: add burst parameter)
  	return 0;
  }
  
 -static int nft_limit_dump(struct sk_buff *skb, const struct nft_limit *limit)
 +static int nft_limit_dump(struct sk_buff *skb, const struct nft_expr *expr)
  {
++<<<<<<< HEAD
 +	const struct nft_limit *priv = nft_expr_priv(expr);
 +	u64 secs = div_u64(priv->nsecs, NSEC_PER_SEC);
 +
 +	if (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(priv->rate)) ||
 +	    nla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(secs)))
++=======
+ 	u64 secs = div_u64(limit->nsecs, NSEC_PER_SEC);
+ 	u64 rate = limit->rate - limit->burst;
+ 
+ 	if (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(rate)) ||
+ 	    nla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(secs)) ||
+ 	    nla_put_be32(skb, NFTA_LIMIT_BURST, htonl(limit->burst)))
++>>>>>>> 3e87baafa4f4 (netfilter: nft_limit: add burst parameter)
  		goto nla_put_failure;
  	return 0;
  
@@@ -94,13 -98,45 +122,48 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static void nft_limit_pkts_eval(const struct nft_expr *expr,
+ 				struct nft_regs *regs,
+ 				const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_limit *priv = nft_expr_priv(expr);
+ 
+ 	if (nft_limit_eval(priv, div_u64(priv->nsecs, priv->rate)))
+ 		regs->verdict.code = NFT_BREAK;
+ }
+ 
+ static const struct nla_policy nft_limit_policy[NFTA_LIMIT_MAX + 1] = {
+ 	[NFTA_LIMIT_RATE]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_UNIT]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_BURST]	= { .type = NLA_U32 },
+ };
+ 
+ static int nft_limit_pkts_init(const struct nft_ctx *ctx,
+ 			       const struct nft_expr *expr,
+ 			       const struct nlattr * const tb[])
+ {
+ 	struct nft_limit *priv = nft_expr_priv(expr);
+ 
+ 	return nft_limit_init(priv, tb);
+ }
+ 
+ static int nft_limit_pkts_dump(struct sk_buff *skb, const struct nft_expr *expr)
+ {
+ 	const struct nft_limit *priv = nft_expr_priv(expr);
+ 
+ 	return nft_limit_dump(skb, priv);
+ }
+ 
++>>>>>>> 3e87baafa4f4 (netfilter: nft_limit: add burst parameter)
  static struct nft_expr_type nft_limit_type;
 -static const struct nft_expr_ops nft_limit_pkts_ops = {
 +static const struct nft_expr_ops nft_limit_ops = {
  	.type		= &nft_limit_type,
  	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit)),
 -	.eval		= nft_limit_pkts_eval,
 -	.init		= nft_limit_pkts_init,
 -	.dump		= nft_limit_pkts_dump,
 +	.eval		= nft_limit_eval,
 +	.init		= nft_limit_init,
 +	.dump		= nft_limit_dump,
  };
  
  static struct nft_expr_type nft_limit_type __read_mostly = {
diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
index 971d245e7378..3da56a1cbf63 100644
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@ -688,11 +688,13 @@ enum nft_ct_attributes {
  *
  * @NFTA_LIMIT_RATE: refill rate (NLA_U64)
  * @NFTA_LIMIT_UNIT: refill unit (NLA_U64)
+ * @NFTA_LIMIT_BURST: burst (NLA_U32)
  */
 enum nft_limit_attributes {
 	NFTA_LIMIT_UNSPEC,
 	NFTA_LIMIT_RATE,
 	NFTA_LIMIT_UNIT,
+	NFTA_LIMIT_BURST,
 	__NFTA_LIMIT_MAX
 };
 #define NFTA_LIMIT_MAX		(__NFTA_LIMIT_MAX - 1)
* Unmerged path net/netfilter/nft_limit.c
