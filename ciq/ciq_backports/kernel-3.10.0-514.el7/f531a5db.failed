xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit f531a5dbc451afb66e9d6c71a69e8358d1847969
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f531a5db.failed

xprtrdma's backward direction send and receive buffers are the same
size as the forechannel's inline threshold, and must be pre-
registered.

The consumer has no control over which receive buffer the adapter
chooses to catch an incoming backwards-direction call. Any receive
buffer can be used for either a forward reply or a backward call.
Thus both types of RPC message must all be the same size.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit f531a5dbc451afb66e9d6c71a69e8358d1847969)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/Makefile
#	net/sunrpc/xprtrdma/verbs.c
#	net/sunrpc/xprtrdma/xprt_rdma.h
diff --cc net/sunrpc/xprtrdma/Makefile
index 579f72bbcf4b,33f99d3004f2..000000000000
--- a/net/sunrpc/xprtrdma/Makefile
+++ b/net/sunrpc/xprtrdma/Makefile
@@@ -1,9 -1,8 +1,18 @@@
 -obj-$(CONFIG_SUNRPC_XPRT_RDMA) += rpcrdma.o
 +obj-$(CONFIG_SUNRPC_XPRT_RDMA_CLIENT) += xprtrdma.o
  
++<<<<<<< HEAD
 +xprtrdma-y := transport.o rpc_rdma.o verbs.o \
 +	fmr_ops.o frwr_ops.o physical_ops.o
 +
 +obj-$(CONFIG_SUNRPC_XPRT_RDMA_SERVER) += svcrdma.o
 +
 +svcrdma-y := svc_rdma.o svc_rdma_transport.o \
 +	svc_rdma_marshal.o svc_rdma_sendto.o svc_rdma_recvfrom.o
++=======
+ rpcrdma-y := transport.o rpc_rdma.o verbs.o \
+ 	fmr_ops.o frwr_ops.o physical_ops.o \
+ 	svc_rdma.o svc_rdma_transport.o \
+ 	svc_rdma_marshal.o svc_rdma_sendto.o svc_rdma_recvfrom.o \
+ 	module.o
+ rpcrdma-$(CONFIG_SUNRPC_BACKCHANNEL) += backchannel.o
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
diff --cc net/sunrpc/xprtrdma/verbs.c
index 6115ededb593,7f0ed30fdc84..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -1034,44 -936,21 +1053,55 @@@ rpcrdma_buffer_create(struct rpcrdma_xp
  {
  	struct rpcrdma_buffer *buf = &r_xprt->rx_buf;
  	struct rpcrdma_ia *ia = &r_xprt->rx_ia;
 +	struct rpcrdma_create_data_internal *cdata = &r_xprt->rx_data;
 +	char *p;
 +	size_t len;
  	int i, rc;
  
++<<<<<<< HEAD
 +	buf->rb_max_requests = cdata->max_requests;
++=======
+ 	buf->rb_max_requests = r_xprt->rx_data.max_requests;
+ 	buf->rb_bc_srv_max_requests = 0;
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
  	spin_lock_init(&buf->rb_lock);
  
 +	/* Need to allocate:
 +	 *   1.  arrays for send and recv pointers
 +	 *   2.  arrays of struct rpcrdma_req to fill in pointers
 +	 *   3.  array of struct rpcrdma_rep for replies
 +	 * Send/recv buffers in req/rep need to be registered
 +	 */
 +	len = buf->rb_max_requests *
 +		(sizeof(struct rpcrdma_req *) + sizeof(struct rpcrdma_rep *));
 +
 +	p = kzalloc(len, GFP_KERNEL);
 +	if (p == NULL) {
 +		dprintk("RPC:       %s: req_t/rep_t/pad kzalloc(%zd) failed\n",
 +			__func__, len);
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +	buf->rb_pool = p;	/* for freeing it later */
 +
 +	buf->rb_send_bufs = (struct rpcrdma_req **) p;
 +	p = (char *) &buf->rb_send_bufs[buf->rb_max_requests];
 +	buf->rb_recv_bufs = (struct rpcrdma_rep **) p;
 +	p = (char *) &buf->rb_recv_bufs[buf->rb_max_requests];
 +
  	rc = ia->ri_ops->ro_init(r_xprt);
  	if (rc)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	INIT_LIST_HEAD(&buf->rb_send_bufs);
+ 	INIT_LIST_HEAD(&buf->rb_allreqs);
+ 	spin_lock_init(&buf->rb_reqslock);
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
  	for (i = 0; i < buf->rb_max_requests; i++) {
  		struct rpcrdma_req *req;
 +		struct rpcrdma_rep *rep;
  
  		req = rpcrdma_create_req(r_xprt);
  		if (IS_ERR(req)) {
@@@ -1080,7 -959,13 +1110,17 @@@
  			rc = PTR_ERR(req);
  			goto out;
  		}
++<<<<<<< HEAD
 +		buf->rb_send_bufs[i] = req;
++=======
+ 		req->rl_backchannel = false;
+ 		list_add(&req->rl_free, &buf->rb_send_bufs);
+ 	}
+ 
+ 	INIT_LIST_HEAD(&buf->rb_recv_bufs);
+ 	for (i = 0; i < buf->rb_max_requests + 2; i++) {
+ 		struct rpcrdma_rep *rep;
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
  
  		rep = rpcrdma_create_rep(r_xprt);
  		if (IS_ERR(rep)) {
@@@ -1123,25 -1024,29 +1157,44 @@@ voi
  rpcrdma_buffer_destroy(struct rpcrdma_buffer *buf)
  {
  	struct rpcrdma_ia *ia = rdmab_to_ia(buf);
 +	int i;
  
 -	while (!list_empty(&buf->rb_recv_bufs)) {
 -		struct rpcrdma_rep *rep;
 +	/* clean up in reverse order from create
 +	 *   1.  recv mr memory (mr free, then kfree)
 +	 *   2.  send mr memory (mr free, then kfree)
 +	 *   3.  MWs
 +	 */
 +	dprintk("RPC:       %s: entering\n", __func__);
  
++<<<<<<< HEAD
 +	for (i = 0; i < buf->rb_max_requests; i++) {
 +		if (buf->rb_recv_bufs)
 +			rpcrdma_destroy_rep(ia, buf->rb_recv_bufs[i]);
 +		if (buf->rb_send_bufs)
 +			rpcrdma_destroy_req(ia, buf->rb_send_bufs[i]);
++=======
+ 		rep = rpcrdma_buffer_get_rep_locked(buf);
+ 		rpcrdma_destroy_rep(ia, rep);
  	}
  
+ 	spin_lock(&buf->rb_reqslock);
+ 	while (!list_empty(&buf->rb_allreqs)) {
+ 		struct rpcrdma_req *req;
+ 
+ 		req = list_first_entry(&buf->rb_allreqs,
+ 				       struct rpcrdma_req, rl_all);
+ 		list_del(&req->rl_all);
+ 
+ 		spin_unlock(&buf->rb_reqslock);
+ 		rpcrdma_destroy_req(ia, req);
+ 		spin_lock(&buf->rb_reqslock);
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
+ 	}
+ 	spin_unlock(&buf->rb_reqslock);
+ 
  	ia->ri_ops->ro_destroy(buf);
 +
 +	kfree(buf->rb_pool);
  }
  
  struct rpcrdma_mw *
diff --cc net/sunrpc/xprtrdma/xprt_rdma.h
index b2d2c86a7023,1eb86c79f4b9..000000000000
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@@ -249,16 -250,22 +249,26 @@@ struct rpcrdma_mr_seg {		/* chunk descr
  	char		*mr_offset;	/* kva if no page, else offset */
  };
  
 -#define RPCRDMA_MAX_IOVS	(2)
 -
  struct rpcrdma_req {
 -	struct list_head	rl_free;
 -	unsigned int		rl_niovs;
 -	unsigned int		rl_nchunks;
 -	unsigned int		rl_connect_cookie;
 -	struct rpcrdma_buffer	*rl_buffer;
 +	unsigned int	rl_niovs;	/* 0, 2 or 4 */
 +	unsigned int	rl_nchunks;	/* non-zero if chunks */
 +	unsigned int	rl_connect_cookie;	/* retry detection */
 +	struct rpcrdma_buffer *rl_buffer; /* home base for this structure */
  	struct rpcrdma_rep	*rl_reply;/* holder for reply buffer */
++<<<<<<< HEAD
 +	struct ib_sge	rl_send_iov[4];	/* for active requests */
 +	struct rpcrdma_regbuf *rl_rdmabuf;
 +	struct rpcrdma_regbuf *rl_sendbuf;
 +	struct rpcrdma_mr_seg rl_segments[RPCRDMA_MAX_SEGS];
++=======
+ 	struct ib_sge		rl_send_iov[RPCRDMA_MAX_IOVS];
+ 	struct rpcrdma_regbuf	*rl_rdmabuf;
+ 	struct rpcrdma_regbuf	*rl_sendbuf;
+ 	struct rpcrdma_mr_seg	rl_segments[RPCRDMA_MAX_SEGS];
+ 
+ 	struct list_head	rl_all;
+ 	bool			rl_backchannel;
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
  };
  
  static inline struct rpcrdma_req *
@@@ -283,12 -290,14 +293,19 @@@ struct rpcrdma_buffer 
  	struct list_head	rb_all;
  	char			*rb_pool;
  
 -	spinlock_t		rb_lock;	/* protect buf lists */
 -	struct list_head	rb_send_bufs;
 -	struct list_head	rb_recv_bufs;
 +	spinlock_t		rb_lock;	/* protect buf arrays */
  	u32			rb_max_requests;
++<<<<<<< HEAD
 +	int			rb_send_index;
 +	int			rb_recv_index;
 +	struct rpcrdma_req	**rb_send_bufs;
 +	struct rpcrdma_rep	**rb_recv_bufs;
++=======
+ 
+ 	u32			rb_bc_srv_max_requests;
+ 	spinlock_t		rb_reqslock;	/* protect rb_allreqs */
+ 	struct list_head	rb_allreqs;
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
  };
  #define rdmab_to_ia(b) (&container_of((b), struct rpcrdma_xprt, rx_buf)->rx_ia)
  
@@@ -485,6 -500,20 +506,23 @@@ void rpcrdma_reply_handler(struct rpcrd
   */
  int rpcrdma_marshal_req(struct rpc_rqst *);
  
++<<<<<<< HEAD
++=======
+ /* RPC/RDMA module init - xprtrdma/transport.c
+  */
+ int xprt_rdma_init(void);
+ void xprt_rdma_cleanup(void);
+ 
+ /* Backchannel calls - xprtrdma/backchannel.c
+  */
+ #if defined(CONFIG_SUNRPC_BACKCHANNEL)
+ int xprt_rdma_bc_setup(struct rpc_xprt *, unsigned int);
+ int rpcrdma_bc_post_recv(struct rpcrdma_xprt *, unsigned int);
+ void xprt_rdma_bc_free_rqst(struct rpc_rqst *);
+ void xprt_rdma_bc_destroy(struct rpc_xprt *, unsigned int);
+ #endif	/* CONFIG_SUNRPC_BACKCHANNEL */
+ 
++>>>>>>> f531a5dbc451 (xprtrdma: Pre-allocate backward rpc_rqst and send/receive buffers)
  /* Temporary NFS request map cache. Created in svc_rdma.c  */
  extern struct kmem_cache *svc_rdma_map_cachep;
  /* WR context cache. Created in svc_rdma.c  */
* Unmerged path net/sunrpc/xprtrdma/Makefile
diff --git a/net/sunrpc/xprtrdma/backchannel.c b/net/sunrpc/xprtrdma/backchannel.c
new file mode 100644
index 000000000000..3d01b328f777
--- /dev/null
+++ b/net/sunrpc/xprtrdma/backchannel.c
@@ -0,0 +1,206 @@
+/*
+ * Copyright (c) 2015 Oracle.  All rights reserved.
+ *
+ * Support for backward direction RPCs on RPC/RDMA.
+ */
+
+#include <linux/module.h>
+
+#include "xprt_rdma.h"
+
+#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)
+# define RPCDBG_FACILITY	RPCDBG_TRANS
+#endif
+
+static void rpcrdma_bc_free_rqst(struct rpcrdma_xprt *r_xprt,
+				 struct rpc_rqst *rqst)
+{
+	struct rpcrdma_buffer *buf = &r_xprt->rx_buf;
+	struct rpcrdma_req *req = rpcr_to_rdmar(rqst);
+
+	spin_lock(&buf->rb_reqslock);
+	list_del(&req->rl_all);
+	spin_unlock(&buf->rb_reqslock);
+
+	rpcrdma_destroy_req(&r_xprt->rx_ia, req);
+
+	kfree(rqst);
+}
+
+static int rpcrdma_bc_setup_rqst(struct rpcrdma_xprt *r_xprt,
+				 struct rpc_rqst *rqst)
+{
+	struct rpcrdma_ia *ia = &r_xprt->rx_ia;
+	struct rpcrdma_regbuf *rb;
+	struct rpcrdma_req *req;
+	struct xdr_buf *buf;
+	size_t size;
+
+	req = rpcrdma_create_req(r_xprt);
+	if (!req)
+		return -ENOMEM;
+	req->rl_backchannel = true;
+
+	size = RPCRDMA_INLINE_WRITE_THRESHOLD(rqst);
+	rb = rpcrdma_alloc_regbuf(ia, size, GFP_KERNEL);
+	if (IS_ERR(rb))
+		goto out_fail;
+	req->rl_rdmabuf = rb;
+
+	size += RPCRDMA_INLINE_READ_THRESHOLD(rqst);
+	rb = rpcrdma_alloc_regbuf(ia, size, GFP_KERNEL);
+	if (IS_ERR(rb))
+		goto out_fail;
+	rb->rg_owner = req;
+	req->rl_sendbuf = rb;
+	/* so that rpcr_to_rdmar works when receiving a request */
+	rqst->rq_buffer = (void *)req->rl_sendbuf->rg_base;
+
+	buf = &rqst->rq_snd_buf;
+	buf->head[0].iov_base = rqst->rq_buffer;
+	buf->head[0].iov_len = 0;
+	buf->tail[0].iov_base = NULL;
+	buf->tail[0].iov_len = 0;
+	buf->page_len = 0;
+	buf->len = 0;
+	buf->buflen = size;
+
+	return 0;
+
+out_fail:
+	rpcrdma_bc_free_rqst(r_xprt, rqst);
+	return -ENOMEM;
+}
+
+/* Allocate and add receive buffers to the rpcrdma_buffer's
+ * existing list of rep's. These are released when the
+ * transport is destroyed.
+ */
+static int rpcrdma_bc_setup_reps(struct rpcrdma_xprt *r_xprt,
+				 unsigned int count)
+{
+	struct rpcrdma_buffer *buffers = &r_xprt->rx_buf;
+	struct rpcrdma_rep *rep;
+	unsigned long flags;
+	int rc = 0;
+
+	while (count--) {
+		rep = rpcrdma_create_rep(r_xprt);
+		if (IS_ERR(rep)) {
+			pr_err("RPC:       %s: reply buffer alloc failed\n",
+			       __func__);
+			rc = PTR_ERR(rep);
+			break;
+		}
+
+		spin_lock_irqsave(&buffers->rb_lock, flags);
+		list_add(&rep->rr_list, &buffers->rb_recv_bufs);
+		spin_unlock_irqrestore(&buffers->rb_lock, flags);
+	}
+
+	return rc;
+}
+
+/**
+ * xprt_rdma_bc_setup - Pre-allocate resources for handling backchannel requests
+ * @xprt: transport associated with these backchannel resources
+ * @reqs: number of concurrent incoming requests to expect
+ *
+ * Returns 0 on success; otherwise a negative errno
+ */
+int xprt_rdma_bc_setup(struct rpc_xprt *xprt, unsigned int reqs)
+{
+	struct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);
+	struct rpcrdma_buffer *buffer = &r_xprt->rx_buf;
+	struct rpc_rqst *rqst;
+	unsigned int i;
+	int rc;
+
+	/* The backchannel reply path returns each rpc_rqst to the
+	 * bc_pa_list _after_ the reply is sent. If the server is
+	 * faster than the client, it can send another backward
+	 * direction request before the rpc_rqst is returned to the
+	 * list. The client rejects the request in this case.
+	 *
+	 * Twice as many rpc_rqsts are prepared to ensure there is
+	 * always an rpc_rqst available as soon as a reply is sent.
+	 */
+	for (i = 0; i < (reqs << 1); i++) {
+		rqst = kzalloc(sizeof(*rqst), GFP_KERNEL);
+		if (!rqst) {
+			pr_err("RPC:       %s: Failed to create bc rpc_rqst\n",
+			       __func__);
+			goto out_free;
+		}
+
+		rqst->rq_xprt = &r_xprt->rx_xprt;
+		INIT_LIST_HEAD(&rqst->rq_list);
+		INIT_LIST_HEAD(&rqst->rq_bc_list);
+
+		if (rpcrdma_bc_setup_rqst(r_xprt, rqst))
+			goto out_free;
+
+		spin_lock_bh(&xprt->bc_pa_lock);
+		list_add(&rqst->rq_bc_pa_list, &xprt->bc_pa_list);
+		spin_unlock_bh(&xprt->bc_pa_lock);
+	}
+
+	rc = rpcrdma_bc_setup_reps(r_xprt, reqs);
+	if (rc)
+		goto out_free;
+
+	rc = rpcrdma_ep_post_extra_recv(r_xprt, reqs);
+	if (rc)
+		goto out_free;
+
+	buffer->rb_bc_srv_max_requests = reqs;
+	request_module("svcrdma");
+
+	return 0;
+
+out_free:
+	xprt_rdma_bc_destroy(xprt, reqs);
+
+	pr_err("RPC:       %s: setup backchannel transport failed\n", __func__);
+	return -ENOMEM;
+}
+
+/**
+ * xprt_rdma_bc_destroy - Release resources for handling backchannel requests
+ * @xprt: transport associated with these backchannel resources
+ * @reqs: number of incoming requests to destroy; ignored
+ */
+void xprt_rdma_bc_destroy(struct rpc_xprt *xprt, unsigned int reqs)
+{
+	struct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);
+	struct rpc_rqst *rqst, *tmp;
+
+	spin_lock_bh(&xprt->bc_pa_lock);
+	list_for_each_entry_safe(rqst, tmp, &xprt->bc_pa_list, rq_bc_pa_list) {
+		list_del(&rqst->rq_bc_pa_list);
+		spin_unlock_bh(&xprt->bc_pa_lock);
+
+		rpcrdma_bc_free_rqst(r_xprt, rqst);
+
+		spin_lock_bh(&xprt->bc_pa_lock);
+	}
+	spin_unlock_bh(&xprt->bc_pa_lock);
+}
+
+/**
+ * xprt_rdma_bc_free_rqst - Release a backchannel rqst
+ * @rqst: request to release
+ */
+void xprt_rdma_bc_free_rqst(struct rpc_rqst *rqst)
+{
+	struct rpc_xprt *xprt = rqst->rq_xprt;
+
+	smp_mb__before_atomic();
+	WARN_ON_ONCE(!test_bit(RPC_BC_PA_IN_USE, &rqst->rq_bc_pa_state));
+	clear_bit(RPC_BC_PA_IN_USE, &rqst->rq_bc_pa_state);
+	smp_mb__after_atomic();
+
+	spin_lock_bh(&xprt->bc_pa_lock);
+	list_add_tail(&rqst->rq_bc_pa_list, &xprt->bc_pa_list);
+	spin_unlock_bh(&xprt->bc_pa_lock);
+}
diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c
index fe00a205527b..f0328f44dbbc 100644
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@ -711,7 +711,12 @@ static struct rpc_xprt_ops xprt_rdma_procs = {
 	.print_stats		= xprt_rdma_print_stats,
 	.enable_swap		= xprt_rdma_enable_swap,
 	.disable_swap		= xprt_rdma_disable_swap,
-	.inject_disconnect	= xprt_rdma_inject_disconnect
+	.inject_disconnect	= xprt_rdma_inject_disconnect,
+#if defined(CONFIG_SUNRPC_BACKCHANNEL)
+	.bc_setup		= xprt_rdma_bc_setup,
+	.bc_free_rqst		= xprt_rdma_bc_free_rqst,
+	.bc_destroy		= xprt_rdma_bc_destroy,
+#endif
 };
 
 static struct xprt_class xprt_rdma = {
* Unmerged path net/sunrpc/xprtrdma/verbs.c
* Unmerged path net/sunrpc/xprtrdma/xprt_rdma.h
