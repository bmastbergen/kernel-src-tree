IB/qib, staging/rdma/hfi1, IB/rdmavt: progress selection changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] ib/qib, rdma/hfi1, ib/rdmavt: progress selection changes (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 93.33%
commit-author Mike Marciniszyn <mike.marciniszyn@intel.com>
commit 91702b4a39fb566b78f2ef1cea8bf6ed3fe9f4a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/91702b4a.failed

The non-rdamvt versions of qib and hfi1 allow for a differing
heuristic to override a schedule progress in favor of a direct
call the the progress routine.

This patch adds that for both drivers and rdmavt.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 91702b4a39fb566b78f2ef1cea8bf6ed3fe9f4a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qib/qib_qp.c
#	drivers/infiniband/sw/rdmavt/qp.c
#	drivers/staging/rdma/hfi1/qp.c
diff --cc drivers/infiniband/hw/qib/qib_qp.c
index cf1dd6e9d434,575b737d9ef3..000000000000
--- a/drivers/infiniband/hw/qib/qib_qp.c
+++ b/drivers/infiniband/hw/qib/qib_qp.c
@@@ -1326,6 -474,45 +1326,48 @@@ void qib_get_credit(struct qib_qp *qp, 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * qib_check_send_wqe - validate wr/wqe
+  * @qp - The qp
+  * @wqe - The built wqe
+  *
+  * validate wr/wqe.  This is called
+  * prior to inserting the wqe into
+  * the ring but after the wqe has been
+  * setup.
+  *
+  * Returns 1 to force direct progress, 0 otherwise, -EINVAL on failure
+  */
+ int qib_check_send_wqe(struct rvt_qp *qp,
+ 		       struct rvt_swqe *wqe)
+ {
+ 	struct rvt_ah *ah;
+ 	int ret = 0;
+ 
+ 	switch (qp->ibqp.qp_type) {
+ 	case IB_QPT_RC:
+ 	case IB_QPT_UC:
+ 		if (wqe->length > 0x80000000U)
+ 			return -EINVAL;
+ 		break;
+ 	case IB_QPT_SMI:
+ 	case IB_QPT_GSI:
+ 	case IB_QPT_UD:
+ 		ah = ibah_to_rvtah(wqe->ud_wr.ah);
+ 		if (wqe->length > (1 << ah->log_pmtu))
+ 			return -EINVAL;
+ 		/* progress hint */
+ 		ret = 1;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 	return ret;
+ }
+ 
++>>>>>>> 91702b4a39fb (IB/qib, staging/rdma/hfi1, IB/rdmavt: progress selection changes)
  #ifdef CONFIG_DEBUG_FS
  
  struct qib_qp_iter {
diff --cc drivers/infiniband/sw/rdmavt/qp.c
index 9fff76d7554d,ef82abf2d89e..000000000000
--- a/drivers/infiniband/sw/rdmavt/qp.c
+++ b/drivers/infiniband/sw/rdmavt/qp.c
@@@ -1467,14 -1530,33 +1469,33 @@@ static int rvt_post_one_wr(struct rvt_q
  		}
  		wqe->wr.num_sge = j;
  	}
++<<<<<<< HEAD
 +	if (qp->ibqp.qp_type == IB_QPT_UC ||
 +	    qp->ibqp.qp_type == IB_QPT_RC) {
 +		if (wqe->length > 0x80000000U)
 +			goto bail_inval_free;
 +	} else {
++=======
+ 
+ 	/* general part of wqe valid - allow for driver checks */
+ 	if (rdi->driver_f.check_send_wqe) {
+ 		ret = rdi->driver_f.check_send_wqe(qp, wqe);
+ 		if (ret < 0)
+ 			goto bail_inval_free;
+ 		if (ret)
+ 			*call_send = ret;
+ 	}
+ 
+ 	log_pmtu = qp->log_pmtu;
+ 	if (qp->ibqp.qp_type != IB_QPT_UC &&
+ 	    qp->ibqp.qp_type != IB_QPT_RC) {
+ 		struct rvt_ah *ah = ibah_to_rvtah(wqe->ud_wr.ah);
+ 
+ 		log_pmtu = ah->log_pmtu;
++>>>>>>> 91702b4a39fb (IB/qib, staging/rdma/hfi1, IB/rdmavt: progress selection changes)
  		atomic_inc(&ibah_to_rvtah(ud_wr(wr)->ah)->refcount);
  	}
 -
  	wqe->ssn = qp->s_ssn++;
 -	wqe->psn = qp->s_next_psn;
 -	wqe->lpsn = wqe->psn +
 -			(wqe->length ? ((wqe->length - 1) >> log_pmtu) : 0);
 -	qp->s_next_psn = wqe->lpsn + 1;
 -	trace_rvt_post_one_wr(qp, wqe);
 -	smp_wmb(); /* see request builders */
 -	qp->s_avail--;
  	qp->s_head = next;
  
  	return 0;
* Unmerged path drivers/staging/rdma/hfi1/qp.c
* Unmerged path drivers/infiniband/hw/qib/qib_qp.c
* Unmerged path drivers/infiniband/sw/rdmavt/qp.c
* Unmerged path drivers/staging/rdma/hfi1/qp.c
