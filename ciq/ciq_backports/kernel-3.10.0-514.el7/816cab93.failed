Thermal: introduce int3400 thermal driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [thermal] introduce int3400 thermal driver (Prarit Bhargava) [1339663]
Rebuild_FUZZ: 87.67%
commit-author Zhang Rui <rui.zhang@intel.com>
commit 816cab931f288c92a3404b1b984576f4822b0445
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/816cab93.failed

Introduce int3400 thermal driver. And make INT3400 driver
enumerate the other int340x thermal components shown in _ART/_TRT.

	Signed-off-by: Zhang Rui <rui.zhang@intel.com>
(cherry picked from commit 816cab931f288c92a3404b1b984576f4822b0445)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/int340x_thermal.c
#	drivers/thermal/Kconfig
#	drivers/thermal/Makefile
diff --cc drivers/thermal/Kconfig
index 21faa8a5bcf8,6f5a87a8f19f..000000000000
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@@ -168,4 -196,73 +168,76 @@@ config INTEL_POWERCLAM
  	  enforce idle time which results in more package C-state residency. The
  	  user interface is exposed via generic thermal framework.
  
++<<<<<<< HEAD
++=======
+ config X86_PKG_TEMP_THERMAL
+ 	tristate "X86 package temperature thermal driver"
+ 	depends on X86_THERMAL_VECTOR
+ 	select THERMAL_GOV_USER_SPACE
+ 	default m
+ 	help
+ 	  Enable this to register CPU digital sensor for package temperature as
+ 	  thermal zone. Each package will have its own thermal zone. There are
+ 	  two trip points which can be set by user to get notifications via thermal
+ 	  notification methods.
+ 
+ config ACPI_INT3403_THERMAL
+ 	tristate "ACPI INT3403 thermal driver"
+ 	depends on X86 && ACPI
+ 	help
+ 	  Newer laptops and tablets that use ACPI may have thermal sensors
+ 	  outside the core CPU/SOC for thermal safety reasons. These
+ 	  temperature sensors are also exposed for the OS to use via the so
+ 	  called INT3403 ACPI object. This driver will, on devices that have
+ 	  such sensors, expose the temperature information from these sensors
+ 	  to userspace via the normal thermal framework. This means that a wide
+ 	  range of applications and GUI widgets can show this information to
+ 	  the user or use this information for making decisions. For example,
+ 	  the Intel Thermal Daemon can use this information to allow the user
+ 	  to select his laptop to run without turning on the fans.
+ 
+ config INTEL_SOC_DTS_THERMAL
+ 	tristate "Intel SoCs DTS thermal driver"
+ 	depends on X86 && IOSF_MBI
+ 	help
+ 	  Enable this to register Intel SoCs (e.g. Bay Trail) platform digital
+ 	  temperature sensor (DTS). These SoCs have two additional DTSs in
+ 	  addition to DTSs on CPU cores. Each DTS will be registered as a
+ 	  thermal zone. There are two trip points. One of the trip point can
+ 	  be set by user mode programs to get notifications via Linux thermal
+ 	  notification methods.The other trip is a critical trip point, which
+ 	  was set by the driver based on the TJ MAX temperature.
+ 
+ config INT340X_THERMAL
+ 	tristate "ACPI INT340X thermal drivers"
+ 	depends on X86 && ACPI
+ 	help
+ 	  Newer laptops and tablets that use ACPI may have thermal sensors and
+ 	  other devices with thermal control capabilities outside the core
+ 	  CPU/SOC, for thermal safety reasons.
+ 	  They are exposed for the OS to use via the INT3400 ACPI device object
+ 	  as the master, and INT3401~INT340B ACPI device objects as the slaves.
+ 	  Enable this to expose the temperature information and cooling ability
+ 	  from these objects to userspace via the normal thermal framework.
+ 	  This means that a wide range of applications and GUI widgets can show
+ 	  the information to the user or use this information for making
+ 	  decisions. For example, the Intel Thermal Daemon can use this
+ 	  information to allow the user to select his laptop to run without
+ 	  turning on the fans.
+ 
+ menu "Texas Instruments thermal drivers"
+ source "drivers/thermal/ti-soc-thermal/Kconfig"
+ endmenu
+ 
+ menu "Samsung thermal drivers"
+ depends on ARCH_EXYNOS
+ source "drivers/thermal/samsung/Kconfig"
+ endmenu
+ 
+ menu "STMicroelectronics thermal drivers"
+ depends on ARCH_STI && OF
+ source "drivers/thermal/st/Kconfig"
+ endmenu
+ 
++>>>>>>> 816cab931f28 (Thermal: introduce int3400 thermal driver)
  endif
diff --cc drivers/thermal/Makefile
index c054d410ac3f,216503eaa232..000000000000
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@@ -21,6 -25,12 +21,15 @@@ obj-$(CONFIG_EXYNOS_THERMAL)	+= exynos_
  obj-$(CONFIG_DOVE_THERMAL)  	+= dove_thermal.o
  obj-$(CONFIG_DB8500_THERMAL)	+= db8500_thermal.o
  obj-$(CONFIG_ARMADA_THERMAL)	+= armada_thermal.o
 -obj-$(CONFIG_IMX_THERMAL)	+= imx_thermal.o
  obj-$(CONFIG_DB8500_CPUFREQ_COOLING)	+= db8500_cpufreq_cooling.o
  obj-$(CONFIG_INTEL_POWERCLAMP)	+= intel_powerclamp.o
++<<<<<<< HEAD
 +
++=======
+ obj-$(CONFIG_X86_PKG_TEMP_THERMAL)	+= x86_pkg_temp_thermal.o
+ obj-$(CONFIG_INTEL_SOC_DTS_THERMAL)	+= intel_soc_dts_thermal.o
+ obj-$(CONFIG_TI_SOC_THERMAL)	+= ti-soc-thermal/
+ obj-$(CONFIG_ACPI_INT3403_THERMAL)	+= int3403_thermal.o
+ obj-$(CONFIG_INT340X_THERMAL)  += int340x_thermal/
+ obj-$(CONFIG_ST_THERMAL)	+= st/
++>>>>>>> 816cab931f28 (Thermal: introduce int3400 thermal driver)
* Unmerged path drivers/acpi/int340x_thermal.c
* Unmerged path drivers/acpi/int340x_thermal.c
* Unmerged path drivers/thermal/Kconfig
* Unmerged path drivers/thermal/Makefile
diff --git a/drivers/thermal/int340x_thermal/Makefile b/drivers/thermal/int340x_thermal/Makefile
new file mode 100644
index 000000000000..e10a53bcefe7
--- /dev/null
+++ b/drivers/thermal/int340x_thermal/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_INT340X_THERMAL)	+= int3400_thermal.o
diff --git a/drivers/thermal/int340x_thermal/int3400_thermal.c b/drivers/thermal/int340x_thermal/int3400_thermal.c
new file mode 100644
index 000000000000..308c1850edee
--- /dev/null
+++ b/drivers/thermal/int340x_thermal/int3400_thermal.c
@@ -0,0 +1,245 @@
+/*
+ * INT3400 thermal driver
+ *
+ * Copyright (C) 2014, Intel Corporation
+ * Authors: Zhang Rui <rui.zhang@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+
+struct art {
+	acpi_handle source;
+	acpi_handle target;
+	u64 weight;
+	u64 ac0_max;
+	u64 ac1_max;
+	u64 ac2_max;
+	u64 ac3_max;
+	u64 ac4_max;
+	u64 ac5_max;
+	u64 ac6_max;
+	u64 ac7_max;
+	u64 ac8_max;
+	u64 ac9_max;
+};
+
+struct trt {
+	acpi_handle source;
+	acpi_handle target;
+	u64 influence;
+	u64 sampling_period;
+	u64 reverved1;
+	u64 reverved2;
+	u64 reverved3;
+	u64 reverved4;
+};
+
+struct int3400_thermal_priv {
+	struct acpi_device *adev;
+	int art_count;
+	struct art *arts;
+	int trt_count;
+	struct trt *trts;
+};
+
+static int parse_art(struct int3400_thermal_priv *priv)
+{
+	acpi_handle handle = priv->adev->handle;
+	acpi_status status;
+	int result = 0;
+	int i;
+	struct acpi_device *adev;
+	union acpi_object *p;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_buffer element = { 0, NULL };
+	struct acpi_buffer art_format = {
+				sizeof("RRNNNNNNNNNNN"), "RRNNNNNNNNNNN" };
+
+	if (!acpi_has_method(handle, "_ART"))
+		return 0;
+
+	status = acpi_evaluate_object(handle, "_ART", NULL, &buffer);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	p = buffer.pointer;
+	if (!p || (p->type != ACPI_TYPE_PACKAGE)) {
+		pr_err("Invalid _ART data\n");
+		result = -EFAULT;
+		goto end;
+	}
+
+	/* ignore p->package.elements[0], as this is _ART Revision field */
+	priv->art_count = p->package.count - 1;
+	priv->arts = kzalloc(sizeof(struct art) * priv->art_count, GFP_KERNEL);
+	if (!priv->arts) {
+		result = -ENOMEM;
+		goto end;
+	}
+
+	for (i = 0; i < priv->art_count; i++) {
+		struct art *art = &(priv->arts[i]);
+
+		element.length = sizeof(struct art);
+		element.pointer = art;
+
+		status = acpi_extract_package(&(p->package.elements[i + 1]),
+					      &art_format, &element);
+		if (ACPI_FAILURE(status)) {
+			pr_err("Invalid _ART data");
+			result = -EFAULT;
+			kfree(priv->arts);
+			goto end;
+		}
+		result = acpi_bus_get_device(art->source, &adev);
+		if (!result)
+			acpi_create_platform_device(adev, NULL);
+		else
+			pr_warn("Failed to get source ACPI device\n");
+		result = acpi_bus_get_device(art->target, &adev);
+		if (!result)
+			acpi_create_platform_device(adev, NULL);
+		else
+			pr_warn("Failed to get source ACPI device\n");
+	}
+end:
+	kfree(buffer.pointer);
+	return result;
+}
+
+static int parse_trt(struct int3400_thermal_priv *priv)
+{
+	acpi_handle handle = priv->adev->handle;
+	acpi_status status;
+	int result = 0;
+	int i;
+	struct acpi_device *adev;
+	union acpi_object *p;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_buffer element = { 0, NULL };
+	struct acpi_buffer trt_format = { sizeof("RRNNNNNN"), "RRNNNNNN" };
+
+	if (!acpi_has_method(handle, "_TRT"))
+		return 0;
+
+	status = acpi_evaluate_object(handle, "_TRT", NULL, &buffer);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	p = buffer.pointer;
+	if (!p || (p->type != ACPI_TYPE_PACKAGE)) {
+		pr_err("Invalid _TRT data\n");
+		result = -EFAULT;
+		goto end;
+	}
+
+	priv->trt_count = p->package.count;
+	priv->trts = kzalloc(sizeof(struct trt) * priv->trt_count, GFP_KERNEL);
+	if (!priv->trts) {
+		result = -ENOMEM;
+		goto end;
+	}
+
+	for (i = 0; i < priv->trt_count; i++) {
+		struct trt *trt = &(priv->trts[i]);
+
+		element.length = sizeof(struct trt);
+		element.pointer = trt;
+
+		status = acpi_extract_package(&(p->package.elements[i]),
+					      &trt_format, &element);
+		if (ACPI_FAILURE(status)) {
+			pr_err("Invalid _ART data");
+			result = -EFAULT;
+			kfree(priv->trts);
+			goto end;
+		}
+
+		result = acpi_bus_get_device(trt->source, &adev);
+		if (!result)
+			acpi_create_platform_device(adev, NULL);
+		else
+			pr_warn("Failed to get source ACPI device\n");
+		result = acpi_bus_get_device(trt->target, &adev);
+		if (!result)
+			acpi_create_platform_device(adev, NULL);
+		else
+			pr_warn("Failed to get target ACPI device\n");
+	}
+end:
+	kfree(buffer.pointer);
+	return result;
+}
+
+static int int3400_thermal_probe(struct platform_device *pdev)
+{
+	struct acpi_device *adev = ACPI_COMPANION(&pdev->dev);
+	struct int3400_thermal_priv *priv;
+	int result;
+
+	if (!adev)
+		return -ENODEV;
+
+	priv = kzalloc(sizeof(struct int3400_thermal_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->adev = adev;
+
+	result = parse_art(priv);
+	if (result)
+		goto free_priv;
+
+	result = parse_trt(priv);
+	if (result)
+		goto free_art;
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+free_art:
+	kfree(priv->arts);
+free_priv:
+	kfree(priv);
+	return result;
+}
+
+static int int3400_thermal_remove(struct platform_device *pdev)
+{
+	struct int3400_thermal_priv *priv = platform_get_drvdata(pdev);
+
+	kfree(priv->trts);
+	kfree(priv->arts);
+	kfree(priv);
+	return 0;
+}
+
+static const struct acpi_device_id int3400_thermal_match[] = {
+	{"INT3400", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, int3400_thermal_match);
+
+static struct platform_driver int3400_thermal_driver = {
+	.probe = int3400_thermal_probe,
+	.remove = int3400_thermal_remove,
+	.driver = {
+		   .name = "int3400 thermal",
+		   .owner = THIS_MODULE,
+		   .acpi_match_table = ACPI_PTR(int3400_thermal_match),
+		   },
+};
+
+module_platform_driver(int3400_thermal_driver);
+
+MODULE_DESCRIPTION("INT3400 Thermal driver");
+MODULE_AUTHOR("Zhang Rui <rui.zhang@intel.com>");
+MODULE_LICENSE("GPL");
