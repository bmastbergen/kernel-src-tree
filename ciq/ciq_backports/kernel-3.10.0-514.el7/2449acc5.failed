powerpc/kernel: Enable seccomp filter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [powerpc] kernel: Enable seccomp filter (Gustavo Duarte) [1186835]
Rebuild_FUZZ: 87.88%
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit 2449acc5348b94325e9374056b2cc3ed55816e96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2449acc5.failed

This commit enables seccomp filter on powerpc, now that we have all the
necessary pieces in place.

To support seccomp's desire to modify the syscall return value under
some circumstances, we use a different ABI to the ptrace ABI. That is we
use r3 as the syscall return value, and orig_gpr3 is the first syscall
parameter.

This means the seccomp code, or a ptracer via SECCOMP_RET_TRACE, will
see -ENOSYS preloaded in r3. This is identical to the behaviour on x86,
and allows seccomp or the ptracer to either leave the -ENOSYS or change
it to something else, as well as rejecting or not the syscall by
modifying r0.

If seccomp does not reject the syscall, we restore the register state to
match what ptrace and audit expect, ie. r3 is the first syscall
parameter again. We do this restore using orig_gpr3, which may have been
modified by seccomp, which allows seccomp to modify the first syscall
paramater and allow the syscall to proceed.

We need to #ifdef the the additional handling of r3 for seccomp, so move
it all out of line.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Reviewed-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit 2449acc5348b94325e9374056b2cc3ed55816e96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/ptrace.c
diff --cc arch/powerpc/kernel/ptrace.c
index f39e3f291595,737c0d0b53ac..000000000000
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@@ -1762,9 -1762,62 +1762,68 @@@ long arch_ptrace(struct task_struct *ch
  	return ret;
  }
  
++<<<<<<< HEAD
 +/*
 + * We must return the syscall number to actually look up in the table.
 + * This can be -1L to skip running any syscall at all.
++=======
+ #ifdef CONFIG_SECCOMP
+ static int do_seccomp(struct pt_regs *regs)
+ {
+ 	if (!test_thread_flag(TIF_SECCOMP))
+ 		return 0;
+ 
+ 	/*
+ 	 * The ABI we present to seccomp tracers is that r3 contains
+ 	 * the syscall return value and orig_gpr3 contains the first
+ 	 * syscall parameter. This is different to the ptrace ABI where
+ 	 * both r3 and orig_gpr3 contain the first syscall parameter.
+ 	 */
+ 	regs->gpr[3] = -ENOSYS;
+ 
+ 	/*
+ 	 * We use the __ version here because we have already checked
+ 	 * TIF_SECCOMP. If this fails, there is nothing left to do, we
+ 	 * have already loaded -ENOSYS into r3, or seccomp has put
+ 	 * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).
+ 	 */
+ 	if (__secure_computing())
+ 		return -1;
+ 
+ 	/*
+ 	 * The syscall was allowed by seccomp, restore the register
+ 	 * state to what ptrace and audit expect.
+ 	 * Note that we use orig_gpr3, which means a seccomp tracer can
+ 	 * modify the first syscall parameter (in orig_gpr3) and also
+ 	 * allow the syscall to proceed.
+ 	 */
+ 	regs->gpr[3] = regs->orig_gpr3;
+ 
+ 	return 0;
+ }
+ #else
+ static inline int do_seccomp(struct pt_regs *regs) { return 0; }
+ #endif /* CONFIG_SECCOMP */
+ 
+ /**
+  * do_syscall_trace_enter() - Do syscall tracing on kernel entry.
+  * @regs: the pt_regs of the task to trace (current)
+  *
+  * Performs various types of tracing on syscall entry. This includes seccomp,
+  * ptrace, syscall tracepoints and audit.
+  *
+  * The pt_regs are potentially visible to userspace via ptrace, so their
+  * contents is ABI.
+  *
+  * One or more of the tracers may modify the contents of pt_regs, in particular
+  * to modify arguments or even the syscall number itself.
+  *
+  * It's also possible that a tracer can choose to reject the system call. In
+  * that case this function will return an illegal syscall number, and will put
+  * an appropriate return value in regs->r3.
+  *
+  * Return: the (possibly changed) syscall number.
++>>>>>>> 2449acc5348b (powerpc/kernel: Enable seccomp filter)
   */
  long do_syscall_trace_enter(struct pt_regs *regs)
  {
@@@ -1772,16 -1825,18 +1831,17 @@@
  
  	user_exit();
  
- 	secure_computing_strict(regs->gpr[0]);
+ 	if (do_seccomp(regs))
+ 		return -1;
  
 -	if (test_thread_flag(TIF_SYSCALL_TRACE)) {
 +	if (test_thread_flag(TIF_SYSCALL_TRACE) &&
 +	    tracehook_report_syscall_entry(regs))
  		/*
 -		 * The tracer may decide to abort the syscall, if so tracehook
 -		 * will return !0. Note that the tracer may also just change
 -		 * regs->gpr[0] to an invalid syscall number, that is handled
 -		 * below on the exit path.
 +		 * Tracing decided this syscall should not happen.
 +		 * We'll return a bogus call number to get an ENOSYS
 +		 * error, but leave the original number in regs->gpr[0].
  		 */
 -		abort = tracehook_report_syscall_entry(regs) != 0;
 -	}
 +		ret = -1L;
  
  	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
  		trace_sys_enter(regs, regs->gpr[0]);
diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 708eef8e757e..d58f890865b2 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -147,6 +147,7 @@ config PPC
 	select HAVE_IRQ_EXIT_ON_IRQ_STACK
 	select ARCH_USE_CMPXCHG_LOCKREF if PPC64
 	select ARCH_HAS_DMA_SET_COHERENT_MASK
+	select HAVE_ARCH_SECCOMP_FILTER
 
 config GENERIC_CSUM
 	def_bool CPU_LITTLE_ENDIAN
* Unmerged path arch/powerpc/kernel/ptrace.c
