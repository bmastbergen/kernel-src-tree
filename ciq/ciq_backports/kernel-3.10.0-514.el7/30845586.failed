megaraid_sas: Don't issue kill adapter for MFI controllers in case of PD list DCMD failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sumit Saxena <sumit.saxena@broadcom.com>
commit 3084558658c2f9a48d7c460d57aeb30964c06b7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/30845586.failed

There are few MFI adapters which do not support MR_DCMD_PD_LIST_QUERY so
if MFI adapters fail this DCMD, it should not be considered as FATAL and
driver should not issue kill adapter and set per controller's instance
variable- pd_list_not_supported so that same variable can be used inside
functions- slave_alloc and slave_configure to allow firmware scan.

Killing adapter because of DCMD failure when this DCMD is not supported
causes driver's probe getting failed. This issue got introduced by
commit 6d40afbc7d13 ("megaraid_sas: MFI IO timeout handling").

Killing adapter in case of this DCMD failure should be limited to Fusion
adapters only. Per controller's instance variable allow_fw_scan is
removed as pd_list_not_supported better reflect the purpose.

Fixes: 6d40afbc7d13359b30a5cd783e3db6ebefa5f40a
	Signed-off-by: Sumit Saxena <sumit.saxena@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Hannes Reinicke <hare@suse.de>
	Reviewed-by: Ewan Milne <emilne@redhat.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3084558658c2f9a48d7c460d57aeb30964c06b7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas.h
#	drivers/scsi/megaraid/megaraid_sas_base.c
diff --cc drivers/scsi/megaraid/megaraid_sas.h
index d4c399b43165,fce414a2cd76..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@@ -1790,6 -2097,7 +1790,10 @@@ struct megasas_instance 
  	u8 UnevenSpanSupport;
  
  	u8 supportmax256vd;
++<<<<<<< HEAD
++=======
+ 	u8 pd_list_not_supported;
++>>>>>>> 3084558658c2 (megaraid_sas: Don't issue kill adapter for MFI controllers in case of PD list DCMD failure)
  	u16 fw_supported_vd_count;
  	u16 fw_supported_pd_count;
  
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index 7868286c419b,69d375b8f2e1..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -1748,14 -1831,31 +1748,34 @@@ static void megasas_set_dma_alignment(s
  	}
  }
  
 -
  static int megasas_slave_configure(struct scsi_device *sdev)
  {
++<<<<<<< HEAD
 +	megasas_set_dma_alignment(sdev);
++=======
+ 	u16 pd_index = 0;
+ 	struct megasas_instance *instance;
+ 
+ 	instance = megasas_lookup_instance(sdev->host->host_no);
+ 	if (instance->pd_list_not_supported) {
+ 		if (sdev->channel < MEGASAS_MAX_PD_CHANNELS &&
+ 			sdev->type == TYPE_DISK) {
+ 			pd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +
+ 				sdev->id;
+ 			if (instance->pd_list[pd_index].driveState !=
+ 				MR_PD_STATE_SYSTEM)
+ 				return -ENXIO;
+ 		}
+ 	}
+ 	megasas_set_device_queue_depth(sdev);
+ 	megasas_update_sdev_properties(sdev);
+ 
++>>>>>>> 3084558658c2 (megaraid_sas: Don't issue kill adapter for MFI controllers in case of PD list DCMD failure)
  	/*
 -	 * The RAID firmware may require extended timeouts.
 -	 */
 +	* The RAID firmware may require extended timeouts.
 +	*/
  	blk_queue_rq_timeout(sdev->request_queue,
 -		scmd_timeout * HZ);
 +		MEGASAS_DEFAULT_CMD_TIMEOUT * HZ);
  
  	return 0;
  }
@@@ -1772,8 -1874,9 +1792,14 @@@ static int megasas_slave_alloc(struct s
  		pd_index =
  			(sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +
  			sdev->id;
++<<<<<<< HEAD
 +		if (instance->pd_list[pd_index].driveState ==
 +					MR_PD_STATE_SYSTEM) {
++=======
+ 		if ((instance->pd_list_not_supported ||
+ 			instance->pd_list[pd_index].driveState ==
+ 			MR_PD_STATE_SYSTEM)) {
++>>>>>>> 3084558658c2 (megaraid_sas: Don't issue kill adapter for MFI controllers in case of PD list DCMD failure)
  			goto scan_target;
  		}
  		return -ENXIO;
@@@ -3952,31 -4086,66 +3978,45 @@@ megasas_get_pd_list(struct megasas_inst
  	else
  		ret = megasas_issue_polled(instance, cmd);
  
++<<<<<<< HEAD
 +	/*
 +	* the following function will get the instance PD LIST.
 +	*/
++=======
+ 	switch (ret) {
+ 	case DCMD_FAILED:
+ 		dev_info(&instance->pdev->dev, "MR_DCMD_PD_LIST_QUERY "
+ 			"failed/not supported by firmware\n");
+ 
+ 		if (instance->ctrl_context)
+ 			megaraid_sas_kill_hba(instance);
+ 		else
+ 			instance->pd_list_not_supported = 1;
+ 		break;
+ 	case DCMD_TIMEOUT:
++>>>>>>> 3084558658c2 (megaraid_sas: Don't issue kill adapter for MFI controllers in case of PD list DCMD failure)
  
 -		switch (dcmd_timeout_ocr_possible(instance)) {
 -		case INITIATE_OCR:
 -			cmd->flags |= DRV_DCMD_SKIP_REFIRE;
 -			/*
 -			 * DCMD failed from AEN path.
 -			 * AEN path already hold reset_mutex to avoid PCI access
 -			 * while OCR is in progress.
 -			 */
 -			mutex_unlock(&instance->reset_mutex);
 -			megasas_reset_fusion(instance->host,
 -						MFI_IO_TIMEOUT_OCR);
 -			mutex_lock(&instance->reset_mutex);
 -			break;
 -		case KILL_ADAPTER:
 -			megaraid_sas_kill_hba(instance);
 -			break;
 -		case IGNORE_TIMEOUT:
 -			dev_info(&instance->pdev->dev, "Ignore DCMD timeout: %s %d \n",
 -				__func__, __LINE__);
 -			break;
 -		}
 -
 -		break;
 -
 -	case DCMD_SUCCESS:
 -		pd_addr = ci->addr;
 +	pd_addr = ci->addr;
  
 -		if ((le32_to_cpu(ci->count) >
 -			(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL)))
 -			break;
 +	if ( ret == 0 &&
 +	     (le32_to_cpu(ci->count) <
 +		  (MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL))) {
  
  		memset(instance->local_pd_list, 0,
 -				MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));
 +			MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));
  
  		for (pd_index = 0; pd_index < le32_to_cpu(ci->count); pd_index++) {
 +
  			instance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].tid	=
 -					le16_to_cpu(pd_addr->deviceId);
 +				le16_to_cpu(pd_addr->deviceId);
  			instance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveType	=
 -					pd_addr->scsiDevType;
 +							pd_addr->scsiDevType;
  			instance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveState	=
 -					MR_PD_STATE_SYSTEM;
 +							MR_PD_STATE_SYSTEM;
  			pd_addr++;
  		}
 -
  		memcpy(instance->pd_list, instance->local_pd_list,
  			sizeof(instance->pd_list));
 -		break;
 -
  	}
  
  	pci_free_consistent(instance->pdev,
* Unmerged path drivers/scsi/megaraid/megaraid_sas.h
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
