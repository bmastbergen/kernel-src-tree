iommu/amd: Put IOMMUv2 devices in a direct mapped domain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] amd: Put IOMMUv2 devices in a direct mapped domain (Myron Stowe) [1050021]
Rebuild_FUZZ: 94.34%
commit-author Joerg Roedel <jroedel@suse.de>
commit 07ee86948c9111d49583be462500042fedfecb4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/07ee8694.failed

A device that might be used for HSA needs to be in a direct
mapped domain so that all DMA-API mappings stay alive when
the IOMMUv2 stack is used.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 07ee86948c9111d49583be462500042fedfecb4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu.c
diff --cc drivers/iommu/amd_iommu.c
index 5607b3ae03af,623be17e28d7..000000000000
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@@ -2370,44 -2251,49 +2370,71 @@@ static void detach_device(struct devic
  	dev_data->ats.enabled = false;
  }
  
 -static int amd_iommu_add_device(struct device *dev)
 +/*
 + * Find out the protection domain structure for a given PCI device. This
 + * will give us the pointer to the page table root for example.
 + */
 +static struct protection_domain *domain_for_device(struct device *dev)
  {
  	struct iommu_dev_data *dev_data;
++<<<<<<< HEAD
 +	struct protection_domain *dom = NULL;
 +	unsigned long flags;
++=======
+ 	struct iommu_domain *domain;
+ 	struct amd_iommu *iommu;
+ 	u16 devid;
+ 	int ret;
++>>>>>>> 07ee86948c91 (iommu/amd: Put IOMMUv2 devices in a direct mapped domain)
  
 -	if (!check_device(dev) || get_dev_data(dev))
 -		return 0;
 +	dev_data   = get_dev_data(dev);
  
 -	devid = get_device_id(dev);
 -	iommu = amd_iommu_rlookup_table[devid];
 +	if (dev_data->domain)
 +		return dev_data->domain;
  
 -	ret = iommu_init_device(dev);
 -	if (ret == -ENOTSUPP) {
 -		iommu_ignore_device(dev);
 -		goto out;
 +	if (dev_data->alias_data != NULL) {
 +		struct iommu_dev_data *alias_data = dev_data->alias_data;
 +
 +		read_lock_irqsave(&amd_iommu_devtable_lock, flags);
 +		if (alias_data->domain != NULL) {
 +			__attach_device(dev_data, alias_data->domain);
 +			dom = alias_data->domain;
 +		}
 +		read_unlock_irqrestore(&amd_iommu_devtable_lock, flags);
  	}
 -	init_iommu_group(dev);
  
++<<<<<<< HEAD
 +	return dom;
++=======
+ 	dev_data = get_dev_data(dev);
+ 	if (dev_data && dev_data->iommu_v2)
+ 		iommu_request_dm_for_dev(dev);
+ 
+ 	/* Domains are initialized for this device - have a look what we ended up with */
+ 	domain = iommu_get_domain_for_dev(dev);
+ 	if (domain->type == IOMMU_DOMAIN_IDENTITY) {
+ 		dev_data->passthrough = true;
+ 		dev->archdata.dma_ops = &nommu_dma_ops;
+ 	} else {
+ 		dev->archdata.dma_ops = &amd_iommu_dma_ops;
+ 	}
+ 
+ out:
+ 	iommu_completion_wait(iommu);
+ 
+ 	return 0;
++>>>>>>> 07ee86948c91 (iommu/amd: Put IOMMUv2 devices in a direct mapped domain)
  }
  
 -static void amd_iommu_remove_device(struct device *dev)
 +static int device_change_notifier(struct notifier_block *nb,
 +				  unsigned long action, void *data)
  {
 +	struct dma_ops_domain *dma_domain;
 +	struct protection_domain *domain;
 +	struct iommu_dev_data *dev_data;
 +	struct device *dev = data;
  	struct amd_iommu *iommu;
 +	unsigned long flags;
  	u16 devid;
  
  	if (!check_device(dev))
* Unmerged path drivers/iommu/amd_iommu.c
