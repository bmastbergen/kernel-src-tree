tpm_tis: Clean up the force=1 module parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit 00194826e6be333083ba9ddbd6e83fb423206f8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/00194826.failed

The TPM core has long assumed that every device has a driver attached,
however the force path was attaching the TPM core outside of a driver
context. This isn't generally reliable as the user could detatch the
driver using sysfs or something, but commit b8b2c7d845d5 ("base/platform:
assert that dev_pm_domain callbacks are called unconditionally")
forced the issue by leaving the driver pointer NULL if there is
no probe.

Rework the TPM setup to create a platform device with resources and
then allow the driver core to naturally bind and probe it through the
normal mechanisms. All this structure is needed anyhow to enable TPM
for OF environments.

Finally, since the entire flow is changing convert the init/exit to use
the modern ifdef-less coding style when possible

	Reported-by: "Wilck, Martin" <martin.wilck@ts.fujitsu.com>
	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Tested-by: Wilck, Martin <martin.wilck@ts.fujitsu.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit 00194826e6be333083ba9ddbd6e83fb423206f8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,ca137b5b7c24..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -65,6 -64,14 +64,17 @@@ enum tis_defaults 
  	TIS_LONG_TIMEOUT = 2000,	/* 2 sec */
  };
  
++<<<<<<< HEAD
++=======
+ struct tpm_info {
+ 	struct resource res;
+ 	/* irq > 0 means: use irq $irq;
+ 	 * irq = 0 means: autoprobe for an irq;
+ 	 * irq = -1 means: no irq support
+ 	 */
+ 	int irq;
+ };
++>>>>>>> 00194826e6be (tpm_tis: Clean up the force=1 module parameter)
  
  /* Some timeout values are needed before it is known whether the chip is
   * TPM 1.0 or TPM 2.0.
@@@ -864,32 -858,31 +873,39 @@@ static int tpm_tis_resume(struct devic
  
  static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_resume);
  
- #ifdef CONFIG_PNP
  static int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,
 -			    const struct pnp_device_id *pnp_id)
 +				      const struct pnp_device_id *pnp_id)
  {
 -	struct tpm_info tpm_info = {};
 +	resource_size_t start, len;
 +	unsigned int irq = 0;
  	acpi_handle acpi_dev_handle = NULL;
 -	struct resource *res;
  
 -	res = pnp_get_resource(pnp_dev, IORESOURCE_MEM, 0);
 -	if (!res)
 -		return -ENODEV;
 -	tpm_info.res = *res;
 +	start = pnp_mem_start(pnp_dev, 0);
 +	len = pnp_mem_len(pnp_dev, 0);
  
  	if (pnp_irq_valid(pnp_dev, 0))
 -		tpm_info.irq = pnp_irq(pnp_dev, 0);
 +		irq = pnp_irq(pnp_dev, 0);
  	else
 -		tpm_info.irq = -1;
 +		interrupts = false;
  
 +	if (is_itpm(pnp_dev))
 +		itpm = true;
 +
++<<<<<<< HEAD
 +#ifdef CONFIG_ACPI
 +	if (pnp_acpi_device(pnp_dev))
 +		acpi_dev_handle = pnp_acpi_device(pnp_dev)->handle;
 +#endif
++=======
+ 	if (pnp_acpi_device(pnp_dev)) {
+ 		if (is_itpm(pnp_acpi_device(pnp_dev)))
+ 			itpm = true;
+ 
+ 		acpi_dev_handle = ACPI_HANDLE(&pnp_dev->dev);
+ 	}
++>>>>>>> 00194826e6be (tpm_tis: Clean up the force=1 module parameter)
  
 -	return tpm_tis_init(&pnp_dev->dev, &tpm_info, acpi_dev_handle);
 +	return tpm_tis_init(&pnp_dev->dev, acpi_dev_handle, start, len, irq);
  }
  
  static struct pnp_device_id tpm_pnp_tbl[] = {
@@@ -927,61 -921,221 +943,258 @@@ static struct pnp_driver tis_pnp_drive
  module_param_string(hid, tpm_pnp_tbl[TIS_HID_USR_IDX].id,
  		    sizeof(tpm_pnp_tbl[TIS_HID_USR_IDX].id), 0444);
  MODULE_PARM_DESC(hid, "Set additional specific HID for this driver to probe");
+ 
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ACPI
+ static int tpm_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct tpm_info *tpm_info = (struct tpm_info *) data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_interrupt(ares, 0, &res))
+ 		tpm_info->irq = res.start;
+ 	else if (acpi_dev_resource_memory(ares, &res))
+ 		tpm_info->res = res;
+ 
+ 	return 1;
+ }
+ 
+ static int tpm_tis_acpi_init(struct acpi_device *acpi_dev)
+ {
+ 	struct acpi_table_tpm2 *tbl;
+ 	acpi_status st;
+ 	struct list_head resources;
+ 	struct tpm_info tpm_info = {};
+ 	int ret;
+ 
+ 	st = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 			    (struct acpi_table_header **) &tbl);
+ 	if (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	tpm_info.irq = -1;
+ 	ret = acpi_dev_get_resources(acpi_dev, &resources, tpm_check_resource,
+ 				     &tpm_info);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (resource_type(&tpm_info.res) != IORESOURCE_MEM) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (is_itpm(acpi_dev))
+ 		itpm = true;
+ 
+ 	return tpm_tis_init(&acpi_dev->dev, &tpm_info, acpi_dev->handle);
+ }
+ 
+ static int tpm_tis_acpi_remove(struct acpi_device *dev)
+ {
+ 	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
+ 
+ 	tpm_chip_unregister(chip);
+ 	tpm_tis_remove(chip);
+ 
+ 	return 0;
+ }
+ 
+ static struct acpi_device_id tpm_acpi_tbl[] = {
+ 	{"MSFT0101", 0},	/* TPM 2.0 */
+ 	/* Add new here */
+ 	{"", 0},		/* User Specified */
+ 	{"", 0}			/* Terminator */
+ };
+ MODULE_DEVICE_TABLE(acpi, tpm_acpi_tbl);
+ 
+ static struct acpi_driver tis_acpi_driver = {
+ 	.name = "tpm_tis",
+ 	.ids = tpm_acpi_tbl,
+ 	.ops = {
+ 		.add = tpm_tis_acpi_init,
+ 		.remove = tpm_tis_acpi_remove,
+ 	},
+ 	.drv = {
+ 		.pm = &tpm_tis_pm,
+ 	},
+ };
  #endif
  
+ static struct platform_device *force_pdev;
+ 
+ static int tpm_tis_plat_probe(struct platform_device *pdev)
+ {
+ 	struct tpm_info tpm_info = {};
+ 	struct resource *res;
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (res == NULL) {
+ 		dev_err(&pdev->dev, "no memory resource defined\n");
+ 		return -ENODEV;
+ 	}
+ 	tpm_info.res = *res;
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+ 	if (res) {
+ 		tpm_info.irq = res->start;
+ 	} else {
+ 		if (pdev == force_pdev)
+ 			tpm_info.irq = -1;
+ 		else
+ 			/* When forcing auto probe the IRQ */
+ 			tpm_info.irq = 0;
+ 	}
+ 
+ 	return tpm_tis_init(&pdev->dev, &tpm_info, NULL);
+ }
+ 
+ static int tpm_tis_plat_remove(struct platform_device *pdev)
+ {
+ 	struct tpm_chip *chip = dev_get_drvdata(&pdev->dev);
+ 
+ 	tpm_chip_unregister(chip);
+ 	tpm_tis_remove(chip);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 00194826e6be (tpm_tis: Clean up the force=1 module parameter)
  static struct platform_driver tis_drv = {
+ 	.probe = tpm_tis_plat_probe,
+ 	.remove = tpm_tis_plat_remove,
  	.driver = {
  		.name		= "tpm_tis",
  		.pm		= &tpm_tis_pm,
  	},
  };
  
- static struct platform_device *pdev;
- 
  static bool force;
+ #ifdef CONFIG_X86
  module_param(force, bool, 0444);
  MODULE_PARM_DESC(force, "Force device probe rather than using ACPI entry");
- static int __init init_tis(void)
+ #endif
+ 
+ static int tpm_tis_force_device(void)
  {
++<<<<<<< HEAD
 +	int rc;
 +#ifdef CONFIG_PNP
++=======
+ 	struct platform_device *pdev;
+ 	static const struct resource x86_resources[] = {
+ 		{
+ 			.start = 0xFED40000,
+ 			.end = 0xFED40000 + TIS_MEM_LEN - 1,
+ 			.flags = IORESOURCE_MEM,
+ 		},
+ 	};
+ 
++>>>>>>> 00194826e6be (tpm_tis: Clean up the force=1 module parameter)
  	if (!force)
 -		return 0;
 +		return pnp_register_driver(&tis_pnp_driver);
 +#endif
  
++<<<<<<< HEAD
 +	rc = platform_driver_register(&tis_drv);
 +	if (rc < 0)
 +		return rc;
 +	pdev = platform_device_register_simple("tpm_tis", -1, NULL, 0);
 +	if (IS_ERR(pdev)) {
 +		rc = PTR_ERR(pdev);
 +		goto err_dev;
 +	}
 +	rc = tpm_tis_init(&pdev->dev, NULL, TIS_MEM_BASE, TIS_MEM_LEN, 0);
 +	if (rc)
 +		goto err_init;
++=======
+ 	/* The driver core will match the name tpm_tis of the device to
+ 	 * the tpm_tis platform driver and complete the setup via
+ 	 * tpm_tis_plat_probe
+ 	 */
+ 	pdev = platform_device_register_simple("tpm_tis", -1, x86_resources,
+ 					       ARRAY_SIZE(x86_resources));
+ 	if (IS_ERR(pdev))
+ 		return PTR_ERR(pdev);
+ 	force_pdev = pdev;
+ 
++>>>>>>> 00194826e6be (tpm_tis: Clean up the force=1 module parameter)
  	return 0;
- err_init:
- 	platform_device_unregister(pdev);
- err_dev:
- 	platform_driver_unregister(&tis_drv);
+ }
+ 
+ static int __init init_tis(void)
+ {
+ 	int rc;
+ 
+ 	rc = tpm_tis_force_device();
+ 	if (rc)
+ 		goto err_force;
+ 
+ 	rc = platform_driver_register(&tis_drv);
+ 	if (rc)
+ 		goto err_platform;
+ 
+ #ifdef CONFIG_ACPI
+ 	rc = acpi_bus_register_driver(&tis_acpi_driver);
+ 	if (rc)
+ 		goto err_acpi;
+ #endif
+ 
+ 	if (IS_ENABLED(CONFIG_PNP)) {
+ 		rc = pnp_register_driver(&tis_pnp_driver);
+ 		if (rc)
+ 			goto err_pnp;
+ 	}
+ 
+ 	return 0;
+ 
+ err_pnp:
+ #ifdef CONFIG_ACPI
+ 	acpi_bus_unregister_driver(&tis_acpi_driver);
+ err_acpi:
+ #endif
+ 	platform_device_unregister(force_pdev);
+ err_platform:
+ 	if (force_pdev)
+ 		platform_device_unregister(force_pdev);
+ err_force:
  	return rc;
  }
  
  static void __exit cleanup_tis(void)
  {
++<<<<<<< HEAD
 +	struct tpm_chip *chip;
 +#ifdef CONFIG_PNP
 +	if (!force) {
 +		pnp_unregister_driver(&tis_pnp_driver);
 +		return;
 +	}
 +#endif
 +	chip = dev_get_drvdata(&pdev->dev);
 +	tpm_chip_unregister(chip);
 +	tpm_tis_remove(chip);
 +	platform_device_unregister(pdev);
++=======
+ 	pnp_unregister_driver(&tis_pnp_driver);
+ #ifdef CONFIG_ACPI
+ 	acpi_bus_unregister_driver(&tis_acpi_driver);
+ #endif
++>>>>>>> 00194826e6be (tpm_tis: Clean up the force=1 module parameter)
  	platform_driver_unregister(&tis_drv);
+ 
+ 	if (force_pdev)
+ 		platform_device_unregister(force_pdev);
  }
  
  module_init(init_tis);
* Unmerged path drivers/char/tpm/tpm_tis.c
