zram: add dynamic device add/remove functionality

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
commit 6566d1a32bf725a4fa9119f16270505451ad01ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6566d1a3.failed

We currently don't support on-demand device creation.  The one and only
way to have N zram devices is to specify num_devices module parameter
(default value: 1).  IOW if, for some reason, at some point, user wants
to have N + 1 devies he/she must umount all the existing devices, unload
the module, load the module passing num_devices equals to N + 1.  And do
this again, if needed.

This patch introduces zram control sysfs class, which has two sysfs
attrs:
- hot_add      -- add a new zram device
- hot_remove   -- remove a specific (device_id) zram device

hot_add sysfs attr is read-only and has only automatic device id
assignment mode (as requested by Minchan Kim).  read operation performed
on this attr creates a new zram device and returns back its device_id or
error status.

Usage example:
	# add a new specific zram device
	cat /sys/class/zram-control/hot_add
	2

	# remove a specific zram device
	echo 4 > /sys/class/zram-control/hot_remove

Returning zram_add() error code back to user (-ENOMEM in this case)

	cat /sys/class/zram-control/hot_add
	cat: /sys/class/zram-control/hot_add: Cannot allocate memory

NOTE, there might be users who already depend on the fact that at least
zram0 device gets always created by zram_init(). Preserve this behavior.

[minchan@kernel.org: use zram->claim to avoid lockdep splat]
	Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6566d1a32bf725a4fa9119f16270505451ad01ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/blockdev/zram.txt
#	drivers/block/zram/zram_drv.c
diff --cc Documentation/blockdev/zram.txt
index f9135b48fe66,c4de576093af..000000000000
--- a/Documentation/blockdev/zram.txt
+++ b/Documentation/blockdev/zram.txt
@@@ -149,7 -168,30 +166,34 @@@ File /sys/block/zram<id>/sta
  Represents block layer statistics. Read Documentation/block/stat.txt for
  details.
  
++<<<<<<< HEAD
 +8) Deactivate:
++=======
+ File /sys/block/zram<id>/io_stat
+ 
+ The stat file represents device's I/O statistics not accounted by block
+ layer and, thus, not available in zram<id>/stat file. It consists of a
+ single line of text and contains the following stats separated by
+ whitespace:
+ 	failed_reads
+ 	failed_writes
+ 	invalid_io
+ 	notify_free
+ 
+ File /sys/block/zram<id>/mm_stat
+ 
+ The stat file represents device's mm statistics. It consists of a single
+ line of text and contains the following stats separated by whitespace:
+ 	orig_data_size
+ 	compr_data_size
+ 	mem_used_total
+ 	mem_limit
+ 	mem_used_max
+ 	zero_pages
+ 	num_migrated
+ 
+ 9) Deactivate:
++>>>>>>> 6566d1a32bf7 (zram: add dynamic device add/remove functionality)
  	swapoff /dev/zram0
  	umount /dev/zram1
  
diff --cc drivers/block/zram/zram_drv.c
index f4772ab5159f,830f0eb501fa..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -32,12 -28,16 +32,24 @@@
  #include <linux/string.h>
  #include <linux/vmalloc.h>
  #include <linux/err.h>
++<<<<<<< HEAD
 +
 +#include "zram_drv.h"
 +
 +/* Globals */
++=======
+ #include <linux/idr.h>
+ #include <linux/sysfs.h>
+ 
+ #include "zram_drv.h"
+ 
+ static DEFINE_IDR(zram_index_idr);
+ /* idr index must be protected */
+ static DEFINE_MUTEX(zram_index_mutex);
+ 
++>>>>>>> 6566d1a32bf7 (zram: add dynamic device add/remove functionality)
  static int zram_major;
 +static struct zram *zram_devices;
  static const char *default_compressor = "lzo";
  
  /* Module params (documentation at end) */
@@@ -1013,59 -1277,148 +1025,192 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void destroy_device(struct zram *zram)
 +{
 +	sysfs_remove_group(&disk_to_dev(zram->disk)->kobj,
 +			&zram_disk_attr_group);
 +
 +	del_gendisk(zram->disk);
 +	put_disk(zram->disk);
 +
 +	blk_cleanup_queue(zram->queue);
++=======
+ static int zram_remove(struct zram *zram)
+ {
+ 	struct block_device *bdev;
+ 
+ 	bdev = bdget_disk(zram->disk, 0);
+ 	if (!bdev)
+ 		return -ENOMEM;
+ 
+ 	mutex_lock(&bdev->bd_mutex);
+ 	if (bdev->bd_openers || zram->claim) {
+ 		mutex_unlock(&bdev->bd_mutex);
+ 		bdput(bdev);
+ 		return -EBUSY;
+ 	}
+ 
+ 	zram->claim = true;
+ 	mutex_unlock(&bdev->bd_mutex);
+ 
+ 	/*
+ 	 * Remove sysfs first, so no one will perform a disksize
+ 	 * store while we destroy the devices. This also helps during
+ 	 * hot_remove -- zram_reset_device() is the last holder of
+ 	 * ->init_lock, no later/concurrent disksize_store() or any
+ 	 * other sysfs handlers are possible.
+ 	 */
+ 	sysfs_remove_group(&disk_to_dev(zram->disk)->kobj,
+ 			&zram_disk_attr_group);
+ 
+ 	/* Make sure all the pending I/O are finished */
+ 	fsync_bdev(bdev);
+ 	zram_reset_device(zram);
+ 	bdput(bdev);
+ 
+ 	pr_info("Removed device: %s\n", zram->disk->disk_name);
+ 
+ 	idr_remove(&zram_index_idr, zram->disk->first_minor);
+ 	blk_cleanup_queue(zram->disk->queue);
+ 	del_gendisk(zram->disk);
+ 	put_disk(zram->disk);
+ 	kfree(zram);
+ 	return 0;
+ }
+ 
+ /* zram-control sysfs attributes */
+ static ssize_t hot_add_show(struct class *class,
+ 			struct class_attribute *attr,
+ 			char *buf)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&zram_index_mutex);
+ 	ret = zram_add();
+ 	mutex_unlock(&zram_index_mutex);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 	return scnprintf(buf, PAGE_SIZE, "%d\n", ret);
+ }
+ 
+ static ssize_t hot_remove_store(struct class *class,
+ 			struct class_attribute *attr,
+ 			const char *buf,
+ 			size_t count)
+ {
+ 	struct zram *zram;
+ 	int ret, dev_id;
+ 
+ 	/* dev_id is gendisk->first_minor, which is `int' */
+ 	ret = kstrtoint(buf, 10, &dev_id);
+ 	if (ret)
+ 		return ret;
+ 	if (dev_id < 0)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&zram_index_mutex);
+ 
+ 	zram = idr_find(&zram_index_idr, dev_id);
+ 	if (zram)
+ 		ret = zram_remove(zram);
+ 	else
+ 		ret = -ENODEV;
+ 
+ 	mutex_unlock(&zram_index_mutex);
+ 	return ret ? ret : count;
+ }
+ 
+ static struct class_attribute zram_control_class_attrs[] = {
+ 	__ATTR_RO(hot_add),
+ 	__ATTR_WO(hot_remove),
+ 	__ATTR_NULL,
+ };
+ 
+ static struct class zram_control_class = {
+ 	.name		= "zram-control",
+ 	.owner		= THIS_MODULE,
+ 	.class_attrs	= zram_control_class_attrs,
+ };
+ 
+ static int zram_remove_cb(int id, void *ptr, void *data)
+ {
+ 	zram_remove(ptr);
+ 	return 0;
+ }
+ 
+ static void destroy_devices(void)
+ {
+ 	class_unregister(&zram_control_class);
+ 	idr_for_each(&zram_index_idr, &zram_remove_cb, NULL);
+ 	idr_destroy(&zram_index_idr);
+ 	unregister_blkdev(zram_major, "zram");
++>>>>>>> 6566d1a32bf7 (zram: add dynamic device add/remove functionality)
  }
  
  static int __init zram_init(void)
  {
 -	int ret;
 +	int ret, dev_id;
 +
 +	if (num_devices > max_num_devices) {
 +		pr_warn("Invalid value for num_devices: %u\n",
 +				num_devices);
 +		ret = -EINVAL;
 +		goto out;
 +	}
  
+ 	ret = class_register(&zram_control_class);
+ 	if (ret) {
+ 		pr_warn("Unable to register zram-control class\n");
+ 		return ret;
+ 	}
+ 
  	zram_major = register_blkdev(0, "zram");
  	if (zram_major <= 0) {
  		pr_warn("Unable to get major number\n");
++<<<<<<< HEAD
 +		ret = -EBUSY;
 +		goto out;
 +	}
 +
 +	/* Allocate the device array and initialize each one */
 +	zram_devices = kzalloc(num_devices * sizeof(struct zram), GFP_KERNEL);
 +	if (!zram_devices) {
 +		ret = -ENOMEM;
 +		goto unregister;
++=======
+ 		class_unregister(&zram_control_class);
+ 		return -EBUSY;
+ 	}
+ 
+ 	while (num_devices != 0) {
+ 		mutex_lock(&zram_index_mutex);
+ 		ret = zram_add();
+ 		mutex_unlock(&zram_index_mutex);
+ 		if (ret < 0)
+ 			goto out_error;
+ 		num_devices--;
++>>>>>>> 6566d1a32bf7 (zram: add dynamic device add/remove functionality)
  	}
  
 +	for (dev_id = 0; dev_id < num_devices; dev_id++) {
 +		ret = create_device(&zram_devices[dev_id], dev_id);
 +		if (ret)
 +			goto free_devices;
 +	}
 +
 +	pr_info("Created %u device(s) ...\n", num_devices);
 +
  	return 0;
  
 -out_error:
 -	destroy_devices();
 +free_devices:
 +	while (dev_id)
 +		destroy_device(&zram_devices[--dev_id]);
 +	kfree(zram_devices);
 +unregister:
 +	unregister_blkdev(zram_major, "zram");
 +out:
  	return ret;
  }
  
diff --git a/Documentation/ABI/testing/sysfs-class-zram b/Documentation/ABI/testing/sysfs-class-zram
new file mode 100644
index 000000000000..48ddacbe0e69
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-class-zram
@@ -0,0 +1,24 @@
+What:		/sys/class/zram-control/
+Date:		August 2015
+KernelVersion:	4.2
+Contact:	Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
+Description:
+		The zram-control/ class sub-directory belongs to zram
+		device class
+
+What:		/sys/class/zram-control/hot_add
+Date:		August 2015
+KernelVersion:	4.2
+Contact:	Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
+Description:
+		RO attribute. Read operation will cause zram to add a new
+		device and return its device id back to user (so one can
+		use /dev/zram<id>), or error code.
+
+What:		/sys/class/zram-control/hot_remove
+Date:		August 2015
+KernelVersion:	4.2
+Contact:	Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
+Description:
+		WO attribute. Remove a specific /dev/zramX device, where X
+		is a device_id provided by user.
* Unmerged path Documentation/blockdev/zram.txt
* Unmerged path drivers/block/zram/zram_drv.c
