netfilter: bridge: refactor conditional in br_nf_dev_queue_xmit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Florian Westphal <fw@strlen.de>
commit 7a8d831df5811f49957cc9b7976319973d088c34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7a8d831d.failed

simpilifies followup patch that re-works brnf ip_fragment handling.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 7a8d831df5811f49957cc9b7976319973d088c34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netfilter.c
diff --cc net/bridge/br_netfilter.c
index d354bf857875,ef1fe281ca11..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -822,14 -771,49 +822,29 @@@ static unsigned int br_nf_forward_arp(c
  	return NF_STOLEN;
  }
  
 -#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
 -static bool nf_bridge_copy_header(struct sk_buff *skb)
 -{
 -	int err;
 -	unsigned int header_size;
 -
 -	nf_bridge_update_protocol(skb);
 -	header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);
 -	err = skb_cow_head(skb, header_size);
 -	if (err)
 -		return false;
 -
 -	skb_copy_to_linear_data_offset(skb, -header_size,
 -				       skb->nf_bridge->data, header_size);
 -	__skb_push(skb, nf_bridge_encap_header_len(skb));
 -	return true;
 -}
 -
 -static int br_nf_push_frag_xmit(struct sk_buff *skb)
 -{
 -	if (!nf_bridge_copy_header(skb)) {
 -		kfree_skb(skb);
 -		return 0;
 -	}
 -
 -	return br_dev_queue_push_xmit(skb);
 -}
 -
 -static int br_nf_dev_queue_xmit(struct sk_buff *skb)
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
  {
  	int ret;
++<<<<<<< HEAD
 +
 +	if (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&
 +	    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
 +	    !skb_is_gso(skb)) {
++=======
+ 	int frag_max_size;
+ 	unsigned int mtu_reserved;
+ 
+ 	if (skb_is_gso(skb) || skb->protocol != htons(ETH_P_IP))
+ 		return br_dev_queue_push_xmit(skb);
+ 
+ 	mtu_reserved = nf_bridge_mtu_reduction(skb);
+ 	/* This is wrong! We should preserve the original fragment
+ 	 * boundaries by preserving frag_list rather than refragmenting.
+ 	 */
+ 	if (skb->len + mtu_reserved > skb->dev->mtu) {
+ 		frag_max_size = BR_INPUT_SKB_CB(skb)->frag_max_size;
++>>>>>>> 7a8d831df581 (netfilter: bridge: refactor conditional in br_nf_dev_queue_xmit)
  		if (br_parse_ip_options(skb))
  			/* Drop invalid packet */
  			return NF_DROP;
* Unmerged path net/bridge/br_netfilter.c
