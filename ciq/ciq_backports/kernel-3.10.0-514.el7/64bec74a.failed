RDMA/iw_cxgb4: Add arp failure handlers to send_mpa_reply/reject()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hariprasad S <hariprasad@chelsio.com>
commit 64bec74a9b3ccc0e9795161427ea49864462f612
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/64bec74a.failed

These handlers when called print error message to the kernel log,
but the actual handling is done by _c4iw_free_ep() and process_timeout().

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 64bec74a9b3ccc0e9795161427ea49864462f612)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index 59084dc17b06,c4b7f1f8f8a5..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -450,6 -515,70 +450,73 @@@ static void arp_failure_discard(void *h
  	kfree_skb(skb);
  }
  
++<<<<<<< HEAD
++=======
+ static void mpa_start_arp_failure(void *handle, struct sk_buff *skb)
+ {
+ 	pr_err("ARP failure during MPA Negotiation - Closing Connection\n");
+ }
+ 
+ enum {
+ 	NUM_FAKE_CPLS = 2,
+ 	FAKE_CPL_PUT_EP_SAFE = NUM_CPL_CMDS + 0,
+ 	FAKE_CPL_PASS_PUT_EP_SAFE = NUM_CPL_CMDS + 1,
+ };
+ 
+ static int _put_ep_safe(struct c4iw_dev *dev, struct sk_buff *skb)
+ {
+ 	struct c4iw_ep *ep;
+ 
+ 	ep = *((struct c4iw_ep **)(skb->cb + 2 * sizeof(void *)));
+ 	release_ep_resources(ep);
+ 	return 0;
+ }
+ 
+ static int _put_pass_ep_safe(struct c4iw_dev *dev, struct sk_buff *skb)
+ {
+ 	struct c4iw_ep *ep;
+ 
+ 	ep = *((struct c4iw_ep **)(skb->cb + 2 * sizeof(void *)));
+ 	c4iw_put_ep(&ep->parent_ep->com);
+ 	release_ep_resources(ep);
+ 	return 0;
+ }
+ 
+ /*
+  * Fake up a special CPL opcode and call sched() so process_work() will call
+  * _put_ep_safe() in a safe context to free the ep resources.  This is needed
+  * because ARP error handlers are called in an ATOMIC context, and
+  * _c4iw_free_ep() needs to block.
+  */
+ static void queue_arp_failure_cpl(struct c4iw_ep *ep, struct sk_buff *skb,
+ 				  int cpl)
+ {
+ 	struct cpl_act_establish *rpl = cplhdr(skb);
+ 
+ 	/* Set our special ARP_FAILURE opcode */
+ 	rpl->ot.opcode = cpl;
+ 
+ 	/*
+ 	 * Save ep in the skb->cb area, after where sched() will save the dev
+ 	 * ptr.
+ 	 */
+ 	*((struct c4iw_ep **)(skb->cb + 2 * sizeof(void *))) = ep;
+ 	sched(ep->com.dev, skb);
+ }
+ 
+ /* Handle an ARP failure for an accept */
+ static void pass_accept_rpl_arp_failure(void *handle, struct sk_buff *skb)
+ {
+ 	struct c4iw_ep *ep = handle;
+ 
+ 	pr_err(MOD "ARP failure during accept - tid %u -dropping connection\n",
+ 	       ep->hwtid);
+ 
+ 	__state_set(&ep->com, DEAD);
+ 	queue_arp_failure_cpl(ep, skb, FAKE_CPL_PASS_PUT_EP_SAFE);
+ }
+ 
++>>>>>>> 64bec74a9b3c (RDMA/iw_cxgb4: Add arp failure handlers to send_mpa_reply/reject())
  /*
   * Handle an ARP failure for an active open.
   */
@@@ -988,7 -1123,7 +1055,11 @@@ static int send_mpa_reject(struct c4iw_
  	 */
  	skb_get(skb);
  	set_wr_txq(skb, CPL_PRIORITY_DATA, ep->txq_idx);
++<<<<<<< HEAD
 +	t4_set_arp_err_handler(skb, NULL, arp_failure_discard);
++=======
+ 	t4_set_arp_err_handler(skb, NULL, mpa_start_arp_failure);
++>>>>>>> 64bec74a9b3c (RDMA/iw_cxgb4: Add arp failure handlers to send_mpa_reply/reject())
  	BUG_ON(ep->mpa_skb);
  	ep->mpa_skb = skb;
  	ep->snd_seq += mpalen;
@@@ -1073,7 -1208,7 +1144,11 @@@ static int send_mpa_reply(struct c4iw_e
  	 * Function fw4_ack() will deref it.
  	 */
  	skb_get(skb);
++<<<<<<< HEAD
 +	t4_set_arp_err_handler(skb, NULL, arp_failure_discard);
++=======
+ 	t4_set_arp_err_handler(skb, NULL, mpa_start_arp_failure);
++>>>>>>> 64bec74a9b3c (RDMA/iw_cxgb4: Add arp failure handlers to send_mpa_reply/reject())
  	ep->mpa_skb = skb;
  	__state_set(&ep->com, MPA_REP_SENT);
  	ep->snd_seq += mpalen;
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
