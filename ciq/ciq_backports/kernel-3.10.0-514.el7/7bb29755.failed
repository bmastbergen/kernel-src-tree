net/mlx5e: Implement a mlx5e workqueue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Implement a mlx5e workqueue (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 94.44%
commit-author Matthew Finlay <matt@mellanox.com>
commit 7bb2975599210097115021e542b6137781a09588
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7bb29755.failed

Implement a mlx5e workqueue to handle all mlx5e specific tasks.  Move
all tasks currently using the system workqueue to the new workqueue.
This is in preparation for vxlan using the mlx5e workqueue in order to
schedule port add/remove operations.

	Signed-off-by: Matthew Finlay <matt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7bb2975599210097115021e542b6137781a09588)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index b2b207af1d60,3881dce0cc30..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -501,9 -564,10 +501,13 @@@ struct mlx5e_priv 
  	struct mlx5e_flow_tables   fts;
  	struct mlx5e_eth_addr_db   eth_addr;
  	struct mlx5e_vlan_db       vlan;
 -	struct mlx5e_vxlan_db      vxlan;
  
  	struct mlx5e_params        params;
++<<<<<<< HEAD
 +	spinlock_t                 async_events_spinlock; /* sync hw events */
++=======
+ 	struct workqueue_struct    *wq;
++>>>>>>> 7bb297559921 (net/mlx5e: Implement a mlx5e workqueue)
  	struct work_struct         update_carrier_work;
  	struct work_struct         set_rx_mode_work;
  	struct delayed_work        update_stats_work;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 23ff9e4eac90,9ab08419c557..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -1430,10 -1500,11 +1429,10 @@@ int mlx5e_open_locked(struct net_devic
  		goto err_close_channels;
  	}
  
 -	mlx5e_redirect_rqts(priv);
  	mlx5e_update_carrier(priv);
 -	mlx5e_timestamp_init(priv);
 +	mlx5e_redirect_rqts(priv);
  
- 	schedule_delayed_work(&priv->update_stats_work, 0);
+ 	queue_delayed_work(priv->wq, &priv->update_stats_work, 0);
  
  	return 0;
  
@@@ -2225,10 -2497,14 +2224,18 @@@ static void *mlx5e_create_netdev(struc
  
  	priv = netdev_priv(netdev);
  
++<<<<<<< HEAD
 +	err = mlx5_alloc_map_uar(mdev, &priv->cq_uar);
++=======
+ 	priv->wq = create_singlethread_workqueue("mlx5e");
+ 	if (!priv->wq)
+ 		goto err_free_netdev;
+ 
+ 	err = mlx5_alloc_map_uar(mdev, &priv->cq_uar, false);
++>>>>>>> 7bb297559921 (net/mlx5e: Implement a mlx5e workqueue)
  	if (err) {
  		mlx5_core_err(mdev, "alloc_map uar failed, %d\n", err);
- 		goto err_free_netdev;
+ 		goto err_destroy_wq;
  	}
  
  	err = mlx5_core_alloc_pd(mdev, &priv->pdn);
@@@ -2290,11 -2566,24 +2297,11 @@@
  	err = register_netdev(netdev);
  	if (err) {
  		mlx5_core_err(mdev, "register_netdev failed, %d\n", err);
 -		goto err_tc_cleanup;
 +		goto err_destroy_flow_tables;
  	}
  
 -	if (mlx5e_vxlan_allowed(mdev))
 -		vxlan_get_rx_port(netdev);
 -
  	mlx5e_enable_async_events(priv);
- 	schedule_work(&priv->set_rx_mode_work);
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
  
  	return priv;
  
@@@ -2341,10 -2636,21 +2351,26 @@@ static void mlx5e_destroy_netdev(struc
  
  	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
  
- 	schedule_work(&priv->set_rx_mode_work);
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
  	mlx5e_disable_async_events(priv);
++<<<<<<< HEAD
 +	flush_scheduled_work();
 +	unregister_netdev(netdev);
++=======
+ 	flush_workqueue(priv->wq);
+ 	if (test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state)) {
+ 		netif_device_detach(netdev);
+ 		mutex_lock(&priv->state_lock);
+ 		if (test_bit(MLX5E_STATE_OPENED, &priv->state))
+ 			mlx5e_close_locked(netdev);
+ 		mutex_unlock(&priv->state_lock);
+ 	} else {
+ 		unregister_netdev(netdev);
+ 	}
+ 
+ 	mlx5e_tc_cleanup(priv);
+ 	mlx5e_vxlan_cleanup(priv);
++>>>>>>> 7bb297559921 (net/mlx5e: Implement a mlx5e workqueue)
  	mlx5e_destroy_flow_tables(priv);
  	mlx5e_destroy_tirs(priv);
  	mlx5e_destroy_rqt(priv, MLX5E_SINGLE_RQ_RQT);
@@@ -2355,7 -2661,11 +2381,15 @@@
  	mlx5_core_dealloc_transport_domain(priv->mdev, priv->tdn);
  	mlx5_core_dealloc_pd(priv->mdev, priv->pdn);
  	mlx5_unmap_free_uar(priv->mdev, &priv->cq_uar);
++<<<<<<< HEAD
 +	free_netdev(netdev);
++=======
+ 	cancel_delayed_work_sync(&priv->update_stats_work);
+ 	destroy_workqueue(priv->wq);
+ 
+ 	if (!test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state))
+ 		free_netdev(netdev);
++>>>>>>> 7bb297559921 (net/mlx5e: Implement a mlx5e workqueue)
  }
  
  static void *mlx5e_get_netdev(void *vpriv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
