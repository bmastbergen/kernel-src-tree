staging/rdma/hfi1: Implement hfi1 support for AH notification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Implement hfi1 support for AH notification (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 92.98%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 8f1764fa2ba5a39c651316998f40631e8492081d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8f1764fa.failed

For OPA devices additional work is required to create an AH.
This patch adds support to set the VL correctly.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 8f1764fa2ba5a39c651316998f40631e8492081d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/verbs.c
diff --cc drivers/staging/hfi1/verbs.c
index cfa74cbcf382,657efd3bd75c..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -1634,59 -1626,33 +1634,82 @@@ int hfi1_check_ah(struct ib_device *ibd
  	sc5 = ibp->sl_to_sc[ah_attr->sl];
  	dd = dd_from_ppd(ppd);
  	if (sc_to_vlt(dd, sc5) > num_vls && sc_to_vlt(dd, sc5) != 0xf)
 -		return -EINVAL;
 +		goto bail;
  	return 0;
 +bail:
 +	return -EINVAL;
 +}
 +
 +/**
 + * create_ah - create an address handle
 + * @pd: the protection domain
 + * @ah_attr: the attributes of the AH
 + *
 + * This may be called from interrupt context.
 + */
 +static struct ib_ah *create_ah(struct ib_pd *pd,
 +			       struct ib_ah_attr *ah_attr)
 +{
 +	struct hfi1_ah *ah;
 +	struct ib_ah *ret;
 +	struct hfi1_ibdev *dev = to_idev(pd->device);
 +	unsigned long flags;
 +
 +	if (hfi1_check_ah(pd->device, ah_attr)) {
 +		ret = ERR_PTR(-EINVAL);
 +		goto bail;
 +	}
 +
 +	ah = kmalloc(sizeof(*ah), GFP_ATOMIC);
 +	if (!ah) {
 +		ret = ERR_PTR(-ENOMEM);
 +		goto bail;
 +	}
 +
 +	spin_lock_irqsave(&dev->n_ahs_lock, flags);
 +	if (dev->n_ahs_allocated == hfi1_max_ahs) {
 +		spin_unlock_irqrestore(&dev->n_ahs_lock, flags);
 +		kfree(ah);
 +		ret = ERR_PTR(-ENOMEM);
 +		goto bail;
 +	}
 +
 +	dev->n_ahs_allocated++;
 +	spin_unlock_irqrestore(&dev->n_ahs_lock, flags);
 +
 +	/* ib_create_ah() will initialize ah->ibah. */
 +	ah->attr = *ah_attr;
 +	atomic_set(&ah->refcount, 0);
 +
 +	ret = &ah->ibah;
 +
 +bail:
 +	return ret;
  }
  
+ static void hfi1_notify_new_ah(struct ib_device *ibdev,
+ 			       struct ib_ah_attr *ah_attr,
+ 			       struct rvt_ah *ah)
+ {
+ 	struct hfi1_ibport *ibp;
+ 	struct hfi1_pportdata *ppd;
+ 	struct hfi1_devdata *dd;
+ 	u8 sc5;
+ 
+ 	/*
+ 	 * Do not trust reading anything from rvt_ah at this point as it is not
+ 	 * done being setup. We can however modify things which we need to set.
+ 	 */
+ 
+ 	ibp = to_iport(ibdev, ah_attr->port_num);
+ 	ppd = ppd_from_ibp(ibp);
+ 	sc5 = ibp->sl_to_sc[ah->attr.sl];
+ 	dd = dd_from_ppd(ppd);
+ 	ah->vl = sc_to_vlt(dd, sc5);
+ 	if (ah->vl < num_vls || ah->vl == 15)
+ 		ah->log_pmtu = ilog2(dd->vld[ah->vl].mtu);
+ }
+ 
  struct ib_ah *hfi1_create_qp0_ah(struct hfi1_ibport *ibp, u16 dlid)
  {
  	struct ib_ah_attr attr;
@@@ -2018,7 -1935,21 +2041,25 @@@ int hfi1_register_ib_device(struct hfi1
  	strncpy(ibdev->node_desc, init_utsname()->nodename,
  		sizeof(ibdev->node_desc));
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ret = ib_register_device(ibdev, hfi1_create_port_files);
++=======
+ 	/*
+ 	 * Fill in rvt info object.
+ 	 */
+ 	dd->verbs_dev.rdi.driver_f.port_callback = hfi1_create_port_files;
+ 	dd->verbs_dev.rdi.driver_f.get_card_name = get_card_name;
+ 	dd->verbs_dev.rdi.driver_f.get_pci_dev = get_pci_dev;
+ 	dd->verbs_dev.rdi.driver_f.check_ah = hfi1_check_ah;
+ 	dd->verbs_dev.rdi.driver_f.notify_new_ah = hfi1_notify_new_ah;
+ 	dd->verbs_dev.rdi.dparms.props.max_ah = hfi1_max_ahs;
+ 	dd->verbs_dev.rdi.dparms.props.max_pd = hfi1_max_pds;
+ 	dd->verbs_dev.rdi.flags = (RVT_FLAG_MR_INIT_DRIVER |
+ 				   RVT_FLAG_QP_INIT_DRIVER |
+ 				   RVT_FLAG_CQ_INIT_DRIVER);
+ 
+ 	ret = rvt_register_device(&dd->verbs_dev.rdi);
++>>>>>>> 8f1764fa2ba5 (staging/rdma/hfi1: Implement hfi1 support for AH notification):drivers/staging/rdma/hfi1/verbs.c
  	if (ret)
  		goto err_reg;
  
* Unmerged path drivers/staging/hfi1/verbs.c
