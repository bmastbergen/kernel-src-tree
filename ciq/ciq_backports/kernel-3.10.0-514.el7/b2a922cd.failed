xfs: remove xfs_caddr_t

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit b2a922cd6c2e3b9c2e36d48683ceb87a5bce8bb8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b2a922cd.failed

Just use char pointers directly instead of the confusing typedef to a
pointer type.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit b2a922cd6c2e3b9c2e36d48683ceb87a5bce8bb8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log_recover.c
diff --cc fs/xfs/xfs_log_recover.c
index b6954ea82c78,212261258c52..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -3377,23 -3367,14 +3377,28 @@@ xlog_recover_add_to_cont_trans
  	int			len)
  {
  	xlog_recover_item_t	*item;
- 	xfs_caddr_t		ptr, old_ptr;
+ 	char			*ptr, *old_ptr;
  	int			old_len;
  
 +	/*
 +	 * If the transaction is empty, the header was split across this and the
 +	 * previous record. Copy the rest of the header.
 +	 */
  	if (list_empty(&trans->r_itemq)) {
 -		/* finish copying rest of trans header */
 +		ASSERT(len < sizeof(struct xfs_trans_header));
 +		if (len > sizeof(struct xfs_trans_header)) {
 +			xfs_warn(log->l_mp, "%s: bad header length", __func__);
 +			return -EIO;
 +		}
 +
  		xlog_recover_add_item(&trans->r_itemq);
++<<<<<<< HEAD
 +		ptr = (xfs_caddr_t) &trans->r_theader +
 +				sizeof(struct xfs_trans_header) - len;
++=======
+ 		ptr = (char *)&trans->r_theader +
+ 				sizeof(xfs_trans_header_t) - len;
++>>>>>>> b2a922cd6c2e (xfs: remove xfs_caddr_t)
  		memcpy(ptr, dp, len);
  		return 0;
  	}
diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h
index 90369d815118..ec0e239a0fa9 100644
--- a/fs/xfs/xfs_linux.h
+++ b/fs/xfs/xfs_linux.h
@@ -35,7 +35,6 @@ typedef unsigned long long int	__uint64_t;
 typedef __s64			xfs_off_t;	/* <file offset> type */
 typedef unsigned long long	xfs_ino_t;	/* <inode> type */
 typedef __s64			xfs_daddr_t;	/* <disk address> type */
-typedef char *			xfs_caddr_t;	/* <core address> type */
 typedef __u32			xfs_dev_t;
 typedef __u32			xfs_nlink_t;
 
diff --git a/fs/xfs/xfs_log.c b/fs/xfs/xfs_log.c
index 70cd92e2059f..83040f8fecea 100644
--- a/fs/xfs/xfs_log.c
+++ b/fs/xfs/xfs_log.c
@@ -1602,7 +1602,7 @@ xlog_pack_data(
 	int			i, j, k;
 	int			size = iclog->ic_offset + roundoff;
 	__be32			cycle_lsn;
-	xfs_caddr_t		dp;
+	char			*dp;
 
 	cycle_lsn = CYCLE_LSN_DISK(iclog->ic_header.h_lsn);
 
@@ -3814,7 +3814,7 @@ xlog_verify_iclog(
 		if (!syncing || (field_offset & 0x1ff)) {
 			clientid = ophead->oh_clientid;
 		} else {
-			idx = BTOBBT((xfs_caddr_t)&(ophead->oh_clientid) - iclog->ic_datap);
+			idx = BTOBBT((char *)&ophead->oh_clientid - iclog->ic_datap);
 			if (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {
 				j = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);
 				k = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);
* Unmerged path fs/xfs/xfs_log_recover.c
