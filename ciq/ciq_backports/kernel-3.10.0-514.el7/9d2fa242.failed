mmc: slot-gpio: add gpiod variant to get wp GPIO

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 9d2fa2428ae149ba3a5b7a4ceb0a9e11f1882b3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9d2fa242.failed

This makes it possible to get the write protect (read only)
GPIO line from a GPIO descriptor. Written to exactly mirror
the card detect function.

	Acked-by: Alexandre Courbot <acourbot@nvidia.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 9d2fa2428ae149ba3a5b7a4ceb0a9e11f1882b3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/slot-gpio.c
#	include/linux/mmc/slot-gpio.h
diff --cc drivers/mmc/core/slot-gpio.c
index f33bbd48c2c0,e3fce4493fab..000000000000
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@@ -250,3 -275,125 +250,128 @@@ void mmc_gpio_free_cd(struct mmc_host *
  	devm_gpio_free(&host->class_dev, gpio);
  }
  EXPORT_SYMBOL(mmc_gpio_free_cd);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * mmc_gpiod_request_cd - request a gpio descriptor for card-detection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  *
+  * Use this function in place of mmc_gpio_request_cd() to use the GPIO
+  * descriptor API.  Note that it is paired with mmc_gpiod_free_cd() not
+  * mmc_gpio_free_cd().  Note also that it must be called prior to mmc_add_host()
+  * otherwise the caller must also call mmc_gpiod_request_cd_irq().
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->cd_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	ctx->override_cd_active_level = override_active_level;
+ 	ctx->cd_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_cd);
+ 
+ /**
+  * mmc_gpiod_request_ro - request a gpio descriptor for write protection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  *
+  * Use this function in place of mmc_gpio_request_ro() to use the GPIO
+  * descriptor API.  Note that it is paired with mmc_gpiod_free_ro() not
+  * mmc_gpio_free_ro().
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->ro_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	ctx->override_ro_active_level = override_active_level;
+ 	ctx->ro_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_ro);
+ 
+ /**
+  * mmc_gpiod_free_cd - free the card-detection gpio descriptor
+  * @host: mmc host
+  *
+  * It's provided only for cases that client drivers need to manually free
+  * up the card-detection gpio requested by mmc_gpiod_request_cd().
+  */
+ void mmc_gpiod_free_cd(struct mmc_host *host)
+ {
+ 	struct mmc_gpio *ctx = host->slot.handler_priv;
+ 
+ 	if (!ctx || !ctx->cd_gpio)
+ 		return;
+ 
+ 	if (host->slot.cd_irq >= 0) {
+ 		devm_free_irq(&host->class_dev, host->slot.cd_irq, host);
+ 		host->slot.cd_irq = -EINVAL;
+ 	}
+ 
+ 	devm_gpiod_put(&host->class_dev, ctx->cd_gpio);
+ 
+ 	ctx->cd_gpio = NULL;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_free_cd);
++>>>>>>> 9d2fa2428ae1 (mmc: slot-gpio: add gpiod variant to get wp GPIO)
diff --cc include/linux/mmc/slot-gpio.h
index 7d88d27bfafa,a0d0442c15bf..000000000000
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@@ -18,7 -18,17 +18,19 @@@ int mmc_gpio_request_ro(struct mmc_hos
  void mmc_gpio_free_ro(struct mmc_host *host);
  
  int mmc_gpio_get_cd(struct mmc_host *host);
 -int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
 -			unsigned int debounce);
 +int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio);
  void mmc_gpio_free_cd(struct mmc_host *host);
  
++<<<<<<< HEAD
++=======
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce);
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce);
+ void mmc_gpiod_free_cd(struct mmc_host *host);
+ void mmc_gpiod_request_cd_irq(struct mmc_host *host);
+ 
++>>>>>>> 9d2fa2428ae1 (mmc: slot-gpio: add gpiod variant to get wp GPIO)
  #endif
* Unmerged path drivers/mmc/core/slot-gpio.c
* Unmerged path include/linux/mmc/slot-gpio.h
