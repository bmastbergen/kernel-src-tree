fanotify: fix double free of pending permission events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jan Kara <jack@suse.cz>
commit 5838d4442bd5971687b72221736222637e03140d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5838d444.failed

Commit 85816794240b ("fanotify: Fix use after free for permission
events") introduced a double free issue for permission events which are
pending in group's notification queue while group is being destroyed.
These events are freed from fanotify_handle_event() but they are not
removed from groups notification queue and thus they get freed again
from fsnotify_flush_notify().

Fix the problem by removing permission events from notification queue
before freeing them if we skip processing access response.  Also expand
comments in fanotify_release() to explain group shutdown in detail.

Fixes: 85816794240b9659e66e4d9b0df7c6e814e5f603
	Signed-off-by: Jan Kara <jack@suse.cz>
	Reported-by: Douglas Leeder <douglas.leeder@sophos.com>
	Tested-by: Douglas Leeder <douglas.leeder@sophos.com>
	Reported-by: Heinrich Schuchard <xypron.glpk@gmx.de>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5838d4442bd5971687b72221736222637e03140d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify_user.c
#	fs/notify/notification.c
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/fanotify/fanotify_user.c
index 8ef1b0f829ee,b13992a41bd9..000000000000
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@@ -380,23 -357,34 +380,39 @@@ static int fanotify_release(struct inod
  	struct fsnotify_group *group = file->private_data;
  
  #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 -	struct fanotify_perm_event_info *event, *next;
 +	struct fanotify_response_event *re, *lre;
  
++<<<<<<< HEAD
 +	mutex_lock(&group->fanotify_data.access_mutex);
++=======
+ 	/*
+ 	 * There may be still new events arriving in the notification queue
+ 	 * but since userspace cannot use fanotify fd anymore, no event can
+ 	 * enter or leave access_list by now.
+ 	 */
+ 	spin_lock(&group->fanotify_data.access_lock);
++>>>>>>> 5838d4442bd5 (fanotify: fix double free of pending permission events)
  
  	atomic_inc(&group->fanotify_data.bypass_perm);
  
 -	list_for_each_entry_safe(event, next, &group->fanotify_data.access_list,
 -				 fae.fse.list) {
 -		pr_debug("%s: found group=%p event=%p\n", __func__, group,
 -			 event);
 +	list_for_each_entry_safe(re, lre, &group->fanotify_data.access_list, list) {
 +		pr_debug("%s: found group=%p re=%p event=%p\n", __func__, group,
 +			 re, re->event);
  
 -		list_del_init(&event->fae.fse.list);
 -		event->response = FAN_ALLOW;
 +		list_del_init(&re->list);
 +		re->event->response = FAN_ALLOW;
 +
 +		kmem_cache_free(fanotify_response_event_cache, re);
  	}
 -	spin_unlock(&group->fanotify_data.access_lock);
 +	mutex_unlock(&group->fanotify_data.access_mutex);
  
+ 	/*
+ 	 * Since bypass_perm is set, newly queued events will not wait for
+ 	 * access response. Wake up the already sleeping ones now.
+ 	 * synchronize_srcu() in fsnotify_destroy_group() will wait for all
+ 	 * processes sleeping in fanotify_handle_event() waiting for access
+ 	 * response and thus also for all permission events to be freed.
+ 	 */
  	wake_up(&group->fanotify_data.access_waitq);
  #endif
  
diff --cc fs/notify/notification.c
index a03904d119e4,a95d8e037aeb..000000000000
--- a/fs/notify/notification.c
+++ b/fs/notify/notification.c
@@@ -76,60 -67,15 +76,66 @@@ bool fsnotify_notify_queue_is_empty(str
  	return list_empty(&group->notification_list) ? true : false;
  }
  
 -void fsnotify_destroy_event(struct fsnotify_group *group,
 -			    struct fsnotify_event *event)
 +void fsnotify_get_event(struct fsnotify_event *event)
  {
 -	/* Overflow events are per-group and we don't want to free them */
 -	if (!event || event->mask == FS_Q_OVERFLOW)
 +	atomic_inc(&event->refcnt);
 +}
 +
 +void fsnotify_put_event(struct fsnotify_event *event)
 +{
 +	if (!event)
  		return;
++<<<<<<< HEAD
 +
 +	if (atomic_dec_and_test(&event->refcnt)) {
 +		pr_debug("%s: event=%p\n", __func__, event);
 +
 +		if (event->data_type == FSNOTIFY_EVENT_PATH)
 +			path_put(&event->path);
 +
 +		BUG_ON(!list_empty(&event->private_data_list));
 +
 +		kfree(event->file_name);
 +		put_pid(event->tgid);
 +		kmem_cache_free(fsnotify_event_cachep, event);
 +	}
 +}
 +
 +struct fsnotify_event_holder *fsnotify_alloc_event_holder(void)
 +{
 +	return kmem_cache_alloc(fsnotify_event_holder_cachep, GFP_KERNEL);
 +}
 +
 +void fsnotify_destroy_event_holder(struct fsnotify_event_holder *holder)
 +{
 +	if (holder)
 +		kmem_cache_free(fsnotify_event_holder_cachep, holder);
 +}
 +
 +/*
 + * Find the private data that the group previously attached to this event when
 + * the group added the event to the notification queue (fsnotify_add_notify_event)
 + */
 +struct fsnotify_event_private_data *fsnotify_remove_priv_from_event(struct fsnotify_group *group, struct fsnotify_event *event)
 +{
 +	struct fsnotify_event_private_data *lpriv;
 +	struct fsnotify_event_private_data *priv = NULL;
 +
 +	assert_spin_locked(&event->lock);
 +
 +	list_for_each_entry(lpriv, &event->private_data_list, event_list) {
 +		if (lpriv->group == group) {
 +			priv = lpriv;
 +			list_del(&priv->event_list);
 +			break;
 +		}
 +	}
 +	return priv;
++=======
+ 	/* If the event is still queued, we have a problem... */
+ 	WARN_ON(!list_empty(&event->list));
+ 	group->ops->free_event(event);
++>>>>>>> 5838d4442bd5 (fanotify: fix double free of pending permission events)
  }
  
  /*
@@@ -243,14 -126,27 +249,34 @@@ alloc_holder
  }
  
  /*
++<<<<<<< HEAD
 + * Remove and return the first event from the notification list.  There is a
 + * reference held on this event since it was on the list.  It is the responsibility
 + * of the caller to drop this reference.
++=======
+  * Remove @event from group's notification queue. It is the responsibility of
+  * the caller to destroy the event.
+  */
+ void fsnotify_remove_event(struct fsnotify_group *group,
+ 			   struct fsnotify_event *event)
+ {
+ 	mutex_lock(&group->notification_mutex);
+ 	if (!list_empty(&event->list)) {
+ 		list_del_init(&event->list);
+ 		group->q_len--;
+ 	}
+ 	mutex_unlock(&group->notification_mutex);
+ }
+ 
+ /*
+  * Remove and return the first event from the notification list.  It is the
+  * responsibility of the caller to destroy the obtained event
++>>>>>>> 5838d4442bd5 (fanotify: fix double free of pending permission events)
   */
 -struct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group)
 +struct fsnotify_event *fsnotify_remove_notify_event(struct fsnotify_group *group)
  {
  	struct fsnotify_event *event;
 +	struct fsnotify_event_holder *holder;
  
  	BUG_ON(!mutex_is_locked(&group->notification_mutex));
  
diff --cc include/linux/fsnotify_backend.h
index 4b2ee8d12f5e,ca060d7c4fa6..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -370,19 -318,16 +370,28 @@@ extern void fsnotify_put_group(struct f
  extern void fsnotify_destroy_group(struct fsnotify_group *group);
  /* fasync handler function */
  extern int fsnotify_fasync(int fd, struct file *file, int on);
 -/* Free event from memory */
 -extern void fsnotify_destroy_event(struct fsnotify_group *group,
 -				   struct fsnotify_event *event);
 +/* take a reference to an event */
 +extern void fsnotify_get_event(struct fsnotify_event *event);
 +extern void fsnotify_put_event(struct fsnotify_event *event);
 +/* find private data previously attached to an event and unlink it */
 +extern struct fsnotify_event_private_data *fsnotify_remove_priv_from_event(struct fsnotify_group *group,
 +									   struct fsnotify_event *event);
 +
  /* attach the event to the group notification queue */
++<<<<<<< HEAD
 +extern struct fsnotify_event *fsnotify_add_notify_event(struct fsnotify_group *group,
 +							struct fsnotify_event *event,
 +							struct fsnotify_event_private_data *priv,
 +							struct fsnotify_event *(*merge)(struct list_head *,
 +											struct fsnotify_event *));
++=======
+ extern int fsnotify_add_event(struct fsnotify_group *group,
+ 			      struct fsnotify_event *event,
+ 			      int (*merge)(struct list_head *,
+ 					   struct fsnotify_event *));
+ /* Remove passed event from groups notification queue */
+ extern void fsnotify_remove_event(struct fsnotify_group *group, struct fsnotify_event *event);
++>>>>>>> 5838d4442bd5 (fanotify: fix double free of pending permission events)
  /* true if the group notification queue is empty */
  extern bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group);
  /* return, but do not dequeue the first event on the notification queue */
diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c
index 0c2f9122b262..82b7f21ce2ba 100644
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@ -102,8 +102,15 @@ static int fanotify_get_response_from_access(struct fsnotify_group *group,
 	wait_event(group->fanotify_data.access_waitq, event->response ||
 				atomic_read(&group->fanotify_data.bypass_perm));
 
-	if (!event->response) /* bypass_perm set */
+	if (!event->response) {	/* bypass_perm set */
+		/*
+		 * Event was canceled because group is being destroyed. Remove
+		 * it from group's event list because we are responsible for
+		 * freeing the permission event.
+		 */
+		fsnotify_remove_event(group, &event->fae.fse);
 		return 0;
+	}
 
 	/* userspace responded, convert to something usable */
 	spin_lock(&event->lock);
* Unmerged path fs/notify/fanotify/fanotify_user.c
* Unmerged path fs/notify/notification.c
* Unmerged path include/linux/fsnotify_backend.h
