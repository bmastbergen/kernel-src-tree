clockevents: Move the tick_notify() switch case to clockevents_notify()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 8c53daf63f56791ed47fc585206ef3049489612f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8c53daf6.failed

No need to call another function and have duplicated cases.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: John Stultz <john.stultz@linaro.org>
	Cc: Magnus Damm <magnus.damm@gmail.com>
Link: http://lkml.kernel.org/r/20130425143436.235746557@linutronix.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 8c53daf63f56791ed47fc585206ef3049489612f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/clockevents.c
#	kernel/time/tick-common.c
#	kernel/time/tick-internal.h
diff --cc kernel/time/clockevents.c
index 21760270cc8a,0e3a8448e115..000000000000
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@@ -453,13 -401,39 +453,43 @@@ int clockevents_notify(unsigned long re
  {
  	struct clock_event_device *dev, *tmp;
  	unsigned long flags;
 -	int cpu;
 +	int cpu, ret = 0;
  
  	raw_spin_lock_irqsave(&clockevents_lock, flags);
++<<<<<<< HEAD
 +	ret = tick_notify(reason, arg);
++=======
++>>>>>>> 8c53daf63f56 (clockevents: Move the tick_notify() switch case to clockevents_notify())
  
  	switch (reason) {
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_ON:
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_OFF:
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_FORCE:
+ 		tick_broadcast_on_off(reason, arg);
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_ENTER:
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_EXIT:
+ 		tick_broadcast_oneshot_control(reason);
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_CPU_DYING:
+ 		tick_handover_do_timer(arg);
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_SUSPEND:
+ 		tick_suspend();
+ 		tick_suspend_broadcast();
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_RESUME:
+ 		tick_resume();
+ 		break;
+ 
  	case CLOCK_EVT_NOTIFY_CPU_DEAD:
+ 		tick_shutdown_broadcast_oneshot(arg);
+ 		tick_shutdown_broadcast(arg);
+ 		tick_shutdown(arg);
  		/*
  		 * Unregister the clock event devices which were
  		 * released from the users in the notify chain.
diff --cc kernel/time/tick-common.c
index b2f41b05d9e4,84c7cfca4d7d..000000000000
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@@ -349,26 -317,20 +349,26 @@@ void tick_shutdown(unsigned int *cpup
  		dev->event_handler = clockevents_handle_noop;
  		td->evtdev = NULL;
  	}
 +	raw_spin_unlock_irqrestore(&tick_device_lock, flags);
  }
  
- static void tick_suspend(void)
+ void tick_suspend(void)
  {
  	struct tick_device *td = &__get_cpu_var(tick_cpu_device);
 +	unsigned long flags;
  
 +	raw_spin_lock_irqsave(&tick_device_lock, flags);
  	clockevents_shutdown(td->evtdev);
 +	raw_spin_unlock_irqrestore(&tick_device_lock, flags);
  }
  
- static void tick_resume(void)
+ void tick_resume(void)
  {
  	struct tick_device *td = &__get_cpu_var(tick_cpu_device);
 +	unsigned long flags;
  	int broadcast = tick_resume_broadcast();
  
 +	raw_spin_lock_irqsave(&tick_device_lock, flags);
  	clockevents_set_mode(td->evtdev, CLOCK_EVT_MODE_RESUME);
  
  	if (!broadcast) {
@@@ -377,56 -339,8 +377,59 @@@
  		else
  			tick_resume_oneshot();
  	}
 +	raw_spin_unlock_irqrestore(&tick_device_lock, flags);
 +}
 +
++<<<<<<< HEAD
 +/*
 + * tick_notify: notification about relevant events
 + * Returns 0 on success, any other value on error
 + */
 +int tick_notify(unsigned long reason, void *dev)
 +{
 +	int ret = 0;
 +
 +	switch (reason) {
 +
 +	case CLOCK_EVT_NOTIFY_BROADCAST_ON:
 +	case CLOCK_EVT_NOTIFY_BROADCAST_OFF:
 +	case CLOCK_EVT_NOTIFY_BROADCAST_FORCE:
 +		tick_broadcast_on_off(reason, dev);
 +		break;
 +
 +	case CLOCK_EVT_NOTIFY_BROADCAST_ENTER:
 +	case CLOCK_EVT_NOTIFY_BROADCAST_EXIT:
 +		ret = tick_broadcast_oneshot_control(reason);
 +		break;
 +
 +	case CLOCK_EVT_NOTIFY_CPU_DYING:
 +		tick_handover_do_timer(dev);
 +		break;
 +
 +	case CLOCK_EVT_NOTIFY_CPU_DEAD:
 +		tick_shutdown_broadcast_oneshot(dev);
 +		tick_shutdown_broadcast(dev);
 +		tick_shutdown(dev);
 +		break;
 +
 +	case CLOCK_EVT_NOTIFY_SUSPEND:
 +		tick_suspend();
 +		tick_suspend_broadcast();
 +		break;
 +
 +	case CLOCK_EVT_NOTIFY_RESUME:
 +		tick_resume();
 +		break;
 +
 +	default:
 +		break;
 +	}
 +
 +	return ret;
  }
  
++=======
++>>>>>>> 8c53daf63f56 (clockevents: Move the tick_notify() switch case to clockevents_notify())
  /**
   * tick_init - initialize the tick control
   */
diff --cc kernel/time/tick-internal.h
index 4b574148f4f0,06bfc8802dfb..000000000000
--- a/kernel/time/tick-internal.h
+++ b/kernel/time/tick-internal.h
@@@ -18,8 -18,11 +18,15 @@@ extern int tick_do_timer_cpu __read_mos
  
  extern void tick_setup_periodic(struct clock_event_device *dev, int broadcast);
  extern void tick_handle_periodic(struct clock_event_device *dev);
++<<<<<<< HEAD
 +extern int tick_notify(unsigned long reason, void *dev);
++=======
++>>>>>>> 8c53daf63f56 (clockevents: Move the tick_notify() switch case to clockevents_notify())
  extern void tick_check_new_device(struct clock_event_device *dev);
+ extern void tick_handover_do_timer(int *cpup);
+ extern void tick_shutdown(unsigned int *cpup);
+ extern void tick_suspend(void);
+ extern void tick_resume(void);
  
  extern void clockevents_shutdown(struct clock_event_device *dev);
  
* Unmerged path kernel/time/clockevents.c
* Unmerged path kernel/time/tick-common.c
* Unmerged path kernel/time/tick-internal.h
