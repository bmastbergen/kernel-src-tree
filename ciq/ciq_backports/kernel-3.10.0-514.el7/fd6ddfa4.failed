fnic: check pci_map_single() return value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Maurizio Lombardi <mlombard@redhat.com>
commit fd6ddfa4c1ddfb4a149b31845144b4cf3cbef54d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fd6ddfa4.failed

the kernel prints some warnings when compiled with CONFIG_DMA_API_DEBUG.
This is because the fnic driver doesn't check the return value of
pci_map_single().

[   11.942770] scsi host12: fnic
[   11.950811] ------------[ cut here ]------------
[   11.950818] WARNING: at lib/dma-debug.c:937 check_unmap+0x47b/0x920()
[   11.950821] fnic 0000:0c:00.0: DMA-API: device driver failed to check map error[device address=0x0000002020a30040] [size=44 bytes] [mapped as single]

	Signed-off-by: Maurizio Lombardi <mlombard@redhat.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
Reviewed By: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit fd6ddfa4c1ddfb4a149b31845144b4cf3cbef54d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic_scsi.c
diff --cc drivers/scsi/fnic/fnic_scsi.c
index c9ceb642ce46,266b909fe854..000000000000
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@@ -331,7 -330,7 +331,11 @@@ static inline int fnic_queue_wq_copy_de
  	int flags;
  	u8 exch_flags;
  	struct scsi_lun fc_lun;
++<<<<<<< HEAD
 +	char msg[2];
++=======
+ 	int r;
++>>>>>>> fd6ddfa4c1dd (fnic: check pci_map_single() return value)
  
  	if (sg_count) {
  		/* For each SGE, create a device desc entry */
@@@ -355,14 -360,17 +365,23 @@@
  					      SCSI_SENSE_BUFFERSIZE,
  					      PCI_DMA_FROMDEVICE);
  
+ 	r = pci_dma_mapping_error(fnic->pdev, io_req->sense_buf_pa);
+ 	if (r) {
+ 		pci_unmap_single(fnic->pdev, io_req->sgl_list_pa,
+ 				sizeof(io_req->sgl_list[0]) * sg_count,
+ 				PCI_DMA_TODEVICE);
+ 		printk(KERN_ERR "PCI mapping failed with error %d\n", r);
+ 		return SCSI_MLQUEUE_HOST_BUSY;
+ 	}
+ 
  	int_to_scsilun(sc->device->lun, &fc_lun);
  
 +	pri_tag = FCPIO_ICMND_PTA_SIMPLE;
 +	msg[0] = MSG_SIMPLE_TAG;
 +	scsi_populate_tag_msg(sc, msg);
 +	if (msg[0] == MSG_ORDERED_TAG)
 +		pri_tag = FCPIO_ICMND_PTA_ORDERED;
 +
  	/* Enqueue the descriptor in the Copy WQ */
  	spin_lock_irqsave(&fnic->wq_copy_lock[0], intr_flags);
  
diff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c
index 42b17ed198e8..c8f05b28a4a6 100644
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@ -944,6 +944,7 @@ int fnic_alloc_rq_frame(struct vnic_rq *rq)
 	struct sk_buff *skb;
 	u16 len;
 	dma_addr_t pa;
+	int r;
 
 	len = FC_FRAME_HEADROOM + FC_MAX_FRAME + FC_FRAME_TAILROOM;
 	skb = dev_alloc_skb(len);
@@ -957,8 +958,19 @@ int fnic_alloc_rq_frame(struct vnic_rq *rq)
 	skb_reset_network_header(skb);
 	skb_put(skb, len);
 	pa = pci_map_single(fnic->pdev, skb->data, len, PCI_DMA_FROMDEVICE);
+
+	r = pci_dma_mapping_error(fnic->pdev, pa);
+	if (r) {
+		printk(KERN_ERR "PCI mapping failed with error %d\n", r);
+		goto free_skb;
+	}
+
 	fnic_queue_rq_desc(rq, skb, pa, len);
 	return 0;
+
+free_skb:
+	kfree_skb(skb);
+	return r;
 }
 
 void fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf)
@@ -986,6 +998,7 @@ void fnic_eth_send(struct fcoe_ctlr *fip, struct sk_buff *skb)
 	struct ethhdr *eth_hdr;
 	struct vlan_ethhdr *vlan_hdr;
 	unsigned long flags;
+	int r;
 
 	if (!fnic->vlan_hw_insert) {
 		eth_hdr = (struct ethhdr *)skb_mac_header(skb);
@@ -1008,18 +1021,27 @@ void fnic_eth_send(struct fcoe_ctlr *fip, struct sk_buff *skb)
 
 	pa = pci_map_single(fnic->pdev, skb->data, skb->len, PCI_DMA_TODEVICE);
 
-	spin_lock_irqsave(&fnic->wq_lock[0], flags);
-	if (!vnic_wq_desc_avail(wq)) {
-		pci_unmap_single(fnic->pdev, pa, skb->len, PCI_DMA_TODEVICE);
-		spin_unlock_irqrestore(&fnic->wq_lock[0], flags);
-		kfree_skb(skb);
-		return;
+	r = pci_dma_mapping_error(fnic->pdev, pa);
+	if (r) {
+		printk(KERN_ERR "PCI mapping failed with error %d\n", r);
+		goto free_skb;
 	}
 
+	spin_lock_irqsave(&fnic->wq_lock[0], flags);
+	if (!vnic_wq_desc_avail(wq))
+		goto irq_restore;
+
 	fnic_queue_wq_eth_desc(wq, skb, pa, skb->len,
 			       0 /* hw inserts cos value */,
 			       fnic->vlan_id, 1);
 	spin_unlock_irqrestore(&fnic->wq_lock[0], flags);
+	return;
+
+irq_restore:
+	spin_unlock_irqrestore(&fnic->wq_lock[0], flags);
+	pci_unmap_single(fnic->pdev, pa, skb->len, PCI_DMA_TODEVICE);
+free_skb:
+	kfree_skb(skb);
 }
 
 /*
@@ -1076,6 +1098,12 @@ static int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)
 
 	pa = pci_map_single(fnic->pdev, eth_hdr, tot_len, PCI_DMA_TODEVICE);
 
+	ret = pci_dma_mapping_error(fnic->pdev, pa);
+	if (ret) {
+		printk(KERN_ERR "DMA map failed with error %d\n", ret);
+		goto free_skb_on_err;
+	}
+
 	if ((fnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_SEND,
 				(char *)eth_hdr, tot_len)) != 0) {
 		printk(KERN_ERR "fnic ctlr frame trace error!!!");
@@ -1087,15 +1115,17 @@ static int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)
 		pci_unmap_single(fnic->pdev, pa,
 				 tot_len, PCI_DMA_TODEVICE);
 		ret = -1;
-		goto fnic_send_frame_end;
+		goto irq_restore;
 	}
 
 	fnic_queue_wq_desc(wq, skb, pa, tot_len, fr_eof(fp),
 			   0 /* hw inserts cos value */,
 			   fnic->vlan_id, 1, 1, 1);
-fnic_send_frame_end:
+
+irq_restore:
 	spin_unlock_irqrestore(&fnic->wq_lock[0], flags);
 
+free_skb_on_err:
 	if (ret)
 		dev_kfree_skb_any(fp_skb(fp));
 
* Unmerged path drivers/scsi/fnic/fnic_scsi.c
