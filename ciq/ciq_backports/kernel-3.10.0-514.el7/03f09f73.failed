ACPI / LPSS: support for 133MHz I2C source clock on Baytrail

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 03f09f73bbd805f918fdc76888a1a83cdc28f28b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/03f09f73.failed

The I2C controllers on Baytrail can get the clock from
100MHz or 133MHz source clock. The first bits in the private
clock parameter register indicates which one is being used.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 03f09f73bbd805f918fdc76888a1a83cdc28f28b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_lpss.c
diff --cc drivers/acpi/acpi_lpss.c
index cfbdc9b37769,b693098f2160..000000000000
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@@ -90,22 -93,18 +91,22 @@@ struct lpss_private_data 
  static void lpss_uart_setup(struct lpss_private_data *pdata)
  {
  	unsigned int offset;
 -	u32 reg;
 +	u32 val;
  
  	offset = pdata->dev_desc->prv_offset + LPSS_TX_INT;
 -	reg = readl(pdata->mmio_base + offset);
 -	writel(reg | LPSS_TX_INT_MASK, pdata->mmio_base + offset);
 -
 -	offset = pdata->dev_desc->prv_offset + LPSS_GENERAL;
 -	reg = readl(pdata->mmio_base + offset);
 -	writel(reg | LPSS_GENERAL_UART_RTS_OVRD, pdata->mmio_base + offset);
 +	val = readl(pdata->mmio_base + offset);
 +	writel(val | LPSS_TX_INT_MASK, pdata->mmio_base + offset);
 +
 +	val = readl(pdata->mmio_base + LPSS_UART_CPR);
 +	if (!(val & LPSS_UART_CPR_AFCE)) {
 +		offset = pdata->dev_desc->prv_offset + LPSS_GENERAL;
 +		val = readl(pdata->mmio_base + offset);
 +		val |= LPSS_GENERAL_UART_RTS_OVRD;
 +		writel(val, pdata->mmio_base + offset);
 +	}
  }
  
- static void lpss_i2c_setup(struct lpss_private_data *pdata)
+ static void byt_i2c_setup(struct lpss_private_data *pdata)
  {
  	unsigned int offset;
  	u32 val;
@@@ -158,7 -168,17 +162,11 @@@ static struct lpss_device_desc byt_sdio
  static struct lpss_device_desc byt_i2c_dev_desc = {
  	.flags = LPSS_CLK | LPSS_SAVE_CTX,
  	.prv_offset = 0x800,
++<<<<<<< HEAD
 +	.setup = lpss_i2c_setup,
++=======
+ 	.setup = byt_i2c_setup,
 -};
 -
 -static struct lpss_shared_clock bsw_pwm_clock = {
 -	.name = "pwm_clk",
 -	.rate = 19200000,
 -};
 -
 -static struct lpss_device_desc bsw_pwm_dev_desc = {
 -	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 -	.shared_clock = &bsw_pwm_clock,
++>>>>>>> 03f09f73bbd8 (ACPI / LPSS: support for 133MHz I2C source clock on Baytrail)
  };
  
  #else
@@@ -237,6 -273,23 +245,26 @@@ static int register_device_clock(struc
  	parent = clk_data->name;
  	prv_base = pdata->mmio_base + dev_desc->prv_offset;
  
++<<<<<<< HEAD
++=======
+ 	if (shared_clock) {
+ 		clk = shared_clock->clk;
+ 		if (!clk) {
+ 			clk = clk_register_fixed_rate(NULL, shared_clock->name,
+ 						      "lpss_clk", 0,
+ 						      shared_clock->rate);
+ 			shared_clock->clk = clk;
+ 		}
+ 		parent = shared_clock->name;
+ 	}
+ 
+ 	if (pdata->fixed_clk_rate) {
+ 		clk = clk_register_fixed_rate(NULL, devname, parent, 0,
+ 					      pdata->fixed_clk_rate);
+ 		goto out;
+ 	}
+ 
++>>>>>>> 03f09f73bbd8 (ACPI / LPSS: support for 133MHz I2C source clock on Baytrail)
  	if (dev_desc->flags & LPSS_CLK_GATE) {
  		clk = clk_register_gate(NULL, devname, parent, 0,
  					prv_base, 0, 0, NULL);
@@@ -313,13 -366,11 +341,16 @@@ static int acpi_lpss_create_device(stru
  
  	acpi_dev_free_resource_list(&resource_list);
  
 +	if (!pdata->mmio_base) {
 +		ret = -ENOMEM;
 +		goto err_out;
 +	}
 +
  	pdata->dev_desc = dev_desc;
  
+ 	if (dev_desc->setup)
+ 		dev_desc->setup(pdata);
+ 
  	if (dev_desc->flags & LPSS_CLK) {
  		ret = register_device_clock(adev, pdata);
  		if (ret) {
* Unmerged path drivers/acpi/acpi_lpss.c
