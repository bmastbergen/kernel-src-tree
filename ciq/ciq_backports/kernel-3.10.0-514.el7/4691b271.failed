nfsd: Fix a memory leak in nfsd4_list_rec_dir()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kinglong Mee <kinglongmee@gmail.com>
commit 4691b271ac3a3bdc0d7d886e4715163eb4fb4bc7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4691b271.failed

If lookup_one_len() failed, nfsd should free those memory allocated for fname.

	Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 4691b271ac3a3bdc0d7d886e4715163eb4fb4bc7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4recover.c
diff --cc fs/nfsd/nfs4recover.c
index 2e4a08ead378,591bfbdf0316..000000000000
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@@ -262,7 -268,11 +262,15 @@@ nfsd4_list_rec_dir(recdir_func *f, stru
  {
  	const struct cred *original_cred;
  	struct dentry *dir = nn->rec_file->f_path.dentry;
++<<<<<<< HEAD
 +	LIST_HEAD(names);
++=======
+ 	struct nfs4_dir_ctx ctx = {
+ 		.ctx.actor = nfsd4_build_namelist,
+ 		.names = LIST_HEAD_INIT(ctx.names)
+ 	};
+ 	struct name_list *entry, *tmp;
++>>>>>>> 4691b271ac3a (nfsd: Fix a memory leak in nfsd4_list_rec_dir())
  	int status;
  
  	status = nfs4_save_creds(&original_cred);
@@@ -275,11 -285,10 +283,18 @@@
  		return status;
  	}
  
++<<<<<<< HEAD
 +	status = vfs_readdir(nn->rec_file, nfsd4_build_namelist, &names);
 +	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
 +	while (!list_empty(&names)) {
 +		struct name_list *entry;
 +		entry = list_entry(names.next, struct name_list, list);
++=======
+ 	status = iterate_dir(nn->rec_file, &ctx.ctx);
+ 	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
+ 
+ 	list_for_each_entry_safe(entry, tmp, &ctx.names, list) {
++>>>>>>> 4691b271ac3a (nfsd: Fix a memory leak in nfsd4_list_rec_dir())
  		if (!status) {
  			struct dentry *dentry;
  			dentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);
@@@ -293,8 -302,14 +308,14 @@@
  		list_del(&entry->list);
  		kfree(entry);
  	}
 -	mutex_unlock(&d_inode(dir)->i_mutex);
 +	mutex_unlock(&dir->d_inode->i_mutex);
  	nfs4_reset_creds(original_cred);
+ 
+ 	list_for_each_entry_safe(entry, tmp, &ctx.names, list) {
+ 		dprintk("NFSD: %s. Left entry %s\n", __func__, entry->name);
+ 		list_del(&entry->list);
+ 		kfree(entry);
+ 	}
  	return status;
  }
  
* Unmerged path fs/nfsd/nfs4recover.c
