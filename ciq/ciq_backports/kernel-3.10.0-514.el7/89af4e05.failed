perf stat report: Allow to override aggr_mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 89af4e05c21d68f22e07fe66940ea675615a49ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/89af4e05.failed

Allowing to override record aggr_mode. It's possible to use perf stat
like:

   $ perf stat report -A
   $ perf stat report --per-core
   $ perf stat report --per-socket

To customize the recorded aggregate mode regardless what was used during
the stat record command.

	Reported-by: Kan Liang <kan.liang@intel.com>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1446734469-11352-19-git-send-email-jolsa@kernel.org
[ Renamed 'stat' parameter to 'st' to fix 'already defined' build error with older distros (e.g. RHEL6.7) ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 89af4e05c21d68f22e07fe66940ea675615a49ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-stat.txt
#	tools/perf/builtin-stat.c
diff --cc tools/perf/Documentation/perf-stat.txt
index 4e074a660826,52ef7a9d50aa..000000000000
--- a/tools/perf/Documentation/perf-stat.txt
+++ b/tools/perf/Documentation/perf-stat.txt
@@@ -159,6 -166,33 +159,36 @@@ filter out the startup phase of the pro
  
  Print statistics of transactional execution if supported.
  
++<<<<<<< HEAD
++=======
+ STAT RECORD
+ -----------
+ Stores stat data into perf data file.
+ 
+ -o file::
+ --output file::
+ Output file name.
+ 
+ STAT REPORT
+ -----------
+ Reads and reports stat data from perf data file.
+ 
+ -i file::
+ --input file::
+ Input file name.
+ 
+ --per-socket::
+ Aggregate counts per processor socket for system-wide mode measurements.
+ 
+ --per-core::
+ Aggregate counts per physical processor for system-wide mode measurements.
+ 
+ -A::
+ --no-aggr::
+ Do not aggregate counts across all monitored CPUs.
+ 
+ 
++>>>>>>> 89af4e05c21d (perf stat report: Allow to override aggr_mode)
  EXAMPLES
  --------
  
diff --cc tools/perf/builtin-stat.c
index 473fc692d35a,9805e03ab163..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -119,7 -124,25 +119,29 @@@ static unsigned int		unit_width			= 4; 
  static bool			forever				= false;
  static struct timespec		ref_time;
  static struct cpu_map		*aggr_map;
++<<<<<<< HEAD
 +static int			(*aggr_get_id)(struct cpu_map *m, int cpu);
++=======
+ static aggr_get_id_t		aggr_get_id;
+ static bool			append_file;
+ static const char		*output_name;
+ static int			output_fd;
+ 
+ struct perf_stat {
+ 	bool			 record;
+ 	struct perf_data_file	 file;
+ 	struct perf_session	*session;
+ 	u64			 bytes_written;
+ 	struct perf_tool	 tool;
+ 	bool			 maps_allocated;
+ 	struct cpu_map		*cpus;
+ 	struct thread_map	*threads;
+ 	enum aggr_mode		 aggr_mode;
+ };
+ 
+ static struct perf_stat		perf_stat;
+ #define STAT_RECORD		perf_stat.record
++>>>>>>> 89af4e05c21d (perf stat report: Allow to override aggr_mode)
  
  static volatile int done = 0;
  
@@@ -1136,71 -1581,227 +1158,293 @@@ static int add_default_attributes(void
  	return perf_evlist__add_default_attrs(evsel_list, very_very_detailed_attrs);
  }
  
++<<<<<<< HEAD
++=======
+ static const char * const recort_usage[] = {
+ 	"perf stat record [<options>]",
+ 	NULL,
+ };
+ 
+ static void init_features(struct perf_session *session)
+ {
+ 	int feat;
+ 
+ 	for (feat = HEADER_FIRST_FEATURE; feat < HEADER_LAST_FEATURE; feat++)
+ 		perf_header__set_feat(&session->header, feat);
+ 
+ 	perf_header__clear_feat(&session->header, HEADER_BUILD_ID);
+ 	perf_header__clear_feat(&session->header, HEADER_TRACING_DATA);
+ 	perf_header__clear_feat(&session->header, HEADER_BRANCH_STACK);
+ 	perf_header__clear_feat(&session->header, HEADER_AUXTRACE);
+ }
+ 
+ static int __cmd_record(int argc, const char **argv)
+ {
+ 	struct perf_session *session;
+ 	struct perf_data_file *file = &perf_stat.file;
+ 
+ 	argc = parse_options(argc, argv, stat_options, record_usage,
+ 			     PARSE_OPT_STOP_AT_NON_OPTION);
+ 
+ 	if (output_name)
+ 		file->path = output_name;
+ 
+ 	if (run_count != 1 || forever) {
+ 		pr_err("Cannot use -r option with perf stat record.\n");
+ 		return -1;
+ 	}
+ 
+ 	session = perf_session__new(file, false, NULL);
+ 	if (session == NULL) {
+ 		pr_err("Perf session creation failed.\n");
+ 		return -1;
+ 	}
+ 
+ 	init_features(session);
+ 
+ 	session->evlist   = evsel_list;
+ 	perf_stat.session = session;
+ 	perf_stat.record  = true;
+ 	return argc;
+ }
+ 
+ static int process_stat_round_event(struct perf_tool *tool __maybe_unused,
+ 				    union perf_event *event,
+ 				    struct perf_session *session)
+ {
+ 	struct stat_round_event *round = &event->stat_round;
+ 	struct perf_evsel *counter;
+ 	struct timespec tsh, *ts = NULL;
+ 	const char **argv = session->header.env.cmdline_argv;
+ 	int argc = session->header.env.nr_cmdline;
+ 
+ 	evlist__for_each(evsel_list, counter)
+ 		perf_stat_process_counter(&stat_config, counter);
+ 
+ 	if (round->type == PERF_STAT_ROUND_TYPE__FINAL)
+ 		update_stats(&walltime_nsecs_stats, round->time);
+ 
+ 	if (stat_config.interval && round->time) {
+ 		tsh.tv_sec  = round->time / NSECS_PER_SEC;
+ 		tsh.tv_nsec = round->time % NSECS_PER_SEC;
+ 		ts = &tsh;
+ 	}
+ 
+ 	print_counters(ts, argc, argv);
+ 	return 0;
+ }
+ 
+ static
+ int process_stat_config_event(struct perf_tool *tool __maybe_unused,
+ 			      union perf_event *event,
+ 			      struct perf_session *session __maybe_unused)
+ {
+ 	struct perf_stat *st = container_of(tool, struct perf_stat, tool);
+ 
+ 	perf_event__read_stat_config(&stat_config, &event->stat_config);
+ 
+ 	if (cpu_map__empty(st->cpus)) {
+ 		if (st->aggr_mode != AGGR_UNSET)
+ 			pr_warning("warning: processing task data, aggregation mode not set\n");
+ 		return 0;
+ 	}
+ 
+ 	if (st->aggr_mode != AGGR_UNSET)
+ 		stat_config.aggr_mode = st->aggr_mode;
+ 
+ 	if (perf_stat.file.is_pipe)
+ 		perf_stat_init_aggr_mode();
+ 	else
+ 		perf_stat_init_aggr_mode_file(st);
+ 
+ 	return 0;
+ }
+ 
+ static int set_maps(struct perf_stat *st)
+ {
+ 	if (!st->cpus || !st->threads)
+ 		return 0;
+ 
+ 	if (WARN_ONCE(st->maps_allocated, "stats double allocation\n"))
+ 		return -EINVAL;
+ 
+ 	perf_evlist__set_maps(evsel_list, st->cpus, st->threads);
+ 
+ 	if (perf_evlist__alloc_stats(evsel_list, true))
+ 		return -ENOMEM;
+ 
+ 	st->maps_allocated = true;
+ 	return 0;
+ }
+ 
+ static
+ int process_thread_map_event(struct perf_tool *tool __maybe_unused,
+ 			     union perf_event *event,
+ 			     struct perf_session *session __maybe_unused)
+ {
+ 	struct perf_stat *st = container_of(tool, struct perf_stat, tool);
+ 
+ 	if (st->threads) {
+ 		pr_warning("Extra thread map event, ignoring.\n");
+ 		return 0;
+ 	}
+ 
+ 	st->threads = thread_map__new_event(&event->thread_map);
+ 	if (!st->threads)
+ 		return -ENOMEM;
+ 
+ 	return set_maps(st);
+ }
+ 
+ static
+ int process_cpu_map_event(struct perf_tool *tool __maybe_unused,
+ 			  union perf_event *event,
+ 			  struct perf_session *session __maybe_unused)
+ {
+ 	struct perf_stat *st = container_of(tool, struct perf_stat, tool);
+ 	struct cpu_map *cpus;
+ 
+ 	if (st->cpus) {
+ 		pr_warning("Extra cpu map event, ignoring.\n");
+ 		return 0;
+ 	}
+ 
+ 	cpus = cpu_map__new_data(&event->cpu_map.data);
+ 	if (!cpus)
+ 		return -ENOMEM;
+ 
+ 	st->cpus = cpus;
+ 	return set_maps(st);
+ }
+ 
+ static const char * const report_usage[] = {
+ 	"perf stat report [<options>]",
+ 	NULL,
+ };
+ 
+ static struct perf_stat perf_stat = {
+ 	.tool = {
+ 		.attr		= perf_event__process_attr,
+ 		.event_update	= perf_event__process_event_update,
+ 		.thread_map	= process_thread_map_event,
+ 		.cpu_map	= process_cpu_map_event,
+ 		.stat_config	= process_stat_config_event,
+ 		.stat		= perf_event__process_stat_event,
+ 		.stat_round	= process_stat_round_event,
+ 	},
+ 	.aggr_mode = AGGR_UNSET,
+ };
+ 
+ static int __cmd_report(int argc, const char **argv)
+ {
+ 	struct perf_session *session;
+ 	const struct option options[] = {
+ 	OPT_STRING('i', "input", &input_name, "file", "input file name"),
+ 	OPT_SET_UINT(0, "per-socket", &perf_stat.aggr_mode,
+ 		     "aggregate counts per processor socket", AGGR_SOCKET),
+ 	OPT_SET_UINT(0, "per-core", &perf_stat.aggr_mode,
+ 		     "aggregate counts per physical processor core", AGGR_CORE),
+ 	OPT_SET_UINT('A', "no-aggr", &perf_stat.aggr_mode,
+ 		     "disable CPU count aggregation", AGGR_NONE),
+ 	OPT_END()
+ 	};
+ 	struct stat st;
+ 	int ret;
+ 
+ 	argc = parse_options(argc, argv, options, report_usage, 0);
+ 
+ 	if (!input_name || !strlen(input_name)) {
+ 		if (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))
+ 			input_name = "-";
+ 		else
+ 			input_name = "perf.data";
+ 	}
+ 
+ 	perf_stat.file.path = input_name;
+ 	perf_stat.file.mode = PERF_DATA_MODE_READ;
+ 
+ 	session = perf_session__new(&perf_stat.file, false, &perf_stat.tool);
+ 	if (session == NULL)
+ 		return -1;
+ 
+ 	perf_stat.session  = session;
+ 	stat_config.output = stderr;
+ 	evsel_list         = session->evlist;
+ 
+ 	ret = perf_session__process_events(session);
+ 	if (ret)
+ 		return ret;
+ 
+ 	perf_session__delete(session);
+ 	return 0;
+ }
+ 
++>>>>>>> 89af4e05c21d (perf stat report: Allow to override aggr_mode)
  int cmd_stat(int argc, const char **argv, const char *prefix __maybe_unused)
  {
 +	bool append_file = false;
 +	int output_fd = 0;
 +	const char *output_name	= NULL;
 +	const struct option options[] = {
 +	OPT_BOOLEAN('T', "transaction", &transaction_run,
 +		    "hardware transaction statistics"),
 +	OPT_CALLBACK('e', "event", &evsel_list, "event",
 +		     "event selector. use 'perf list' to list available events",
 +		     parse_events_option),
 +	OPT_CALLBACK(0, "filter", &evsel_list, "filter",
 +		     "event filter", parse_filter),
 +	OPT_BOOLEAN('i', "no-inherit", &no_inherit,
 +		    "child tasks do not inherit counters"),
 +	OPT_STRING('p', "pid", &target.pid, "pid",
 +		   "stat events on existing process id"),
 +	OPT_STRING('t', "tid", &target.tid, "tid",
 +		   "stat events on existing thread id"),
 +	OPT_BOOLEAN('a', "all-cpus", &target.system_wide,
 +		    "system-wide collection from all CPUs"),
 +	OPT_BOOLEAN('g', "group", &group,
 +		    "put the counters into a counter group"),
 +	OPT_BOOLEAN('c', "scale", &stat_config.scale, "scale/normalize counters"),
 +	OPT_INCR('v', "verbose", &verbose,
 +		    "be more verbose (show counter open errors, etc)"),
 +	OPT_INTEGER('r', "repeat", &run_count,
 +		    "repeat command and print average + stddev (max: 100, forever: 0)"),
 +	OPT_BOOLEAN('n', "null", &null_run,
 +		    "null run - dont start any counters"),
 +	OPT_INCR('d', "detailed", &detailed_run,
 +		    "detailed run - start a lot of events"),
 +	OPT_BOOLEAN('S', "sync", &sync_run,
 +		    "call sync() before starting a run"),
 +	OPT_CALLBACK_NOOPT('B', "big-num", NULL, NULL,
 +			   "print large numbers with thousands\' separators",
 +			   stat__set_big_num),
 +	OPT_STRING('C', "cpu", &target.cpu_list, "cpu",
 +		    "list of cpus to monitor in system-wide"),
 +	OPT_SET_UINT('A', "no-aggr", &stat_config.aggr_mode,
 +		    "disable CPU count aggregation", AGGR_NONE),
 +	OPT_STRING('x', "field-separator", &csv_sep, "separator",
 +		   "print counts with custom separator"),
 +	OPT_CALLBACK('G', "cgroup", &evsel_list, "name",
 +		     "monitor event in cgroup name only", parse_cgroups),
 +	OPT_STRING('o', "output", &output_name, "file", "output file name"),
 +	OPT_BOOLEAN(0, "append", &append_file, "append to the output file"),
 +	OPT_INTEGER(0, "log-fd", &output_fd,
 +		    "log output to fd, instead of stderr"),
 +	OPT_STRING(0, "pre", &pre_cmd, "command",
 +			"command to run prior to the measured command"),
 +	OPT_STRING(0, "post", &post_cmd, "command",
 +			"command to run after to the measured command"),
 +	OPT_UINTEGER('I', "interval-print", &stat_config.interval,
 +		    "print counts at regular interval in ms (>= 10)"),
 +	OPT_SET_UINT(0, "per-socket", &stat_config.aggr_mode,
 +		     "aggregate counts per processor socket", AGGR_SOCKET),
 +	OPT_SET_UINT(0, "per-core", &stat_config.aggr_mode,
 +		     "aggregate counts per physical processor core", AGGR_CORE),
 +	OPT_SET_UINT(0, "per-thread", &stat_config.aggr_mode,
 +		     "aggregate counts per thread", AGGR_THREAD),
 +	OPT_UINTEGER('D', "delay", &initial_delay,
 +		     "ms to wait before starting measurement after program start"),
 +	OPT_END()
 +	};
  	const char * const stat_usage[] = {
  		"perf stat [<options>] [<command>]",
  		NULL
* Unmerged path tools/perf/Documentation/perf-stat.txt
* Unmerged path tools/perf/builtin-stat.c
