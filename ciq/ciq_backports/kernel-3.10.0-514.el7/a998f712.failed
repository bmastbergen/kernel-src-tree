rhashtable: Round up/down min/max_size to ensure we respect limit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit a998f712f77ea4892d3fcf24e0a67603e63da128
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a998f712.failed

Round up min_size respectively round down max_size to the next power
of two to make sure we always respect the limit specified by the
user. This is required because we compare the table size against the
limit before we expand or shrink.

Also fixes a minor bug where we modified min_size in the params
provided instead of the copy stored in struct rhashtable.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a998f712f77ea4892d3fcf24e0a67603e63da128)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/rhashtable.c
diff --cc lib/rhashtable.c
index 6d0c4774001c,e75c48d9d82f..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -522,13 -930,30 +522,39 @@@ int rhashtable_init(struct rhashtable *
  	    (!params->key_len && !params->obj_hashfn))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	params->min_shift = max_t(size_t, params->min_shift,
 +				  ilog2(HASH_MIN_SIZE));
++=======
+ 	if (params->nulls_base && params->nulls_base < (1U << RHT_BASE_SHIFT))
+ 		return -EINVAL;
++>>>>>>> a998f712f77e (rhashtable: Round up/down min/max_size to ensure we respect limit)
  
  	if (params->nelem_hint)
  		size = rounded_hashtable_size(params);
  
++<<<<<<< HEAD
 +	tbl = bucket_table_alloc(size);
++=======
+ 	memset(ht, 0, sizeof(*ht));
+ 	mutex_init(&ht->mutex);
+ 	memcpy(&ht->p, params, sizeof(*params));
+ 
+ 	if (params->min_size)
+ 		ht->p.min_size = roundup_pow_of_two(params->min_size);
+ 
+ 	if (params->max_size)
+ 		ht->p.max_size = rounddown_pow_of_two(params->max_size);
+ 
+ 	ht->p.min_size = max(params->min_size, HASH_MIN_SIZE);
+ 
+ 	if (params->locks_mul)
+ 		ht->p.locks_mul = roundup_pow_of_two(params->locks_mul);
+ 	else
+ 		ht->p.locks_mul = BUCKET_LOCKS_PER_CPU;
+ 
+ 	tbl = bucket_table_alloc(ht, size);
++>>>>>>> a998f712f77e (rhashtable: Round up/down min/max_size to ensure we respect limit)
  	if (tbl == NULL)
  		return -ENOMEM;
  
* Unmerged path lib/rhashtable.c
