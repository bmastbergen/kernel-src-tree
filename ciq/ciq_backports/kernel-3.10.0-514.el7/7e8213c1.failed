x86/efi: Correct EFI boot stub use of code32_start

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] efi: Correct EFI boot stub use of code32_start (Lenny Szubowicz) [1310154]
Rebuild_FUZZ: 95.83%
commit-author Matt Fleming <matt@console-pimps.org>
commit 7e8213c1f3acc064aef37813a39f13cbfe7c3ce7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7e8213c1.failed

code32_start should point at the start of the protected mode code, and
*not* at the beginning of the bzImage. This is much easier to do in
assembly so document that callers of make_boot_params() need to fill out
code32_start.

The fallout from this bug is that we would end up relocating the image
but copying the image at some offset, resulting in what appeared to be
memory corruption.

	Reported-by: Thomas BÃ¤chler <thomas@archlinux.org>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 7e8213c1f3acc064aef37813a39f13cbfe7c3ce7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/head_32.S
#	arch/x86/boot/compressed/head_64.S
diff --cc arch/x86/boot/compressed/head_32.S
index 1e3184f6072f,cbed1407a5cd..000000000000
--- a/arch/x86/boot/compressed/head_32.S
+++ b/arch/x86/boot/compressed/head_32.S
@@@ -42,33 -42,56 +42,34 @@@ ENTRY(startup_32
  ENTRY(efi_pe_entry)
  	add	$0x4, %esp
  
 -	call	1f
 -1:	popl	%esi
 -	subl	$1b, %esi
 -
 -	popl	%ecx
 -	movl	%ecx, efi32_config(%esi)	/* Handle */
 -	popl	%ecx
 -	movl	%ecx, efi32_config+8(%esi)	/* EFI System table pointer */
 -
 -	/* Relocate efi_config->call() */
 -	leal	efi32_config(%esi), %eax
 -	add	%esi, 88(%eax)
 -	pushl	%eax
 -
  	call	make_boot_params
  	cmpl	$0, %eax
++<<<<<<< HEAD
 +	je	1f
 +	movl	0x4(%esp), %esi
 +	movl	(%esp), %ecx
++=======
+ 	je	fail
+ 	movl	%esi, BP_code32_start(%eax)
+ 	popl	%ecx
++>>>>>>> 7e8213c1f3ac (x86/efi: Correct EFI boot stub use of code32_start)
  	pushl	%eax
 +	pushl	%esi
  	pushl	%ecx
 -	jmp	2f		/* Skip efi_config initialization */
 +	sub	$0x4, %esp
  
 -ENTRY(efi32_stub_entry)
 +ENTRY(efi_stub_entry)
  	add	$0x4, %esp
 -	popl	%ecx
 -	popl	%edx
 -
 -	call	1f
 -1:	popl	%esi
 -	subl	$1b, %esi
 -
 -	movl	%ecx, efi32_config(%esi)	/* Handle */
 -	movl	%edx, efi32_config+8(%esi)	/* EFI System table pointer */
 -
 -	/* Relocate efi_config->call() */
 -	leal	efi32_config(%esi), %eax
 -	add	%esi, 88(%eax)
 -	pushl	%eax
 -2:
  	call	efi_main
  	cmpl	$0, %eax
  	movl	%eax, %esi
  	jne	2f
 -fail:
 +1:
  	/* EFI init failed, so hang. */
  	hlt
 -	jmp	fail
 +	jmp	1b
  2:
- 	call	3f
- 3:
- 	popl	%eax
- 	subl	$3b, %eax
- 	subl	BP_pref_address(%esi), %eax
- 	add	BP_code32_start(%esi), %eax
+ 	movl	BP_code32_start(%esi), %eax
  	leal	preferred_addr(%eax), %eax
  	jmp	*%eax
  
diff --cc arch/x86/boot/compressed/head_64.S
index a71d43a7a6b9,0d558ee899ae..000000000000
--- a/arch/x86/boot/compressed/head_64.S
+++ b/arch/x86/boot/compressed/head_64.S
@@@ -210,33 -241,52 +210,36 @@@ ENTRY(startup_64
  	jmp	preferred_addr
  
  ENTRY(efi_pe_entry)
 -	movq	%rcx, efi64_config(%rip)	/* Handle */
 -	movq	%rdx, efi64_config+8(%rip) /* EFI System table pointer */
 -
 -	leaq	efi64_config(%rip), %rax
 -	movq	%rax, efi_config(%rip)
 -
 -	call	1f
 -1:	popq	%rbp
 -	subq	$1b, %rbp
 -
 -	/*
 -	 * Relocate efi_config->call().
 -	 */
 -	addq	%rbp, efi64_config+88(%rip)
 -
 -	movq	%rax, %rdi
 +	mov	%rcx, %rdi
 +	mov	%rdx, %rsi
 +	pushq	%rdi
 +	pushq	%rsi
  	call	make_boot_params
  	cmpq	$0,%rax
++<<<<<<< HEAD
 +	je	1f
 +	mov	%rax, %rdx
 +	popq	%rsi
 +	popq	%rdi
++=======
+ 	je	fail
+ 	mov	%rax, %rsi
+ 	leaq	startup_32(%rip), %rax
+ 	movl	%eax, BP_code32_start(%rsi)
+ 	jmp	2f		/* Skip the relocation */
++>>>>>>> 7e8213c1f3ac (x86/efi: Correct EFI boot stub use of code32_start)
  
 -handover_entry:
 -	call	1f
 -1:	popq	%rbp
 -	subq	$1b, %rbp
 -
 -	/*
 -	 * Relocate efi_config->call().
 -	 */
 -	movq	efi_config(%rip), %rax
 -	addq	%rbp, 88(%rax)
 -2:
 -	movq	efi_config(%rip), %rdi
 +ENTRY(efi_stub_entry)
  	call	efi_main
  	movq	%rax,%rsi
  	cmpq	$0,%rax
  	jne	2f
 -fail:
 +1:
  	/* EFI init failed, so hang. */
  	hlt
 -	jmp	fail
 +	jmp	1b
  2:
- 	call	3f
- 3:
- 	popq	%rax
- 	subq	$3b, %rax
- 	subq	BP_pref_address(%rsi), %rax
- 	add	BP_code32_start(%esi), %eax
+ 	movl	BP_code32_start(%esi), %eax
  	leaq	preferred_addr(%rax), %rax
  	jmp	*%rax
  
diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c
index a1ae20b40077..f4f0b15e09a0 100644
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@ -475,6 +475,9 @@ static int get_secure_boot(void)
  * Because the x86 boot code expects to be passed a boot_params we
  * need to create one ourselves (usually the bootloader would create
  * one for us).
+ *
+ * The caller is responsible for filling out ->code32_start in the
+ * returned boot_params.
  */
 struct boot_params *make_boot_params(void *handle, efi_system_table_t *_table)
 {
@@ -531,8 +534,6 @@ struct boot_params *make_boot_params(void *handle, efi_system_table_t *_table)
 	hdr->vid_mode = 0xffff;
 	hdr->boot_flag = 0xAA55;
 
-	hdr->code32_start = (__u64)(unsigned long)image->image_base;
-
 	hdr->type_of_loader = 0x21;
 
 	/* Convert unicode cmdline to ascii */
* Unmerged path arch/x86/boot/compressed/head_32.S
* Unmerged path arch/x86/boot/compressed/head_64.S
