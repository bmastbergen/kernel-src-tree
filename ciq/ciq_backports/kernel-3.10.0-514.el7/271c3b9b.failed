tcp: honour SO_BINDTODEVICE for TW_RST case too

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Florian Westphal <fw@strlen.de>
commit 271c3b9b7bdae09c7da467ac1ae96e3298754977
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/271c3b9b.failed

Hannes points out that when we generate tcp reset for timewait sockets we
pretend we found no socket and pass NULL sk to tcp_vX_send_reset().

Make it cope with inet tw sockets and then provide tw sk.

This makes RSTs appear on correct interface when SO_BINDTODEVICE is used.

Packetdrill test case:
// want default route to be used, we rely on BINDTODEVICE
`ip route del 192.0.2.0/24 via 192.168.0.2 dev tun0`

0.000 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3
// test case still works due to BINDTODEVICE
0.001 setsockopt(3, SOL_SOCKET, SO_BINDTODEVICE, "tun0", 4) = 0
0.100...0.200 connect(3, ..., ...) = 0

0.100 > S 0:0(0) <mss 1460,sackOK,nop,nop>
0.200 < S. 0:0(0) ack 1 win 32792 <mss 1460,sackOK,nop,nop>
0.200 > . 1:1(0) ack 1

0.210 close(3) = 0

0.210 > F. 1:1(0) ack 1 win 29200
0.300 < . 1:1(0) ack 2 win 46

// more data while in FIN_WAIT2, expect RST
1.300 < P. 1:1001(1000) ack 1 win 46

// fails without this change -- default route is used
1.301 > R 1:1(0) win 0

	Reported-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 271c3b9b7bdae09c7da467ac1ae96e3298754977)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_minisocks.c
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv4/tcp_minisocks.c
index 5129a4495bc8,75632a925824..000000000000
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@@ -156,12 -145,8 +156,15 @@@ tcp_timewait_state_process(struct inet_
  		 * reset.
  		 */
  		if (!th->fin ||
++<<<<<<< HEAD
 +		    TCP_SKB_CB(skb)->end_seq != tcptw->tw_rcv_nxt + 1) {
 +kill_with_rst:
 +			inet_twsk_deschedule(tw, &tcp_death_row);
 +			inet_twsk_put(tw);
++=======
+ 		    TCP_SKB_CB(skb)->end_seq != tcptw->tw_rcv_nxt + 1)
++>>>>>>> 271c3b9b7bda (tcp: honour SO_BINDTODEVICE for TW_RST case too)
  			return TCP_TW_RST;
- 		}
  
  		/* FIN arrived, enter true time-wait state. */
  		tw->tw_substate	  = TCP_TIME_WAIT;
diff --cc net/ipv6/tcp_ipv6.c
index 2ab7bcc949ac,9ecb012291cf..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1514,7 -1515,10 +1514,14 @@@ do_time_wait
  		tcp_v6_timewait_ack(sk, skb);
  		break;
  	case TCP_TW_RST:
++<<<<<<< HEAD
 +		goto no_tcp_socket;
++=======
+ 		tcp_v6_restore_cb(skb);
+ 		tcp_v6_send_reset(sk, skb);
+ 		inet_twsk_deschedule_put(inet_twsk(sk));
+ 		goto discard_it;
++>>>>>>> 271c3b9b7bda (tcp: honour SO_BINDTODEVICE for TW_RST case too)
  	case TCP_TW_SUCCESS:
  		;
  	}
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 2ea261af04d9..aff0db25fc20 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -631,7 +631,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 	net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);
 #ifdef CONFIG_TCP_MD5SIG
 	hash_location = tcp_parse_md5sig_option(th);
-	if (sk) {
+	if (sk && sk_fullsock(sk)) {
 		key = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)
 					&ip_hdr(skb)->saddr, AF_INET);
 	} else if (hash_location) {
@@ -678,7 +678,8 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 				      ip_hdr(skb)->saddr, /* XXX */
 				      arg.iov[0].iov_len, IPPROTO_TCP, 0);
 	arg.csumoffset = offsetof(struct tcphdr, check) / 2;
-	arg.flags = (sk && inet_sk(sk)->transparent) ? IP_REPLY_ARG_NOSRCCHECK : 0;
+	arg.flags = (sk && inet_sk_transparent(sk)) ? IP_REPLY_ARG_NOSRCCHECK : 0;
+
 	/* When socket is gone, all binding information is lost.
 	 * routing might fail in this case. No choice here, if we choose to force
 	 * input interface, we will misroute in case of asymmetric route.
@@ -686,6 +687,9 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 	if (sk)
 		arg.bound_dev_if = sk->sk_bound_dev_if;
 
+	BUILD_BUG_ON(offsetof(struct sock, sk_bound_dev_if) !=
+		     offsetof(struct inet_timewait_sock, tw_bound_dev_if));
+
 	arg.tos = ip_hdr(skb)->tos;
 	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4_tcp_sk),
 			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
@@ -1763,7 +1767,9 @@ do_time_wait:
 		tcp_v4_timewait_ack(sk, skb);
 		break;
 	case TCP_TW_RST:
-		goto no_tcp_socket;
+		tcp_v4_send_reset(sk, skb);
+		inet_twsk_deschedule_put(inet_twsk(sk));
+		goto discard_it;
 	case TCP_TW_SUCCESS:;
 	}
 	goto discard_it;
* Unmerged path net/ipv4/tcp_minisocks.c
* Unmerged path net/ipv6/tcp_ipv6.c
