tpm_crb/tis: fix: use dev_name() for /proc/iomem

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 30f9c8c9e2ea37473a51354e9e492580a40661ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/30f9c8c9.failed

In all cases use dev_name() for the mapped resources. This is both
for sake of consistency and also with some platforms resource name
given by ACPI object seems to return garbage.

	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Fixes: 1bd047be37d9 ("tpm_crb: Use devm_ioremap_resource")
(cherry picked from commit 30f9c8c9e2ea37473a51354e9e492580a40661ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_crb.c
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_crb.c
index 21a066b73f54,9eb04044c385..000000000000
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@@ -299,6 -222,123 +299,126 @@@ static int crb_acpi_add(struct acpi_dev
  	return tpm_chip_register(chip);
  }
  
++<<<<<<< HEAD
++=======
+ static int crb_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct crb_priv *priv = data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_memory(ares, &res)) {
+ 		priv->res = res;
+ 		priv->res.name = NULL;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,
+ 				 u64 start, u32 size)
+ {
+ 	struct resource new_res = {
+ 		.start	= start,
+ 		.end	= start + size - 1,
+ 		.flags	= IORESOURCE_MEM,
+ 	};
+ 
+ 	/* Detect a 64 bit address on a 32 bit system */
+ 	if (start != new_res.start)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (!resource_contains(&priv->res, &new_res))
+ 		return devm_ioremap_resource(dev, &new_res);
+ 
+ 	return priv->iobase + (new_res.start - priv->res.start);
+ }
+ 
+ static int crb_map_io(struct acpi_device *device, struct crb_priv *priv,
+ 		      struct acpi_table_tpm2 *buf)
+ {
+ 	struct list_head resources;
+ 	struct device *dev = &device->dev;
+ 	u64 pa;
+ 	int ret;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	ret = acpi_dev_get_resources(device, &resources, crb_check_resource,
+ 				     priv);
+ 	if (ret < 0)
+ 		return ret;
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (resource_type(&priv->res) != IORESOURCE_MEM) {
+ 		dev_err(dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	priv->iobase = devm_ioremap_resource(dev, &priv->res);
+ 	if (IS_ERR(priv->iobase))
+ 		return PTR_ERR(priv->iobase);
+ 
+ 	priv->cca = crb_map_res(dev, priv, buf->control_address, 0x1000);
+ 	if (IS_ERR(priv->cca))
+ 		return PTR_ERR(priv->cca);
+ 
+ 	pa = ((u64) ioread32(&priv->cca->cmd_pa_high) << 32) |
+ 	      (u64) ioread32(&priv->cca->cmd_pa_low);
+ 	priv->cmd = crb_map_res(dev, priv, pa, ioread32(&priv->cca->cmd_size));
+ 	if (IS_ERR(priv->cmd))
+ 		return PTR_ERR(priv->cmd);
+ 
+ 	memcpy_fromio(&pa, &priv->cca->rsp_pa, 8);
+ 	pa = le64_to_cpu(pa);
+ 	priv->rsp = crb_map_res(dev, priv, pa, ioread32(&priv->cca->rsp_size));
+ 	return PTR_ERR_OR_ZERO(priv->rsp);
+ }
+ 
+ static int crb_acpi_add(struct acpi_device *device)
+ {
+ 	struct acpi_table_tpm2 *buf;
+ 	struct crb_priv *priv;
+ 	struct device *dev = &device->dev;
+ 	acpi_status status;
+ 	u32 sm;
+ 	int rc;
+ 
+ 	status = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 				(struct acpi_table_header **) &buf);
+ 	if (ACPI_FAILURE(status) || buf->header.length < sizeof(*buf)) {
+ 		dev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Should the FIFO driver handle this? */
+ 	sm = buf->start_method;
+ 	if (sm == ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(struct crb_priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	/* The reason for the extra quirk is that the PTT in 4th Gen Core CPUs
+ 	 * report only ACPI start but in practice seems to require both
+ 	 * ACPI start and CRB start.
+ 	 */
+ 	if (sm == ACPI_TPM2_COMMAND_BUFFER || sm == ACPI_TPM2_MEMORY_MAPPED ||
+ 	    !strcmp(acpi_device_hid(device), "MSFT0101"))
+ 		priv->flags |= CRB_FL_CRB_START;
+ 
+ 	if (sm == ACPI_TPM2_START_METHOD ||
+ 	    sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD)
+ 		priv->flags |= CRB_FL_ACPI_START;
+ 
+ 	rc = crb_map_io(device, priv, buf);
+ 	if (rc)
+ 		return rc;
+ 
+ 	return crb_init(device, priv);
+ }
+ 
++>>>>>>> 30f9c8c9e2ea (tpm_crb/tis: fix: use dev_name() for /proc/iomem)
  static int crb_acpi_remove(struct acpi_device *device)
  {
  	struct device *dev = &device->dev;
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,2b2eff9e769e..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -927,9 -921,135 +927,98 @@@ static struct pnp_driver tis_pnp_drive
  module_param_string(hid, tpm_pnp_tbl[TIS_HID_USR_IDX].id,
  		    sizeof(tpm_pnp_tbl[TIS_HID_USR_IDX].id), 0444);
  MODULE_PARM_DESC(hid, "Set additional specific HID for this driver to probe");
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_ACPI
+ static int tpm_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct tpm_info *tpm_info = (struct tpm_info *) data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_interrupt(ares, 0, &res))
+ 		tpm_info->irq = res.start;
+ 	else if (acpi_dev_resource_memory(ares, &res)) {
+ 		tpm_info->res = res;
+ 		tpm_info->res.name = NULL;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static int tpm_tis_acpi_init(struct acpi_device *acpi_dev)
+ {
+ 	struct acpi_table_tpm2 *tbl;
+ 	acpi_status st;
+ 	struct list_head resources;
+ 	struct tpm_info tpm_info = {};
+ 	int ret;
+ 
+ 	st = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 			    (struct acpi_table_header **) &tbl);
+ 	if (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	tpm_info.irq = -1;
+ 	ret = acpi_dev_get_resources(acpi_dev, &resources, tpm_check_resource,
+ 				     &tpm_info);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (resource_type(&tpm_info.res) != IORESOURCE_MEM) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (is_itpm(acpi_dev))
+ 		itpm = true;
+ 
+ 	return tpm_tis_init(&acpi_dev->dev, &tpm_info, acpi_dev->handle);
+ }
+ 
+ static int tpm_tis_acpi_remove(struct acpi_device *dev)
+ {
+ 	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
+ 
+ 	tpm_chip_unregister(chip);
+ 	tpm_tis_remove(chip);
+ 
+ 	return 0;
+ }
+ 
+ static struct acpi_device_id tpm_acpi_tbl[] = {
+ 	{"MSFT0101", 0},	/* TPM 2.0 */
+ 	/* Add new here */
+ 	{"", 0},		/* User Specified */
+ 	{"", 0}			/* Terminator */
+ };
+ MODULE_DEVICE_TABLE(acpi, tpm_acpi_tbl);
+ 
+ static struct acpi_driver tis_acpi_driver = {
+ 	.name = "tpm_tis",
+ 	.ids = tpm_acpi_tbl,
+ 	.ops = {
+ 		.add = tpm_tis_acpi_init,
+ 		.remove = tpm_tis_acpi_remove,
+ 	},
+ 	.drv = {
+ 		.pm = &tpm_tis_pm,
+ 	},
+ };
++>>>>>>> 30f9c8c9e2ea (tpm_crb/tis: fix: use dev_name() for /proc/iomem)
  #endif
  
 -static struct platform_device *force_pdev;
 -
 -static int tpm_tis_plat_probe(struct platform_device *pdev)
 -{
 -	struct tpm_info tpm_info = {};
 -	struct resource *res;
 -
 -	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (res == NULL) {
 -		dev_err(&pdev->dev, "no memory resource defined\n");
 -		return -ENODEV;
 -	}
 -	tpm_info.res = *res;
 -
 -	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 -	if (res) {
 -		tpm_info.irq = res->start;
 -	} else {
 -		if (pdev == force_pdev)
 -			tpm_info.irq = -1;
 -		else
 -			/* When forcing auto probe the IRQ */
 -			tpm_info.irq = 0;
 -	}
 -
 -	return tpm_tis_init(&pdev->dev, &tpm_info, NULL);
 -}
 -
 -static int tpm_tis_plat_remove(struct platform_device *pdev)
 -{
 -	struct tpm_chip *chip = dev_get_drvdata(&pdev->dev);
 -
 -	tpm_chip_unregister(chip);
 -	tpm_tis_remove(chip);
 -
 -	return 0;
 -}
 -
  static struct platform_driver tis_drv = {
 -	.probe = tpm_tis_plat_probe,
 -	.remove = tpm_tis_plat_remove,
  	.driver = {
  		.name		= "tpm_tis",
  		.pm		= &tpm_tis_pm,
* Unmerged path drivers/char/tpm/tpm_crb.c
* Unmerged path drivers/char/tpm/tpm_tis.c
