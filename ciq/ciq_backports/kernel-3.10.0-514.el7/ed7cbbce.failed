udp: Resolve NULL pointer dereference over flow-based vxlan device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit ed7cbbce544856b20e5811de373cf92e92499771
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ed7cbbce.failed

While testing an OpenStack configuration using VXLANs I saw the following
call trace:

 RIP: 0010:[<ffffffff815fad49>] udp4_lib_lookup_skb+0x49/0x80
 RSP: 0018:ffff88103867bc50  EFLAGS: 00010286
 RAX: ffff88103269bf00 RBX: ffff88103269bf00 RCX: 00000000ffffffff
 RDX: 0000000000004300 RSI: 0000000000000000 RDI: ffff880f2932e780
 RBP: ffff88103867bc60 R08: 0000000000000000 R09: 000000009001a8c0
 R10: 0000000000004400 R11: ffffffff81333a58 R12: ffff880f2932e794
 R13: 0000000000000014 R14: 0000000000000014 R15: ffffe8efbfd89ca0
 FS:  0000000000000000(0000) GS:ffff88103fd80000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000000000000488 CR3: 0000000001c06000 CR4: 00000000001426e0
 Stack:
  ffffffff81576515 ffffffff815733c0 ffff88103867bc98 ffffffff815fcc17
  ffff88103269bf00 ffffe8efbfd89ca0 0000000000000014 0000000000000080
  ffffe8efbfd89ca0 ffff88103867bcc8 ffffffff815fcf8b ffff880f2932e794
 Call Trace:
  [<ffffffff81576515>] ? skb_checksum+0x35/0x50
  [<ffffffff815733c0>] ? skb_push+0x40/0x40
  [<ffffffff815fcc17>] udp_gro_receive+0x57/0x130
  [<ffffffff815fcf8b>] udp4_gro_receive+0x10b/0x2c0
  [<ffffffff81605863>] inet_gro_receive+0x1d3/0x270
  [<ffffffff81589e59>] dev_gro_receive+0x269/0x3b0
  [<ffffffff8158a1b8>] napi_gro_receive+0x38/0x120
  [<ffffffffa0871297>] gro_cell_poll+0x57/0x80 [vxlan]
  [<ffffffff815899d0>] net_rx_action+0x160/0x380
  [<ffffffff816965c7>] __do_softirq+0xd7/0x2c5
  [<ffffffff8107d969>] run_ksoftirqd+0x29/0x50
  [<ffffffff8109a50f>] smpboot_thread_fn+0x10f/0x160
  [<ffffffff8109a400>] ? sort_range+0x30/0x30
  [<ffffffff81096da8>] kthread+0xd8/0xf0
  [<ffffffff81693c82>] ret_from_fork+0x22/0x40
  [<ffffffff81096cd0>] ? kthread_park+0x60/0x60

The following trace is seen when receiving a DHCP request over a flow-based
VXLAN tunnel.  I believe this is caused by the metadata dst having a NULL
dev value and as a result dev_net(dev) is causing a NULL pointer dereference.

To resolve this I am replacing the check for skb_dst(skb)->dev with just
skb->dev.  This makes sense as the callers of this function are usually in
the receive path and as such skb->dev should always be populated.  In
addition other functions in the area where these are called are already
using dev_net(skb->dev) to determine the namespace the UDP packet belongs
in.

Fixes: 63058308cd55 ("udp: Add udp6_lib_lookup_skb and udp4_lib_lookup_skb")
	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed7cbbce544856b20e5811de373cf92e92499771)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc net/ipv4/udp.c
index 556580e2c4f8,2e3ebfe5549e..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -560,17 -602,25 +560,37 @@@ static inline struct sock *__udp4_lib_l
  						 __be16 sport, __be16 dport,
  						 struct udp_table *udptable)
  {
 +	struct sock *sk;
  	const struct iphdr *iph = ip_hdr(skb);
  
++<<<<<<< HEAD
 +	if (unlikely(sk = skb_steal_sock(skb)))
 +		return sk;
 +	else
 +		return __udp4_lib_lookup(dev_net(skb_dst(skb)->dev), iph->saddr, sport,
 +					 iph->daddr, dport, inet_iif(skb),
 +					 udptable);
 +}
 +
++=======
+ 	return __udp4_lib_lookup(dev_net(skb->dev), iph->saddr, sport,
+ 				 iph->daddr, dport, inet_iif(skb),
+ 				 udptable, skb);
+ }
+ 
+ struct sock *udp4_lib_lookup_skb(struct sk_buff *skb,
+ 				 __be16 sport, __be16 dport)
+ {
+ 	return __udp4_lib_lookup_skb(skb, sport, dport, &udp_table);
+ }
+ EXPORT_SYMBOL_GPL(udp4_lib_lookup_skb);
+ 
+ /* Must be called under rcu_read_lock().
+  * Does increment socket refcount.
+  */
+ #if IS_ENABLED(CONFIG_NETFILTER_XT_MATCH_SOCKET) || \
+     IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TPROXY)
++>>>>>>> ed7cbbce5448 (udp: Resolve NULL pointer dereference over flow-based vxlan device)
  struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
  			     __be32 daddr, __be16 dport, int dif)
  {
diff --cc net/ipv6/udp.c
index 2c9dae38dffd,2ba6a77a8815..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -355,16 -315,33 +355,35 @@@ static struct sock *__udp6_lib_lookup_s
  					  __be16 sport, __be16 dport,
  					  struct udp_table *udptable)
  {
- 	struct sock *sk;
  	const struct ipv6hdr *iph = ipv6_hdr(skb);
+ 	struct sock *sk;
  
 -	sk = skb_steal_sock(skb);
 -	if (unlikely(sk))
 +	if (unlikely(sk = skb_steal_sock(skb)))
  		return sk;
- 	return __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,
+ 	return __udp6_lib_lookup(dev_net(skb->dev), &iph->saddr, sport,
  				 &iph->daddr, dport, inet6_iif(skb),
 -				 udptable, skb);
 +				 udptable);
  }
  
++<<<<<<< HEAD
++=======
+ struct sock *udp6_lib_lookup_skb(struct sk_buff *skb,
+ 				 __be16 sport, __be16 dport)
+ {
+ 	const struct ipv6hdr *iph = ipv6_hdr(skb);
+ 
+ 	return __udp6_lib_lookup(dev_net(skb->dev), &iph->saddr, sport,
+ 				 &iph->daddr, dport, inet6_iif(skb),
+ 				 &udp_table, skb);
+ }
+ EXPORT_SYMBOL_GPL(udp6_lib_lookup_skb);
+ 
+ /* Must be called under rcu_read_lock().
+  * Does increment socket refcount.
+  */
+ #if IS_ENABLED(CONFIG_NETFILTER_XT_MATCH_SOCKET) || \
+     IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TPROXY)
++>>>>>>> ed7cbbce5448 (udp: Resolve NULL pointer dereference over flow-based vxlan device)
  struct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
  			     const struct in6_addr *daddr, __be16 dport, int dif)
  {
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/udp.c
