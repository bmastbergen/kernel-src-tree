sunrpc: add tracepoints in xs_tcp_data_recv

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@primarydata.com>
commit 1a867a0898b2e366a1eb5b7fe21413a2b2b1629f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1a867a08.failed

Add tracepoints inside the main loop on xs_tcp_data_recv that allow
us to keep an eye on what's happening during each phase of it.

	Signed-off-by: Jeff Layton <jlayton@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 1a867a0898b2e366a1eb5b7fe21413a2b2b1629f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/sunrpc.h
#	net/sunrpc/xprtsock.c
diff --cc include/trace/events/sunrpc.h
index 1fef3e6e9436,171ca4ff6d99..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -6,6 -6,8 +6,11 @@@
  
  #include <linux/sunrpc/sched.h>
  #include <linux/sunrpc/clnt.h>
++<<<<<<< HEAD
++=======
+ #include <linux/sunrpc/svc.h>
+ #include <linux/sunrpc/xprtsock.h>
++>>>>>>> 1a867a0898b2 (sunrpc: add tracepoints in xs_tcp_data_recv)
  #include <net/tcp_states.h>
  #include <linux/net.h>
  #include <linux/tracepoint.h>
@@@ -306,6 -308,164 +311,167 @@@ DEFINE_RPC_SOCKET_EVENT_DONE(rpc_socket
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_close);
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_shutdown);
  
++<<<<<<< HEAD
++=======
+ DECLARE_EVENT_CLASS(rpc_xprt_event,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 
+ 	TP_ARGS(xprt, xid, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(__be32, xid)
+ 		__field(int, status)
+ 		__string(addr, xprt->address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xprt->address_strings[RPC_DISPLAY_PORT])
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = xid;
+ 		__entry->status = status;
+ 		__assign_str(addr, xprt->address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xprt->address_strings[RPC_DISPLAY_PORT]);
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x status=%d", __get_str(addr),
+ 			__get_str(port), be32_to_cpu(__entry->xid),
+ 			__entry->status)
+ );
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_lookup_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_transmit,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_complete_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ TRACE_EVENT(xs_tcp_data_ready,
+ 	TP_PROTO(struct rpc_xprt *xprt, int err, unsigned int total),
+ 
+ 	TP_ARGS(xprt, err, total),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, err)
+ 		__field(unsigned int, total)
+ 		__string(addr, xprt ? xprt->address_strings[RPC_DISPLAY_ADDR] :
+ 				"(null)")
+ 		__string(port, xprt ? xprt->address_strings[RPC_DISPLAY_PORT] :
+ 				"(null)")
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->err = err;
+ 		__entry->total = total;
+ 		__assign_str(addr, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_ADDR] : "(null)");
+ 		__assign_str(port, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_PORT] : "(null)");
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s err=%d total=%u", __get_str(addr),
+ 			__get_str(port), __entry->err, __entry->total)
+ );
+ 
+ #define rpc_show_sock_xprt_flags(flags) \
+ 	__print_flags(flags, "|", \
+ 		{ TCP_RCV_LAST_FRAG, "TCP_RCV_LAST_FRAG" }, \
+ 		{ TCP_RCV_COPY_FRAGHDR, "TCP_RCV_COPY_FRAGHDR" }, \
+ 		{ TCP_RCV_COPY_XID, "TCP_RCV_COPY_XID" }, \
+ 		{ TCP_RCV_COPY_DATA, "TCP_RCV_COPY_DATA" }, \
+ 		{ TCP_RCV_READ_CALLDIR, "TCP_RCV_READ_CALLDIR" }, \
+ 		{ TCP_RCV_COPY_CALLDIR, "TCP_RCV_COPY_CALLDIR" }, \
+ 		{ TCP_RPC_REPLY, "TCP_RPC_REPLY" })
+ 
+ TRACE_EVENT(xs_tcp_data_recv,
+ 	TP_PROTO(struct sock_xprt *xs),
+ 
+ 	TP_ARGS(xs),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xs->xprt.address_strings[RPC_DISPLAY_PORT])
+ 		__field(__be32, xid)
+ 		__field(unsigned long, flags)
+ 		__field(unsigned long, copied)
+ 		__field(unsigned int, reclen)
+ 		__field(unsigned long, offset)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xs->xprt.address_strings[RPC_DISPLAY_PORT]);
+ 		__entry->xid = xs->tcp_xid;
+ 		__entry->flags = xs->tcp_flags;
+ 		__entry->copied = xs->tcp_copied;
+ 		__entry->reclen = xs->tcp_reclen;
+ 		__entry->offset = xs->tcp_offset;
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x flags=%s copied=%lu reclen=%u offset=%lu",
+ 			__get_str(addr), __get_str(port), be32_to_cpu(__entry->xid),
+ 			rpc_show_sock_xprt_flags(__entry->flags),
+ 			__entry->copied, __entry->reclen, __entry->offset)
+ );
+ 
+ TRACE_EVENT(svc_recv,
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 
+ 	TP_ARGS(rqst, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(struct sockaddr *, addr)
+ 		__field(__be32, xid)
+ 		__field(int, status)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->addr = (struct sockaddr *)&rqst->rq_addr;
+ 		__entry->xid = status > 0 ? rqst->rq_xid : 0;
+ 		__entry->status = status;
+ 	),
+ 
+ 	TP_printk("addr=%pIScp xid=0x%x status=%d", __entry->addr,
+ 			be32_to_cpu(__entry->xid), __entry->status)
+ );
+ 
+ DECLARE_EVENT_CLASS(svc_rqst_status,
+ 
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 
+ 	TP_ARGS(rqst, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(struct sockaddr *, addr)
+ 		__field(__be32, xid)
+ 		__field(int, dropme)
+ 		__field(int, status)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->addr = (struct sockaddr *)&rqst->rq_addr;
+ 		__entry->xid = rqst->rq_xid;
+ 		__entry->dropme = (int)rqst->rq_dropme;
+ 		__entry->status = status;
+ 	),
+ 
+ 	TP_printk("addr=%pIScp rq_xid=0x%x dropme=%d status=%d",
+ 		__entry->addr, be32_to_cpu(__entry->xid), __entry->dropme,
+ 		__entry->status)
+ );
+ 
+ DEFINE_EVENT(svc_rqst_status, svc_process,
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 	TP_ARGS(rqst, status));
+ 
+ DEFINE_EVENT(svc_rqst_status, svc_send,
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 	TP_ARGS(rqst, status));
+ 
++>>>>>>> 1a867a0898b2 (sunrpc: add tracepoints in xs_tcp_data_recv)
  #endif /* _TRACE_SUNRPC_H */
  
  #include <trace/define_trace.h>
diff --cc net/sunrpc/xprtsock.c
index 28893e435064,31c015196a29..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -216,65 -216,6 +216,68 @@@ static inline void xs_pktdump(char *msg
  }
  #endif
  
++<<<<<<< HEAD
 +struct sock_xprt {
 +	struct rpc_xprt		xprt;
 +
 +	/*
 +	 * Network layer
 +	 */
 +	struct socket *		sock;
 +	struct sock *		inet;
 +
 +	/*
 +	 * State of TCP reply receive
 +	 */
 +	__be32			tcp_fraghdr,
 +				tcp_xid,
 +				tcp_calldir;
 +
 +	u32			tcp_offset,
 +				tcp_reclen;
 +
 +	unsigned long		tcp_copied,
 +				tcp_flags;
 +
 +	/*
 +	 * Connection of transports
 +	 */
 +	struct delayed_work	connect_worker;
 +	struct sockaddr_storage	srcaddr;
 +	unsigned short		srcport;
 +
 +	/*
 +	 * UDP socket buffer size parameters
 +	 */
 +	size_t			rcvsize,
 +				sndsize;
 +
 +	/*
 +	 * Saved socket callback addresses
 +	 */
 +	void			(*old_data_ready)(struct sock *, int);
 +	void			(*old_state_change)(struct sock *);
 +	void			(*old_write_space)(struct sock *);
 +	void			(*old_error_report)(struct sock *);
 +};
 +
 +/*
 + * TCP receive state flags
 + */
 +#define TCP_RCV_LAST_FRAG	(1UL << 0)
 +#define TCP_RCV_COPY_FRAGHDR	(1UL << 1)
 +#define TCP_RCV_COPY_XID	(1UL << 2)
 +#define TCP_RCV_COPY_DATA	(1UL << 3)
 +#define TCP_RCV_READ_CALLDIR	(1UL << 4)
 +#define TCP_RCV_COPY_CALLDIR	(1UL << 5)
 +
 +/*
 + * TCP RPC flags
 + */
 +#define TCP_RPC_REPLY		(1UL << 6)
 +
++=======
++>>>>>>> 1a867a0898b2 (sunrpc: add tracepoints in xs_tcp_data_recv)
  static inline struct rpc_xprt *xprt_from_sock(struct sock *sk)
  {
  	return (struct rpc_xprt *) sk->sk_user_data;
diff --git a/include/linux/sunrpc/xprtsock.h b/include/linux/sunrpc/xprtsock.h
index 1ad36cc25b2e..7591788e9fbf 100644
--- a/include/linux/sunrpc/xprtsock.h
+++ b/include/linux/sunrpc/xprtsock.h
@@ -17,6 +17,65 @@ void		cleanup_socket_xprt(void);
 #define RPC_DEF_MIN_RESVPORT	(665U)
 #define RPC_DEF_MAX_RESVPORT	(1023U)
 
+struct sock_xprt {
+	struct rpc_xprt		xprt;
+
+	/*
+	 * Network layer
+	 */
+	struct socket *		sock;
+	struct sock *		inet;
+
+	/*
+	 * State of TCP reply receive
+	 */
+	__be32			tcp_fraghdr,
+				tcp_xid,
+				tcp_calldir;
+
+	u32			tcp_offset,
+				tcp_reclen;
+
+	unsigned long		tcp_copied,
+				tcp_flags;
+
+	/*
+	 * Connection of transports
+	 */
+	struct delayed_work	connect_worker;
+	struct sockaddr_storage	srcaddr;
+	unsigned short		srcport;
+
+	/*
+	 * UDP socket buffer size parameters
+	 */
+	size_t			rcvsize,
+				sndsize;
+
+	/*
+	 * Saved socket callback addresses
+	 */
+	void			(*old_data_ready)(struct sock *);
+	void			(*old_state_change)(struct sock *);
+	void			(*old_write_space)(struct sock *);
+	void			(*old_error_report)(struct sock *);
+};
+
+/*
+ * TCP receive state flags
+ */
+#define TCP_RCV_LAST_FRAG	(1UL << 0)
+#define TCP_RCV_COPY_FRAGHDR	(1UL << 1)
+#define TCP_RCV_COPY_XID	(1UL << 2)
+#define TCP_RCV_COPY_DATA	(1UL << 3)
+#define TCP_RCV_READ_CALLDIR	(1UL << 4)
+#define TCP_RCV_COPY_CALLDIR	(1UL << 5)
+
+/*
+ * TCP RPC flags
+ */
+#define TCP_RPC_REPLY		(1UL << 6)
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SUNRPC_XPRTSOCK_H */
* Unmerged path include/trace/events/sunrpc.h
* Unmerged path net/sunrpc/xprtsock.c
