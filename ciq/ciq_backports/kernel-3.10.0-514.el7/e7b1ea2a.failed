ext2: huge page fault support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit e7b1ea2ad6581b83f63246db48aa2c2c9bf2ec8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e7b1ea2a.failed

Use DAX to provide support for huge pages.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Hillf Danton <dhillf@gmail.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Cc: Jan Kara <jack@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e7b1ea2ad6581b83f63246db48aa2c2c9bf2ec8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext2/file.c
diff --cc fs/ext2/file.c
index a5b3a5db3120,1982c3f11aec..000000000000
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@@ -25,6 -26,44 +25,47 @@@
  #include "xattr.h"
  #include "acl.h"
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_FS_DAX
+ static int ext2_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+ {
+ 	return dax_fault(vma, vmf, ext2_get_block, NULL);
+ }
+ 
+ static int ext2_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
+ 						pmd_t *pmd, unsigned int flags)
+ {
+ 	return dax_pmd_fault(vma, addr, pmd, flags, ext2_get_block, NULL);
+ }
+ 
+ static int ext2_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
+ {
+ 	return dax_mkwrite(vma, vmf, ext2_get_block, NULL);
+ }
+ 
+ static const struct vm_operations_struct ext2_dax_vm_ops = {
+ 	.fault		= ext2_dax_fault,
+ 	.pmd_fault	= ext2_dax_pmd_fault,
+ 	.page_mkwrite	= ext2_dax_mkwrite,
+ 	.pfn_mkwrite	= dax_pfn_mkwrite,
+ };
+ 
+ static int ext2_file_mmap(struct file *file, struct vm_area_struct *vma)
+ {
+ 	if (!IS_DAX(file_inode(file)))
+ 		return generic_file_mmap(file, vma);
+ 
+ 	file_accessed(file);
+ 	vma->vm_ops = &ext2_dax_vm_ops;
+ 	vma->vm_flags |= VM_MIXEDMAP | VM_HUGEPAGE;
+ 	return 0;
+ }
+ #else
+ #define ext2_file_mmap	generic_file_mmap
+ #endif
+ 
++>>>>>>> e7b1ea2ad658 (ext2: huge page fault support)
  /*
   * Called when filp is released. This happens when all file descriptors
   * for a single struct file are closed. Note that different open() calls
* Unmerged path fs/ext2/file.c
