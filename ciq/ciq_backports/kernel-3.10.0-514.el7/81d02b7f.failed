ipmi: Make some data const that was only read

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 81d02b7f8c507f06299476a0e5b2aa677c5eaecb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/81d02b7f.failed

Several data structures were only used for reading, so make them
const.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 81d02b7f8c507f06299476a0e5b2aa677c5eaecb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 3aeb84caf24d,4a4a13dc98b3..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -2742,9 -2634,145 +2745,149 @@@ static int ipmi_probe(struct platform_d
  		kfree(info);
  		return ret;
  	}
 +#endif
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ #else
+ #define of_ipmi_match NULL
+ static int of_ipmi_probe(struct platform_device *dev)
+ {
+ 	return -ENODEV;
+ }
+ #endif
+ 
+ #ifdef CONFIG_ACPI
+ static int acpi_ipmi_probe(struct platform_device *dev)
+ {
+ 	struct smi_info *info;
+ 	struct resource *res, *res_second;
+ 	acpi_handle handle;
+ 	acpi_status status;
+ 	unsigned long long tmp;
+ 	int rv = -EINVAL;
+ 
+ 	handle = ACPI_HANDLE(&dev->dev);
+ 	if (!handle)
+ 		return -ENODEV;
+ 
+ 	info = smi_info_alloc();
+ 	if (!info)
+ 		return -ENOMEM;
+ 
+ 	info->addr_source = SI_ACPI;
+ 	dev_info(&dev->dev, PFX "probing via ACPI\n");
+ 
+ 	info->addr_info.acpi_info.acpi_handle = handle;
+ 
+ 	/* _IFT tells us the interface type: KCS, BT, etc */
+ 	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(&dev->dev, "Could not find ACPI IPMI interface type\n");
+ 		goto err_free;
+ 	}
+ 
+ 	switch (tmp) {
+ 	case 1:
+ 		info->si_type = SI_KCS;
+ 		break;
+ 	case 2:
+ 		info->si_type = SI_SMIC;
+ 		break;
+ 	case 3:
+ 		info->si_type = SI_BT;
+ 		break;
+ 	case 4: /* SSIF, just ignore */
+ 		rv = -ENODEV;
+ 		goto err_free;
+ 	default:
+ 		dev_info(&dev->dev, "unknown IPMI type %lld\n", tmp);
+ 		goto err_free;
+ 	}
+ 
+ 	res = platform_get_resource(dev, IORESOURCE_IO, 0);
+ 	if (res) {
+ 		info->io_setup = port_setup;
+ 		info->io.addr_type = IPMI_IO_ADDR_SPACE;
+ 	} else {
+ 		res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+ 		if (res) {
+ 			info->io_setup = mem_setup;
+ 			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
+ 		}
+ 	}
+ 	if (!res) {
+ 		dev_err(&dev->dev, "no I/O or memory address\n");
+ 		goto err_free;
+ 	}
+ 	info->io.addr_data = res->start;
+ 
+ 	info->io.regspacing = DEFAULT_REGSPACING;
+ 	res_second = platform_get_resource(dev,
+ 			       (info->io.addr_type == IPMI_IO_ADDR_SPACE) ?
+ 					IORESOURCE_IO : IORESOURCE_MEM,
+ 			       1);
+ 	if (res_second) {
+ 		if (res_second->start > info->io.addr_data)
+ 			info->io.regspacing =
+ 				res_second->start - info->io.addr_data;
+ 	}
+ 	info->io.regsize = DEFAULT_REGSPACING;
+ 	info->io.regshift = 0;
+ 
+ 	/* If _GPE exists, use it; otherwise use standard interrupts */
+ 	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
+ 	if (ACPI_SUCCESS(status)) {
+ 		info->irq = tmp;
+ 		info->irq_setup = acpi_gpe_irq_setup;
+ 	} else {
+ 		int irq = platform_get_irq(dev, 0);
+ 
+ 		if (irq > 0) {
+ 			info->irq = irq;
+ 			info->irq_setup = std_irq_setup;
+ 		}
+ 	}
+ 
+ 	info->dev = &dev->dev;
+ 	platform_set_drvdata(dev, info);
+ 
+ 	dev_info(info->dev, "%pR regsize %d spacing %d irq %d\n",
+ 		 res, info->io.regsize, info->io.regspacing,
+ 		 info->irq);
+ 
+ 	rv = add_smi(info);
+ 	if (rv)
+ 		kfree(info);
+ 
+ 	return rv;
+ 
+ err_free:
+ 	kfree(info);
+ 	return rv;
+ }
+ 
+ static const struct acpi_device_id acpi_ipmi_match[] = {
+ 	{ "IPI0001", 0 },
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(acpi, acpi_ipmi_match);
+ #else
+ static int acpi_ipmi_probe(struct platform_device *dev)
+ {
+ 	return -ENODEV;
+ }
+ #endif
+ 
+ static int ipmi_probe(struct platform_device *dev)
+ {
+ 	if (of_ipmi_probe(dev) == 0)
+ 		return 0;
+ 
+ 	return acpi_ipmi_probe(dev);
+ }
++>>>>>>> 81d02b7f8c50 (ipmi: Make some data const that was only read)
  
  static int ipmi_remove(struct platform_device *dev)
  {
diff --git a/drivers/char/ipmi/ipmi_bt_sm.c b/drivers/char/ipmi/ipmi_bt_sm.c
index 61e71616689b..feafdab734ae 100644
--- a/drivers/char/ipmi/ipmi_bt_sm.c
+++ b/drivers/char/ipmi/ipmi_bt_sm.c
@@ -694,7 +694,7 @@ static int bt_size(void)
 	return sizeof(struct si_sm_data);
 }
 
-struct si_sm_handlers bt_smi_handlers = {
+const struct si_sm_handlers bt_smi_handlers = {
 	.init_data		= bt_init_data,
 	.start_transaction	= bt_start_transaction,
 	.get_result		= bt_get_result,
diff --git a/drivers/char/ipmi/ipmi_kcs_sm.c b/drivers/char/ipmi/ipmi_kcs_sm.c
index 8c25f596808a..1da61af7f576 100644
--- a/drivers/char/ipmi/ipmi_kcs_sm.c
+++ b/drivers/char/ipmi/ipmi_kcs_sm.c
@@ -540,7 +540,7 @@ static void kcs_cleanup(struct si_sm_data *kcs)
 {
 }
 
-struct si_sm_handlers kcs_smi_handlers = {
+const struct si_sm_handlers kcs_smi_handlers = {
 	.init_data         = init_kcs_data,
 	.start_transaction = start_kcs_transaction,
 	.get_result        = get_kcs_result,
diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index 3f4e4ac6b8be..5f0c356b2560 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -344,7 +344,7 @@ struct ipmi_smi {
 	 * an umpreemptible region to use this.  You must fetch the
 	 * value into a local variable and make sure it is not NULL.
 	 */
-	struct ipmi_smi_handlers *handlers;
+	const struct ipmi_smi_handlers *handlers;
 	void                     *send_info;
 
 #ifdef CONFIG_PROC_FS
@@ -1029,7 +1029,7 @@ int ipmi_get_smi_info(int if_num, struct ipmi_smi_info *data)
 {
 	int           rv = 0;
 	ipmi_smi_t    intf;
-	struct ipmi_smi_handlers *handlers;
+	const struct ipmi_smi_handlers *handlers;
 
 	mutex_lock(&ipmi_interfaces_mutex);
 	list_for_each_entry_rcu(intf, &ipmi_interfaces, link) {
@@ -1517,7 +1517,7 @@ static struct ipmi_smi_msg *smi_add_send_msg(ipmi_smi_t intf,
 }
 
 
-static void smi_send(ipmi_smi_t intf, struct ipmi_smi_handlers *handlers,
+static void smi_send(ipmi_smi_t intf, const struct ipmi_smi_handlers *handlers,
 		     struct ipmi_smi_msg *smi_msg, int priority)
 {
 	int run_to_completion = intf->run_to_completion;
@@ -2764,7 +2764,7 @@ void ipmi_poll_interface(ipmi_user_t user)
 }
 EXPORT_SYMBOL(ipmi_poll_interface);
 
-int ipmi_register_smi(struct ipmi_smi_handlers *handlers,
+int ipmi_register_smi(const struct ipmi_smi_handlers *handlers,
 		      void		       *send_info,
 		      struct ipmi_device_id    *device_id,
 		      struct device            *si_dev,
@@ -4033,7 +4033,7 @@ static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,
 			      unsigned int *waiting_msgs)
 {
 	struct ipmi_recv_msg     *msg;
-	struct ipmi_smi_handlers *handlers;
+	const struct ipmi_smi_handlers *handlers;
 
 	if (intf->in_shutdown)
 		return;
@@ -4100,7 +4100,7 @@ static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,
 				ipmi_inc_stat(intf,
 					      retransmitted_ipmb_commands);
 
-			smi_send(intf, intf->handlers, smi_msg, 0);
+			smi_send(intf, handlers, smi_msg, 0);
 		} else
 			ipmi_free_smi_msg(smi_msg);
 
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
diff --git a/drivers/char/ipmi/ipmi_si_sm.h b/drivers/char/ipmi/ipmi_si_sm.h
index df89f73475fb..a705027c0493 100644
--- a/drivers/char/ipmi/ipmi_si_sm.h
+++ b/drivers/char/ipmi/ipmi_si_sm.h
@@ -46,8 +46,8 @@ struct si_sm_data;
  * this interface.
  */
 struct si_sm_io {
-	unsigned char (*inputb)(struct si_sm_io *io, unsigned int offset);
-	void (*outputb)(struct si_sm_io *io,
+	unsigned char (*inputb)(const struct si_sm_io *io, unsigned int offset);
+	void (*outputb)(const struct si_sm_io *io,
 			unsigned int  offset,
 			unsigned char b);
 
@@ -135,7 +135,7 @@ struct si_sm_handlers {
 };
 
 /* Current state machines that we can use. */
-extern struct si_sm_handlers kcs_smi_handlers;
-extern struct si_sm_handlers smic_smi_handlers;
-extern struct si_sm_handlers bt_smi_handlers;
+extern const struct si_sm_handlers kcs_smi_handlers;
+extern const struct si_sm_handlers smic_smi_handlers;
+extern const struct si_sm_handlers bt_smi_handlers;
 
diff --git a/drivers/char/ipmi/ipmi_smic_sm.c b/drivers/char/ipmi/ipmi_smic_sm.c
index c8e77afa8b96..8f7c73ff58f2 100644
--- a/drivers/char/ipmi/ipmi_smic_sm.c
+++ b/drivers/char/ipmi/ipmi_smic_sm.c
@@ -589,7 +589,7 @@ static int smic_size(void)
 	return sizeof(struct si_sm_data);
 }
 
-struct si_sm_handlers smic_smi_handlers = {
+const struct si_sm_handlers smic_smi_handlers = {
 	.init_data         = init_smic_data,
 	.start_transaction = start_smic_transaction,
 	.get_result        = smic_get_result,
diff --git a/include/linux/ipmi_smi.h b/include/linux/ipmi_smi.h
index 24b9643f267d..099b59c64f9d 100644
--- a/include/linux/ipmi_smi.h
+++ b/include/linux/ipmi_smi.h
@@ -227,7 +227,7 @@ static inline int ipmi_demangle_device_id(const unsigned char *data,
    upper layer until the start_processing() function in the handlers
    is called, and the lower layer must get the interface from that
    call. */
-int ipmi_register_smi(struct ipmi_smi_handlers *handlers,
+int ipmi_register_smi(const struct ipmi_smi_handlers *handlers,
 		      void                     *send_info,
 		      struct ipmi_device_id    *device_id,
 		      struct device            *dev,
