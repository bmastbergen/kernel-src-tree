GFS2: Extract quota data from reservations structure (revert 5407e24)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit b54e9a0b92d44843f6719ae22b0f6daf5b9b23b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b54e9a0b.failed

This patch basically reverts the majority of patch 5407e24.
That patch eliminated the gfs2_qadata structure in favor of just
using the reservations structure. The problem with doing that is that
it increases the size of the reservations structure. That is not an
issue until it comes time to fold the reservations structure into the
inode in memory so we know it's always there. By separating out the
quota structure again, we aren't punishing the non-quota users by
making all the inodes bigger, requiring more slab space. This patch
creates a new slab area to allocate the quota stuff so it's managed
a little more sanely.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit b54e9a0b92d44843f6719ae22b0f6daf5b9b23b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
#	fs/gfs2/file.c
#	fs/gfs2/incore.h
#	fs/gfs2/inode.c
#	fs/gfs2/rgrp.c
#	fs/gfs2/rgrp.h
#	fs/gfs2/super.c
diff --cc fs/gfs2/bmap.c
index c9e860161c6f,8d46ae4fa873..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -1296,7 -1297,7 +1296,11 @@@ int gfs2_setattr_size(struct inode *ino
  
  	inode_dio_wait(inode);
  
++<<<<<<< HEAD
 +	ret = gfs2_rs_alloc(GFS2_I(inode));
++=======
+ 	ret = gfs2_rsqa_alloc(ip);
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  	if (ret)
  		goto out;
  
diff --cc fs/gfs2/file.c
index 96a7ba9500e8,de001eb27bed..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -631,7 -623,7 +631,11 @@@ static int gfs2_release(struct inode *i
  	if (!(file->f_mode & FMODE_WRITE))
  		return 0;
  
++<<<<<<< HEAD
 +	gfs2_rs_delete(ip);
++=======
+ 	gfs2_rsqa_delete(ip, &inode->i_writecount);
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  	return 0;
  }
  
diff --cc fs/gfs2/incore.h
index 2caf75dc0244,6a22f66f058d..000000000000
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@@ -257,6 -267,16 +257,19 @@@ struct gfs2_holder 
  	unsigned long gh_ip;
  };
  
++<<<<<<< HEAD
++=======
+ /* Number of quota types we support */
+ #define GFS2_MAXQUOTAS 2
+ 
+ struct gfs2_qadata { /* quota allocation data */
+ 	/* Quota stuff */
+ 	struct gfs2_quota_data *qa_qd[2 * GFS2_MAXQUOTAS];
+ 	struct gfs2_holder qa_qd_ghs[2 * GFS2_MAXQUOTAS];
+ 	unsigned int qa_qd_num;
+ };
+ 
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  /* Resource group multi-block reservation, in order of appearance:
  
     Step 1. Function prepares to write, allocates a mb, sets the size hint.
@@@ -275,11 -295,6 +288,14 @@@ struct gfs2_blkreserv 
  	struct gfs2_rbm rs_rbm;       /* Start of reservation */
  	u32 rs_free;                  /* how many blocks are still free */
  	u64 rs_inum;                  /* Inode number for reservation */
++<<<<<<< HEAD
 +
 +	/* ancillary quota stuff */
 +	struct gfs2_quota_data *rs_qa_qd[2 * MAXQUOTAS];
 +	struct gfs2_holder rs_qa_qd_ghs[2 * MAXQUOTAS];
 +	unsigned int rs_qa_qd_num;
++=======
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  };
  
  /*
diff --cc fs/gfs2/inode.c
index 4b5ce5a448da,c37e6bf2958e..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -617,10 -648,14 +617,10 @@@ static int gfs2_create_inode(struct ino
  	if (!inode)
  		goto fail_gunlock;
  
 -	error = posix_acl_create(dir, &mode, &default_acl, &acl);
 -	if (error)
 -		goto fail_free_vfs_inode;
 -
  	ip = GFS2_I(inode);
- 	error = gfs2_rs_alloc(ip);
+ 	error = gfs2_rsqa_alloc(ip);
  	if (error)
 -		goto fail_free_acls;
 +		goto fail_free_inode;
  
  	inode->i_mode = mode;
  	set_nlink(inode, S_ISDIR(mode) ? 2 : 1);
@@@ -722,9 -781,16 +722,19 @@@ fail_gunlock2
  fail_free_inode:
  	if (ip->i_gl)
  		gfs2_glock_put(ip->i_gl);
++<<<<<<< HEAD
 +	gfs2_rs_delete(ip);
++=======
+ 	gfs2_rsqa_delete(ip, NULL);
+ fail_free_acls:
+ 	if (default_acl)
+ 		posix_acl_release(default_acl);
+ 	if (acl)
+ 		posix_acl_release(acl);
+ fail_free_vfs_inode:
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  	free_vfs_inode = 1;
  fail_gunlock:
 -	gfs2_dir_no_add(&da);
  	gfs2_glock_dq_uninit(ghs);
  	if (inode && !IS_ERR(inode)) {
  		clear_nlink(inode);
diff --cc fs/gfs2/rgrp.c
index 28da34fba03d,cb30748e7b19..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -650,16 -685,15 +657,20 @@@ void gfs2_rs_deltree(struct gfs2_blkres
  }
  
  /**
-  * gfs2_rs_delete - delete a multi-block reservation
+  * gfs2_rsqa_delete - delete a multi-block reservation and quota allocation
   * @ip: The inode for this reservation
 - * @wcount: The inode's write count, or NULL
   *
   */
++<<<<<<< HEAD
 +void gfs2_rs_delete(struct gfs2_inode *ip)
++=======
+ void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount)
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  {
 +	struct inode *inode = &ip->i_inode;
 +
  	down_write(&ip->i_rw_mutex);
 -	if (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {
 +	if (ip->i_res && atomic_read(&inode->i_writecount) <= 1) {
  		gfs2_rs_deltree(ip->i_res);
  		BUG_ON(ip->i_res->rs_free);
  		kmem_cache_free(gfs2_rsrv_cachep, ip->i_res);
diff --cc fs/gfs2/rgrp.h
index c4023545919a,06bbefaabc31..000000000000
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@@ -49,9 -49,9 +49,13 @@@ extern void gfs2_inplace_release(struc
  extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
  			     bool dinode, u64 *generation);
  
- extern int gfs2_rs_alloc(struct gfs2_inode *ip);
+ extern int gfs2_rsqa_alloc(struct gfs2_inode *ip);
  extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
++<<<<<<< HEAD
 +extern void gfs2_rs_delete(struct gfs2_inode *ip);
++=======
+ extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
  extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
  extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
diff --cc fs/gfs2/super.c
index 7c8f12885717,b030ca223067..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1564,7 -1607,7 +1564,11 @@@ out_unlock
  out:
  	/* Case 3 starts here */
  	truncate_inode_pages_final(&inode->i_data);
++<<<<<<< HEAD
 +	gfs2_rs_delete(ip);
++=======
+ 	gfs2_rsqa_delete(ip, NULL);
++>>>>>>> b54e9a0b92d4 (GFS2: Extract quota data from reservations structure (revert 5407e24))
  	gfs2_ordered_del_inode(ip);
  	clear_inode(inode);
  	gfs2_dir_hash_inval(ip);
diff --git a/fs/gfs2/aops.c b/fs/gfs2/aops.c
index fda3e9513f0b..bf2c51a97d09 100644
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@ -938,7 +938,7 @@ static int gfs2_write_end(struct file *file, struct address_space *mapping,
 failed:
 	gfs2_trans_end(sdp);
 	gfs2_inplace_release(ip);
-	if (ip->i_res->rs_qa_qd_num)
+	if (ip->i_qadata && ip->i_qadata->qa_qd_num)
 		gfs2_quota_unlock(ip);
 	if (inode == sdp->sd_rindex) {
 		gfs2_glock_dq(&m_ip->i_gh);
* Unmerged path fs/gfs2/bmap.c
* Unmerged path fs/gfs2/file.c
* Unmerged path fs/gfs2/incore.h
* Unmerged path fs/gfs2/inode.c
diff --git a/fs/gfs2/main.c b/fs/gfs2/main.c
index 8bc711b547e8..3e55d5c11c59 100644
--- a/fs/gfs2/main.c
+++ b/fs/gfs2/main.c
@@ -38,6 +38,7 @@ static void gfs2_init_inode_once(void *foo)
 	inode_init_once(&ip->i_inode);
 	init_rwsem(&ip->i_rw_mutex);
 	INIT_LIST_HEAD(&ip->i_trunc_list);
+	ip->i_qadata = NULL;
 	ip->i_res = NULL;
 	ip->i_hash_cache = NULL;
 }
@@ -132,6 +133,12 @@ static int __init init_gfs2_fs(void)
 	if (!gfs2_quotad_cachep)
 		goto fail;
 
+	gfs2_qadata_cachep = kmem_cache_create("gfs2_qadata",
+					       sizeof(struct gfs2_qadata),
+					       0, 0, NULL);
+	if (!gfs2_qadata_cachep)
+		goto fail;
+
 	gfs2_rsrv_cachep = kmem_cache_create("gfs2_mblk",
 					     sizeof(struct gfs2_blkreserv),
 					       0, 0, NULL);
@@ -186,6 +193,9 @@ fail_lru:
 	if (gfs2_rsrv_cachep)
 		kmem_cache_destroy(gfs2_rsrv_cachep);
 
+	if (gfs2_qadata_cachep)
+		kmem_cache_destroy(gfs2_qadata_cachep);
+
 	if (gfs2_quotad_cachep)
 		kmem_cache_destroy(gfs2_quotad_cachep);
 
@@ -228,6 +238,7 @@ static void __exit exit_gfs2_fs(void)
 
 	mempool_destroy(gfs2_page_pool);
 	kmem_cache_destroy(gfs2_rsrv_cachep);
+	kmem_cache_destroy(gfs2_qadata_cachep);
 	kmem_cache_destroy(gfs2_quotad_cachep);
 	kmem_cache_destroy(gfs2_rgrpd_cachep);
 	kmem_cache_destroy(gfs2_bufdata_cachep);
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index 481208bbcaf7..b2797d227263 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -515,37 +515,70 @@ static void qdsb_put(struct gfs2_quota_data *qd)
 	qd_put(qd);
 }
 
+/**
+ * gfs2_qa_alloc - make sure we have a quota allocations data structure,
+ *                 if necessary
+ * @ip: the inode for this reservation
+ */
+int gfs2_qa_alloc(struct gfs2_inode *ip)
+{
+	int error = 0;
+	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
+
+	if (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)
+		return 0;
+
+	down_write(&ip->i_rw_mutex);
+	if (ip->i_qadata == NULL) {
+		ip->i_qadata = kmem_cache_zalloc(gfs2_qadata_cachep, GFP_NOFS);
+		if (!ip->i_qadata)
+			error = -ENOMEM;
+	}
+	up_write(&ip->i_rw_mutex);
+	return error;
+}
+
+void gfs2_qa_delete(struct gfs2_inode *ip)
+{
+	down_write(&ip->i_rw_mutex);
+	if (ip->i_qadata) {
+		kmem_cache_free(gfs2_qadata_cachep, ip->i_qadata);
+		ip->i_qadata = NULL;
+	}
+	up_write(&ip->i_rw_mutex);
+}
+
 int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	struct gfs2_quota_data **qd;
 	int error;
 
-	if (ip->i_res == NULL) {
-		error = gfs2_rs_alloc(ip);
+	if (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)
+		return 0;
+
+	if (ip->i_qadata == NULL) {
+		error = gfs2_rsqa_alloc(ip);
 		if (error)
 			return error;
 	}
 
-	qd = ip->i_res->rs_qa_qd;
+	qd = ip->i_qadata->qa_qd;
 
-	if (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||
+	if (gfs2_assert_warn(sdp, !ip->i_qadata->qa_qd_num) ||
 	    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))
 		return -EIO;
 
-	if (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)
-		return 0;
-
 	error = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);
 	if (error)
 		goto out;
-	ip->i_res->rs_qa_qd_num++;
+	ip->i_qadata->qa_qd_num++;
 	qd++;
 
 	error = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);
 	if (error)
 		goto out;
-	ip->i_res->rs_qa_qd_num++;
+	ip->i_qadata->qa_qd_num++;
 	qd++;
 
 	if (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&
@@ -553,7 +586,7 @@ int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)
 		error = qdsb_get(sdp, make_kqid_uid(uid), qd);
 		if (error)
 			goto out;
-		ip->i_res->rs_qa_qd_num++;
+		ip->i_qadata->qa_qd_num++;
 		qd++;
 	}
 
@@ -562,7 +595,7 @@ int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)
 		error = qdsb_get(sdp, make_kqid_gid(gid), qd);
 		if (error)
 			goto out;
-		ip->i_res->rs_qa_qd_num++;
+		ip->i_qadata->qa_qd_num++;
 		qd++;
 	}
 
@@ -577,15 +610,15 @@ void gfs2_quota_unhold(struct gfs2_inode *ip)
 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	unsigned int x;
 
-	if (ip->i_res == NULL)
+	if (ip->i_qadata == NULL)
 		return;
 	gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));
 
-	for (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {
-		qdsb_put(ip->i_res->rs_qa_qd[x]);
-		ip->i_res->rs_qa_qd[x] = NULL;
+	for (x = 0; x < ip->i_qadata->qa_qd_num; x++) {
+		qdsb_put(ip->i_qadata->qa_qd[x]);
+		ip->i_qadata->qa_qd[x] = NULL;
 	}
-	ip->i_res->rs_qa_qd_num = 0;
+	ip->i_qadata->qa_qd_num = 0;
 }
 
 static int sort_qd(const void *a, const void *b)
@@ -834,7 +867,7 @@ static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)
 	unsigned int nalloc = 0, blocks;
 	int error;
 
-	error = gfs2_rs_alloc(ip);
+	error = gfs2_rsqa_alloc(ip);
 	if (error)
 		return error;
 
@@ -997,20 +1030,20 @@ int gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)
 	unsigned int x;
 	int error = 0;
 
-	error = gfs2_quota_hold(ip, uid, gid);
-	if (error)
-		return error;
-
 	if (capable(CAP_SYS_RESOURCE) ||
 	    sdp->sd_args.ar_quota != GFS2_QUOTA_ON)
 		return 0;
 
-	sort(ip->i_res->rs_qa_qd, ip->i_res->rs_qa_qd_num,
+	error = gfs2_quota_hold(ip, uid, gid);
+	if (error)
+		return error;
+
+	sort(ip->i_qadata->qa_qd, ip->i_qadata->qa_qd_num,
 	     sizeof(struct gfs2_quota_data *), sort_qd, NULL);
 
-	for (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {
-		qd = ip->i_res->rs_qa_qd[x];
-		error = do_glock(qd, NO_FORCE, &ip->i_res->rs_qa_qd_ghs[x]);
+	for (x = 0; x < ip->i_qadata->qa_qd_num; x++) {
+		qd = ip->i_qadata->qa_qd[x];
+		error = do_glock(qd, NO_FORCE, &ip->i_qadata->qa_qd_ghs[x]);
 		if (error)
 			break;
 	}
@@ -1019,7 +1052,7 @@ int gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)
 		set_bit(GIF_QD_LOCKED, &ip->i_flags);
 	else {
 		while (x--)
-			gfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);
+			gfs2_glock_dq_uninit(&ip->i_qadata->qa_qd_ghs[x]);
 		gfs2_quota_unhold(ip);
 	}
 
@@ -1073,14 +1106,14 @@ void gfs2_quota_unlock(struct gfs2_inode *ip)
 	if (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))
 		goto out;
 
-	for (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {
+	for (x = 0; x < ip->i_qadata->qa_qd_num; x++) {
 		struct gfs2_quota_data *qd;
 		int sync;
 
-		qd = ip->i_res->rs_qa_qd[x];
+		qd = ip->i_qadata->qa_qd[x];
 		sync = need_sync(qd);
 
-		gfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);
+		gfs2_glock_dq_uninit(&ip->i_qadata->qa_qd_ghs[x]);
 		if (!sync)
 			continue;
 
@@ -1159,8 +1192,8 @@ int gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid,
         if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)
                 return 0;
 
-	for (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {
-		qd = ip->i_res->rs_qa_qd[x];
+	for (x = 0; x < ip->i_qadata->qa_qd_num; x++) {
+		qd = ip->i_qadata->qa_qd[x];
 
 		if (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||
 		      qid_eq(qd->qd_id, make_kqid_gid(gid))))
@@ -1208,14 +1241,16 @@ void gfs2_quota_change(struct gfs2_inode *ip, s64 change,
 {
 	struct gfs2_quota_data *qd;
 	unsigned int x;
+	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 
-	if (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))
+	if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON ||
+	    gfs2_assert_warn(sdp, change))
 		return;
 	if (ip->i_diskflags & GFS2_DIF_SYSTEM)
 		return;
 
-	for (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {
-		qd = ip->i_res->rs_qa_qd[x];
+	for (x = 0; x < ip->i_qadata->qa_qd_num; x++) {
+		qd = ip->i_qadata->qa_qd[x];
 
 		if (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||
 		    qid_eq(qd->qd_id, make_kqid_gid(gid))) {
@@ -1637,7 +1672,7 @@ static int gfs2_set_dqblk(struct super_block *sb, struct kqid qid,
 	if (error)
 		return error;
 
-	error = gfs2_rs_alloc(ip);
+	error = gfs2_rsqa_alloc(ip);
 	if (error)
 		goto out_put;
 
diff --git a/fs/gfs2/quota.h b/fs/gfs2/quota.h
index ad04b3acae2b..1940dd9cb1c7 100644
--- a/fs/gfs2/quota.h
+++ b/fs/gfs2/quota.h
@@ -18,6 +18,8 @@ struct gfs2_sbd;
 #define NO_UID_QUOTA_CHANGE INVALID_UID
 #define NO_GID_QUOTA_CHANGE INVALID_GID
 
+extern int gfs2_qa_alloc(struct gfs2_inode *ip);
+extern void gfs2_qa_delete(struct gfs2_inode *ip);
 extern int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid);
 extern void gfs2_quota_unhold(struct gfs2_inode *ip);
 
* Unmerged path fs/gfs2/rgrp.c
* Unmerged path fs/gfs2/rgrp.h
* Unmerged path fs/gfs2/super.c
diff --git a/fs/gfs2/util.c b/fs/gfs2/util.c
index cdacc01e25b8..a439267ba126 100644
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@ -25,6 +25,7 @@ struct kmem_cache *gfs2_inode_cachep __read_mostly;
 struct kmem_cache *gfs2_bufdata_cachep __read_mostly;
 struct kmem_cache *gfs2_rgrpd_cachep __read_mostly;
 struct kmem_cache *gfs2_quotad_cachep __read_mostly;
+struct kmem_cache *gfs2_qadata_cachep __read_mostly;
 struct kmem_cache *gfs2_rsrv_cachep __read_mostly;
 mempool_t *gfs2_page_pool __read_mostly;
 
diff --git a/fs/gfs2/util.h b/fs/gfs2/util.h
index b7ffb09b99ea..c3425ba7237a 100644
--- a/fs/gfs2/util.h
+++ b/fs/gfs2/util.h
@@ -148,6 +148,7 @@ extern struct kmem_cache *gfs2_inode_cachep;
 extern struct kmem_cache *gfs2_bufdata_cachep;
 extern struct kmem_cache *gfs2_rgrpd_cachep;
 extern struct kmem_cache *gfs2_quotad_cachep;
+extern struct kmem_cache *gfs2_qadata_cachep;
 extern struct kmem_cache *gfs2_rsrv_cachep;
 extern mempool_t *gfs2_page_pool;
 
