ixgbe: use msleep for long delays

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit d4f90d9dca26efef7a1112a8f4258c90b73bb37f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d4f90d9d.failed

The newly added x550em_a support causes a link failure on ARM because of
an overly long time passed into udelay():

ERROR: "__bad_udelay" [drivers/net/ethernet/intel/ixgbe/ixgbe.ko] undefined!

There are multiple variants of the ixgbe_acquire_swfw_sync_*() function,
and the other ones all use msleep(), so we can safely assume that all
callers are allowed to sleep, which makes msleep() a better replacement
than mdelay().

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Fixes: 49425dfc7451 ("ixgbe: Add support for x550em_a 10G MAC type")
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit d4f90d9dca26efef7a1112a8f4258c90b73bb37f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
index 98d6e51de236,19b75cd98682..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
@@@ -2417,6 -2736,110 +2417,113 @@@ static void ixgbe_release_swfw_sync_X55
  	ixgbe_release_swfw_sync_X540(hw, mask);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ixgbe_acquire_swfw_sync_x550em_a - Acquire SWFW semaphore
+  * @hw: pointer to hardware structure
+  * @mask: Mask to specify which semaphore to acquire
+  *
+  * Acquires the SWFW semaphore and get the shared PHY token as needed
+  */
+ static s32 ixgbe_acquire_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
+ {
+ 	u32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;
+ 	int retries = FW_PHY_TOKEN_RETRIES;
+ 	s32 status;
+ 
+ 	while (--retries) {
+ 		status = 0;
+ 		if (hmask)
+ 			status = ixgbe_acquire_swfw_sync_X540(hw, hmask);
+ 		if (status)
+ 			return status;
+ 		if (!(mask & IXGBE_GSSR_TOKEN_SM))
+ 			return 0;
+ 
+ 		status = ixgbe_get_phy_token(hw);
+ 		if (!status)
+ 			return 0;
+ 		if (hmask)
+ 			ixgbe_release_swfw_sync_X540(hw, hmask);
+ 		if (status != IXGBE_ERR_TOKEN_RETRY)
+ 			return status;
+ 		msleep(FW_PHY_TOKEN_DELAY);
+ 	}
+ 
+ 	return status;
+ }
+ 
+ /**
+  * ixgbe_release_swfw_sync_x550em_a - Release SWFW semaphore
+  * @hw: pointer to hardware structure
+  * @mask: Mask to specify which semaphore to release
+  *
+  * Release the SWFW semaphore and puts the shared PHY token as needed
+  */
+ static void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
+ {
+ 	u32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;
+ 
+ 	if (mask & IXGBE_GSSR_TOKEN_SM)
+ 		ixgbe_put_phy_token(hw);
+ 
+ 	if (hmask)
+ 		ixgbe_release_swfw_sync_X540(hw, hmask);
+ }
+ 
+ /**
+  * ixgbe_read_phy_reg_x550a - Reads specified PHY register
+  * @hw: pointer to hardware structure
+  * @reg_addr: 32 bit address of PHY register to read
+  * @phy_data: Pointer to read data from PHY register
+  *
+  * Reads a value from a specified PHY register using the SWFW lock and PHY
+  * Token. The PHY Token is needed since the MDIO is shared between to MAC
+  * instances.
+  */
+ static s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+ 				    u32 device_type, u16 *phy_data)
+ {
+ 	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
+ 	s32 status;
+ 
+ 	if (hw->mac.ops.acquire_swfw_sync(hw, mask))
+ 		return IXGBE_ERR_SWFW_SYNC;
+ 
+ 	status = hw->phy.ops.read_reg_mdi(hw, reg_addr, device_type, phy_data);
+ 
+ 	hw->mac.ops.release_swfw_sync(hw, mask);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * ixgbe_write_phy_reg_x550a - Writes specified PHY register
+  * @hw: pointer to hardware structure
+  * @reg_addr: 32 bit PHY register to write
+  * @device_type: 5 bit device type
+  * @phy_data: Data to write to the PHY register
+  *
+  * Writes a value to specified PHY register using the SWFW lock and PHY Token.
+  * The PHY Token is needed since the MDIO is shared between to MAC instances.
+  */
+ static s32 ixgbe_write_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+ 				     u32 device_type, u16 phy_data)
+ {
+ 	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
+ 	s32 status;
+ 
+ 	if (hw->mac.ops.acquire_swfw_sync(hw, mask))
+ 		return IXGBE_ERR_SWFW_SYNC;
+ 
+ 	status = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type, phy_data);
+ 	hw->mac.ops.release_swfw_sync(hw, mask);
+ 
+ 	return status;
+ }
+ 
++>>>>>>> d4f90d9dca26 (ixgbe: use msleep for long delays)
  #define X550_COMMON_MAC \
  	.init_hw			= &ixgbe_init_hw_generic, \
  	.start_hw			= &ixgbe_start_hw_X540, \
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
