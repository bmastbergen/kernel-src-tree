x86/topology: Fix Intel HT disable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] topology: Fix Intel HT disable (Jiri Olsa) [1337866]
Rebuild_FUZZ: 93.75%
commit-author Peter Zijlstra <peterz@infradead.org>
commit 63d1e995be455ae9196270eb4b789de21afd42ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/63d1e995.failed

As per the comment in the code; due to BIOS it is sometimes impossible to know
if there actually are smp siblings until the machine is fully enumerated. So
we rather overestimate the number of possible packages.

Fixes: 1f12e32f4cd5 ("x86/topology: Create logical package id")
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: aherrmann@suse.com
	Cc: jencce.kernel@gmail.com
	Cc: bp@alien8.de
	Cc: Mike Galbraith <umgwanakikbuti@gmail.com>
Link: http://lkml.kernel.org/r/20160318150538.611014173@infradead.org
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 63d1e995be455ae9196270eb4b789de21afd42ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/smpboot.c
diff --cc arch/x86/kernel/smpboot.c
index 7dbc496614e0,81e6a432f23c..000000000000
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@@ -233,7 -256,106 +233,110 @@@ static void notrace start_secondary(voi
  	x86_cpuinit.setup_percpu_clockev();
  
  	wmb();
++<<<<<<< HEAD
 +	cpu_startup_entry(CPUHP_ONLINE);
++=======
+ 	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);
+ }
+ 
+ int topology_update_package_map(unsigned int apicid, unsigned int cpu)
+ {
+ 	unsigned int new, pkg = apicid >> boot_cpu_data.x86_coreid_bits;
+ 
+ 	/* Called from early boot ? */
+ 	if (!physical_package_map)
+ 		return 0;
+ 
+ 	if (pkg >= max_physical_pkg_id)
+ 		return -EINVAL;
+ 
+ 	/* Set the logical package id */
+ 	if (test_and_set_bit(pkg, physical_package_map))
+ 		goto found;
+ 
+ 	new = find_first_zero_bit(logical_package_map, __max_logical_packages);
+ 	if (new >= __max_logical_packages) {
+ 		physical_to_logical_pkg[pkg] = -1;
+ 		pr_warn("APIC(%x) Package %u exceeds logical package map\n",
+ 			apicid, pkg);
+ 		return -ENOSPC;
+ 	}
+ 	set_bit(new, logical_package_map);
+ 	pr_info("APIC(%x) Converting physical %u to logical package %u\n",
+ 		apicid, pkg, new);
+ 	physical_to_logical_pkg[pkg] = new;
+ 
+ found:
+ 	cpu_data(cpu).logical_proc_id = physical_to_logical_pkg[pkg];
+ 	return 0;
+ }
+ 
+ /**
+  * topology_phys_to_logical_pkg - Map a physical package id to a logical
+  *
+  * Returns logical package id or -1 if not found
+  */
+ int topology_phys_to_logical_pkg(unsigned int phys_pkg)
+ {
+ 	if (phys_pkg >= max_physical_pkg_id)
+ 		return -1;
+ 	return physical_to_logical_pkg[phys_pkg];
+ }
+ EXPORT_SYMBOL(topology_phys_to_logical_pkg);
+ 
+ static void __init smp_init_package_map(void)
+ {
+ 	unsigned int ncpus, cpu;
+ 	size_t size;
+ 
+ 	/*
+ 	 * Today neither Intel nor AMD support heterogenous systems. That
+ 	 * might change in the future....
+ 	 *
+ 	 * While ideally we'd want '* smp_num_siblings' in the below @ncpus
+ 	 * computation, this won't actually work since some Intel BIOSes
+ 	 * report inconsistent HT data when they disable HT.
+ 	 *
+ 	 * In particular, they reduce the APIC-IDs to only include the cores,
+ 	 * but leave the CPUID topology to say there are (2) siblings.
+ 	 * This means we don't know how many threads there will be until
+ 	 * after the APIC enumeration.
+ 	 *
+ 	 * By not including this we'll sometimes over-estimate the number of
+ 	 * logical packages by the amount of !present siblings, but this is
+ 	 * still better than MAX_LOCAL_APIC.
+ 	 */
+ 	ncpus = boot_cpu_data.x86_max_cores;
+ 	__max_logical_packages = DIV_ROUND_UP(nr_cpu_ids, ncpus);
+ 
+ 	/*
+ 	 * Possibly larger than what we need as the number of apic ids per
+ 	 * package can be smaller than the actual used apic ids.
+ 	 */
+ 	max_physical_pkg_id = DIV_ROUND_UP(MAX_LOCAL_APIC, ncpus);
+ 	size = max_physical_pkg_id * sizeof(unsigned int);
+ 	physical_to_logical_pkg = kmalloc(size, GFP_KERNEL);
+ 	memset(physical_to_logical_pkg, 0xff, size);
+ 	size = BITS_TO_LONGS(max_physical_pkg_id) * sizeof(unsigned long);
+ 	physical_package_map = kzalloc(size, GFP_KERNEL);
+ 	size = BITS_TO_LONGS(__max_logical_packages) * sizeof(unsigned long);
+ 	logical_package_map = kzalloc(size, GFP_KERNEL);
+ 
+ 	pr_info("Max logical packages: %u\n", __max_logical_packages);
+ 
+ 	for_each_present_cpu(cpu) {
+ 		unsigned int apicid = apic->cpu_present_to_apicid(cpu);
+ 
+ 		if (apicid == BAD_APICID || !apic->apic_id_valid(apicid))
+ 			continue;
+ 		if (!topology_update_package_map(apicid, cpu))
+ 			continue;
+ 		pr_warn("CPU %u APICId %x disabled\n", cpu, apicid);
+ 		per_cpu(x86_bios_cpu_apicid, cpu) = BAD_APICID;
+ 		set_cpu_possible(cpu, false);
+ 		set_cpu_present(cpu, false);
+ 	}
++>>>>>>> 63d1e995be45 (x86/topology: Fix Intel HT disable)
  }
  
  void __init smp_store_boot_cpu_info(void)
* Unmerged path arch/x86/kernel/smpboot.c
