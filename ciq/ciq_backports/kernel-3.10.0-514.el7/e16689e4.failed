IB/rdmavt: Add trace and error print statements in post_one_wr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Harish Chegondi <harish.chegondi@intel.com>
commit e16689e49216d08336da2d96cbc8c4b6b914dc99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e16689e4.failed

These trace and error print statements would help in debugging issues which
are caused due to messed up QP ring buffer pointers.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e16689e49216d08336da2d96cbc8c4b6b914dc99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rdmavt/qp.c
diff --cc drivers/infiniband/sw/rdmavt/qp.c
index e8d0da89ea8e,d629911ab0ab..000000000000
--- a/drivers/infiniband/sw/rdmavt/qp.c
+++ b/drivers/infiniband/sw/rdmavt/qp.c
@@@ -1394,7 -1438,18 +1394,22 @@@ static int rvt_post_one_wr(struct rvt_q
  	} else if (wr->opcode >= IB_WR_RDMA_READ && !qp->s_max_rd_atomic) {
  		return -EINVAL;
  	}
- 
++<<<<<<< HEAD
++
++=======
+ 	/* check for avail */
+ 	if (unlikely(!qp->s_avail)) {
+ 		qp->s_avail = qp_get_savail(qp);
+ 		if (WARN_ON(qp->s_avail > (qp->s_size - 1)))
+ 			rvt_pr_err(rdi,
+ 				   "More avail entries than QP RB size.\nQP: %u, size: %u, avail: %u\nhead: %u, tail: %u, cur: %u, acked: %u, last: %u",
+ 				   qp->ibqp.qp_num, qp->s_size, qp->s_avail,
+ 				   qp->s_head, qp->s_tail, qp->s_cur,
+ 				   qp->s_acked, qp->s_last);
+ 		if (!qp->s_avail)
+ 			return -ENOMEM;
+ 	}
++>>>>>>> e16689e49216 (IB/rdmavt: Add trace and error print statements in post_one_wr)
  	next = qp->s_head + 1;
  	if (next >= qp->s_size)
  		next = 0;
@@@ -1442,14 -1493,31 +1457,24 @@@
  		}
  		wqe->wr.num_sge = j;
  	}
 -
 -	/* general part of wqe valid - allow for driver checks */
 -	if (rdi->driver_f.check_send_wqe) {
 -		ret = rdi->driver_f.check_send_wqe(qp, wqe);
 -		if (ret)
 +	if (qp->ibqp.qp_type == IB_QPT_UC ||
 +	    qp->ibqp.qp_type == IB_QPT_RC) {
 +		if (wqe->length > 0x80000000U)
  			goto bail_inval_free;
 -	}
 -
 -	log_pmtu = qp->log_pmtu;
 -	if (qp->ibqp.qp_type != IB_QPT_UC &&
 -	    qp->ibqp.qp_type != IB_QPT_RC) {
 -		struct rvt_ah *ah = ibah_to_rvtah(wqe->ud_wr.ah);
 -
 -		log_pmtu = ah->log_pmtu;
 +	} else {
  		atomic_inc(&ibah_to_rvtah(ud_wr(wr)->ah)->refcount);
  	}
 -
  	wqe->ssn = qp->s_ssn++;
++<<<<<<< HEAD
++=======
+ 	wqe->psn = qp->s_next_psn;
+ 	wqe->lpsn = wqe->psn +
+ 			(wqe->length ? ((wqe->length - 1) >> log_pmtu) : 0);
+ 	qp->s_next_psn = wqe->lpsn + 1;
+ 	trace_rvt_post_one_wr(qp, wqe);
+ 	smp_wmb(); /* see request builders */
+ 	qp->s_avail--;
++>>>>>>> e16689e49216 (IB/rdmavt: Add trace and error print statements in post_one_wr)
  	qp->s_head = next;
  
  	return 0;
* Unmerged path drivers/infiniband/sw/rdmavt/qp.c
diff --git a/drivers/infiniband/sw/rdmavt/trace.h b/drivers/infiniband/sw/rdmavt/trace.h
index d5b128118b73..6c0457db5499 100644
--- a/drivers/infiniband/sw/rdmavt/trace.h
+++ b/drivers/infiniband/sw/rdmavt/trace.h
@@ -54,6 +54,7 @@
 #include <linux/tracepoint.h>
 #include <linux/trace_seq.h>
 
+#include <rdma/ib_verbs.h>
 #include <rdma/rdma_vt.h>
 
 #define RDI_DEV_ENTRY(rdi)   __string(dev, rdi->driver_f.get_card_name(rdi))
@@ -108,6 +109,75 @@ DEFINE_EVENT(rvt_qphash_template, rvt_qpremove,
 	TP_PROTO(struct rvt_qp *qp, u32 bucket),
 	TP_ARGS(qp, bucket));
 
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM rvt_tx
+
+#define wr_opcode_name(opcode) { IB_WR_##opcode, #opcode  }
+#define show_wr_opcode(opcode)                             \
+__print_symbolic(opcode,                                   \
+	wr_opcode_name(RDMA_WRITE),                        \
+	wr_opcode_name(RDMA_WRITE_WITH_IMM),               \
+	wr_opcode_name(SEND),                              \
+	wr_opcode_name(SEND_WITH_IMM),                     \
+	wr_opcode_name(RDMA_READ),                         \
+	wr_opcode_name(ATOMIC_CMP_AND_SWP),                \
+	wr_opcode_name(ATOMIC_FETCH_AND_ADD),              \
+	wr_opcode_name(LSO),                               \
+	wr_opcode_name(SEND_WITH_INV),                     \
+	wr_opcode_name(RDMA_READ_WITH_INV),                \
+	wr_opcode_name(LOCAL_INV),                         \
+	wr_opcode_name(MASKED_ATOMIC_CMP_AND_SWP),         \
+	wr_opcode_name(MASKED_ATOMIC_FETCH_AND_ADD))
+
+#define POS_PRN \
+"[%s] wr_id %llx qpn %x psn 0x%x lpsn 0x%x length %u opcode 0x%.2x,%s size %u avail %u head %u last %u"
+
+TRACE_EVENT(
+	rvt_post_one_wr,
+	TP_PROTO(struct rvt_qp *qp, struct rvt_swqe *wqe),
+	TP_ARGS(qp, wqe),
+	TP_STRUCT__entry(
+		RDI_DEV_ENTRY(ib_to_rvt(qp->ibqp.device))
+		__field(u64, wr_id)
+		__field(u32, qpn)
+		__field(u32, psn)
+		__field(u32, lpsn)
+		__field(u32, length)
+		__field(u32, opcode)
+		__field(u32, size)
+		__field(u32, avail)
+		__field(u32, head)
+		__field(u32, last)
+	),
+	TP_fast_assign(
+		RDI_DEV_ASSIGN(ib_to_rvt(qp->ibqp.device))
+		__entry->wr_id = wqe->wr.wr_id;
+		__entry->qpn = qp->ibqp.qp_num;
+		__entry->psn = wqe->psn;
+		__entry->lpsn = wqe->lpsn;
+		__entry->length = wqe->length;
+		__entry->opcode = wqe->wr.opcode;
+		__entry->size = qp->s_size;
+		__entry->avail = qp->s_avail;
+		__entry->head = qp->s_head;
+		__entry->last = qp->s_last;
+	),
+	TP_printk(
+		POS_PRN,
+		__get_str(dev),
+		__entry->wr_id,
+		__entry->qpn,
+		__entry->psn,
+		__entry->lpsn,
+		__entry->length,
+		__entry->opcode, show_wr_opcode(__entry->opcode),
+		__entry->size,
+		__entry->avail,
+		__entry->head,
+		__entry->last
+	)
+);
+
 #endif /* __RDMAVT_TRACE_H */
 
 #undef TRACE_INCLUDE_PATH
