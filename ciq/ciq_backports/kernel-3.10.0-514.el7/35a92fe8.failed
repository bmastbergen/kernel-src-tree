nfsd: serialize state seqid morphing operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit 35a92fe8770ce54c5eb275cd76128645bea2d200
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/35a92fe8.failed

Andrew was seeing a race occur when an OPEN and OPEN_DOWNGRADE were
running in parallel. The server would receive the OPEN_DOWNGRADE first
and check its seqid, but then an OPEN would race in and bump it. The
OPEN_DOWNGRADE would then complete and bump the seqid again.  The result
was that the OPEN_DOWNGRADE would be applied after the OPEN, even though
it should have been rejected since the seqid changed.

The only recourse we have here I think is to serialize operations that
bump the seqid in a stateid, particularly when we're given a seqid in
the call. To address this, we add a new rw_semaphore to the
nfs4_ol_stateid struct. We do a down_write prior to checking the seqid
after looking up the stateid to ensure that nothing else is going to
bump it while we're operating on it.

In the case of OPEN, we do a down_read, as the call doesn't contain a
seqid. Those can run in parallel -- we just need to serialize them when
there is a concurrent OPEN_DOWNGRADE or CLOSE.

LOCK and LOCKU however always take the write lock as there is no
opportunity for parallelizing those.

Reported-and-Tested-by: Andrew W Elble <aweits@rit.edu>
	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 35a92fe8770ce54c5eb275cd76128645bea2d200)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4state.c
#	fs/nfsd/state.h
diff --cc fs/nfsd/nfs4state.c
index 15108be5ae8d,1b39edf10b67..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -4681,10 -4826,13 +4688,19 @@@ static __be32 nfs4_seqid_op_checks(stru
  		 * revoked delegations are kept only for free_stateid.
  		 */
  		return nfserr_bad_stateid;
+ 	down_write(&stp->st_rwsem);
  	status = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));
++<<<<<<< HEAD
 +	if (status)
 +		return status;
 +	return nfs4_check_fh(current_fh, stp);
++=======
+ 	if (status == nfs_ok)
+ 		status = nfs4_check_fh(current_fh, &stp->st_stid);
+ 	if (status != nfs_ok)
+ 		up_write(&stp->st_rwsem);
+ 	return status;
++>>>>>>> 35a92fe8770c (nfsd: serialize state seqid morphing operations)
  }
  
  /* 
@@@ -4897,10 -5050,8 +4918,11 @@@ nfsd4_close(struct svc_rqst *rqstp, str
  		goto out; 
  	update_stateid(&stp->st_stid.sc_stateid);
  	memcpy(&close->cl_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));
+ 	up_write(&stp->st_rwsem);
  
 +	nfsd4_return_all_file_layouts(stp->st_stateowner->so_client,
 +				      stp->st_stid.sc_file);
 +
  	nfsd4_close_open_stateid(stp);
  
  	/* put reference from nfs4_preprocess_seqid_op */
diff --cc fs/nfsd/state.h
index 51023f12e0cb,31bde12feefe..000000000000
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@@ -515,14 -534,16 +515,27 @@@ struct nfs4_file 
   * Better suggestions welcome.
   */
  struct nfs4_ol_stateid {
++<<<<<<< HEAD
 +	struct nfs4_stid    st_stid; /* must be first field */
 +	struct list_head              st_perfile;
 +	struct list_head              st_perstateowner;
 +	struct list_head              st_locks;
 +	struct nfs4_stateowner      * st_stateowner;
 +	unsigned char                 st_access_bmap;
 +	unsigned char                 st_deny_bmap;
 +	struct nfs4_ol_stateid         * st_openstp;
++=======
+ 	struct nfs4_stid		st_stid;
+ 	struct list_head		st_perfile;
+ 	struct list_head		st_perstateowner;
+ 	struct list_head		st_locks;
+ 	struct nfs4_stateowner		*st_stateowner;
+ 	struct nfs4_clnt_odstate	*st_clnt_odstate;
+ 	unsigned char			st_access_bmap;
+ 	unsigned char			st_deny_bmap;
+ 	struct nfs4_ol_stateid		*st_openstp;
+ 	struct rw_semaphore		st_rwsem;
++>>>>>>> 35a92fe8770c (nfsd: serialize state seqid morphing operations)
  };
  
  static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)
* Unmerged path fs/nfsd/nfs4state.c
* Unmerged path fs/nfsd/state.h
