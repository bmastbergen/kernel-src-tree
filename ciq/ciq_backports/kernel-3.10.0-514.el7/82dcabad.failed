libceph: revamp subs code, switch to SUBSCRIBE2 protocol

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 82dcabad750a36a2b749889bc89c5a3188775b2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/82dcabad.failed

It is currently hard-coded in the mon_client that mdsmap and monmap
subs are continuous, while osdmap sub is always "onetime".  To better
handle full clusters/pools in the osd_client, we need to be able to
issue continuous osdmap subs.  Revamp subs code to allow us to specify
for each sub whether it should be continuous or not.

Although not strictly required for the above, switch to SUBSCRIBE2
protocol while at it, eliminating the ambiguity between a request for
"every map since X" and a request for "just the latest" when we don't
have a map yet (i.e. have epoch 0).  SUBSCRIBE2 feature bit is now
required - it's been supported since pre-argonaut (2010).

Move "got mdsmap" call to the end of ceph_mdsc_handle_map() - calling
in before we validate the epoch and successfully install the new map
can mess up mon_client sub state.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 82dcabad750a36a2b749889bc89c5a3188775b2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/mon_client.c
diff --cc net/ceph/mon_client.c
index 4a66c44fabbd,89029916315c..000000000000
--- a/net/ceph/mon_client.c
+++ b/net/ceph/mon_client.c
@@@ -170,18 -173,30 +169,25 @@@ static bool __sub_expired(struct ceph_m
   */
  static void __schedule_delayed(struct ceph_mon_client *monc)
  {
 -	struct ceph_options *opt = monc->client->options;
 -	unsigned long delay;
 +	unsigned int delay;
  
 -	if (monc->cur_mon < 0 || __sub_expired(monc)) {
 +	if (monc->cur_mon < 0 || __sub_expired(monc))
  		delay = 10 * HZ;
 -	} else {
 +	else
  		delay = 20 * HZ;
 -		if (opt->monc_ping_timeout > 0)
 -			delay = min(delay, opt->monc_ping_timeout / 3);
 -	}
 -	dout("__schedule_delayed after %lu\n", delay);
 -	schedule_delayed_work(&monc->delayed_work,
 -			      round_jiffies_relative(delay));
 +	dout("__schedule_delayed after %u\n", delay);
 +	schedule_delayed_work(&monc->delayed_work, delay);
  }
  
+ const char *ceph_sub_str[] = {
+ 	[CEPH_SUB_MDSMAP] = "mdsmap",
+ 	[CEPH_SUB_MONMAP] = "monmap",
+ 	[CEPH_SUB_OSDMAP] = "osdmap",
+ };
+ 
  /*
-  * Send subscribe request for mdsmap and/or osdmap.
+  * Send subscribe request for one or more maps, according to
+  * monc->subs.
   */
  static void __send_subscribe(struct ceph_mon_client *monc)
  {
@@@ -296,17 -362,18 +347,22 @@@ int ceph_monc_wait_osdmap(struct ceph_m
  			  unsigned long timeout)
  {
  	unsigned long started = jiffies;
 -	long ret;
 +	int ret;
  
  	mutex_lock(&monc->mutex);
- 	while (monc->have_osdmap < epoch) {
+ 	while (monc->subs[CEPH_SUB_OSDMAP].have < epoch) {
  		mutex_unlock(&monc->mutex);
  
 -		if (timeout && time_after_eq(jiffies, started + timeout))
 +		if (timeout != 0 && time_after_eq(jiffies, started + timeout))
  			return -ETIMEDOUT;
  
  		ret = wait_event_interruptible_timeout(monc->client->auth_wq,
++<<<<<<< HEAD
 +					 monc->have_osdmap >= epoch, timeout);
++=======
+ 				     monc->subs[CEPH_SUB_OSDMAP].have >= epoch,
+ 				     ceph_timeout_jiffies(timeout));
++>>>>>>> 82dcabad750a (libceph: revamp subs code, switch to SUBSCRIBE2 protocol)
  		if (ret < 0)
  			return ret;
  
@@@ -693,12 -764,30 +753,23 @@@ static void delayed_work(struct work_st
  		__close_session(monc);
  		__open_session(monc);  /* continue hunting */
  	} else {
 -		struct ceph_options *opt = monc->client->options;
 -		int is_auth = ceph_auth_is_authenticated(monc->auth);
 -		if (ceph_con_keepalive_expired(&monc->con,
 -					       opt->monc_ping_timeout)) {
 -			dout("monc keepalive timeout\n");
 -			is_auth = 0;
 -			__close_session(monc);
 -			monc->hunting = true;
 -			__open_session(monc);
 -		}
 +		ceph_con_keepalive(&monc->con);
  
 -		if (!monc->hunting) {
 -			ceph_con_keepalive(&monc->con);
 -			__validate_auth(monc);
 -		}
 +		__validate_auth(monc);
  
++<<<<<<< HEAD
 +		if (ceph_auth_is_authenticated(monc->auth))
 +			__send_subscribe(monc);
++=======
+ 		if (is_auth) {
+ 			unsigned long now = jiffies;
+ 
+ 			dout("%s renew subs? now %lu renew after %lu\n",
+ 			     __func__, now, monc->sub_renew_after);
+ 			if (time_after_eq(now, monc->sub_renew_after))
+ 				__send_subscribe(monc);
+ 		}
++>>>>>>> 82dcabad750a (libceph: revamp subs code, switch to SUBSCRIBE2 protocol)
  	}
  	__schedule_delayed(monc);
  	mutex_unlock(&monc->mutex);
diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c
index 0a8d4826f8f7..cd25e3602a54 100644
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@ -3720,7 +3720,6 @@ void ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)
 	dout("handle_map epoch %u len %d\n", epoch, (int)maplen);
 
 	/* do we need it? */
-	ceph_monc_got_mdsmap(&mdsc->fsc->client->monc, epoch);
 	mutex_lock(&mdsc->mutex);
 	if (mdsc->mdsmap && epoch <= mdsc->mdsmap->m_epoch) {
 		dout("handle_map epoch %u <= our %u\n",
@@ -3747,6 +3746,8 @@ void ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)
 	mdsc->fsc->sb->s_maxbytes = mdsc->mdsmap->m_max_file_size;
 
 	__wake_requests(mdsc, &mdsc->waiting_for_map);
+	ceph_monc_got_map(&mdsc->fsc->client->monc, CEPH_SUB_MDSMAP,
+			  mdsc->mdsmap->m_epoch);
 
 	mutex_unlock(&mdsc->mutex);
 	schedule_delayed(mdsc);
diff --git a/fs/ceph/super.c b/fs/ceph/super.c
index 9acdf48b8d6b..d0d6a4ceaf83 100644
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@ -492,7 +492,7 @@ static struct ceph_fs_client *create_fs_client(struct ceph_mount_options *fsopt,
 		goto fail;
 	}
 	fsc->client->extra_mon_dispatch = extra_mon_dispatch;
-	fsc->client->monc.want_mdsmap = 1;
+	ceph_monc_want_map(&fsc->client->monc, CEPH_SUB_MDSMAP, 0, true);
 
 	fsc->mount_options = fsopt;
 
diff --git a/include/linux/ceph/ceph_features.h b/include/linux/ceph/ceph_features.h
index c1ef6f14e7be..d2d78861c30a 100644
--- a/include/linux/ceph/ceph_features.h
+++ b/include/linux/ceph/ceph_features.h
@@ -104,6 +104,7 @@ static inline u64 ceph_sanitize_features(u64 features)
  */
 #define CEPH_FEATURES_SUPPORTED_DEFAULT		\
 	(CEPH_FEATURE_NOSRCADDR |		\
+	 CEPH_FEATURE_SUBSCRIBE2 |		\
 	 CEPH_FEATURE_RECONNECT_SEQ |		\
 	 CEPH_FEATURE_PGID64 |			\
 	 CEPH_FEATURE_PGPOOL3 |			\
@@ -126,6 +127,7 @@ static inline u64 ceph_sanitize_features(u64 features)
 
 #define CEPH_FEATURES_REQUIRED_DEFAULT   \
 	(CEPH_FEATURE_NOSRCADDR |	 \
+	 CEPH_FEATURE_SUBSCRIBE2 |	 \
 	 CEPH_FEATURE_RECONNECT_SEQ |	 \
 	 CEPH_FEATURE_PGID64 |		 \
 	 CEPH_FEATURE_PGPOOL3 |		 \
diff --git a/include/linux/ceph/ceph_fs.h b/include/linux/ceph/ceph_fs.h
index d7d072a25c27..bf74005eedec 100644
--- a/include/linux/ceph/ceph_fs.h
+++ b/include/linux/ceph/ceph_fs.h
@@ -198,8 +198,8 @@ struct ceph_client_mount {
 #define CEPH_SUBSCRIBE_ONETIME    1  /* i want only 1 update after have */
 
 struct ceph_mon_subscribe_item {
-	__le64 have_version;    __le64 have;
-	__u8 onetime;
+	__le64 start;
+	__u8 flags;
 } __attribute__ ((packed));
 
 struct ceph_mon_subscribe_ack {
diff --git a/include/linux/ceph/mon_client.h b/include/linux/ceph/mon_client.h
index 81810dc21f06..8b2d2f0b659e 100644
--- a/include/linux/ceph/mon_client.h
+++ b/include/linux/ceph/mon_client.h
@@ -68,7 +68,8 @@ struct ceph_mon_client {
 
 	bool hunting;
 	int cur_mon;                       /* last monitor i contacted */
-	unsigned long sub_sent, sub_renew_after;
+	unsigned long sub_renew_after;
+	unsigned long sub_renew_sent;
 	struct ceph_connection con;
 
 	/* pending generic requests */
@@ -76,10 +77,12 @@ struct ceph_mon_client {
 	int num_generic_requests;
 	u64 last_tid;
 
-	/* mds/osd map */
-	int want_mdsmap;
-	int want_next_osdmap; /* 1 = want, 2 = want+asked */
-	u32 have_osdmap, have_mdsmap;
+	/* subs, indexed with CEPH_SUB_* */
+	struct {
+		struct ceph_mon_subscribe_item item;
+		bool want;
+		u32 have; /* epoch */
+	} subs[3];
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *debugfs_file;
@@ -93,14 +96,23 @@ extern int ceph_monmap_contains(struct ceph_monmap *m,
 extern int ceph_monc_init(struct ceph_mon_client *monc, struct ceph_client *cl);
 extern void ceph_monc_stop(struct ceph_mon_client *monc);
 
+enum {
+	CEPH_SUB_MDSMAP = 0,
+	CEPH_SUB_MONMAP,
+	CEPH_SUB_OSDMAP,
+};
+
+extern const char *ceph_sub_str[];
+
 /*
  * The model here is to indicate that we need a new map of at least
- * epoch @want, and also call in when we receive a map.  We will
+ * epoch @epoch, and also call in when we receive a map.  We will
  * periodically rerequest the map from the monitor cluster until we
  * get what we want.
  */
-extern int ceph_monc_got_mdsmap(struct ceph_mon_client *monc, u32 have);
-extern int ceph_monc_got_osdmap(struct ceph_mon_client *monc, u32 have);
+bool ceph_monc_want_map(struct ceph_mon_client *monc, int sub, u32 epoch,
+			bool continuous);
+void ceph_monc_got_map(struct ceph_mon_client *monc, int sub, u32 epoch);
 
 extern void ceph_monc_request_next_osdmap(struct ceph_mon_client *monc);
 extern int ceph_monc_wait_osdmap(struct ceph_mon_client *monc, u32 epoch,
diff --git a/net/ceph/debugfs.c b/net/ceph/debugfs.c
index 593dc2eabcc8..b902fbc7863e 100644
--- a/net/ceph/debugfs.c
+++ b/net/ceph/debugfs.c
@@ -112,15 +112,20 @@ static int monc_show(struct seq_file *s, void *p)
 	struct ceph_mon_generic_request *req;
 	struct ceph_mon_client *monc = &client->monc;
 	struct rb_node *rp;
+	int i;
 
 	mutex_lock(&monc->mutex);
 
-	if (monc->have_mdsmap)
-		seq_printf(s, "have mdsmap %u\n", (unsigned int)monc->have_mdsmap);
-	if (monc->have_osdmap)
-		seq_printf(s, "have osdmap %u\n", (unsigned int)monc->have_osdmap);
-	if (monc->want_next_osdmap)
-		seq_printf(s, "want next osdmap\n");
+	for (i = 0; i < ARRAY_SIZE(monc->subs); i++) {
+		seq_printf(s, "have %s %u", ceph_sub_str[i],
+			   monc->subs[i].have);
+		if (monc->subs[i].want)
+			seq_printf(s, " want %llu%s",
+				   le64_to_cpu(monc->subs[i].item.start),
+				   (monc->subs[i].item.flags &
+					CEPH_SUBSCRIBE_ONETIME ?  "" : "+"));
+		seq_putc(s, '\n');
+	}
 
 	for (rp = rb_first(&monc->generic_request_tree); rp; rp = rb_next(rp)) {
 		__u16 op;
* Unmerged path net/ceph/mon_client.c
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 9216aa1711b2..60dffbe831bb 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -2188,7 +2188,8 @@ void ceph_osdc_handle_map(struct ceph_osd_client *osdc, struct ceph_msg *msg)
 		goto bad;
 done:
 	downgrade_write(&osdc->map_sem);
-	ceph_monc_got_osdmap(&osdc->client->monc, osdc->osdmap->epoch);
+	ceph_monc_got_map(&osdc->client->monc, CEPH_SUB_OSDMAP,
+			  osdc->osdmap->epoch);
 
 	/*
 	 * subscribe to subsequent osdmap updates if full to ensure
