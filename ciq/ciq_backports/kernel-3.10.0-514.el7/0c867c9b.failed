vxlan: move Ethernet initialization to a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 0c867c9bf84ce2a998f83725bd363f66ce84d548
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0c867c9b.failed

This will allow to initialize vxlan in ARPHRD_NONE mode based on the passed
rtnl attributes.

v2: renamed "l2mode" to "ether".

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0c867c9bf84ce2a998f83725bd363f66ce84d548)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 9215c93ac7ca,6bd5b874ead7..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2303,7 -2362,49 +2303,53 @@@ static int vxlan_change_mtu(struct net_
  	return __vxlan_change_mtu(dev, lowerdev, dst, new_mtu, true);
  }
  
++<<<<<<< HEAD
 +static const struct net_device_ops vxlan_netdev_ops = {
++=======
+ static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	__be16 sport, dport;
+ 
+ 	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				  vxlan->cfg.port_max, true);
+ 	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		struct rtable *rt;
+ 
+ 		if (!vxlan->vn4_sock)
+ 			return -EINVAL;
+ 		rt = vxlan_get_route(vxlan, skb, 0, info->key.tos,
+ 				     info->key.u.ipv4.dst,
+ 				     &info->key.u.ipv4.src, NULL, info);
+ 		if (IS_ERR(rt))
+ 			return PTR_ERR(rt);
+ 		ip_rt_put(rt);
+ 	} else {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		struct dst_entry *ndst;
+ 
+ 		if (!vxlan->vn6_sock)
+ 			return -EINVAL;
+ 		ndst = vxlan6_get_route(vxlan, skb, 0, info->key.tos,
+ 					info->key.label, &info->key.u.ipv6.dst,
+ 					&info->key.u.ipv6.src, NULL, info);
+ 		if (IS_ERR(ndst))
+ 			return PTR_ERR(ndst);
+ 		dst_release(ndst);
+ #else /* !CONFIG_IPV6 */
+ 		return -EPFNOSUPPORT;
+ #endif
+ 	}
+ 	info->key.tp_src = sport;
+ 	info->key.tp_dst = dport;
+ 	return 0;
+ }
+ 
+ static const struct net_device_ops vxlan_netdev_ether_ops = {
++>>>>>>> 0c867c9bf84c (vxlan: move Ethernet initialization to a separate function)
  	.ndo_init		= vxlan_init,
  	.ndo_uninit		= vxlan_uninit,
  	.ndo_open		= vxlan_open,
@@@ -2578,59 -2680,80 +2628,61 @@@ struct vxlan_sock *vxlan_sock_add(struc
  		}
  		spin_unlock(&vn->sock_lock);
  	}
 -	if (!vs)
 -		vs = vxlan_socket_create(vxlan->net, ipv6,
 -					 vxlan->cfg.dst_port, vxlan->flags);
 -	if (IS_ERR(vs))
 -		return PTR_ERR(vs);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	if (ipv6)
 -		vxlan->vn6_sock = vs;
 -	else
 -#endif
 -		vxlan->vn4_sock = vs;
 -	vxlan_vs_add_dev(vs, vxlan);
 -	return 0;
 -}
 -
 -static int vxlan_sock_add(struct vxlan_dev *vxlan)
 -{
 -	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
 -	bool metadata = vxlan->flags & VXLAN_F_COLLECT_METADATA;
 -	int ret = 0;
  
 -	vxlan->vn4_sock = NULL;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	vxlan->vn6_sock = NULL;
 -	if (ipv6 || metadata)
 -		ret = __vxlan_sock_add(vxlan, true);
 -#endif
 -	if (!ret && (!ipv6 || metadata))
 -		ret = __vxlan_sock_add(vxlan, false);
 -	if (ret < 0)
 -		vxlan_sock_release(vxlan);
 -	return ret;
 +	return vxlan_socket_create(net, port, rcv, data, flags);
  }
 +EXPORT_SYMBOL_GPL(vxlan_sock_add);
  
 -static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,
 -			       struct vxlan_config *conf)
 +static int vxlan_newlink(struct net *src_net, struct net_device *dev,
 +			 struct nlattr *tb[], struct nlattr *data[])
  {
  	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
 -	struct vxlan_dev *vxlan = netdev_priv(dev), *tmp;
 +	struct vxlan_dev *vxlan = netdev_priv(dev);
  	struct vxlan_rdst *dst = &vxlan->default_dst;
 -	unsigned short needed_headroom = ETH_HLEN;
 +	__u32 vni;
  	int err;
  	bool use_ipv6 = false;
 -	__be16 default_port = vxlan->cfg.dst_port;
 -	struct net_device *lowerdev = NULL;
 +
 +	if (!data[IFLA_VXLAN_ID])
 +		return -EINVAL;
  
+ 	vxlan_ether_setup(dev);
+ 
  	vxlan->net = src_net;
  
 -	dst->remote_vni = conf->vni;
 -
 -	memcpy(&dst->remote_ip, &conf->remote_ip, sizeof(conf->remote_ip));
 +	vni = nla_get_u32(data[IFLA_VXLAN_ID]);
 +	dst->remote_vni = vni;
  
  	/* Unless IPv6 is explicitly requested, assume IPv4 */
 -	if (!dst->remote_ip.sa.sa_family)
 -		dst->remote_ip.sa.sa_family = AF_INET;
 -
 -	if (dst->remote_ip.sa.sa_family == AF_INET6 ||
 -	    vxlan->cfg.saddr.sa.sa_family == AF_INET6) {
 +	dst->remote_ip.sa.sa_family = AF_INET;
 +	if (data[IFLA_VXLAN_GROUP]) {
 +		dst->remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);
 +	} else if (data[IFLA_VXLAN_GROUP6]) {
  		if (!IS_ENABLED(CONFIG_IPV6))
  			return -EPFNOSUPPORT;
 +
 +		dst->remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);
 +		dst->remote_ip.sa.sa_family = AF_INET6;
  		use_ipv6 = true;
 -		vxlan->flags |= VXLAN_F_IPV6;
  	}
  
 -	if (conf->label && !use_ipv6) {
 -		pr_info("label only supported in use with IPv6\n");
 -		return -EINVAL;
 +	if (data[IFLA_VXLAN_LOCAL]) {
 +		vxlan->saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);
 +		vxlan->saddr.sa.sa_family = AF_INET;
 +	} else if (data[IFLA_VXLAN_LOCAL6]) {
 +		if (!IS_ENABLED(CONFIG_IPV6))
 +			return -EPFNOSUPPORT;
 +
 +		/* TODO: respect scope id */
 +		vxlan->saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);
 +		vxlan->saddr.sa.sa_family = AF_INET6;
 +		use_ipv6 = true;
  	}
  
 -	if (conf->remote_ifindex) {
 -		lowerdev = __dev_get_by_index(src_net, conf->remote_ifindex);
 -		dst->remote_ifindex = conf->remote_ifindex;
 +	if (data[IFLA_VXLAN_LINK] &&
 +	    (dst->remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]))) {
 +		struct net_device *lowerdev
 +			 = __dev_get_by_index(src_net, dst->remote_ifindex);
  
  		if (!lowerdev) {
  			pr_info("ifindex %d does not exist\n", dst->remote_ifindex);
* Unmerged path drivers/net/vxlan.c
