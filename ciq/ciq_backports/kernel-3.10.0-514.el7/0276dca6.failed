rbd: add force close option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mike Christie <mchristi@redhat.com>
commit 0276dca6c1ecb9a665645ff573e70685a57759af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0276dca6.failed

This adds a force close option, so we can force the unmapping
of a rbd device that is open. If a path/device is blacklisted, apps
like multipathd can map a new device and then unmap the old one.
The unmapping cleanup would then be handled by the generic hotunplug
code paths in multipahd like is done for iSCSI, FC/FCOE, SAS, etc.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 0276dca6c1ecb9a665645ff573e70685a57759af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index 0ea1260a957b,35fc1da6c83d..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -5655,18 -6347,26 +5655,36 @@@ static ssize_t do_rbd_remove(struct bus
  	struct rbd_device *rbd_dev = NULL;
  	struct list_head *tmp;
  	int dev_id;
- 	unsigned long ul;
+ 	char opt_buf[6];
  	bool already = false;
+ 	bool force = false;
  	int ret;
  
++<<<<<<< HEAD
 +	ret = strict_strtoul(buf, 10, &ul);
 +	if (ret)
 +		return ret;
 +
 +	/* convert to int; abort if we lost anything in the conversion */
 +	dev_id = (int)ul;
 +	if (dev_id != ul)
++=======
+ 	dev_id = -1;
+ 	opt_buf[0] = '\0';
+ 	sscanf(buf, "%d %5s", &dev_id, opt_buf);
+ 	if (dev_id < 0) {
+ 		pr_err("dev_id out of range\n");
++>>>>>>> 0276dca6c1ec (rbd: add force close option)
  		return -EINVAL;
+ 	}
+ 	if (opt_buf[0] != '\0') {
+ 		if (!strcmp(opt_buf, "force")) {
+ 			force = true;
+ 		} else {
+ 			pr_err("bad remove option at '%s'\n", opt_buf);
+ 			return -EINVAL;
+ 		}
+ 	}
  
  	ret = -ENOENT;
  	spin_lock(&rbd_dev_list_lock);
@@@ -5690,7 -6390,20 +5708,24 @@@
  	if (ret < 0 || already)
  		return ret;
  
++<<<<<<< HEAD
 +	rbd_dev_header_unwatch_sync(rbd_dev);
++=======
+ 	if (force) {
+ 		/*
+ 		 * Prevent new IO from being queued and wait for existing
+ 		 * IO to complete/fail.
+ 		 */
+ 		blk_mq_freeze_queue(rbd_dev->disk->queue);
+ 		blk_set_queue_dying(rbd_dev->disk->queue);
+ 	}
+ 
+ 	down_write(&rbd_dev->lock_rwsem);
+ 	if (__rbd_is_lock_owner(rbd_dev))
+ 		rbd_unlock(rbd_dev);
+ 	up_write(&rbd_dev->lock_rwsem);
+ 	rbd_unregister_watch(rbd_dev);
++>>>>>>> 0276dca6c1ec (rbd: add force close option)
  
  	/*
  	 * Don't free anything from rbd_dev->disk until after all
diff --git a/Documentation/ABI/testing/sysfs-bus-rbd b/Documentation/ABI/testing/sysfs-bus-rbd
index 7bf8d4fa6f63..a0169700efd8 100644
--- a/Documentation/ABI/testing/sysfs-bus-rbd
+++ b/Documentation/ABI/testing/sysfs-bus-rbd
@@ -6,7 +6,7 @@ Description:
 
 Being used for adding and removing rbd block devices.
 
-Usage: <mon ip addr> <options> <pool name> <rbd image name> [snap name]
+Usage: <mon ip addr> <options> <pool name> <rbd image name> [<snap name>]
 
  $ echo "192.168.0.1 name=admin rbd foo" > /sys/bus/rbd/add
 
@@ -14,9 +14,13 @@ The snapshot name can be "-" or omitted to map the image read/write. A <dev-id>
 will be assigned for any registered block device. If snapshot is used, it will
 be mapped read-only.
 
-Removal of a device:
+Usage: <dev-id> [force]
 
-  $ echo <dev-id> > /sys/bus/rbd/remove
+ $ echo 2 > /sys/bus/rbd/remove
+
+Optional "force" argument which when passed will wait for running requests and
+then unmap the image. Requests sent to the driver after initiating the removal
+will be failed.  (August 2016, since 4.9.)
 
 What:		/sys/bus/rbd/add_single_major
 Date:		December 2013
* Unmerged path drivers/block/rbd.c
