perf hists: Use own hpp_list for hierarchy mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 1b2dbbf41a0f4cf7a5662bccb9a18128d16e5ffb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1b2dbbf4.failed

Now each hists has its own hpp lists in hierarchy.  So instead of having
a pointer to a single perf_hpp_fmt in a hist entry, make it point the
hpp_list for its level.  This will be used to support multiple sort keys
in a single hierarchy level.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1457361308-514-3-git-send-email-namhyung@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1b2dbbf41a0f4cf7a5662bccb9a18128d16e5ffb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/browsers/hists.c
#	tools/perf/ui/hist.c
#	tools/perf/ui/stdio/hist.c
#	tools/perf/util/hist.c
#	tools/perf/util/hist.h
#	tools/perf/util/sort.h
diff --cc tools/perf/ui/browsers/hists.c
index d1445dd5bb7f,928b4825b752..000000000000
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@@ -1213,6 -1277,233 +1213,236 @@@ static int hist_browser__show_entry(str
  	return printed;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_browser__show_hierarchy_entry(struct hist_browser *browser,
+ 					      struct hist_entry *entry,
+ 					      unsigned short row,
+ 					      int level, int nr_sort_keys)
+ {
+ 	int printed = 0;
+ 	int width = browser->b.width;
+ 	char folded_sign = ' ';
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	off_t row_offset = entry->row_offset;
+ 	bool first = true;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hpp_arg arg = {
+ 		.b		= &browser->b,
+ 		.current_entry	= current_entry,
+ 	};
+ 	int column = 0;
+ 	int hierarchy_indent = (nr_sort_keys - 1) * HIERARCHY_INDENT;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = entry;
+ 		browser->selection = &entry->ms;
+ 	}
+ 
+ 	hist_entry__init_have_children(entry);
+ 	folded_sign = hist_entry__folded(entry);
+ 	arg.folded_sign = folded_sign;
+ 
+ 	if (entry->leaf && row_offset) {
+ 		row_offset--;
+ 		goto show_callchain;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(entry->hists, fmt) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (perf_hpp__should_skip(fmt, entry->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		if (first) {
+ 			ui_browser__printf(&browser->b, "%c", folded_sign);
+ 			width--;
+ 			first = false;
+ 		} else {
+ 			ui_browser__printf(&browser->b, "  ");
+ 			width -= 2;
+ 		}
+ 
+ 		if (fmt->color) {
+ 			int ret = fmt->color(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			/*
+ 			 * fmt->color() already used ui_browser to
+ 			 * print the non alignment bits, skip it (+ret):
+ 			 */
+ 			ui_browser__printf(&browser->b, "%s", s + ret);
+ 		} else {
+ 			int ret = fmt->entry(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			ui_browser__printf(&browser->b, "%s", s);
+ 		}
+ 		width -= hpp.buf - s;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", hierarchy_indent);
+ 	width -= hierarchy_indent;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		perf_hpp_list__for_each_format(entry->hpp_list, fmt) {
+ 			ui_browser__write_nstring(&browser->b, "", 2);
+ 			width -= 2;
+ 
+ 			/*
+ 			 * No need to call hist_entry__snprintf_alignment()
+ 			 * since this fmt is always the last column in the
+ 			 * hierarchy mode.
+ 			 */
+ 			if (fmt->color) {
+ 				width -= fmt->color(fmt, &hpp, entry);
+ 			} else {
+ 				int i = 0;
+ 
+ 				width -= fmt->entry(fmt, &hpp, entry);
+ 				ui_browser__printf(&browser->b, "%s", ltrim(s));
+ 
+ 				while (isspace(s[i++]))
+ 					width++;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 
+ 	++row;
+ 	++printed;
+ 
+ show_callchain:
+ 	if (entry->leaf && folded_sign == '-' && row != browser->b.rows) {
+ 		struct callchain_print_arg carg = {
+ 			.row_offset = row_offset,
+ 		};
+ 
+ 		printed += hist_browser__show_callchain(browser, entry,
+ 					level + 1, row,
+ 					hist_browser__show_callchain_entry, &carg,
+ 					hist_browser__check_output_full);
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static int hist_browser__show_no_entry(struct hist_browser *browser,
+ 				       unsigned short row,
+ 				       int level, int nr_sort_keys)
+ {
+ 	int width = browser->b.width;
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	bool first = true;
+ 	int column = 0;
+ 	int ret;
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = NULL;
+ 		browser->selection = NULL;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(browser->hists, fmt) {
+ 		if (perf_hpp__should_skip(fmt, browser->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		ret = fmt->width(fmt, NULL, hists_to_evsel(browser->hists));
+ 
+ 		if (first) {
+ 			/* for folded sign */
+ 			first = false;
+ 			ret++;
+ 		} else {
+ 			/* space between columns */
+ 			ret += 2;
+ 		}
+ 
+ 		ui_browser__write_nstring(&browser->b, "", ret);
+ 		width -= ret;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", nr_sort_keys * HIERARCHY_INDENT);
+ 	width -= nr_sort_keys * HIERARCHY_INDENT;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char buf[32];
+ 
+ 		ret = snprintf(buf, sizeof(buf), "no entry >= %.2f%%", browser->min_pcnt);
+ 		ui_browser__printf(&browser->b, "  %s", buf);
+ 		width -= ret + 2;
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 	return 1;
+ }
+ 
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
  static int advance_hpp_check(struct perf_hpp *hpp, int inc)
  {
  	advance_hpp(hpp, inc);
@@@ -1582,12 -1908,75 +1812,78 @@@ static int hist_browser__fprintf_entry(
  			first = false;
  
  		ret = fmt->entry(fmt, &hpp, he);
++<<<<<<< HEAD
 +		advance_hpp(&hpp, ret);
 +	}
++=======
+ 		ret = hist_entry__snprintf_alignment(he, &hpp, fmt, ret);
+ 		advance_hpp(&hpp, ret);
+ 	}
+ 	printed += fprintf(fp, "%s\n", s);
+ 
+ 	if (folded_sign == '-')
+ 		printed += hist_browser__fprintf_callchain(browser, he, fp, 1);
+ 
+ 	return printed;
+ }
+ 
+ 
+ static int hist_browser__fprintf_hierarchy_entry(struct hist_browser *browser,
+ 						 struct hist_entry *he,
+ 						 FILE *fp, int level,
+ 						 int nr_sort_keys)
+ {
+ 	char s[8192];
+ 	int printed = 0;
+ 	char folded_sign = ' ';
+ 	struct perf_hpp hpp = {
+ 		.buf = s,
+ 		.size = sizeof(s),
+ 	};
+ 	struct perf_hpp_fmt *fmt;
+ 	bool first = true;
+ 	int ret;
+ 	int hierarchy_indent = nr_sort_keys * HIERARCHY_INDENT;
+ 
+ 	printed = fprintf(fp, "%*s", level * HIERARCHY_INDENT, "");
+ 
+ 	folded_sign = hist_entry__folded(he);
+ 	printed += fprintf(fp, "%c", folded_sign);
+ 
+ 	hists__for_each_format(he->hists, fmt) {
+ 		if (perf_hpp__should_skip(fmt, he->hists))
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (!first) {
+ 			ret = scnprintf(hpp.buf, hpp.size, "  ");
+ 			advance_hpp(&hpp, ret);
+ 		} else
+ 			first = false;
+ 
+ 		ret = fmt->entry(fmt, &hpp, he);
+ 		advance_hpp(&hpp, ret);
+ 	}
+ 
+ 	ret = scnprintf(hpp.buf, hpp.size, "%*s", hierarchy_indent, "");
+ 	advance_hpp(&hpp, ret);
+ 
+ 	perf_hpp_list__for_each_format(he->hpp_list, fmt) {
+ 		ret = scnprintf(hpp.buf, hpp.size, "  ");
+ 		advance_hpp(&hpp, ret);
+ 
+ 		ret = fmt->entry(fmt, &hpp, he);
+ 		advance_hpp(&hpp, ret);
+ 	}
+ 
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
  	printed += fprintf(fp, "%s\n", rtrim(s));
  
 -	if (he->leaf && folded_sign == '-') {
 -		printed += hist_browser__fprintf_callchain(browser, he, fp,
 -							   he->depth + 1);
 -	}
 +	if (folded_sign == '-')
 +		printed += hist_browser__fprintf_callchain(browser, he, fp);
  
  	return printed;
  }
diff --cc tools/perf/ui/hist.c
index ad40452da995,95795ef4209b..000000000000
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@@ -687,3 -716,70 +687,73 @@@ void perf_hpp__set_user_width(const cha
  			break;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int add_hierarchy_fmt(struct hists *hists, struct perf_hpp_fmt *fmt)
+ {
+ 	struct perf_hpp_list_node *node = NULL;
+ 	struct perf_hpp_fmt *fmt_copy;
+ 	bool found = false;
+ 	bool skip = perf_hpp__should_skip(fmt, hists);
+ 
+ 	list_for_each_entry(node, &hists->hpp_formats, list) {
+ 		if (node->level == fmt->level) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		node = malloc(sizeof(*node));
+ 		if (node == NULL)
+ 			return -1;
+ 
+ 		node->skip = skip;
+ 		node->level = fmt->level;
+ 		perf_hpp_list__init(&node->hpp);
+ 
+ 		list_add_tail(&node->list, &hists->hpp_formats);
+ 	}
+ 
+ 	fmt_copy = perf_hpp_fmt__dup(fmt);
+ 	if (fmt_copy == NULL)
+ 		return -1;
+ 
+ 	if (!skip)
+ 		node->skip = false;
+ 
+ 	list_add_tail(&fmt_copy->list, &node->hpp.fields);
+ 	list_add_tail(&fmt_copy->sort_list, &node->hpp.sorts);
+ 
+ 	return 0;
+ }
+ 
+ int perf_hpp__setup_hists_formats(struct perf_hpp_list *list,
+ 				  struct perf_evlist *evlist)
+ {
+ 	struct perf_evsel *evsel;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hists *hists;
+ 	int ret;
+ 
+ 	if (!symbol_conf.report_hierarchy)
+ 		return 0;
+ 
+ 	evlist__for_each(evlist, evsel) {
+ 		hists = evsel__hists(evsel);
+ 
+ 		perf_hpp_list__for_each_sort_list(list, fmt) {
+ 			if (perf_hpp__is_dynamic_entry(fmt) &&
+ 			    !perf_hpp__defined_dynamic_entry(fmt, hists))
+ 				continue;
+ 
+ 			ret = add_hierarchy_fmt(hists, fmt);
+ 			if (ret < 0)
+ 				return ret;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
diff --cc tools/perf/ui/stdio/hist.c
index 28fcb1ee0342,073642a63cc9..000000000000
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@@ -409,6 -410,86 +409,89 @@@ static int hist_entry__snprintf(struct 
  	return hpp->buf - start;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_entry__hierarchy_fprintf(struct hist_entry *he,
+ 					 struct perf_hpp *hpp,
+ 					 int nr_sort_key, struct hists *hists,
+ 					 FILE *fp)
+ {
+ 	const char *sep = symbol_conf.field_sep;
+ 	struct perf_hpp_fmt *fmt;
+ 	char *buf = hpp->buf;
+ 	size_t size = hpp->size;
+ 	int ret, printed = 0;
+ 	bool first = true;
+ 
+ 	if (symbol_conf.exclude_other && !he->parent)
+ 		return 0;
+ 
+ 	ret = scnprintf(hpp->buf, hpp->size, "%*s", he->depth * HIERARCHY_INDENT, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	hists__for_each_format(he->hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		/*
+ 		 * If there's no field_sep, we still need
+ 		 * to display initial '  '.
+ 		 */
+ 		if (!sep || !first) {
+ 			ret = scnprintf(hpp->buf, hpp->size, "%s", sep ?: "  ");
+ 			advance_hpp(hpp, ret);
+ 		} else
+ 			first = false;
+ 
+ 		if (perf_hpp__use_color() && fmt->color)
+ 			ret = fmt->color(fmt, hpp, he);
+ 		else
+ 			ret = fmt->entry(fmt, hpp, he);
+ 
+ 		ret = hist_entry__snprintf_alignment(he, hpp, fmt, ret);
+ 		advance_hpp(hpp, ret);
+ 	}
+ 
+ 	if (!sep)
+ 		ret = scnprintf(hpp->buf, hpp->size, "%*s",
+ 				(nr_sort_key - 1) * HIERARCHY_INDENT, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	printed += fprintf(fp, "%s", buf);
+ 
+ 	perf_hpp_list__for_each_format(he->hpp_list, fmt) {
+ 		hpp->buf  = buf;
+ 		hpp->size = size;
+ 
+ 		/*
+ 		 * No need to call hist_entry__snprintf_alignment() since this
+ 		 * fmt is always the last column in the hierarchy mode.
+ 		 */
+ 		if (perf_hpp__use_color() && fmt->color)
+ 			fmt->color(fmt, hpp, he);
+ 		else
+ 			fmt->entry(fmt, hpp, he);
+ 
+ 		/*
+ 		 * dynamic entries are right-aligned but we want left-aligned
+ 		 * in the hierarchy mode
+ 		 */
+ 		printed += fprintf(fp, "%s%s", sep ?: "  ", ltrim(buf));
+ 	}
+ 	printed += putc('\n', fp);
+ 
+ 	if (symbol_conf.use_callchain && he->leaf) {
+ 		u64 total = hists__total_period(hists);
+ 
+ 		printed += hist_entry_callchain__fprintf(he, total, 0, fp);
+ 		goto out;
+ 	}
+ 
+ out:
+ 	return printed;
+ }
+ 
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
  static int hist_entry__fprintf(struct hist_entry *he, size_t size,
  			       struct hists *hists,
  			       char *bf, size_t bfsz, FILE *fp)
diff --cc tools/perf/util/hist.c
index 9a525a5b649f,29da9e0d8db9..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -1039,6 -1086,121 +1039,124 @@@ void hist_entry__delete(struct hist_ent
   * collapse the histogram
   */
  
++<<<<<<< HEAD
++=======
+ static void hists__apply_filters(struct hists *hists, struct hist_entry *he);
+ 
+ static struct hist_entry *hierarchy_insert_entry(struct hists *hists,
+ 						 struct rb_root *root,
+ 						 struct hist_entry *he,
+ 						 struct perf_hpp_list *hpp_list)
+ {
+ 	struct rb_node **p = &root->rb_node;
+ 	struct rb_node *parent = NULL;
+ 	struct hist_entry *iter, *new;
+ 	struct perf_hpp_fmt *fmt;
+ 	int64_t cmp;
+ 
+ 	while (*p != NULL) {
+ 		parent = *p;
+ 		iter = rb_entry(parent, struct hist_entry, rb_node_in);
+ 
+ 		cmp = 0;
+ 		perf_hpp_list__for_each_sort_list(hpp_list, fmt) {
+ 			cmp = fmt->collapse(fmt, iter, he);
+ 			if (cmp)
+ 				break;
+ 		}
+ 
+ 		if (!cmp) {
+ 			he_stat__add_stat(&iter->stat, &he->stat);
+ 			return iter;
+ 		}
+ 
+ 		if (cmp < 0)
+ 			p = &parent->rb_left;
+ 		else
+ 			p = &parent->rb_right;
+ 	}
+ 
+ 	new = hist_entry__new(he, true);
+ 	if (new == NULL)
+ 		return NULL;
+ 
+ 	hists__apply_filters(hists, new);
+ 	hists->nr_entries++;
+ 
+ 	/* save related format list for output */
+ 	new->hpp_list = hpp_list;
+ 
+ 	/* some fields are now passed to 'new' */
+ 	perf_hpp_list__for_each_sort_list(hpp_list, fmt) {
+ 		if (perf_hpp__is_trace_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			he->trace_output = NULL;
+ 		else
+ 			new->trace_output = NULL;
+ 
+ 		if (perf_hpp__is_srcline_entry(fmt))
+ 			he->srcline = NULL;
+ 		else
+ 			new->srcline = NULL;
+ 
+ 		if (perf_hpp__is_srcfile_entry(fmt))
+ 			he->srcfile = NULL;
+ 		else
+ 			new->srcfile = NULL;
+ 	}
+ 
+ 	rb_link_node(&new->rb_node_in, parent, p);
+ 	rb_insert_color(&new->rb_node_in, root);
+ 	return new;
+ }
+ 
+ static int hists__hierarchy_insert_entry(struct hists *hists,
+ 					 struct rb_root *root,
+ 					 struct hist_entry *he)
+ {
+ 	struct perf_hpp_list_node *node;
+ 	struct hist_entry *new_he = NULL;
+ 	struct hist_entry *parent = NULL;
+ 	int depth = 0;
+ 	int ret = 0;
+ 
+ 	list_for_each_entry(node, &hists->hpp_formats, list) {
+ 		/* skip period (overhead) and elided columns */
+ 		if (node->level == 0 || node->skip)
+ 			continue;
+ 
+ 		/* insert copy of 'he' for each fmt into the hierarchy */
+ 		new_he = hierarchy_insert_entry(hists, root, he, &node->hpp);
+ 		if (new_he == NULL) {
+ 			ret = -1;
+ 			break;
+ 		}
+ 
+ 		root = &new_he->hroot_in;
+ 		new_he->parent_he = parent;
+ 		new_he->depth = depth++;
+ 		parent = new_he;
+ 	}
+ 
+ 	if (new_he) {
+ 		new_he->leaf = true;
+ 
+ 		if (symbol_conf.use_callchain) {
+ 			callchain_cursor_reset(&callchain_cursor);
+ 			if (callchain_merge(&callchain_cursor,
+ 					    new_he->callchain,
+ 					    he->callchain) < 0)
+ 				ret = -1;
+ 		}
+ 	}
+ 
+ 	/* 'he' is no longer used */
+ 	hist_entry__delete(he);
+ 
+ 	/* return 0 (or -1) since it already applied filters */
+ 	return ret;
+ }
+ 
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
  int hists__collapse_insert_entry(struct hists *hists, struct rb_root *root,
  				 struct hist_entry *he)
  {
@@@ -1211,6 -1379,12 +1330,15 @@@ static void hierarchy_insert_output_ent
  
  	rb_link_node(&he->rb_node, parent, p);
  	rb_insert_color(&he->rb_node, root);
++<<<<<<< HEAD
++=======
+ 
+ 	/* update column width of dynamic entry */
+ 	perf_hpp_list__for_each_sort_list(he->hpp_list, fmt) {
+ 		if (perf_hpp__is_dynamic_entry(fmt))
+ 			fmt->sort(fmt, he, NULL);
+ 	}
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
  }
  
  static void hists__hierarchy_output_resort(struct hists *hists,
diff --cc tools/perf/util/hist.h
index 1d52912874e9,2209188d729c..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -226,6 -245,13 +226,16 @@@ struct perf_hpp_list 
  
  extern struct perf_hpp_list perf_hpp_list;
  
++<<<<<<< HEAD
++=======
+ struct perf_hpp_list_node {
+ 	struct list_head	list;
+ 	struct perf_hpp_list	hpp;
+ 	int			level;
+ 	bool			skip;
+ };
+ 
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
  void perf_hpp_list__column_register(struct perf_hpp_list *list,
  				    struct perf_hpp_fmt *format);
  void perf_hpp_list__register_sort_field(struct perf_hpp_list *list,
diff --cc tools/perf/util/sort.h
index cb167fb3da85,ea1f722cffea..000000000000
--- a/tools/perf/util/sort.h
+++ b/tools/perf/util/sort.h
@@@ -124,6 -129,17 +124,20 @@@ struct hist_entry 
  	void			*raw_data;
  	u32			raw_size;
  	void			*trace_output;
++<<<<<<< HEAD
++=======
+ 	struct perf_hpp_fmt	*fmt;
+ 	struct perf_hpp_list	*hpp_list;
+ 	struct hist_entry	*parent_he;
+ 	union {
+ 		/* this is for hierarchical entry structure */
+ 		struct {
+ 			struct rb_root	hroot_in;
+ 			struct rb_root  hroot_out;
+ 		};				/* non-leaf entries */
+ 		struct rb_root	sorted_chain;	/* leaf entry has callchains */
+ 	};
++>>>>>>> 1b2dbbf41a0f (perf hists: Use own hpp_list for hierarchy mode)
  	struct callchain_root	callchain[0]; /* must be last member */
  };
  
* Unmerged path tools/perf/ui/browsers/hists.c
diff --git a/tools/perf/ui/gtk/hists.c b/tools/perf/ui/gtk/hists.c
index d0c6b87e8015..9fdfb3a0c432 100644
--- a/tools/perf/ui/gtk/hists.c
+++ b/tools/perf/ui/gtk/hists.c
@@ -412,6 +412,7 @@ static void perf_gtk__add_hierarchy_entries(struct hists *hists,
 	for (node = rb_first(root); node; node = rb_next(node)) {
 		GtkTreeIter iter;
 		float percent;
+		char *bf;
 
 		he = rb_entry(node, struct hist_entry, rb_node);
 		if (he->filtered)
@@ -437,13 +438,20 @@ static void perf_gtk__add_hierarchy_entries(struct hists *hists,
 			gtk_tree_store_set(store, &iter, col_idx++, hpp->buf, -1);
 		}
 
-		fmt = he->fmt;
-		if (fmt->color)
-			fmt->color(fmt, hpp, he);
-		else
-			fmt->entry(fmt, hpp, he);
+		bf = hpp->buf;
+		perf_hpp_list__for_each_format(he->hpp_list, fmt) {
+			int ret;
+
+			if (fmt->color)
+				ret = fmt->color(fmt, hpp, he);
+			else
+				ret = fmt->entry(fmt, hpp, he);
+
+			snprintf(hpp->buf + ret, hpp->size - ret, "  ");
+			advance_hpp(hpp, ret + 2);
+		}
 
-		gtk_tree_store_set(store, &iter, col_idx, rtrim(hpp->buf), -1);
+		gtk_tree_store_set(store, &iter, col_idx, rtrim(bf), -1);
 
 		if (!he->leaf) {
 			perf_gtk__add_hierarchy_entries(hists, &he->hroot_out,
* Unmerged path tools/perf/ui/hist.c
* Unmerged path tools/perf/ui/stdio/hist.c
* Unmerged path tools/perf/util/hist.c
* Unmerged path tools/perf/util/hist.h
* Unmerged path tools/perf/util/sort.h
