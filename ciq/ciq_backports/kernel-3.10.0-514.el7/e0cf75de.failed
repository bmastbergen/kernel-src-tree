IB/hfi1: Fix mm_struct use after free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ira Weiny <ira.weiny@intel.com>
commit e0cf75deab8155334c8228eb7f097b15127d0a49
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e0cf75de.failed

Testing with CONFIG_SLUB_DEBUG_ON=y resulted in the kernel panic below.

This is the result of the mm_struct sometimes being free'd prior to
hfi1_file_close being called.

This was due to the combination of 2 reasons:

1) hfi1_file_close is deferred in process exit and it therefore may not
   be called synchronously with process exit.
2) exit_mm is called prior to exit_files in do_exit.  Normally this is ok
   however, our kernel bypass code requires us to have access to the
   mm_struct for house keeping both at "normal" close time as well as at
   process exit.

Therefore, the fix is to simply keep a reference to the mm_struct until
we are done with it.

[ 3006.340150] general protection fault: 0000 [#1] SMP
[ 3006.346469] Modules linked in: hfi1 rdmavt rpcrdma ib_isert iscsi_target_mod
ib_iser libiscsi scsi_transport_iscsi ib_srpt target_core_mod
 ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_ucm ib_uverbs ib_umad rdma_cm
 ib_cm iw_cm dm_mirror dm_region_hash dm_log dm_mod snd_hda_code
 c_realtek iTCO_wdt snd_hda_codec_generic iTCO_vendor_support sb_edac edac_core
 x86_pkg_temp_thermal intel_powerclamp coretemp kvm irqbypass c
 rct10dif_pclmul crc32_pclmul ghash_clmulni_intel aesni_intel lrw snd_hda_intel
 gf128mul snd_hda_codec glue_helper snd_hda_core ablk_helper sn
 d_hwdep cryptd snd_seq snd_seq_device snd_pcm snd_timer snd soundcore pcspkr
 shpchp mei_me sg lpc_ich mei i2c_i801 mfd_core ioatdma ipmi_devi
 ntf wmi ipmi_si ipmi_msghandler acpi_cpufreq nfsd auth_rpcgss nfs_acl lockd
 grace sunrpc ip_tables ext4 jbd2 mbcache mlx4_en ib_core sr_mod s
 d_mod cdrom crc32c_intel mgag200 drm_kms_helper syscopyarea sysfillrect igb
 sysimgblt fb_sys_fops ptp mlx4_core ttm isci pps_core ahci drm li
 bsas libahci dca firewire_ohci i2c_algo_bit scsi_transport_sas firewire_core
 crc_itu_t i2c_core libata [last unloaded: mlx4_ib]
 [ 3006.461759] CPU: 16 PID: 11624 Comm: mpi_stress Not tainted 4.7.0-rc5+ #1
 [ 3006.469915] Hardware name: Intel Corporation W2600CR ........../W2600CR, BIOS SE5C600.86B.01.08.0003.022620131521 02/26/2013
 [ 3006.483027] task: ffff8804102f0040 ti: ffff8804102f8000 task.ti: ffff8804102f8000
 [ 3006.491971] RIP: 0010:[<ffffffff810f0383>]  [<ffffffff810f0383>] __lock_acquire+0xb3/0x19e0
 [ 3006.501905] RSP: 0018:ffff8804102fb908  EFLAGS: 00010002
 [ 3006.508447] RAX: 6b6b6b6b6b6b6b6b RBX: 0000000000000001 RCX: 0000000000000000
 [ 3006.517012] RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff880410b56a40
 [ 3006.525569] RBP: ffff8804102fb9b0 R08: 0000000000000001 R09: 0000000000000000
 [ 3006.534119] R10: ffff8804102f0040 R11: 0000000000000000 R12: 0000000000000000
 [ 3006.542664] R13: ffff880410b56a40 R14: 0000000000000000 R15: 0000000000000000
 [ 3006.551203] FS:  00007ff478c08700(0000) GS:ffff88042e200000(0000) knlGS:0000000000000000
 [ 3006.560814] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 [ 3006.567806] CR2: 00007f667f5109e0 CR3: 0000000001c06000 CR4: 00000000000406e0
 [ 3006.576352] Stack:
 [ 3006.579157]  ffffffff8124b819 ffffffffffffffff 0000000000000000 ffff8804102fb940
 [ 3006.588072]  0000000000000002 0000000000000000 ffff8804102f0040 0000000000000007
 [ 3006.596971]  0000000000000006 ffff8803cad6f000 0000000000000000 ffff8804102f0040
 [ 3006.605878] Call Trace:
 [ 3006.609220]  [<ffffffff8124b819>] ? uncharge_batch+0x109/0x250
 [ 3006.616382]  [<ffffffff810f2313>] lock_acquire+0xd3/0x220
 [ 3006.623056]  [<ffffffffa0a30bfc>] ? hfi1_release_user_pages+0x7c/0xa0 [hfi1]
 [ 3006.631593]  [<ffffffff81775579>] down_write+0x49/0x80
 [ 3006.638022]  [<ffffffffa0a30bfc>] ? hfi1_release_user_pages+0x7c/0xa0 [hfi1]
 [ 3006.646569]  [<ffffffffa0a30bfc>] hfi1_release_user_pages+0x7c/0xa0 [hfi1]
 [ 3006.654898]  [<ffffffffa0a2efb6>] cacheless_tid_rb_remove+0x106/0x330 [hfi1]
 [ 3006.663417]  [<ffffffff810efd36>] ? mark_held_locks+0x66/0x90
 [ 3006.670498]  [<ffffffff817771f6>] ? _raw_spin_unlock_irqrestore+0x36/0x60
 [ 3006.678741]  [<ffffffffa0a2f1ee>] tid_rb_remove+0xe/0x10 [hfi1]
 [ 3006.686010]  [<ffffffffa0a0c5d5>] hfi1_mmu_rb_unregister+0xc5/0x100 [hfi1]
 [ 3006.694387]  [<ffffffffa0a2fcb9>] hfi1_user_exp_rcv_free+0x39/0x120 [hfi1]
 [ 3006.702732]  [<ffffffffa09fc6ea>] hfi1_file_close+0x17a/0x330 [hfi1]
 [ 3006.710489]  [<ffffffff81263e9a>] __fput+0xfa/0x230
 [ 3006.716595]  [<ffffffff8126400e>] ____fput+0xe/0x10
 [ 3006.722696]  [<ffffffff810b95c6>] task_work_run+0x86/0xc0
 [ 3006.729379]  [<ffffffff81099933>] do_exit+0x323/0xc40
 [ 3006.735672]  [<ffffffff8109a2dc>] do_group_exit+0x4c/0xc0
 [ 3006.742371]  [<ffffffff810a7f55>] get_signal+0x345/0x940
 [ 3006.748958]  [<ffffffff810340c7>] do_signal+0x37/0x700
 [ 3006.755328]  [<ffffffff8127872a>] ? poll_select_set_timeout+0x5a/0x90
 [ 3006.763146]  [<ffffffff811609cb>] ? __audit_syscall_exit+0x1db/0x260
 [ 3006.770853]  [<ffffffff8110f3e3>] ? rcu_read_lock_sched_held+0x93/0xa0
 [ 3006.778765]  [<ffffffff812347a4>] ? kfree+0x1e4/0x2a0
 [ 3006.784986]  [<ffffffff8108e75a>] ? exit_to_usermode_loop+0x33/0xac
 [ 3006.792551]  [<ffffffff8108e785>] exit_to_usermode_loop+0x5e/0xac
 [ 3006.799907]  [<ffffffff81003dca>] do_syscall_64+0x12a/0x190
 [ 3006.806664]  [<ffffffff81777a7f>] entry_SYSCALL64_slow_path+0x25/0x25
 [ 3006.814396] Code: 24 08 44 89 44 24 10 89 4c 24 18 e8 a8 d8 ff ff 48 85 c0
 8b 4c 24 18 44 8b 44 24 10 44 8b 4c 24 08 4c 8b 14 24 0f 84 30
 08 00 00 <f0> ff 80 98 01 00 00 8b 3d 48 ad be 01 45 8b a2 90 0b 00 00 85
 [ 3006.837158] RIP  [<ffffffff810f0383>] __lock_acquire+0xb3/0x19e0
 [ 3006.844401]  RSP <ffff8804102fb908>
 [ 3006.851170] ---[ end trace b7b9f21cf06c27df ]---
 [ 3006.927420] Kernel panic - not syncing: Fatal exception
 [ 3006.933954] Kernel Offset: disabled
 [ 3006.940961] ---[ end Kernel panic - not syncing: Fatal exception
 [ 3006.948249] ------------[ cut here ]------------

Fixes: 3faa3d9a308e ("IB/hfi1: Make use of mm consistent")
	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e0cf75deab8155334c8228eb7f097b15127d0a49)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/file_ops.c
diff --cc drivers/staging/hfi1/file_ops.c
index 834243df87b3,7e03ccd2554d..000000000000
--- a/drivers/staging/hfi1/file_ops.c
+++ b/drivers/staging/hfi1/file_ops.c
@@@ -194,129 -168,87 +194,144 @@@ static inline int is_valid_mmap(u64 tok
  
  static int hfi1_file_open(struct inode *inode, struct file *fp)
  {
 -	struct hfi1_filedata *fd;
 -	struct hfi1_devdata *dd = container_of(inode->i_cdev,
 -					       struct hfi1_devdata,
 -					       user_cdev);
 -
 -	/* Just take a ref now. Not all opens result in a context assign */
 -	kobject_get(&dd->kobj);
 -
  	/* The real work is performed later in assign_ctxt() */
++<<<<<<< HEAD:drivers/staging/hfi1/file_ops.c
 +	fp->private_data = kzalloc(sizeof(struct hfi1_filedata), GFP_KERNEL);
 +	if (fp->private_data) /* no cpu affinity by default */
 +		((struct hfi1_filedata *)fp->private_data)->rec_cpu_num = -1;
 +	return fp->private_data ? 0 : -ENOMEM;
++=======
+ 
+ 	fd = kzalloc(sizeof(*fd), GFP_KERNEL);
+ 
+ 	if (fd) {
+ 		fd->rec_cpu_num = -1; /* no cpu affinity by default */
+ 		fd->mm = current->mm;
+ 		atomic_inc(&fd->mm->mm_count);
+ 	}
+ 
+ 	fp->private_data = fd;
+ 
+ 	return fd ? 0 : -ENOMEM;
++>>>>>>> e0cf75deab81 (IB/hfi1: Fix mm_struct use after free):drivers/infiniband/hw/hfi1/file_ops.c
  }
  
 -static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,
 -			    unsigned long arg)
 +static ssize_t hfi1_file_write(struct file *fp, const char __user *data,
 +			       size_t count, loff_t *offset)
  {
 +	const struct hfi1_cmd __user *ucmd;
  	struct hfi1_filedata *fd = fp->private_data;
  	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 +	struct hfi1_cmd cmd;
  	struct hfi1_user_info uinfo;
  	struct hfi1_tid_info tinfo;
 -	int ret = 0;
 -	unsigned long addr;
 -	int uval = 0;
 -	unsigned long ul_uval = 0;
 -	u16 uval16 = 0;
 -
 -	hfi1_cdbg(IOCTL, "IOCTL recv: 0x%x", cmd);
 -	if (cmd != HFI1_IOCTL_ASSIGN_CTXT &&
 -	    cmd != HFI1_IOCTL_GET_VERS &&
 -	    !uctxt)
 -		return -EINVAL;
 +	ssize_t consumed = 0, copy = 0, ret = 0;
 +	void *dest = NULL;
 +	__u64 user_val = 0;
 +	int uctxt_required = 1;
 +	int must_be_root = 0;
 +
 +	if (count < sizeof(cmd)) {
 +		ret = -EINVAL;
 +		goto bail;
 +	}
 +
 +	ucmd = (const struct hfi1_cmd __user *)data;
 +	if (copy_from_user(&cmd, ucmd, sizeof(cmd))) {
 +		ret = -EFAULT;
 +		goto bail;
 +	}
 +
 +	consumed = sizeof(cmd);
 +
 +	switch (cmd.type) {
 +	case HFI1_CMD_ASSIGN_CTXT:
 +		uctxt_required = 0;	/* assigned user context not required */
 +		copy = sizeof(uinfo);
 +		dest = &uinfo;
 +		break;
 +	case HFI1_CMD_CREDIT_UPD:
 +		copy = 0;
 +		break;
 +	case HFI1_CMD_TID_UPDATE:
 +	case HFI1_CMD_TID_FREE:
 +		copy = sizeof(tinfo);
 +		dest = &tinfo;
 +		break;
 +	case HFI1_CMD_USER_INFO:
 +	case HFI1_CMD_RECV_CTRL:
 +	case HFI1_CMD_POLL_TYPE:
 +	case HFI1_CMD_ACK_EVENT:
 +	case HFI1_CMD_CTXT_INFO:
 +	case HFI1_CMD_SET_PKEY:
 +	case HFI1_CMD_CTXT_RESET:
 +		copy = 0;
 +		user_val = cmd.addr;
 +		break;
 +	case HFI1_CMD_EP_INFO:
 +	case HFI1_CMD_EP_ERASE_CHIP:
 +	case HFI1_CMD_EP_ERASE_RANGE:
 +	case HFI1_CMD_EP_READ_RANGE:
 +	case HFI1_CMD_EP_WRITE_RANGE:
 +		uctxt_required = 0;	/* assigned user context not required */
 +		must_be_root = 1;	/* validate user */
 +		copy = 0;
 +		break;
 +	case HFI1_CMD_TID_INVAL_READ:
 +	default:
 +		ret = -EINVAL;
 +		goto bail;
 +	}
  
 -	switch (cmd) {
 -	case HFI1_IOCTL_ASSIGN_CTXT:
 -		if (uctxt)
 -			return -EINVAL;
 +	/* If the command comes with user data, copy it. */
 +	if (copy) {
 +		if (copy_from_user(dest, (void __user *)cmd.addr, copy)) {
 +			ret = -EFAULT;
 +			goto bail;
 +		}
 +		consumed += copy;
 +	}
  
 -		if (copy_from_user(&uinfo,
 -				   (struct hfi1_user_info __user *)arg,
 -				   sizeof(uinfo)))
 -			return -EFAULT;
 +	/*
 +	 * Make sure there is a uctxt when needed.
 +	 */
 +	if (uctxt_required && !uctxt) {
 +		ret = -EINVAL;
 +		goto bail;
 +	}
  
 +	/* only root can do these operations */
 +	if (must_be_root && !capable(CAP_SYS_ADMIN)) {
 +		ret = -EPERM;
 +		goto bail;
 +	}
 +
 +	switch (cmd.type) {
 +	case HFI1_CMD_ASSIGN_CTXT:
  		ret = assign_ctxt(fp, &uinfo);
  		if (ret < 0)
 -			return ret;
 +			goto bail;
  		ret = setup_ctxt(fp);
  		if (ret)
 -			return ret;
 +			goto bail;
  		ret = user_init(fp);
  		break;
 -	case HFI1_IOCTL_CTXT_INFO:
 -		ret = get_ctxt_info(fp, (void __user *)(unsigned long)arg,
 -				    sizeof(struct hfi1_ctxt_info));
 +	case HFI1_CMD_CTXT_INFO:
 +		ret = get_ctxt_info(fp, (void __user *)(unsigned long)
 +				    user_val, cmd.len);
  		break;
 -	case HFI1_IOCTL_USER_INFO:
 -		ret = get_base_info(fp, (void __user *)(unsigned long)arg,
 -				    sizeof(struct hfi1_base_info));
 +	case HFI1_CMD_USER_INFO:
 +		ret = get_base_info(fp, (void __user *)(unsigned long)
 +				    user_val, cmd.len);
  		break;
 -	case HFI1_IOCTL_CREDIT_UPD:
 -		if (uctxt)
 +	case HFI1_CMD_CREDIT_UPD:
 +		if (uctxt && uctxt->sc)
  			sc_return_credits(uctxt->sc);
  		break;
 -
 -	case HFI1_IOCTL_TID_UPDATE:
 -		if (copy_from_user(&tinfo,
 -				   (struct hfi11_tid_info __user *)arg,
 -				   sizeof(tinfo)))
 -			return -EFAULT;
 -
 -		ret = hfi1_user_exp_rcv_setup(fp, &tinfo);
 +	case HFI1_CMD_TID_UPDATE:
 +		ret = exp_tid_setup(fp, &tinfo);
  		if (!ret) {
 +			unsigned long addr;
  			/*
  			 * Copy the number of tidlist entries we used
  			 * and the length of the buffer we registered.
@@@ -807,6 -780,8 +822,11 @@@ static int hfi1_file_close(struct inod
  	mutex_unlock(&hfi1_mutex);
  	hfi1_free_ctxtdata(dd, uctxt);
  done:
++<<<<<<< HEAD:drivers/staging/hfi1/file_ops.c
++=======
+ 	mmdrop(fdata->mm);
+ 	kobject_put(&dd->kobj);
++>>>>>>> e0cf75deab81 (IB/hfi1: Fix mm_struct use after free):drivers/infiniband/hw/hfi1/file_ops.c
  	kfree(fdata);
  	return 0;
  }
* Unmerged path drivers/staging/hfi1/file_ops.c
