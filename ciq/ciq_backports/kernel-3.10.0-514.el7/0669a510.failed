KVM: x86: zero apic_arb_prio on reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 0669a51015c58b1f036030743a0c0781eb63867f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0669a510.failed

BSP doesn't get INIT so its apic_arb_prio isn't zeroed after reboot.
BSP won't get lowest priority interrupts until other VCPUs get enough
interrupts to match their pre-reboot apic_arb_prio.

That behavior doesn't fit into KVM's round-robin-like interpretation of
lowest priority delivery ... userspace should KVM_SET_LAPIC on reset, so
just zero apic_arb_prio there.

	Reported-by: Yuki Shibuya <shibuya.yk@ncos.nec.co.jp>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0669a51015c58b1f036030743a0c0781eb63867f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 37f736cffd24,ecd4ea1d28a8..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -1883,7 -1916,10 +1883,14 @@@ void kvm_apic_post_state_restore(struc
  		kvm_x86_ops->hwapic_isr_update(vcpu->kvm,
  				apic_find_highest_isr(apic));
  	kvm_make_request(KVM_REQ_EVENT, vcpu);
++<<<<<<< HEAD
 +	kvm_rtc_eoi_tracking_restore_one(vcpu);
++=======
+ 	if (ioapic_in_kernel(vcpu->kvm))
+ 		kvm_rtc_eoi_tracking_restore_one(vcpu);
+ 
+ 	vcpu->arch.apic_arb_prio = 0;
++>>>>>>> 0669a51015c5 (KVM: x86: zero apic_arb_prio on reset)
  }
  
  void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/lapic.c
