net: cdc_ncm: support rx_max/tx_max updates when running

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjørn Mork <bjorn@mork.no>
commit 68864abf08f06d7cbbabd03740beb383ccf5e5d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/68864abf.failed

Finish the rx_max/tx_max setup by flushing buffers and
informing usbnet about the changes.  This way, the settings
can be modified while the netdev is up and running.

	Signed-off-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 68864abf08f06d7cbbabd03740beb383ccf5e5d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/cdc_ncm.c
diff --cc drivers/net/usb/cdc_ncm.c
index 4bae7ffa5334,2ec3790a4db8..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -68,31 -65,140 +68,163 @@@ static void cdc_ncm_tx_timeout_start(st
  static enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *hr_timer);
  static struct usb_driver cdc_ncm_driver;
  
 -/* handle rx_max and tx_max changes */
 -static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx)
 +static void
 +cdc_ncm_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
 +{
 +	struct usbnet *dev = netdev_priv(net);
 +
 +	strlcpy(info->driver, dev->driver_name, sizeof(info->driver));
 +	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
 +	strlcpy(info->fw_version, dev->driver_info->description,
 +		sizeof(info->fw_version));
 +	usb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));
 +}
 +
 +static u8 cdc_ncm_setup(struct usbnet *dev)
  {
  	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
++<<<<<<< HEAD
 +	u32 val;
 +	u8 flags;
 +	u8 iface_no;
++=======
+ 	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
+ 	u32 val, max, min;
+ 
+ 	/* clamp new_rx to sane values */
+ 	min = USB_CDC_NCM_NTB_MIN_IN_SIZE;
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_RX, le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));
+ 
+ 	/* dwNtbInMaxSize spec violation? Use MIN size for both limits */
+ 	if (max < min) {
+ 		dev_warn(&dev->intf->dev, "dwNtbInMaxSize=%u is too small. Using %u\n",
+ 			 le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize), min);
+ 		max = min;
+ 	}
+ 
+ 	val = clamp_t(u32, new_rx, min, max);
+ 	if (val != new_rx) {
+ 		dev_dbg(&dev->intf->dev, "rx_max must be in the [%u, %u] range. Using %u\n",
+ 			min, max, val);
+ 	}
+ 
+ 	/* usbnet use these values for sizing rx queues */
+ 	dev->rx_urb_size = val;
+ 
+ 	/* inform device about NTB input size changes */
+ 	if (val != ctx->rx_max) {
+ 		__le32 dwNtbInMaxSize = cpu_to_le32(val);
+ 
+ 		dev_info(&dev->intf->dev, "setting rx_max = %u\n", val);
+ 
+ 		/* need to unlink rx urbs before increasing buffer size */
+ 		if (netif_running(dev->net) && dev->rx_urb_size > ctx->rx_max)
+ 			usbnet_unlink_rx_urbs(dev);
+ 
+ 		/* tell device to use new size */
+ 		if (usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,
+ 				     USB_TYPE_CLASS | USB_DIR_OUT
+ 				     | USB_RECIP_INTERFACE,
+ 				     0, iface_no, &dwNtbInMaxSize, 4) < 0)
+ 			dev_dbg(&dev->intf->dev, "Setting NTB Input Size failed\n");
+ 		else
+ 			ctx->rx_max = val;
+ 	}
+ 
+ 	/* clamp new_tx to sane values */
+ 	min = CDC_NCM_MIN_HDR_SIZE + ctx->max_datagram_size;
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_TX, le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));
+ 
+ 	/* some devices set dwNtbOutMaxSize too low for the above default */
+ 	min = min(min, max);
+ 
+ 	val = clamp_t(u32, new_tx, min, max);
+ 	if (val != new_tx) {
+ 		dev_dbg(&dev->intf->dev, "tx_max must be in the [%u, %u] range. Using %u\n",
+ 			min, max, val);
+ 	}
+ 	if (val != ctx->tx_max)
+ 		dev_info(&dev->intf->dev, "setting tx_max = %u\n", val);
+ 
+ 	/* Adding a pad byte here if necessary simplifies the handling
+ 	 * in cdc_ncm_fill_tx_frame, making tx_max always represent
+ 	 * the real skb max size.
+ 	 *
+ 	 * We cannot use dev->maxpacket here because this is called from
+ 	 * .bind which is called before usbnet sets up dev->maxpacket
+ 	 */
+ 	if (val != le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize) &&
+ 	    val % usb_maxpacket(dev->udev, dev->out, 1) == 0)
+ 		val++;
+ 
+ 	/* we might need to flush any pending tx buffers if running */
+ 	if (netif_running(dev->net) && val > ctx->tx_max) {
+ 		netif_tx_lock_bh(dev->net);
+ 		usbnet_start_xmit(NULL, dev->net);
+ 		ctx->tx_max = val;
+ 		netif_tx_unlock_bh(dev->net);
+ 	} else {
+ 		ctx->tx_max = val;
+ 	}
+ 
+ 	dev->hard_mtu = ctx->tx_max;
+ 
+ 	/* max qlen depend on hard_mtu and rx_urb_size */
+ 	usbnet_update_max_qlen(dev);
+ }
+ 
+ /* helpers for NCM and MBIM differences */
+ static u8 cdc_ncm_flags(struct usbnet *dev)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
+ 		return ctx->mbim_desc->bmNetworkCapabilities;
+ 	if (ctx->func_desc)
+ 		return ctx->func_desc->bmNetworkCapabilities;
+ 	return 0;
+ }
+ 
+ static int cdc_ncm_eth_hlen(struct usbnet *dev)
+ {
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
+ 		return 0;
+ 	return ETH_HLEN;
+ }
+ 
+ static u32 cdc_ncm_min_dgram_size(struct usbnet *dev)
+ {
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
+ 		return CDC_MBIM_MIN_DATAGRAM_SIZE;
+ 	return CDC_NCM_MIN_DATAGRAM_SIZE;
+ }
+ 
+ static u32 cdc_ncm_max_dgram_size(struct usbnet *dev)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
+ 		return le16_to_cpu(ctx->mbim_desc->wMaxSegmentSize);
+ 	if (ctx->ether_desc)
+ 		return le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);
+ 	return CDC_NCM_MAX_DATAGRAM_SIZE;
+ }
+ 
+ /* initial one-time device setup.  MUST be called with the data interface
+  * in altsetting 0
+  */
+ static int cdc_ncm_init(struct usbnet *dev)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
++>>>>>>> 68864abf08f0 (net: cdc_ncm: support rx_max/tx_max updates when running)
  	int err;
 +	int eth_hlen;
 +	u16 mbim_mtu;
 +	u16 ntb_fmt_supported;
 +	__le16 max_datagram_size;
 +
 +	iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
  
  	err = usbnet_read_cmd(dev, USB_CDC_GET_NTB_PARAMETERS,
  			      USB_TYPE_CLASS | USB_DIR_IN
* Unmerged path drivers/net/usb/cdc_ncm.c
