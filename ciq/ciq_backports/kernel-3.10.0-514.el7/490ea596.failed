RDS: IB: move FMR code to its own file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author santosh.shilimkar@oracle.com <santosh.shilimkar@oracle.com>
commit 490ea5967b0d94b84747d3327903d31f287f30e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/490ea596.failed

No functional change.

	Signed-off-by: Santosh Shilimkar <ssantosh@kernel.org>
	Signed-off-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 490ea5967b0d94b84747d3327903d31f287f30e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/ib_fmr.c
#	net/rds/ib_mr.h
#	net/rds/ib_rdma.c
diff --cc net/rds/ib_rdma.c
index 676225d1748c,0e848433597f..000000000000
--- a/net/rds/ib_rdma.c
+++ b/net/rds/ib_rdma.c
@@@ -623,10 -330,10 +623,14 @@@ static void list_to_llist_nodes(struct 
   * If the number of MRs allocated exceeds the limit, we also try
   * to free as many MRs as needed to get back to this limit.
   */
 -int rds_ib_flush_mr_pool(struct rds_ib_mr_pool *pool,
 -			 int free_all, struct rds_ib_mr **ibmr_ret)
 +static int rds_ib_flush_mr_pool(struct rds_ib_mr_pool *pool,
 +				int free_all, struct rds_ib_mr **ibmr_ret)
  {
++<<<<<<< HEAD
 +	struct rds_ib_mr *ibmr, *next;
++=======
+ 	struct rds_ib_mr *ibmr;
++>>>>>>> 490ea5967b0d (RDS: IB: move FMR code to its own file)
  	struct llist_node *clean_nodes;
  	struct llist_node *clean_tail;
  	LIST_HEAD(unmap_list);
@@@ -687,30 -392,7 +689,34 @@@
  	if (list_empty(&unmap_list))
  		goto out;
  
++<<<<<<< HEAD
 +	/* String all ib_mr's onto one list and hand them to ib_unmap_fmr */
 +	list_for_each_entry(ibmr, &unmap_list, unmap_list)
 +		list_add(&ibmr->fmr->list, &fmr_list);
 +
 +	ret = ib_unmap_fmr(&fmr_list);
 +	if (ret)
 +		printk(KERN_WARNING "RDS/IB: ib_unmap_fmr failed (err=%d)\n", ret);
 +
 +	/* Now we can destroy the DMA mapping and unpin any pages */
 +	list_for_each_entry_safe(ibmr, next, &unmap_list, unmap_list) {
 +		unpinned += ibmr->sg_len;
 +		__rds_ib_teardown_mr(ibmr);
 +		if (nfreed < free_goal ||
 +		    ibmr->remap_count >= pool->fmr_attr.max_maps) {
 +			if (ibmr->pool->pool_type == RDS_IB_MR_8K_POOL)
 +				rds_ib_stats_inc(s_ib_rdma_mr_8k_free);
 +			else
 +				rds_ib_stats_inc(s_ib_rdma_mr_1m_free);
 +			list_del(&ibmr->unmap_list);
 +			ib_dealloc_fmr(ibmr->fmr);
 +			kfree(ibmr);
 +			nfreed++;
 +		}
 +	}
++=======
+ 	rds_ib_unreg_fmr(&unmap_list, &nfreed, &unpinned, free_goal);
++>>>>>>> 490ea5967b0d (RDS: IB: move FMR code to its own file)
  
  	if (!list_empty(&unmap_list)) {
  		/* we have to make sure that none of the things we're about
@@@ -823,29 -542,17 +866,34 @@@ void *rds_ib_get_mr(struct scatterlist 
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	ibmr = rds_ib_alloc_fmr(rds_ibdev, nents);
 +	if (IS_ERR(ibmr)) {
 +		rds_ib_dev_put(rds_ibdev);
 +		return ibmr;
 +	}
 +
 +	ret = rds_ib_map_fmr(rds_ibdev, ibmr, sg, nents);
 +	if (ret == 0)
 +		*key_ret = ibmr->fmr->rkey;
 +	else
 +		printk(KERN_WARNING "RDS/IB: map_fmr failed (errno=%d)\n", ret);
 +
 +	ibmr->device = rds_ibdev;
 +	rds_ibdev = NULL;
++=======
+ 	ibmr = rds_ib_reg_fmr(rds_ibdev, sg, nents, key_ret);
+ 	if (ibmr)
+ 		rds_ibdev = NULL;
++>>>>>>> 490ea5967b0d (RDS: IB: move FMR code to its own file)
  
   out:
- 	if (ret) {
- 		if (ibmr)
- 			rds_ib_free_mr(ibmr, 0);
- 		ibmr = ERR_PTR(ret);
- 	}
+ 	if (!ibmr)
+ 		pr_warn("RDS/IB: rds_ib_get_mr failed (errno=%d)\n", ret);
+ 
  	if (rds_ibdev)
  		rds_ib_dev_put(rds_ibdev);
+ 
  	return ibmr;
  }
  
* Unmerged path net/rds/ib_fmr.c
* Unmerged path net/rds/ib_mr.h
* Unmerged path net/rds/ib_fmr.c
* Unmerged path net/rds/ib_mr.h
* Unmerged path net/rds/ib_rdma.c
