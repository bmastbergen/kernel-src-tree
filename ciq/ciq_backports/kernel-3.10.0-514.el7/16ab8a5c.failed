vfio/noiommu: Don't use iommu_present() to track fake groups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [vfio] noiommu: Don't use iommu_present() to track fake groups (Alex Williamson) [1299662 1322577]
Rebuild_FUZZ: 95.65%
commit-author Alex Williamson <alex.williamson@redhat.com>
commit 16ab8a5cbea463e4d14bf0ce698f11fa64b70ae1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/16ab8a5c.failed

Using iommu_present() to determine whether an IOMMU group is real or
fake has some problems.  First, apparently Power systems don't
register an IOMMU on the device bus, so the groups and containers get
marked as noiommu and then won't bind to their actual IOMMU driver.
Second, I expect we'll run into the same issue as we try to support
vGPUs through vfio, since they're likely to emulate this behavior of
creating an IOMMU group on a virtual device and then providing a vfio
IOMMU backend tailored to the sort of isolation they provide, which
won't necessarily be fully compatible with the IOMMU API.

The solution here is to use the existing iommudata interface to IOMMU
groups, which allows us to easily identify the fake groups we've
created for noiommu purposes.  The iommudata we set is purely
arbitrary since we're only comparing the address, so we use the
address of the noiommu switch itself.

	Reported-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Tested-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Tested-by: Anatoly Burakov <anatoly.burakov@intel.com>
	Tested-by: Santosh Shukla <sshukla@mvista.com>
Fixes: 03a76b60f8ba ("vfio: Include No-IOMMU mode")
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit 16ab8a5cbea463e4d14bf0ce698f11fa64b70ae1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/vfio.c
diff --cc drivers/vfio/vfio.c
index e49d4b42465f,ecca316386f5..000000000000
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@@ -342,8 -318,7 +337,12 @@@ static void vfio_group_unlock_and_free(
  /**
   * Group objects - create, release, get, put, search
   */
++<<<<<<< HEAD
 +static struct vfio_group *vfio_create_group(struct iommu_group *iommu_group,
 +					    bool noiommu)
++=======
+ static struct vfio_group *vfio_create_group(struct iommu_group *iommu_group)
++>>>>>>> 16ab8a5cbea4 (vfio/noiommu: Don't use iommu_present() to track fake groups)
  {
  	struct vfio_group *group, *tmp;
  	struct device *dev;
@@@ -361,7 -336,9 +360,13 @@@
  	atomic_set(&group->container_users, 0);
  	atomic_set(&group->opened, 0);
  	group->iommu_group = iommu_group;
++<<<<<<< HEAD
 +	group->noiommu = noiommu;
++=======
+ #ifdef CONFIG_VFIO_NOIOMMU
+ 	group->noiommu = (iommu_group_get_iommudata(iommu_group) == &noiommu);
+ #endif
++>>>>>>> 16ab8a5cbea4 (vfio/noiommu: Don't use iommu_present() to track fake groups)
  
  	group->nb.notifier_call = vfio_iommu_group_notifier;
  
@@@ -793,8 -763,7 +798,12 @@@ int vfio_add_group_dev(struct device *d
  
  	group = vfio_group_get_from_iommu(iommu_group);
  	if (!group) {
++<<<<<<< HEAD
 +		group = vfio_create_group(iommu_group,
 +					  !iommu_present(dev->bus));
++=======
+ 		group = vfio_create_group(iommu_group);
++>>>>>>> 16ab8a5cbea4 (vfio/noiommu: Don't use iommu_present() to track fake groups)
  		if (IS_ERR(group)) {
  			iommu_group_put(iommu_group);
  			return PTR_ERR(group);
* Unmerged path drivers/vfio/vfio.c
