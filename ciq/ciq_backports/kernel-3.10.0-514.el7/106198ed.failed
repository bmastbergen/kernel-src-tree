nvme: add explicit quirk handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 106198edb74cdf3fe1aefa6ad1e199b58ab7c4cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/106198ed.failed

Add an enum for all workarounds not in the spec and identify the affected
controllers at probe time.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 106198edb74cdf3fe1aefa6ad1e199b58ab7c4cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,27d74490ff87..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -2411,22 -2026,13 +2411,25 @@@ static void nvme_dev_scan(struct work_s
   */
  static int nvme_dev_add(struct nvme_dev *dev)
  {
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	struct pci_dev *pdev = dev->pci_dev;
++=======
++>>>>>>> 106198edb74c (nvme: add explicit quirk handling):drivers/nvme/host/pci.c
  	int res;
 +	unsigned nn;
  	struct nvme_id_ctrl *ctrl;
 -	int shift = NVME_CAP_MPSMIN(lo_hi_readq(dev->bar + NVME_REG_CAP)) + 12;
 +	void *mem;
 +	dma_addr_t dma_addr;
 +	int shift = NVME_CAP_MPSMIN(readq(&dev->bar->cap)) + 12;
  
 -	res = nvme_identify_ctrl(&dev->ctrl, &ctrl);
 +	mem = dma_alloc_coherent(&pdev->dev, 4096, &dma_addr, GFP_KERNEL);
 +	if (!mem)
 +		return -ENOMEM;
 +
 +	res = nvme_identify(dev, 0, 1, dma_addr);
  	if (res) {
 -		dev_err(dev->dev, "Identify Controller failed (%d)\n", res);
 +		dev_err(&pdev->dev, "Identify Controller failed (%d)\n", res);
 +		dma_free_coherent(&dev->pci_dev->dev, 4096, mem, dma_addr);
  		return -EIO;
  	}
  
@@@ -3123,9 -2712,14 +3126,17 @@@ static int nvme_probe(struct pci_dev *p
  		goto free;
  
  	INIT_LIST_HEAD(&dev->namespaces);
 -	INIT_WORK(&dev->reset_work, nvme_reset_work);
 -	dev->dev = get_device(&pdev->dev);
 +	INIT_WORK(&dev->reset_work, nvme_reset_failed_dev);
 +	dev->pci_dev = pci_dev_get(pdev);
  	pci_set_drvdata(pdev, dev);
++<<<<<<< HEAD:drivers/block/nvme-core.c
++=======
+ 
+ 	dev->ctrl.ops = &nvme_pci_ctrl_ops;
+ 	dev->ctrl.dev = dev->dev;
+ 	dev->ctrl.quirks = id->driver_data;
+ 
++>>>>>>> 106198edb74c (nvme: add explicit quirk handling):drivers/nvme/host/pci.c
  	result = nvme_set_instance(dev);
  	if (result)
  		goto put_pci;
@@@ -3259,7 -2846,10 +3270,9 @@@ static const struct pci_error_handlers 
  #define PCI_CLASS_STORAGE_EXPRESS	0x010802
  
  static const struct pci_device_id nvme_id_table[] = {
+ 	{ PCI_VDEVICE(INTEL, 0x0953),
+ 		.driver_data = NVME_QUIRK_STRIPE_SIZE, },
  	{ PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_EXPRESS, 0xffffff) },
 -	{ PCI_DEVICE(PCI_VENDOR_ID_APPLE, 0x2001) },
  	{ 0, }
  };
  MODULE_DEVICE_TABLE(pci, nvme_id_table);
* Unmerged path drivers/nvme/host/nvme.h
* Unmerged path drivers/block/nvme-core.c
* Unmerged path drivers/nvme/host/nvme.h
