crypto: testmgr - limit IV copy length in aead tests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [crypto] testmgr - limit IV copy length in aead tests (Jerome Marchand) [1340073]
Rebuild_FUZZ: 91.67%
commit-author Cristian Stoica <cristian.stoica@freescale.com>
commit 424a5da6919073392c11345d1b7baa9f31c62734
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/424a5da6.failed

The working copy of IV is the same size as the transformation's IV.
It is not necessary to copy more than that from the template since
iv_len is usually less than MAX_IVLEN and the rest of the copied data
is garbage.

	Signed-off-by: Cristian Stoica <cristian.stoica@freescale.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 424a5da6919073392c11345d1b7baa9f31c62734)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/testmgr.c
diff --cc crypto/testmgr.c
index 5e4cc3e054b1,f4ed6d4205e7..000000000000
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@@ -428,112 -481,116 +428,143 @@@ static int __test_aead(struct crypto_ae
  				  tcrypt_complete, &result);
  
  	for (i = 0, j = 0; i < tcount; i++) {
 -		if (template[i].np)
 -			continue;
 +		if (!template[i].np) {
 +			j++;
  
 -		j++;
 +			/* some tepmplates have no input data but they will
 +			 * touch input
 +			 */
 +			input = xbuf[0];
 +			assoc = axbuf[0];
  
++<<<<<<< HEAD
++=======
+ 		/* some templates have no input data but they will
+ 		 * touch input
+ 		 */
+ 		input = xbuf[0];
+ 		input += align_offset;
+ 		assoc = axbuf[0];
+ 
+ 		ret = -EINVAL;
+ 		if (WARN_ON(align_offset + template[i].ilen >
+ 			    PAGE_SIZE || template[i].alen > PAGE_SIZE))
+ 			goto out;
+ 
+ 		memcpy(input, template[i].input, template[i].ilen);
+ 		memcpy(assoc, template[i].assoc, template[i].alen);
+ 		iv_len = crypto_aead_ivsize(tfm);
+ 		if (template[i].iv)
+ 			memcpy(iv, template[i].iv, iv_len);
+ 		else
+ 			memset(iv, 0, iv_len);
+ 
+ 		crypto_aead_clear_flags(tfm, ~0);
+ 		if (template[i].wk)
+ 			crypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);
+ 
+ 		if (template[i].klen > MAX_KEYLEN) {
+ 			pr_err("alg: aead%s: setkey failed on test %d for %s: key size %d > %d\n",
+ 			       d, j, algo, template[i].klen,
+ 			       MAX_KEYLEN);
++>>>>>>> 424a5da69190 (crypto: testmgr - limit IV copy length in aead tests)
  			ret = -EINVAL;
 -			goto out;
 -		}
 -		memcpy(key, template[i].key, template[i].klen);
 +			if (WARN_ON(template[i].ilen > PAGE_SIZE ||
 +				    template[i].alen > PAGE_SIZE))
 +				goto out;
  
 -		ret = crypto_aead_setkey(tfm, key, template[i].klen);
 -		if (!ret == template[i].fail) {
 -			pr_err("alg: aead%s: setkey failed on test %d for %s: flags=%x\n",
 -			       d, j, algo, crypto_aead_get_flags(tfm));
 -			goto out;
 -		} else if (ret)
 -			continue;
 +			memcpy(input, template[i].input, template[i].ilen);
 +			memcpy(assoc, template[i].assoc, template[i].alen);
 +			if (template[i].iv)
 +				memcpy(iv, template[i].iv, MAX_IVLEN);
 +			else
 +				memset(iv, 0, MAX_IVLEN);
  
 -		authsize = abs(template[i].rlen - template[i].ilen);
 -		ret = crypto_aead_setauthsize(tfm, authsize);
 -		if (ret) {
 -			pr_err("alg: aead%s: Failed to set authsize to %u on test %d for %s\n",
 -			       d, authsize, j, algo);
 -			goto out;
 -		}
 +			crypto_aead_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_aead_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 +
 +			key = template[i].key;
 +
 +			ret = crypto_aead_setkey(tfm, key,
 +						 template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: aead%s: setkey failed on test %d for %s: flags=%x\n",
 +				       d, j, algo, crypto_aead_get_flags(tfm));
 +				goto out;
 +			} else if (ret)
 +				continue;
 +
 +			authsize = abs(template[i].rlen - template[i].ilen);
 +			ret = crypto_aead_setauthsize(tfm, authsize);
 +			if (ret) {
 +				pr_err("alg: aead%s: Failed to set authsize to %u on test %d for %s\n",
 +				       d, authsize, j, algo);
 +				goto out;
 +			}
  
 -		if (diff_dst) {
 -			output = xoutbuf[0];
 -			output += align_offset;
 -			sg_init_one(&sg[0], input, template[i].ilen);
 -			sg_init_one(&sgout[0], output, template[i].rlen);
 -		} else {
  			sg_init_one(&sg[0], input,
  				    template[i].ilen + (enc ? authsize : 0));
 -			output = input;
 -		}
  
 -		sg_init_one(&asg[0], assoc, template[i].alen);
 +			if (diff_dst) {
 +				output = xoutbuf[0];
 +				sg_init_one(&sgout[0], output,
 +					    template[i].ilen +
 +						(enc ? authsize : 0));
 +			} else {
 +				output = input;
 +			}
 +
 +			sg_init_one(&asg[0], assoc, template[i].alen);
  
 -		aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 -				       template[i].ilen, iv);
 +			aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 +					       template[i].ilen, iv);
  
 -		aead_request_set_assoc(req, asg, template[i].alen);
 +			aead_request_set_assoc(req, asg, template[i].alen);
  
 -		ret = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
 +			ret = enc ?
 +				crypto_aead_encrypt(req) :
 +				crypto_aead_decrypt(req);
  
 -		switch (ret) {
 -		case 0:
 -			if (template[i].novrfy) {
 -				/* verification was supposed to fail */
 -				pr_err("alg: aead%s: %s failed on test %d for %s: ret was 0, expected -EBADMSG\n",
 -				       d, e, j, algo);
 -				/* so really, we got a bad message */
 -				ret = -EBADMSG;
 +			switch (ret) {
 +			case 0:
 +				if (template[i].novrfy) {
 +					/* verification was supposed to fail */
 +					pr_err("alg: aead%s: %s failed on test %d for %s: ret was 0, expected -EBADMSG\n",
 +					       d, e, j, algo);
 +					/* so really, we got a bad message */
 +					ret = -EBADMSG;
 +					goto out;
 +				}
 +				break;
 +			case -EINPROGRESS:
 +			case -EBUSY:
 +				ret = wait_for_completion_interruptible(
 +					&result.completion);
 +				if (!ret && !(ret = result.err)) {
 +					INIT_COMPLETION(result.completion);
 +					break;
 +				}
 +			case -EBADMSG:
 +				if (template[i].novrfy)
 +					/* verification failure was expected */
 +					continue;
 +				/* fall through */
 +			default:
 +				pr_err("alg: aead%s: %s failed on test %d for %s: ret=%d\n",
 +				       d, e, j, algo, -ret);
  				goto out;
  			}
 -			break;
 -		case -EINPROGRESS:
 -		case -EBUSY:
 -			wait_for_completion(&result.completion);
 -			reinit_completion(&result.completion);
 -			ret = result.err;
 -			if (!ret)
 -				break;
 -		case -EBADMSG:
 -			if (template[i].novrfy)
 -				/* verification failure was expected */
 -				continue;
 -			/* fall through */
 -		default:
 -			pr_err("alg: aead%s: %s failed on test %d for %s: ret=%d\n",
 -			       d, e, j, algo, -ret);
 -			goto out;
 -		}
  
 -		q = output;
 -		if (memcmp(q, template[i].result, template[i].rlen)) {
 -			pr_err("alg: aead%s: Test %d failed on %s for %s\n",
 -			       d, j, e, algo);
 -			hexdump(q, template[i].rlen);
 -			ret = -EINVAL;
 -			goto out;
 +			q = output;
 +			if (memcmp(q, template[i].result, template[i].rlen)) {
 +				pr_err("alg: aead%s: Test %d failed on %s for %s\n",
 +				       d, j, e, algo);
 +				hexdump(q, template[i].rlen);
 +				ret = -EINVAL;
 +				goto out;
 +			}
  		}
  	}
  
* Unmerged path crypto/testmgr.c
