btrfs: replace remaining do_div calls with div_u64 variants

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author David Sterba <dsterba@suse.cz>
commit 35b850f16d9adbb833775105ec942fbc818ee6a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/35b850f1.failed

Switch to div_u64_rem that does type checking and has more obvious
semantics than do_div.

	Signed-off-by: David Sterba <dsterba@suse.cz>
(cherry picked from commit 35b850f16d9adbb833775105ec942fbc818ee6a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/volumes.c
diff --cc fs/btrfs/volumes.c
index 0455a2c06b77,e79eee9c127e..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -5241,6 -5258,33 +5245,36 @@@ static int __btrfs_map_block(struct btr
  	if (dev_replace_is_ongoing)
  		bbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);
  
++<<<<<<< HEAD
++=======
+ 	/* build raid_map */
+ 	if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&
+ 	    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||
+ 	    mirror_num > 1)) {
+ 		u64 tmp;
+ 		int i, rot;
+ 
+ 		bbio->raid_map = (u64 *)((void *)bbio->stripes +
+ 				 sizeof(struct btrfs_bio_stripe) *
+ 				 num_alloc_stripes +
+ 				 sizeof(int) * tgtdev_indexes);
+ 
+ 		/* Work out the disk rotation on this stripe-set */
+ 		div_u64_rem(stripe_nr, num_stripes, &rot);
+ 
+ 		/* Fill in the logical address of each stripe */
+ 		tmp = stripe_nr * nr_data_stripes(map);
+ 		for (i = 0; i < nr_data_stripes(map); i++)
+ 			bbio->raid_map[(i+rot) % num_stripes] =
+ 				em->start + (tmp + i) * map->stripe_len;
+ 
+ 		bbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;
+ 		if (map->type & BTRFS_BLOCK_GROUP_RAID6)
+ 			bbio->raid_map[(i+rot+1) % num_stripes] =
+ 				RAID6_Q_STRIPE;
+ 	}
+ 
++>>>>>>> 35b850f16d9a (btrfs: replace remaining do_div calls with div_u64 variants)
  	if (rw & REQ_DISCARD) {
  		int factor = 0;
  		int sub_stripes = 0;
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 73349126f84f..fd463d5fb6c3 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -8719,7 +8719,7 @@ int btrfs_can_relocate(struct btrfs_root *root, u64 bytenr)
 		min_free <<= 1;
 	} else if (index == BTRFS_RAID_RAID0) {
 		dev_min = fs_devices->rw_devices;
-		do_div(min_free, dev_min);
+		min_free = div64_u64(min_free, dev_min);
 	}
 
 	/* We need to do this so that we can look at pending chunks */
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index 6e5d0abec6f9..c4558a52ce7d 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -1673,7 +1673,7 @@ find_free_space(struct btrfs_free_space_ctl *ctl, u64 *offset, u64 *bytes,
 		 */
 		if (*bytes >= align) {
 			tmp = entry->offset - ctl->start + align - 1;
-			do_div(tmp, align);
+			tmp = div64_u64(tmp, align);
 			tmp = tmp * align + ctl->start;
 			align_off = tmp - entry->offset;
 		} else {
diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index 5662ab657252..e01f3d7c7eb9 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -2342,7 +2342,7 @@ static inline void __scrub_mark_bitmap(struct scrub_parity *sparity,
 	}
 
 	start -= sparity->logic_start;
-	offset = (int)do_div(start, sparity->stripe_len);
+	start = div_u64_rem(start, sparity->stripe_len, &offset);
 	offset /= sectorsize;
 	nsectors = (int)len / sectorsize;
 
@@ -2642,7 +2642,7 @@ static int get_raid56_logic_offset(u64 physical, int num,
 		do_div(stripe_nr, nr_data_stripes(map));
 
 		/* Work out the disk rotation on this stripe-set */
-		rot = do_div(stripe_nr, map->num_stripes);
+		stripe_nr = div_u64_rem(stripe_nr, map->num_stripes, &rot);
 		/* calculate which stripe this data locates */
 		rot += i;
 		stripe_index = rot % map->num_stripes;
* Unmerged path fs/btrfs/volumes.c
