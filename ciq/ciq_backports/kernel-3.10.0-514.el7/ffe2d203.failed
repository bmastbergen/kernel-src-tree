Btrfs: Introduce BTRFS_BLOCK_GROUP_RAID56_MASK to check raid56 simply

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Zhao Lei <zhaolei@cn.fujitsu.com>
commit ffe2d2034bbb34f49f76c808550fdfbea2ea1659
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ffe2d203.failed

So we can check raid56 with:
 (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)
instead of long:
 (map->type & (BTRFS_BLOCK_GROUP_RAID5 | BTRFS_BLOCK_GROUP_RAID6))

	Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
	Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit ffe2d2034bbb34f49f76c808550fdfbea2ea1659)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/scrub.c
#	fs/btrfs/volumes.c
diff --cc fs/btrfs/scrub.c
index 37f347301744,1ae527c9f8f4..000000000000
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@@ -1282,7 -1273,7 +1282,11 @@@ static inline void scrub_stripe_index_a
  {
  	int i;
  
++<<<<<<< HEAD
 +	if (raid_map) {
++=======
+ 	if (map_type & BTRFS_BLOCK_GROUP_RAID56_MASK) {
++>>>>>>> ffe2d2034bbb (Btrfs: Introduce BTRFS_BLOCK_GROUP_RAID56_MASK to check raid56 simply)
  		/* RAID5/6 */
  		for (i = 0; i < nstripes; i++) {
  			if (raid_map[i] == RAID6_Q_STRIPE ||
@@@ -1433,7 -1419,8 +1437,12 @@@ static void scrub_bio_wait_endio(struc
  
  static inline int scrub_is_page_on_raid56(struct scrub_page *page)
  {
++<<<<<<< HEAD
 +	return page->recover && page->recover->raid_map;
++=======
+ 	return page->recover &&
+ 	       (page->recover->bbio->map_type & BTRFS_BLOCK_GROUP_RAID56_MASK);
++>>>>>>> ffe2d2034bbb (Btrfs: Introduce BTRFS_BLOCK_GROUP_RAID56_MASK to check raid56 simply)
  }
  
  static int scrub_submit_raid56_bio_wait(struct btrfs_fs_info *fs_info,
diff --cc fs/btrfs/volumes.c
index 6efc272f0e6d,da7e0e1107d2..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -5158,15 -5184,10 +5154,20 @@@ static int __btrfs_map_block(struct btr
  			mirror_num = stripe_index - old_stripe_index + 1;
  		}
  
++<<<<<<< HEAD
 +	} else if (map->type & (BTRFS_BLOCK_GROUP_RAID5 |
 +				BTRFS_BLOCK_GROUP_RAID6)) {
 +		u64 tmp;
 +
 +		if (raid_map_ret &&
++=======
+ 	} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {
+ 		if (need_raid_map &&
++>>>>>>> ffe2d2034bbb (Btrfs: Introduce BTRFS_BLOCK_GROUP_RAID56_MASK to check raid56 simply)
  		    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||
  		     mirror_num > 1)) {
 +			int i, rot;
 +
  			/* push stripe_nr back to the start of the full stripe */
  			stripe_nr = raid56_full_stripe_start;
  			do_div(stripe_nr, stripe_len * nr_data_stripes(map));
@@@ -5249,6 -5247,34 +5250,37 @@@
  	if (dev_replace_is_ongoing)
  		bbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);
  
++<<<<<<< HEAD
++=======
+ 	/* build raid_map */
+ 	if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&
+ 	    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||
+ 	    mirror_num > 1)) {
+ 		u64 tmp;
+ 		int i, rot;
+ 
+ 		bbio->raid_map = (u64 *)((void *)bbio->stripes +
+ 				 sizeof(struct btrfs_bio_stripe) *
+ 				 num_alloc_stripes +
+ 				 sizeof(int) * tgtdev_indexes);
+ 
+ 		/* Work out the disk rotation on this stripe-set */
+ 		tmp = stripe_nr;
+ 		rot = do_div(tmp, num_stripes);
+ 
+ 		/* Fill in the logical address of each stripe */
+ 		tmp = stripe_nr * nr_data_stripes(map);
+ 		for (i = 0; i < nr_data_stripes(map); i++)
+ 			bbio->raid_map[(i+rot) % num_stripes] =
+ 				em->start + (tmp + i) * map->stripe_len;
+ 
+ 		bbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;
+ 		if (map->type & BTRFS_BLOCK_GROUP_RAID6)
+ 			bbio->raid_map[(i+rot+1) % num_stripes] =
+ 				RAID6_Q_STRIPE;
+ 	}
+ 
++>>>>>>> ffe2d2034bbb (Btrfs: Introduce BTRFS_BLOCK_GROUP_RAID56_MASK to check raid56 simply)
  	if (rw & REQ_DISCARD) {
  		int factor = 0;
  		int sub_stripes = 0;
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index ac2fc74ec942..8ad622a66b8b 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -1020,6 +1020,9 @@ enum btrfs_raid_types {
 					 BTRFS_BLOCK_GROUP_RAID6 |   \
 					 BTRFS_BLOCK_GROUP_DUP |     \
 					 BTRFS_BLOCK_GROUP_RAID10)
+#define BTRFS_BLOCK_GROUP_RAID56_MASK	(BTRFS_BLOCK_GROUP_RAID5 |   \
+					 BTRFS_BLOCK_GROUP_RAID6)
+
 /*
  * We need a bit for restriper to be able to tell when chunks of type
  * SINGLE are available.  This "extended" profile format is used in
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index c2fbf124af56..831ec9ffac01 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -7801,8 +7801,7 @@ static int btrfs_submit_direct_hook(int rw, struct btrfs_dio_private *dip,
 	}
 
 	/* async crcs make it difficult to collect full stripe writes. */
-	if (btrfs_get_alloc_profile(root, 1) &
-	    (BTRFS_BLOCK_GROUP_RAID5 | BTRFS_BLOCK_GROUP_RAID6))
+	if (btrfs_get_alloc_profile(root, 1) & BTRFS_BLOCK_GROUP_RAID56_MASK)
 		async_submit = 0;
 	else
 		async_submit = 1;
* Unmerged path fs/btrfs/scrub.c
* Unmerged path fs/btrfs/volumes.c
