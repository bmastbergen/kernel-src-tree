r8152: replace tasklet with NAPI

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author hayeswang <hayeswang@realtek.com>
commit d823ab68fbb0fa504a2490bd499ac921bdf497d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d823ab68.failed

Replace tasklet with NAPI.

Add rx_queue to queue the remaining rx packets if the number of the
rx packets is more than the request from poll().

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d823ab68fbb0fa504a2490bd499ac921bdf497d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index 85c8afddef6e,2e2244221cbe..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -25,11 -24,12 +25,15 @@@
  #include <net/ip6_checksum.h>
  #include <uapi/linux/mdio.h>
  #include <linux/mdio.h>
 -#include <linux/usb/cdc.h>
  
  /* Version Information */
++<<<<<<< HEAD
 +#define DRIVER_VERSION "v1.06.0 (2014/03/03)"
++=======
+ #define DRIVER_VERSION "v1.08.0 (2015/01/13)"
++>>>>>>> d823ab68fbb0 (r8152: replace tasklet with NAPI)
  #define DRIVER_AUTHOR "Realtek linux nic maintainers <nic_swsd@realtek.com>"
 -#define DRIVER_DESC "Realtek RTL8152/RTL8153 Based USB Ethernet Adapters"
 +#define DRIVER_DESC "Realtek RTL8152 Based USB 2.0 Ethernet Adapters"
  #define MODULENAME "r8152"
  
  #define R8152_PHY_ID		32
@@@ -433,8 -443,12 +437,9 @@@ enum rtl_register_content 
  #define BYTE_EN_START_MASK	0x0f
  #define BYTE_EN_END_MASK	0xf0
  
 -#define RTL8153_MAX_PACKET	9216 /* 9K */
 -#define RTL8153_MAX_MTU		(RTL8153_MAX_PACKET - VLAN_ETH_HLEN - VLAN_HLEN)
  #define RTL8152_RMS		(VLAN_ETH_FRAME_LEN + VLAN_HLEN)
 -#define RTL8153_RMS		RTL8153_MAX_PACKET
  #define RTL8152_TX_TIMEOUT	(5 * HZ)
+ #define RTL8152_NAPI_WEIGHT	64
  
  /* rtl8152 flags */
  enum rtl8152_flags {
@@@ -1972,6 -2053,55 +2021,58 @@@ static void rxdy_gated_en(struct r8152 
  	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MISC_1, ocp_data);
  }
  
++<<<<<<< HEAD
++=======
+ static int rtl_start_rx(struct r8152 *tp)
+ {
+ 	int i, ret = 0;
+ 
+ 	napi_disable(&tp->napi);
+ 	INIT_LIST_HEAD(&tp->rx_done);
+ 	for (i = 0; i < RTL8152_MAX_RX; i++) {
+ 		INIT_LIST_HEAD(&tp->rx_info[i].list);
+ 		ret = r8152_submit_rx(tp, &tp->rx_info[i], GFP_KERNEL);
+ 		if (ret)
+ 			break;
+ 	}
+ 	napi_enable(&tp->napi);
+ 
+ 	if (ret && ++i < RTL8152_MAX_RX) {
+ 		struct list_head rx_queue;
+ 		unsigned long flags;
+ 
+ 		INIT_LIST_HEAD(&rx_queue);
+ 
+ 		do {
+ 			struct rx_agg *agg = &tp->rx_info[i++];
+ 			struct urb *urb = agg->urb;
+ 
+ 			urb->actual_length = 0;
+ 			list_add_tail(&agg->list, &rx_queue);
+ 		} while (i < RTL8152_MAX_RX);
+ 
+ 		spin_lock_irqsave(&tp->rx_lock, flags);
+ 		list_splice_tail(&rx_queue, &tp->rx_done);
+ 		spin_unlock_irqrestore(&tp->rx_lock, flags);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int rtl_stop_rx(struct r8152 *tp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < RTL8152_MAX_RX; i++)
+ 		usb_kill_urb(tp->rx_info[i].urb);
+ 
+ 	while (!skb_queue_empty(&tp->rx_queue))
+ 		dev_kfree_skb(__skb_dequeue(&tp->rx_queue));
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d823ab68fbb0 (r8152: replace tasklet with NAPI)
  static int rtl_enable(struct r8152 *tp)
  {
  	u32 ocp_data;
@@@ -2919,8 -3033,12 +3021,13 @@@ static int rtl8152_open(struct net_devi
  		netif_warn(tp, ifup, netdev, "intr_urb submit failed: %d\n",
  			   res);
  		free_all_mem(tp);
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		napi_enable(&tp->napi);
++>>>>>>> d823ab68fbb0 (r8152: replace tasklet with NAPI)
  	}
  
 -	mutex_unlock(&tp->control);
 -
  	usb_autopm_put_interface(tp->intf);
  
  out:
@@@ -2932,6 -3050,7 +3039,10 @@@ static int rtl8152_close(struct net_dev
  	struct r8152 *tp = netdev_priv(netdev);
  	int res = 0;
  
++<<<<<<< HEAD
++=======
+ 	napi_disable(&tp->napi);
++>>>>>>> d823ab68fbb0 (r8152: replace tasklet with NAPI)
  	clear_bit(WORK_ENABLE, &tp->flags);
  	usb_kill_urb(tp->intr_urb);
  	cancel_delayed_work_sync(&tp->schedule);
@@@ -2940,7 -3059,10 +3051,8 @@@
  	res = usb_autopm_get_interface(tp->intf);
  	if (res < 0) {
  		rtl_drop_queued_tx(tp);
+ 		rtl_stop_rx(tp);
  	} else {
 -		mutex_lock(&tp->control);
 -
  		/* The autosuspend may have been enabled and wouldn't
  		 * be disable when autoresume occurs, because the
  		 * netif_running() would be false.
@@@ -3162,26 -3296,39 +3274,34 @@@ static void r8153_init(struct r8152 *tp
  static int rtl8152_suspend(struct usb_interface *intf, pm_message_t message)
  {
  	struct r8152 *tp = usb_get_intfdata(intf);
 -	struct net_device *netdev = tp->netdev;
 -	int ret = 0;
 -
 -	mutex_lock(&tp->control);
 -
 -	if (PMSG_IS_AUTO(message)) {
 -		if (netif_running(netdev) && work_busy(&tp->schedule.work)) {
 -			ret = -EBUSY;
 -			goto out1;
 -		}
  
 +	if (PMSG_IS_AUTO(message))
  		set_bit(SELECTIVE_SUSPEND, &tp->flags);
 -	} else {
 -		netif_device_detach(netdev);
 -	}
 +	else
 +		netif_device_detach(tp->netdev);
  
 -	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
 +	if (netif_running(tp->netdev)) {
  		clear_bit(WORK_ENABLE, &tp->flags);
  		usb_kill_urb(tp->intr_urb);
++<<<<<<< HEAD
 +		cancel_delayed_work_sync(&tp->schedule);
++=======
+ 		napi_disable(&tp->napi);
++>>>>>>> d823ab68fbb0 (r8152: replace tasklet with NAPI)
  		if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
 -			rtl_stop_rx(tp);
  			rtl_runtime_suspend_enable(tp, true);
  		} else {
 -			cancel_delayed_work_sync(&tp->schedule);
 +			tasklet_disable(&tp->tl);
  			tp->rtl_ops.down(tp);
 +			tasklet_enable(&tp->tl);
  		}
++<<<<<<< HEAD
++=======
+ 		napi_enable(&tp->napi);
++>>>>>>> d823ab68fbb0 (r8152: replace tasklet with NAPI)
  	}
 -out1:
 -	mutex_unlock(&tp->control);
  
 -	return ret;
 +	return 0;
  }
  
  static int rtl8152_resume(struct usb_interface *intf)
@@@ -3539,7 -3907,7 +3659,11 @@@ static int rtl8152_probe(struct usb_int
  	if (ret)
  		goto out;
  
++<<<<<<< HEAD
 +	tasklet_init(&tp->tl, bottom_half, (unsigned long)tp);
++=======
+ 	mutex_init(&tp->control);
++>>>>>>> d823ab68fbb0 (r8152: replace tasklet with NAPI)
  	INIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);
  
  	netdev->netdev_ops = &rtl8152_netdev_ops;
* Unmerged path drivers/net/usb/r8152.c
