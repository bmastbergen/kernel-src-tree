ipv4: Fix compilation errors in fib_rebalance

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Nørlund <pch@ordbogen.com>
commit 0a837fe4724713ef701e47d6bfab98a5efaff3eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0a837fe4.failed

This fixes

net/built-in.o: In function `fib_rebalance':
fib_semantics.c:(.text+0x9df14): undefined reference to `__divdi3'

and

net/built-in.o: In function `fib_rebalance':
net/ipv4/fib_semantics.c:572: undefined reference to `__aeabi_ldivmod'

Fixes: 0e884c78ee19 ("ipv4: L3 hash-based multipath")

	Signed-off-by: Peter Nørlund <pch@ordbogen.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0a837fe4724713ef701e47d6bfab98a5efaff3eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_semantics.c
diff --cc net/ipv4/fib_semantics.c
index c1ff5dc475fa,7bd698c3bd3a..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -479,9 -523,99 +479,97 @@@ static int fib_get_nhs(struct fib_info 
  	} endfor_nexthops(fi);
  
  	return 0;
 -
 -err_inval:
 -	ret = -EINVAL;
 -
 -errout:
 -	return ret;
  }
  
++<<<<<<< HEAD
 +#endif
++=======
+ static void fib_rebalance(struct fib_info *fi)
+ {
+ 	int total;
+ 	int w;
+ 	struct in_device *in_dev;
+ 
+ 	if (fi->fib_nhs < 2)
+ 		return;
+ 
+ 	total = 0;
+ 	for_nexthops(fi) {
+ 		if (nh->nh_flags & RTNH_F_DEAD)
+ 			continue;
+ 
+ 		in_dev = __in_dev_get_rcu(nh->nh_dev);
+ 
+ 		if (in_dev &&
+ 		    IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&
+ 		    nh->nh_flags & RTNH_F_LINKDOWN)
+ 			continue;
+ 
+ 		total += nh->nh_weight;
+ 	} endfor_nexthops(fi);
+ 
+ 	w = 0;
+ 	change_nexthops(fi) {
+ 		int upper_bound;
+ 
+ 		in_dev = __in_dev_get_rcu(nexthop_nh->nh_dev);
+ 
+ 		if (nexthop_nh->nh_flags & RTNH_F_DEAD) {
+ 			upper_bound = -1;
+ 		} else if (in_dev &&
+ 			   IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&
+ 			   nexthop_nh->nh_flags & RTNH_F_LINKDOWN) {
+ 			upper_bound = -1;
+ 		} else {
+ 			w += nexthop_nh->nh_weight;
+ 			upper_bound = DIV_ROUND_CLOSEST_ULL((u64)w << 31,
+ 							    total) - 1;
+ 		}
+ 
+ 		atomic_set(&nexthop_nh->nh_upper_bound, upper_bound);
+ 	} endfor_nexthops(fi);
+ 
+ 	net_get_random_once(&fib_multipath_secret,
+ 			    sizeof(fib_multipath_secret));
+ }
+ 
+ static inline void fib_add_weight(struct fib_info *fi,
+ 				  const struct fib_nh *nh)
+ {
+ 	fi->fib_weight += nh->nh_weight;
+ }
+ 
+ #else /* CONFIG_IP_ROUTE_MULTIPATH */
+ 
+ #define fib_rebalance(fi) do { } while (0)
+ #define fib_add_weight(fi, nh) do { } while (0)
+ 
+ #endif /* CONFIG_IP_ROUTE_MULTIPATH */
+ 
+ static int fib_encap_match(struct net *net, u16 encap_type,
+ 			   struct nlattr *encap,
+ 			   int oif, const struct fib_nh *nh,
+ 			   const struct fib_config *cfg)
+ {
+ 	struct lwtunnel_state *lwtstate;
+ 	struct net_device *dev = NULL;
+ 	int ret, result = 0;
+ 
+ 	if (encap_type == LWTUNNEL_ENCAP_NONE)
+ 		return 0;
+ 
+ 	if (oif)
+ 		dev = __dev_get_by_index(net, oif);
+ 	ret = lwtunnel_build_state(dev, encap_type, encap,
+ 				   AF_INET, cfg, &lwtstate);
+ 	if (!ret) {
+ 		result = lwtunnel_cmp_encap(lwtstate, nh->nh_lwtstate);
+ 		lwtstate_free(lwtstate);
+ 	}
+ 
+ 	return result;
+ }
++>>>>>>> 0a837fe47247 (ipv4: Fix compilation errors in fib_rebalance)
  
  int fib_nh_match(struct fib_config *cfg, struct fib_info *fi)
  {
* Unmerged path net/ipv4/fib_semantics.c
