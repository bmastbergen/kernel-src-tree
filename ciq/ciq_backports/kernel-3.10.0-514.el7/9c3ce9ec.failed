ext2: get rid of most mentions of XIP in ext2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew Wilcox <matthew.r.wilcox@intel.com>
commit 9c3ce9ec58716733232b97771b10f31901caf62e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9c3ce9ec.failed

To help people transition, accept the 'xip' mount option (and report it in
/proc/mounts), but print a message encouraging people to switch over to
the 'dax' option.

	Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Andreas Dilger <andreas.dilger@intel.com>
	Cc: Boaz Harrosh <boaz@plexistor.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9c3ce9ec58716733232b97771b10f31901caf62e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext2/ext2.h
#	fs/ext2/file.c
#	fs/ext2/inode.c
#	fs/ext2/namei.c
#	fs/ext2/super.c
diff --cc fs/ext2/ext2.h
index d9a17d0b124d,678f9ab08c48..000000000000
--- a/fs/ext2/ext2.h
+++ b/fs/ext2/ext2.h
@@@ -380,7 -380,7 +380,11 @@@ struct ext2_inode 
  #define EXT2_MOUNT_NO_UID32		0x000200  /* Disable 32-bit UIDs */
  #define EXT2_MOUNT_XATTR_USER		0x004000  /* Extended user attributes */
  #define EXT2_MOUNT_POSIX_ACL		0x008000  /* POSIX Access Control Lists */
++<<<<<<< HEAD
 +#define EXT2_MOUNT_XIP			0x010000  /* Execute in place */
++=======
+ #define EXT2_MOUNT_XIP			0x010000  /* Obsolete, use DAX */
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  #define EXT2_MOUNT_USRQUOTA		0x020000  /* user quota */
  #define EXT2_MOUNT_GRPQUOTA		0x040000  /* group quota */
  #define EXT2_MOUNT_RESERVATION		0x080000  /* Preallocation */
diff --cc fs/ext2/file.c
index a5b3a5db3120,e31701713516..000000000000
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@@ -75,14 -105,16 +75,19 @@@ const struct file_operations ext2_file_
  	.release	= ext2_release_file,
  	.fsync		= ext2_fsync,
  	.splice_read	= generic_file_splice_read,
 -	.splice_write	= iter_file_splice_write,
 +	.splice_write	= generic_file_splice_write,
  };
  
++<<<<<<< HEAD
 +#ifdef CONFIG_EXT2_FS_XIP
 +const struct file_operations ext2_xip_file_operations = {
++=======
+ #ifdef CONFIG_FS_DAX
+ const struct file_operations ext2_dax_file_operations = {
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  	.llseek		= generic_file_llseek,
 -	.read		= new_sync_read,
 -	.write		= new_sync_write,
 -	.read_iter	= generic_file_read_iter,
 -	.write_iter	= generic_file_write_iter,
 +	.read		= xip_file_read,
 +	.write		= xip_file_write,
  	.unlocked_ioctl = ext2_ioctl,
  #ifdef CONFIG_COMPAT
  	.compat_ioctl	= ext2_compat_ioctl,
diff --cc fs/ext2/inode.c
index 115fa58bb9ae,6434bc000125..000000000000
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@@ -1282,6 -1286,8 +1282,11 @@@ void ext2_set_inode_flags(struct inode 
  		inode->i_flags |= S_NOATIME;
  	if (flags & EXT2_DIRSYNC_FL)
  		inode->i_flags |= S_DIRSYNC;
++<<<<<<< HEAD
++=======
+ 	if (test_opt(inode->i_sb, DAX))
+ 		inode->i_flags |= S_DAX;
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  }
  
  /* Propagate flags from i_flags to EXT2_I(inode)->i_flags */
@@@ -1382,9 -1388,9 +1387,15 @@@ struct inode *ext2_iget (struct super_b
  
  	if (S_ISREG(inode->i_mode)) {
  		inode->i_op = &ext2_file_inode_operations;
++<<<<<<< HEAD
 +		if (ext2_use_xip(inode->i_sb)) {
 +			inode->i_mapping->a_ops = &ext2_aops_xip;
 +			inode->i_fop = &ext2_xip_file_operations;
++=======
+ 		if (test_opt(inode->i_sb, DAX)) {
+ 			inode->i_mapping->a_ops = &ext2_aops;
+ 			inode->i_fop = &ext2_dax_file_operations;
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  		} else if (test_opt(inode->i_sb, NOBH)) {
  			inode->i_mapping->a_ops = &ext2_nobh_aops;
  			inode->i_fop = &ext2_file_operations;
diff --cc fs/ext2/namei.c
index 73b0d9519836,148f6e3789ea..000000000000
--- a/fs/ext2/namei.c
+++ b/fs/ext2/namei.c
@@@ -105,9 -104,9 +105,15 @@@ static int ext2_create (struct inode * 
  		return PTR_ERR(inode);
  
  	inode->i_op = &ext2_file_inode_operations;
++<<<<<<< HEAD
 +	if (ext2_use_xip(inode->i_sb)) {
 +		inode->i_mapping->a_ops = &ext2_aops_xip;
 +		inode->i_fop = &ext2_xip_file_operations;
++=======
+ 	if (test_opt(inode->i_sb, DAX)) {
+ 		inode->i_mapping->a_ops = &ext2_aops;
+ 		inode->i_fop = &ext2_dax_file_operations;
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  	} else if (test_opt(inode->i_sb, NOBH)) {
  		inode->i_mapping->a_ops = &ext2_nobh_aops;
  		inode->i_fop = &ext2_file_operations;
@@@ -119,6 -118,29 +125,32 @@@
  	return ext2_add_nondir(dentry, inode);
  }
  
++<<<<<<< HEAD
++=======
+ static int ext2_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)
+ {
+ 	struct inode *inode = ext2_new_inode(dir, mode, NULL);
+ 	if (IS_ERR(inode))
+ 		return PTR_ERR(inode);
+ 
+ 	inode->i_op = &ext2_file_inode_operations;
+ 	if (test_opt(inode->i_sb, DAX)) {
+ 		inode->i_mapping->a_ops = &ext2_aops;
+ 		inode->i_fop = &ext2_dax_file_operations;
+ 	} else if (test_opt(inode->i_sb, NOBH)) {
+ 		inode->i_mapping->a_ops = &ext2_nobh_aops;
+ 		inode->i_fop = &ext2_file_operations;
+ 	} else {
+ 		inode->i_mapping->a_ops = &ext2_aops;
+ 		inode->i_fop = &ext2_file_operations;
+ 	}
+ 	mark_inode_dirty(inode);
+ 	d_tmpfile(dentry, inode);
+ 	unlock_new_inode(inode);
+ 	return 0;
+ }
+ 
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  static int ext2_mknod (struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)
  {
  	struct inode * inode;
diff --cc fs/ext2/super.c
index a47e9381bae0,d0e746e96511..000000000000
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@@ -288,9 -291,11 +288,11 @@@ static int ext2_show_options(struct seq
  		seq_puts(seq, ",grpquota");
  #endif
  
 -#ifdef CONFIG_FS_DAX
 +#if defined(CONFIG_EXT2_FS_XIP)
  	if (sbi->s_mount_opt & EXT2_MOUNT_XIP)
  		seq_puts(seq, ",xip");
+ 	if (sbi->s_mount_opt & EXT2_MOUNT_DAX)
+ 		seq_puts(seq, ",dax");
  #endif
  
  	if (!test_opt(sb, RESERVATION))
@@@ -550,10 -561,14 +553,19 @@@ static int parse_options(char *options
  			break;
  #endif
  		case Opt_xip:
++<<<<<<< HEAD
 +#ifdef CONFIG_EXT2_FS_XIP
 +			set_opt (sbi->s_mount_opt, XIP);
++=======
+ 			ext2_msg(sb, KERN_INFO, "use dax instead of xip");
+ 			set_opt(sbi->s_mount_opt, XIP);
+ 			/* Fall through */
+ 		case Opt_dax:
+ #ifdef CONFIG_FS_DAX
+ 			set_opt(sbi->s_mount_opt, DAX);
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  #else
- 			ext2_msg(sb, KERN_INFO, "xip option not supported");
+ 			ext2_msg(sb, KERN_INFO, "dax option not supported");
  #endif
  			break;
  
@@@ -900,11 -912,17 +912,25 @@@ static int ext2_fill_super(struct super
  
  	blocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);
  
++<<<<<<< HEAD
 +	if (ext2_use_xip(sb) && blocksize != PAGE_SIZE) {
 +		if (!silent)
 +			ext2_msg(sb, KERN_ERR,
 +				"error: unsupported blocksize for xip");
 +		goto failed_mount;
++=======
+ 	if (sbi->s_mount_opt & EXT2_MOUNT_DAX) {
+ 		if (blocksize != PAGE_SIZE) {
+ 			ext2_msg(sb, KERN_ERR,
+ 					"error: unsupported blocksize for dax");
+ 			goto failed_mount;
+ 		}
+ 		if (!sb->s_bdev->bd_disk->fops->direct_access) {
+ 			ext2_msg(sb, KERN_ERR,
+ 					"error: device does not support dax");
+ 			goto failed_mount;
+ 		}
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  	}
  
  	/* If the blocksize doesn't match, re-read the thing.. */
@@@ -1273,22 -1292,11 +1299,29 @@@ static int ext2_remount (struct super_b
  	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
  		((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
  
 +	ext2_xip_verify_sb(sb); /* see if bdev supports xip, unset
 +				    EXT2_MOUNT_XIP if not */
 +
 +	if ((ext2_use_xip(sb)) && (sb->s_blocksize != PAGE_SIZE)) {
 +		ext2_msg(sb, KERN_WARNING,
 +			"warning: unsupported blocksize for xip");
 +		err = -EINVAL;
 +		goto restore_opts;
 +	}
 +
  	es = sbi->s_es;
++<<<<<<< HEAD
 +	if ((sbi->s_mount_opt ^ old_mount_opt) & EXT2_MOUNT_XIP) {
 +		ext2_msg(sb, KERN_WARNING, "warning: refusing change of "
 +			 "xip flag with busy inodes while remounting");
 +		sbi->s_mount_opt &= ~EXT2_MOUNT_XIP;
 +		sbi->s_mount_opt |= old_mount_opt & EXT2_MOUNT_XIP;
++=======
+ 	if ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT2_MOUNT_DAX) {
+ 		ext2_msg(sb, KERN_WARNING, "warning: refusing change of "
+ 			 "dax flag with busy inodes while remounting");
+ 		sbi->s_mount_opt ^= EXT2_MOUNT_DAX;
++>>>>>>> 9c3ce9ec5871 (ext2: get rid of most mentions of XIP in ext2)
  	}
  	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {
  		spin_unlock(&sbi->s_lock);
diff --git a/Documentation/filesystems/ext2.txt b/Documentation/filesystems/ext2.txt
index 67639f905f10..b9714569e472 100644
--- a/Documentation/filesystems/ext2.txt
+++ b/Documentation/filesystems/ext2.txt
@@ -20,6 +20,9 @@ minixdf				Makes `df' act like Minix.
 check=none, nocheck	(*)	Don't do extra checking of bitmaps on mount
 				(check=normal and check=strict options removed)
 
+dax				Use direct access (no page cache).  See
+				Documentation/filesystems/dax.txt.
+
 debug				Extra debugging information is sent to the
 				kernel syslog.  Useful for developers.
 
@@ -56,8 +59,6 @@ noacl				Don't support POSIX ACLs.
 
 nobh				Do not attach buffer_heads to file pagecache.
 
-xip				Use execute in place (no caching) if possible
-
 grpquota,noquota,quota,usrquota	Quota options are silently ignored by ext2.
 
 
* Unmerged path fs/ext2/ext2.h
* Unmerged path fs/ext2/file.c
* Unmerged path fs/ext2/inode.c
* Unmerged path fs/ext2/namei.c
* Unmerged path fs/ext2/super.c
