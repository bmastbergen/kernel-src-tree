nvme: split __nvme_submit_sync_cmd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 4160982e7594481d6b7f90aa693638a37d20ea17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4160982e.failed

Add a separate nvme_submit_user_cmd for commands that directly DMA
to or from userspace.  We'll add metadata support to that soon and
the common version would become too messy.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 4160982e7594481d6b7f90aa693638a37d20ea17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
#	drivers/block/nvme-scsi.c
#	drivers/nvme/host/core.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,91e013b8de23..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1704,21 -1695,17 +1704,27 @@@ static int nvme_submit_io(struct nvme_n
  	c.rw.reftag = cpu_to_le32(io.reftag);
  	c.rw.apptag = cpu_to_le16(io.apptag);
  	c.rw.appmask = cpu_to_le16(io.appmask);
 +	c.rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
 +	c.rw.prp2 = cpu_to_le64(iod->first_dma);
  	c.rw.metadata = cpu_to_le64(meta_dma);
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	status = nvme_submit_sync_cmd(ns->queue, &c);
++=======
+ 
+ 	status = nvme_submit_user_cmd(ns->queue, &c,
+ 			(void __user *)(uintptr_t)io.addr, length, NULL, 0);
++>>>>>>> 4160982e7594 (nvme: split __nvme_submit_sync_cmd):drivers/nvme/host/pci.c
   unmap:
 +	nvme_unmap_user_pages(dev, write, iod);
 +	nvme_free_iod(dev, iod);
 +
  	if (meta) {
  		if (status == NVME_SC_SUCCESS && !write) {
 -			if (copy_to_user(metadata, meta, meta_len))
 +			if (copy_to_user((void __user *)io.metadata, meta,
 +					 meta_len))
  				status = -EFAULT;
  		}
 -		dma_free_coherent(dev->dev, meta_len, meta, meta_dma);
 +		dma_free_coherent(&dev->pci_dev->dev, meta_len, meta, meta_dma);
  	}
  	return status;
  }
@@@ -1750,38 -1736,17 +1756,50 @@@ static int nvme_user_cmd(struct nvme_de
  	c.common.cdw10[4] = cpu_to_le32(cmd.cdw14);
  	c.common.cdw10[5] = cpu_to_le32(cmd.cdw15);
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	length = cmd.data_len;
 +	if (cmd.data_len) {
 +		iod = nvme_map_user_pages(dev, cmd.opcode & 1, cmd.addr,
 +								length);
 +		if (IS_ERR(iod))
 +			return PTR_ERR(iod);
 +		length = nvme_setup_prps(dev, iod, length, GFP_KERNEL);
 +		c.common.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
 +		c.common.prp2 = cpu_to_le64(iod->first_dma);
++=======
+ 	if (cmd.timeout_ms)
+ 		timeout = msecs_to_jiffies(cmd.timeout_ms);
+ 
+ 	status = nvme_submit_user_cmd(ns ? ns->queue : ctrl->admin_q, &c,
+ 			(void __user *)(uintptr_t)cmd.addr, cmd.data_len,
+ 			&cmd.result, timeout);
+ 	if (status >= 0) {
+ 		if (put_user(cmd.result, &ucmd->result))
+ 			return -EFAULT;
++>>>>>>> 4160982e7594 (nvme: split __nvme_submit_sync_cmd):drivers/nvme/host/pci.c
 +	}
 +
 +	timeout = cmd.timeout_ms ? msecs_to_jiffies(cmd.timeout_ms) :
 +								ADMIN_TIMEOUT;
 +
 +	if (length != cmd.data_len) {
 +		status = -ENOMEM;
 +		goto out;
 +	}
 +
 +	status = __nvme_submit_sync_cmd(ns ? ns->queue : dev->admin_q, &c,
 +					&cmd.result, timeout);
 +
 +out:
 +	if (cmd.data_len) {
 +		nvme_unmap_user_pages(dev, cmd.opcode & 1, iod);
 +		nvme_free_iod(dev, iod);
  	}
  
 +	if ((status >= 0) && copy_to_user(&ucmd->result, &cmd.result,
 +							sizeof(cmd.result)))
 +		status = -EFAULT;
 +
  	return status;
  }
  
diff --cc drivers/block/nvme-scsi.c
index daa0d50b3bfd,eaf725610fe2..000000000000
--- a/drivers/block/nvme-scsi.c
+++ b/drivers/block/nvme-scsi.c
@@@ -1418,13 -1327,9 +1418,19 @@@ static int nvme_trans_send_download_fw_
  	c.dlfw.numd = cpu_to_le32((tot_len/BYTES_TO_DWORDS) - 1);
  	c.dlfw.offset = cpu_to_le32(offset/BYTES_TO_DWORDS);
  
++<<<<<<< HEAD:drivers/block/nvme-scsi.c
 +	nvme_sc = nvme_submit_sync_cmd(dev->admin_q, &c);
 +	res = nvme_trans_status_code(hdr, nvme_sc);
 +
 + out_unmap:
 +	nvme_unmap_user_pages(dev, DMA_TO_DEVICE, iod);
 +	nvme_free_iod(dev, iod);
 +	return res;
++=======
+ 	nvme_sc = nvme_submit_user_cmd(ns->ctrl->admin_q, &c,
+ 			hdr->dxferp, tot_len, NULL, 0);
+ 	return nvme_trans_status_code(hdr, nvme_sc);
++>>>>>>> 4160982e7594 (nvme: split __nvme_submit_sync_cmd):drivers/nvme/host/scsi.c
  }
  
  /* Mode Select Helper Functions */
@@@ -1850,35 -1726,17 +1856,42 @@@ static int nvme_trans_do_nvme_io(struc
  		control = nvme_trans_io_get_control(ns, cdb_info);
  		c.rw.control = cpu_to_le16(control);
  
 -		if (get_capacity(ns->disk) - unit_num_blocks <
 -				cdb_info->lba + nvme_offset) {
 -			nvme_sc = NVME_SC_LBA_RANGE;
 -			break;
 +		iod = nvme_map_user_pages(dev,
 +			(is_write) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,
 +			(unsigned long)next_mapping_addr, unit_len);
 +		if (IS_ERR(iod))
 +			return PTR_ERR(iod);
 +
 +		retcode = nvme_setup_prps(dev, iod, unit_len, GFP_KERNEL);
 +		if (retcode != unit_len) {
 +			nvme_unmap_user_pages(dev,
 +				(is_write) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,
 +				iod);
 +			nvme_free_iod(dev, iod);
 +			return -ENOMEM;
  		}
++<<<<<<< HEAD:drivers/block/nvme-scsi.c
 +		c.rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
 +		c.rw.prp2 = cpu_to_le64(iod->first_dma);
++=======
+ 		nvme_sc = nvme_submit_user_cmd(ns->queue, &c,
+ 				next_mapping_addr, unit_len, NULL, 0);
+ 		if (nvme_sc)
+ 			break;
++>>>>>>> 4160982e7594 (nvme: split __nvme_submit_sync_cmd):drivers/nvme/host/scsi.c
  
  		nvme_offset += unit_num_blocks;
 +
 +		nvme_sc = nvme_submit_sync_cmd(ns->queue, &c);
 +
 +		nvme_unmap_user_pages(dev,
 +				(is_write) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,
 +				iod);
 +		nvme_free_iod(dev, iod);
 +
 +
 +		if (nvme_sc != NVME_SC_SUCCESS)
 +			break;
  	}
  
  	return nvme_trans_status_code(hdr, nvme_sc);
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/nvme.h
* Unmerged path drivers/block/nvme-core.c
* Unmerged path drivers/block/nvme-scsi.c
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/nvme.h
