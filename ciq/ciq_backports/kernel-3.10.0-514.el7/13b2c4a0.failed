PM / QoS: Make it possible to expose device latency tolerance to userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 13b2c4a0c3b1cd37ee6bcfbb5b6e2b94e9a75364
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/13b2c4a0.failed

Typically when a device is created the bus core it belongs to (for example
PCI) does not know if the device supports things like latency tolerance.
This is left to the driver that binds to the device in question. However,
at that time the device has already been created and there is no way to set
its dev->power.set_latency_tolerance anymore.

So follow what has been done for other PM QoS attributes as well and allow
drivers to expose and hide latency tolerance from userspace, if the device
supports it.

	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Lee Jones <lee.jones@linaro.org>
(cherry picked from commit 13b2c4a0c3b1cd37ee6bcfbb5b6e2b94e9a75364)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/power.h
#	drivers/base/power/qos.c
#	include/linux/pm_qos.h
diff --cc drivers/base/power/power.h
index cfc3226ec492,998fa6b23084..000000000000
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@@ -20,7 -20,63 +20,67 @@@ static inline void pm_runtime_early_ini
  extern void pm_runtime_init(struct device *dev);
  extern void pm_runtime_remove(struct device *dev);
  
++<<<<<<< HEAD
 +#else /* !CONFIG_PM_RUNTIME */
++=======
+ struct wake_irq {
+ 	struct device *dev;
+ 	int irq;
+ 	bool dedicated_irq:1;
+ };
+ 
+ extern void dev_pm_arm_wake_irq(struct wake_irq *wirq);
+ extern void dev_pm_disarm_wake_irq(struct wake_irq *wirq);
+ 
+ #ifdef CONFIG_PM_SLEEP
+ 
+ extern int device_wakeup_attach_irq(struct device *dev,
+ 				    struct wake_irq *wakeirq);
+ extern void device_wakeup_detach_irq(struct device *dev);
+ extern void device_wakeup_arm_wake_irqs(void);
+ extern void device_wakeup_disarm_wake_irqs(void);
+ 
+ #else
+ 
+ static inline int
+ device_wakeup_attach_irq(struct device *dev,
+ 			 struct wake_irq *wakeirq)
+ {
+ 	return 0;
+ }
+ 
+ static inline void device_wakeup_detach_irq(struct device *dev)
+ {
+ }
+ 
+ static inline void device_wakeup_arm_wake_irqs(void)
+ {
+ }
+ 
+ static inline void device_wakeup_disarm_wake_irqs(void)
+ {
+ }
+ 
+ #endif /* CONFIG_PM_SLEEP */
+ 
+ /*
+  * sysfs.c
+  */
+ 
+ extern int dpm_sysfs_add(struct device *dev);
+ extern void dpm_sysfs_remove(struct device *dev);
+ extern void rpm_sysfs_remove(struct device *dev);
+ extern int wakeup_sysfs_add(struct device *dev);
+ extern void wakeup_sysfs_remove(struct device *dev);
+ extern int pm_qos_sysfs_add_resume_latency(struct device *dev);
+ extern void pm_qos_sysfs_remove_resume_latency(struct device *dev);
+ extern int pm_qos_sysfs_add_flags(struct device *dev);
+ extern void pm_qos_sysfs_remove_flags(struct device *dev);
+ extern int pm_qos_sysfs_add_latency_tolerance(struct device *dev);
+ extern void pm_qos_sysfs_remove_latency_tolerance(struct device *dev);
+ 
+ #else /* CONFIG_PM */
++>>>>>>> 13b2c4a0c3b1 (PM / QoS: Make it possible to expose device latency tolerance to userspace)
  
  static inline void pm_runtime_early_init(struct device *dev)
  {
diff --cc drivers/base/power/qos.c
index 3c215fa0aecf,7f3646e459cb..000000000000
--- a/drivers/base/power/qos.c
+++ b/drivers/base/power/qos.c
@@@ -868,7 -883,40 +868,47 @@@ int dev_pm_qos_update_user_latency_tole
  	mutex_unlock(&dev_pm_qos_mtx);
  	return ret;
  }
++<<<<<<< HEAD
 +#else /* !CONFIG_PM_RUNTIME */
 +static void __dev_pm_qos_hide_latency_limit(struct device *dev) {}
 +static void __dev_pm_qos_hide_flags(struct device *dev) {}
 +#endif /* CONFIG_PM_RUNTIME */
++=======
+ 
+ /**
+  * dev_pm_qos_expose_latency_tolerance - Expose latency tolerance to userspace
+  * @dev: Device whose latency tolerance to expose
+  */
+ int dev_pm_qos_expose_latency_tolerance(struct device *dev)
+ {
+ 	int ret;
+ 
+ 	if (!dev->power.set_latency_tolerance)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&dev_pm_qos_sysfs_mtx);
+ 	ret = pm_qos_sysfs_add_latency_tolerance(dev);
+ 	mutex_unlock(&dev_pm_qos_sysfs_mtx);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(dev_pm_qos_expose_latency_tolerance);
+ 
+ /**
+  * dev_pm_qos_hide_latency_tolerance - Hide latency tolerance from userspace
+  * @dev: Device whose latency tolerance to hide
+  */
+ void dev_pm_qos_hide_latency_tolerance(struct device *dev)
+ {
+ 	mutex_lock(&dev_pm_qos_sysfs_mtx);
+ 	pm_qos_sysfs_remove_latency_tolerance(dev);
+ 	mutex_unlock(&dev_pm_qos_sysfs_mtx);
+ 
+ 	/* Remove the request from user space now */
+ 	pm_runtime_get_sync(dev);
+ 	dev_pm_qos_update_user_latency_tolerance(dev,
+ 		PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT);
+ 	pm_runtime_put(dev);
+ }
+ EXPORT_SYMBOL_GPL(dev_pm_qos_hide_latency_tolerance);
++>>>>>>> 13b2c4a0c3b1 (PM / QoS: Make it possible to expose device latency tolerance to userspace)
diff --cc include/linux/pm_qos.h
index 5ae622835cb1,0f65d36c2a75..000000000000
--- a/include/linux/pm_qos.h
+++ b/include/linux/pm_qos.h
@@@ -150,7 -152,27 +150,31 @@@ int dev_pm_qos_remove_global_notifier(s
  void dev_pm_qos_constraints_init(struct device *dev);
  void dev_pm_qos_constraints_destroy(struct device *dev);
  int dev_pm_qos_add_ancestor_request(struct device *dev,
++<<<<<<< HEAD
 +				    struct dev_pm_qos_request *req, s32 value);
++=======
+ 				    struct dev_pm_qos_request *req,
+ 				    enum dev_pm_qos_req_type type, s32 value);
+ int dev_pm_qos_expose_latency_limit(struct device *dev, s32 value);
+ void dev_pm_qos_hide_latency_limit(struct device *dev);
+ int dev_pm_qos_expose_flags(struct device *dev, s32 value);
+ void dev_pm_qos_hide_flags(struct device *dev);
+ int dev_pm_qos_update_flags(struct device *dev, s32 mask, bool set);
+ s32 dev_pm_qos_get_user_latency_tolerance(struct device *dev);
+ int dev_pm_qos_update_user_latency_tolerance(struct device *dev, s32 val);
+ int dev_pm_qos_expose_latency_tolerance(struct device *dev);
+ void dev_pm_qos_hide_latency_tolerance(struct device *dev);
+ 
+ static inline s32 dev_pm_qos_requested_resume_latency(struct device *dev)
+ {
+ 	return dev->power.qos->resume_latency_req->data.pnode.prio;
+ }
+ 
+ static inline s32 dev_pm_qos_requested_flags(struct device *dev)
+ {
+ 	return dev->power.qos->flags_req->data.flr.flags;
+ }
++>>>>>>> 13b2c4a0c3b1 (PM / QoS: Make it possible to expose device latency tolerance to userspace)
  #else
  static inline enum pm_qos_flags_status __dev_pm_qos_flags(struct device *dev,
  							  s32 mask)
@@@ -228,8 -231,11 +252,11 @@@ static inline s32 dev_pm_qos_get_user_l
  			{ return PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT; }
  static inline int dev_pm_qos_update_user_latency_tolerance(struct device *dev, s32 val)
  			{ return 0; }
+ static inline int dev_pm_qos_expose_latency_tolerance(struct device *dev)
+ 			{ return 0; }
+ static inline void dev_pm_qos_hide_latency_tolerance(struct device *dev) {}
  
 -static inline s32 dev_pm_qos_requested_resume_latency(struct device *dev) { return 0; }
 +static inline s32 dev_pm_qos_requested_latency(struct device *dev) { return 0; }
  static inline s32 dev_pm_qos_requested_flags(struct device *dev) { return 0; }
  #endif
  
* Unmerged path drivers/base/power/power.h
* Unmerged path drivers/base/power/qos.c
diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index 6da7b66fc41f..7e4b937bbe4b 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -751,6 +751,17 @@ void pm_qos_sysfs_remove_flags(struct device *dev)
 	sysfs_unmerge_group(&dev->kobj, &pm_qos_flags_attr_group);
 }
 
+int pm_qos_sysfs_add_latency_tolerance(struct device *dev)
+{
+	return sysfs_merge_group(&dev->kobj,
+				 &pm_qos_latency_tolerance_attr_group);
+}
+
+void pm_qos_sysfs_remove_latency_tolerance(struct device *dev)
+{
+	sysfs_unmerge_group(&dev->kobj, &pm_qos_latency_tolerance_attr_group);
+}
+
 void rpm_sysfs_remove(struct device *dev)
 {
 	sysfs_unmerge_group(&dev->kobj, &pm_runtime_attr_group);
* Unmerged path include/linux/pm_qos.h
