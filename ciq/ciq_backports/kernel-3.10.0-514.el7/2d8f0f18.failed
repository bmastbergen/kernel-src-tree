perf tools: Add stat round user level event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 2d8f0f18a5c37cf0322cb385b99adb1167b7cf78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2d8f0f18.failed

Adding the stat round event to be stored after each stat interval round,
so that report tools (report/script) gets notified and process interval
data.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1445784728-21732-18-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2d8f0f18a5c37cf0322cb385b99adb1167b7cf78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/event.c
#	tools/perf/util/event.h
#	tools/perf/util/session.c
#	tools/perf/util/tool.h
diff --cc tools/perf/util/event.c
index 763fbcde76fc,725db548c7d5..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -35,6 -39,11 +35,14 @@@ static const char *perf_event__names[] 
  	[PERF_RECORD_AUXTRACE_INFO]		= "AUXTRACE_INFO",
  	[PERF_RECORD_AUXTRACE]			= "AUXTRACE",
  	[PERF_RECORD_AUXTRACE_ERROR]		= "AUXTRACE_ERROR",
++<<<<<<< HEAD
++=======
+ 	[PERF_RECORD_THREAD_MAP]		= "THREAD_MAP",
+ 	[PERF_RECORD_CPU_MAP]			= "CPU_MAP",
+ 	[PERF_RECORD_STAT_CONFIG]		= "STAT_CONFIG",
+ 	[PERF_RECORD_STAT]			= "STAT",
+ 	[PERF_RECORD_STAT_ROUND]		= "STAT_ROUND",
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  };
  
  const char *perf_event__name(unsigned int id)
diff --cc tools/perf/util/event.h
index 9400ef1c1335,5eb4f55a141d..000000000000
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@@ -226,6 -226,11 +226,14 @@@ enum perf_user_event_type { /* above an
  	PERF_RECORD_AUXTRACE_INFO		= 70,
  	PERF_RECORD_AUXTRACE			= 71,
  	PERF_RECORD_AUXTRACE_ERROR		= 72,
++<<<<<<< HEAD
++=======
+ 	PERF_RECORD_THREAD_MAP			= 73,
+ 	PERF_RECORD_CPU_MAP			= 74,
+ 	PERF_RECORD_STAT_CONFIG			= 75,
+ 	PERF_RECORD_STAT			= 76,
+ 	PERF_RECORD_STAT_ROUND			= 77,
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  	PERF_RECORD_HEADER_MAX
  };
  
@@@ -350,6 -381,69 +358,72 @@@ struct itrace_start_event 
  	u32 pid, tid;
  };
  
++<<<<<<< HEAD
++=======
+ struct context_switch_event {
+ 	struct perf_event_header header;
+ 	u32 next_prev_pid;
+ 	u32 next_prev_tid;
+ };
+ 
+ struct thread_map_event_entry {
+ 	u64	pid;
+ 	char	comm[16];
+ };
+ 
+ struct thread_map_event {
+ 	struct perf_event_header	header;
+ 	u64				nr;
+ 	struct thread_map_event_entry	entries[];
+ };
+ 
+ enum {
+ 	PERF_STAT_CONFIG_TERM__AGGR_MODE	= 0,
+ 	PERF_STAT_CONFIG_TERM__INTERVAL		= 1,
+ 	PERF_STAT_CONFIG_TERM__SCALE		= 2,
+ 	PERF_STAT_CONFIG_TERM__MAX		= 3,
+ };
+ 
+ struct stat_config_event_entry {
+ 	u64	tag;
+ 	u64	val;
+ };
+ 
+ struct stat_config_event {
+ 	struct perf_event_header	header;
+ 	u64				nr;
+ 	struct stat_config_event_entry	data[];
+ };
+ 
+ struct stat_event {
+ 	struct perf_event_header	header;
+ 
+ 	u64	id;
+ 	u32	cpu;
+ 	u32	thread;
+ 
+ 	union {
+ 		struct {
+ 			u64 val;
+ 			u64 ena;
+ 			u64 run;
+ 		};
+ 		u64 values[3];
+ 	};
+ };
+ 
+ enum {
+ 	PERF_STAT_ROUND_TYPE__INTERVAL	= 0,
+ 	PERF_STAT_ROUND_TYPE__FINAL	= 1,
+ };
+ 
+ struct stat_round_event {
+ 	struct perf_event_header	header;
+ 	u64				type;
+ 	u64				time;
+ };
+ 
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  union perf_event {
  	struct perf_event_header	header;
  	struct mmap_event		mmap;
@@@ -371,6 -465,12 +445,15 @@@
  	struct auxtrace_error_event	auxtrace_error;
  	struct aux_event		aux;
  	struct itrace_start_event	itrace_start;
++<<<<<<< HEAD
++=======
+ 	struct context_switch_event	context_switch;
+ 	struct thread_map_event		thread_map;
+ 	struct cpu_map_event		cpu_map;
+ 	struct stat_config_event	stat_config;
+ 	struct stat_event		stat;
+ 	struct stat_round_event		stat_round;
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  };
  
  void perf_event__print_totals(void);
diff --cc tools/perf/util/session.c
index 5c19125e63db,5b3a81a6b795..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -296,6 -296,52 +296,55 @@@ int process_event_auxtrace_error_stub(s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ static
+ int process_event_thread_map_stub(struct perf_tool *tool __maybe_unused,
+ 				  union perf_event *event __maybe_unused,
+ 				  struct perf_session *session __maybe_unused)
+ {
+ 	dump_printf(": unhandled!\n");
+ 	return 0;
+ }
+ 
+ static
+ int process_event_cpu_map_stub(struct perf_tool *tool __maybe_unused,
+ 			       union perf_event *event __maybe_unused,
+ 			       struct perf_session *session __maybe_unused)
+ {
+ 	dump_printf(": unhandled!\n");
+ 	return 0;
+ }
+ 
+ static
+ int process_event_stat_config_stub(struct perf_tool *tool __maybe_unused,
+ 				   union perf_event *event __maybe_unused,
+ 				   struct perf_session *session __maybe_unused)
+ {
+ 	dump_printf(": unhandled!\n");
+ 	return 0;
+ }
+ 
+ static int process_stat_stub(struct perf_tool *tool __maybe_unused,
+ 			     union perf_event *event __maybe_unused,
+ 			     struct perf_session *perf_session
+ 			     __maybe_unused)
+ {
+ 	dump_printf(": unhandled!\n");
+ 	return 0;
+ }
+ 
+ static int process_stat_round_stub(struct perf_tool *tool __maybe_unused,
+ 				   union perf_event *event __maybe_unused,
+ 				   struct perf_session *perf_session
+ 				   __maybe_unused)
+ {
+ 	dump_printf(": unhandled!\n");
+ 	return 0;
+ }
+ 
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  void perf_tool__fill_defaults(struct perf_tool *tool)
  {
  	if (tool->sample == NULL)
@@@ -344,6 -392,16 +393,19 @@@
  		tool->auxtrace = process_event_auxtrace_stub;
  	if (tool->auxtrace_error == NULL)
  		tool->auxtrace_error = process_event_auxtrace_error_stub;
++<<<<<<< HEAD
++=======
+ 	if (tool->thread_map == NULL)
+ 		tool->thread_map = process_event_thread_map_stub;
+ 	if (tool->cpu_map == NULL)
+ 		tool->cpu_map = process_event_cpu_map_stub;
+ 	if (tool->stat_config == NULL)
+ 		tool->stat_config = process_event_stat_config_stub;
+ 	if (tool->stat == NULL)
+ 		tool->stat = process_stat_stub;
+ 	if (tool->stat_round == NULL)
+ 		tool->stat_round = process_stat_round_stub;
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  }
  
  static void swap_sample_id_all(union perf_event *event, void *data)
@@@ -601,6 -672,81 +663,84 @@@ static void perf_event__auxtrace_error_
  	event->auxtrace_error.ip   = bswap_64(event->auxtrace_error.ip);
  }
  
++<<<<<<< HEAD
++=======
+ static void perf_event__thread_map_swap(union perf_event *event,
+ 					bool sample_id_all __maybe_unused)
+ {
+ 	unsigned i;
+ 
+ 	event->thread_map.nr = bswap_64(event->thread_map.nr);
+ 
+ 	for (i = 0; i < event->thread_map.nr; i++)
+ 		event->thread_map.entries[i].pid = bswap_64(event->thread_map.entries[i].pid);
+ }
+ 
+ static void perf_event__cpu_map_swap(union perf_event *event,
+ 				     bool sample_id_all __maybe_unused)
+ {
+ 	struct cpu_map_data *data = &event->cpu_map.data;
+ 	struct cpu_map_entries *cpus;
+ 	struct cpu_map_mask *mask;
+ 	unsigned i;
+ 
+ 	data->type = bswap_64(data->type);
+ 
+ 	switch (data->type) {
+ 	case PERF_CPU_MAP__CPUS:
+ 		cpus = (struct cpu_map_entries *)data->data;
+ 
+ 		cpus->nr = bswap_16(cpus->nr);
+ 
+ 		for (i = 0; i < cpus->nr; i++)
+ 			cpus->cpu[i] = bswap_16(cpus->cpu[i]);
+ 		break;
+ 	case PERF_CPU_MAP__MASK:
+ 		mask = (struct cpu_map_mask *) data->data;
+ 
+ 		mask->nr = bswap_16(mask->nr);
+ 		mask->long_size = bswap_16(mask->long_size);
+ 
+ 		switch (mask->long_size) {
+ 		case 4: mem_bswap_32(&mask->mask, mask->nr); break;
+ 		case 8: mem_bswap_64(&mask->mask, mask->nr); break;
+ 		default:
+ 			pr_err("cpu_map swap: unsupported long size\n");
+ 		}
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void perf_event__stat_config_swap(union perf_event *event,
+ 					 bool sample_id_all __maybe_unused)
+ {
+ 	u64 size;
+ 
+ 	size  = event->stat_config.nr * sizeof(event->stat_config.data[0]);
+ 	size += 1; /* nr item itself */
+ 	mem_bswap_64(&event->stat_config.nr, size);
+ }
+ 
+ static void perf_event__stat_swap(union perf_event *event,
+ 				  bool sample_id_all __maybe_unused)
+ {
+ 	event->stat.id     = bswap_64(event->stat.id);
+ 	event->stat.thread = bswap_32(event->stat.thread);
+ 	event->stat.cpu    = bswap_32(event->stat.cpu);
+ 	event->stat.val    = bswap_64(event->stat.val);
+ 	event->stat.ena    = bswap_64(event->stat.ena);
+ 	event->stat.run    = bswap_64(event->stat.run);
+ }
+ 
+ static void perf_event__stat_round_swap(union perf_event *event,
+ 					bool sample_id_all __maybe_unused)
+ {
+ 	event->stat_round.type = bswap_64(event->stat_round.type);
+ 	event->stat_round.time = bswap_64(event->stat_round.time);
+ }
+ 
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  typedef void (*perf_event__swap_op)(union perf_event *event,
  				    bool sample_id_all);
  
@@@ -626,6 -774,11 +766,14 @@@ static perf_event__swap_op perf_event__
  	[PERF_RECORD_AUXTRACE_INFO]	  = perf_event__auxtrace_info_swap,
  	[PERF_RECORD_AUXTRACE]		  = perf_event__auxtrace_swap,
  	[PERF_RECORD_AUXTRACE_ERROR]	  = perf_event__auxtrace_error_swap,
++<<<<<<< HEAD
++=======
+ 	[PERF_RECORD_THREAD_MAP]	  = perf_event__thread_map_swap,
+ 	[PERF_RECORD_CPU_MAP]		  = perf_event__cpu_map_swap,
+ 	[PERF_RECORD_STAT_CONFIG]	  = perf_event__stat_config_swap,
+ 	[PERF_RECORD_STAT]		  = perf_event__stat_swap,
+ 	[PERF_RECORD_STAT_ROUND]	  = perf_event__stat_round_swap,
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  	[PERF_RECORD_HEADER_MAX]	  = NULL,
  };
  
@@@ -1159,6 -1315,16 +1307,19 @@@ static s64 perf_session__process_user_e
  	case PERF_RECORD_AUXTRACE_ERROR:
  		perf_session__auxtrace_error_inc(session, event);
  		return tool->auxtrace_error(tool, event, session);
++<<<<<<< HEAD
++=======
+ 	case PERF_RECORD_THREAD_MAP:
+ 		return tool->thread_map(tool, event, session);
+ 	case PERF_RECORD_CPU_MAP:
+ 		return tool->cpu_map(tool, event, session);
+ 	case PERF_RECORD_STAT_CONFIG:
+ 		return tool->stat_config(tool, event, session);
+ 	case PERF_RECORD_STAT:
+ 		return tool->stat(tool, event, session);
+ 	case PERF_RECORD_STAT_ROUND:
+ 		return tool->stat_round(tool, event, session);
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  	default:
  		return -EINVAL;
  	}
diff --cc tools/perf/util/tool.h
index c307dd438286,d04d9e5f444a..000000000000
--- a/tools/perf/util/tool.h
+++ b/tools/perf/util/tool.h
@@@ -54,7 -55,12 +54,16 @@@ struct perf_tool 
  	event_op2	build_id,
  			id_index,
  			auxtrace_info,
++<<<<<<< HEAD
 +			auxtrace_error;
++=======
+ 			auxtrace_error,
+ 			thread_map,
+ 			cpu_map,
+ 			stat_config,
+ 			stat,
+ 			stat_round;
++>>>>>>> 2d8f0f18a5c3 (perf tools: Add stat round user level event)
  	event_op3	auxtrace;
  	bool		ordered_events;
  	bool		ordering_requires_timestamps;
* Unmerged path tools/perf/util/event.c
* Unmerged path tools/perf/util/event.h
* Unmerged path tools/perf/util/session.c
* Unmerged path tools/perf/util/tool.h
