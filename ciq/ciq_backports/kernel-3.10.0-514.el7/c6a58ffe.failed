RDS: TCP: Add sysctl tunables for sndbuf/rcvbuf on rds-tcp socket

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sowmini Varadhan <sowmini.varadhan@oracle.com>
commit c6a58ffed53612be86b758df1cdb0b0f4305e9cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c6a58ffe.failed

Add per-net sysctl tunables to set the size of sndbuf and
rcvbuf on the kernel tcp socket.

The tunables are added at /proc/sys/net/rds/tcp/rds_tcp_sndbuf
and /proc/sys/net/rds/tcp/rds_tcp_rcvbuf.

These values must be set before accept() or connect(),
and there may be an arbitrary number of existing rds-tcp
sockets when the tunable is modified. To make sure that all
connections in the netns pick up the same value for the tunable,
we reset existing rds-tcp connections in the netns, so that
they can reconnect with the new parameters.

	Signed-off-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c6a58ffed53612be86b758df1cdb0b0f4305e9cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/tcp.c
diff --cc net/rds/tcp.c
index 0f9cb6d5a317,380278540465..000000000000
--- a/net/rds/tcp.c
+++ b/net/rds/tcp.c
@@@ -273,6 -286,241 +293,244 @@@ struct rds_transport rds_tcp_transport 
  	.t_prefer_loopback	= 1,
  };
  
++<<<<<<< HEAD
++=======
+ static int rds_tcp_netid;
+ 
+ /* per-network namespace private data for this module */
+ struct rds_tcp_net {
+ 	struct socket *rds_tcp_listen_sock;
+ 	struct work_struct rds_tcp_accept_w;
+ 	struct ctl_table_header *rds_tcp_sysctl;
+ 	struct ctl_table *ctl_table;
+ 	int sndbuf_size;
+ 	int rcvbuf_size;
+ };
+ 
+ /* All module specific customizations to the RDS-TCP socket should be done in
+  * rds_tcp_tune() and applied after socket creation.
+  */
+ void rds_tcp_tune(struct socket *sock)
+ {
+ 	struct sock *sk = sock->sk;
+ 	struct net *net = sock_net(sk);
+ 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);
+ 
+ 	rds_tcp_nonagle(sock);
+ 	lock_sock(sk);
+ 	if (rtn->sndbuf_size > 0) {
+ 		sk->sk_sndbuf = rtn->sndbuf_size;
+ 		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
+ 	}
+ 	if (rtn->rcvbuf_size > 0) {
+ 		sk->sk_sndbuf = rtn->rcvbuf_size;
+ 		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
+ 	}
+ 	release_sock(sk);
+ }
+ 
+ static void rds_tcp_accept_worker(struct work_struct *work)
+ {
+ 	struct rds_tcp_net *rtn = container_of(work,
+ 					       struct rds_tcp_net,
+ 					       rds_tcp_accept_w);
+ 
+ 	while (rds_tcp_accept_one(rtn->rds_tcp_listen_sock) == 0)
+ 		cond_resched();
+ }
+ 
+ void rds_tcp_accept_work(struct sock *sk)
+ {
+ 	struct net *net = sock_net(sk);
+ 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);
+ 
+ 	queue_work(rds_wq, &rtn->rds_tcp_accept_w);
+ }
+ 
+ static __net_init int rds_tcp_init_net(struct net *net)
+ {
+ 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);
+ 	struct ctl_table *tbl;
+ 	int err = 0;
+ 
+ 	memset(rtn, 0, sizeof(*rtn));
+ 
+ 	/* {snd, rcv}buf_size default to 0, which implies we let the
+ 	 * stack pick the value, and permit auto-tuning of buffer size.
+ 	 */
+ 	if (net == &init_net) {
+ 		tbl = rds_tcp_sysctl_table;
+ 	} else {
+ 		tbl = kmemdup(rds_tcp_sysctl_table,
+ 			      sizeof(rds_tcp_sysctl_table), GFP_KERNEL);
+ 		if (!tbl) {
+ 			pr_warn("could not set allocate syctl table\n");
+ 			return -ENOMEM;
+ 		}
+ 		rtn->ctl_table = tbl;
+ 	}
+ 	tbl[RDS_TCP_SNDBUF].data = &rtn->sndbuf_size;
+ 	tbl[RDS_TCP_RCVBUF].data = &rtn->rcvbuf_size;
+ 	rtn->rds_tcp_sysctl = register_net_sysctl(net, "net/rds/tcp", tbl);
+ 	if (!rtn->rds_tcp_sysctl) {
+ 		pr_warn("could not register sysctl\n");
+ 		err = -ENOMEM;
+ 		goto fail;
+ 	}
+ 	rtn->rds_tcp_listen_sock = rds_tcp_listen_init(net);
+ 	if (!rtn->rds_tcp_listen_sock) {
+ 		pr_warn("could not set up listen sock\n");
+ 		unregister_net_sysctl_table(rtn->rds_tcp_sysctl);
+ 		rtn->rds_tcp_sysctl = NULL;
+ 		err = -EAFNOSUPPORT;
+ 		goto fail;
+ 	}
+ 	INIT_WORK(&rtn->rds_tcp_accept_w, rds_tcp_accept_worker);
+ 	return 0;
+ 
+ fail:
+ 	if (net != &init_net)
+ 		kfree(tbl);
+ 	return err;
+ }
+ 
+ static void __net_exit rds_tcp_exit_net(struct net *net)
+ {
+ 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);
+ 
+ 	if (rtn->rds_tcp_sysctl)
+ 		unregister_net_sysctl_table(rtn->rds_tcp_sysctl);
+ 
+ 	if (net != &init_net && rtn->ctl_table)
+ 		kfree(rtn->ctl_table);
+ 
+ 	/* If rds_tcp_exit_net() is called as a result of netns deletion,
+ 	 * the rds_tcp_kill_sock() device notifier would already have cleaned
+ 	 * up the listen socket, thus there is no work to do in this function.
+ 	 *
+ 	 * If rds_tcp_exit_net() is called as a result of module unload,
+ 	 * i.e., due to rds_tcp_exit() -> unregister_pernet_subsys(), then
+ 	 * we do need to clean up the listen socket here.
+ 	 */
+ 	if (rtn->rds_tcp_listen_sock) {
+ 		rds_tcp_listen_stop(rtn->rds_tcp_listen_sock);
+ 		rtn->rds_tcp_listen_sock = NULL;
+ 		flush_work(&rtn->rds_tcp_accept_w);
+ 	}
+ }
+ 
+ static struct pernet_operations rds_tcp_net_ops = {
+ 	.init = rds_tcp_init_net,
+ 	.exit = rds_tcp_exit_net,
+ 	.id = &rds_tcp_netid,
+ 	.size = sizeof(struct rds_tcp_net),
+ };
+ 
+ static void rds_tcp_kill_sock(struct net *net)
+ {
+ 	struct rds_tcp_connection *tc, *_tc;
+ 	struct sock *sk;
+ 	LIST_HEAD(tmp_list);
+ 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);
+ 
+ 	rds_tcp_listen_stop(rtn->rds_tcp_listen_sock);
+ 	rtn->rds_tcp_listen_sock = NULL;
+ 	flush_work(&rtn->rds_tcp_accept_w);
+ 	spin_lock_irq(&rds_tcp_conn_lock);
+ 	list_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {
+ 		struct net *c_net = read_pnet(&tc->conn->c_net);
+ 
+ 		if (net != c_net || !tc->t_sock)
+ 			continue;
+ 		list_move_tail(&tc->t_tcp_node, &tmp_list);
+ 	}
+ 	spin_unlock_irq(&rds_tcp_conn_lock);
+ 	list_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node) {
+ 		sk = tc->t_sock->sk;
+ 		sk->sk_prot->disconnect(sk, 0);
+ 		tcp_done(sk);
+ 		if (tc->conn->c_passive)
+ 			rds_conn_destroy(tc->conn->c_passive);
+ 		rds_conn_destroy(tc->conn);
+ 	}
+ }
+ 
+ static int rds_tcp_dev_event(struct notifier_block *this,
+ 			     unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+ 
+ 	/* rds-tcp registers as a pernet subys, so the ->exit will only
+ 	 * get invoked after network acitivity has quiesced. We need to
+ 	 * clean up all sockets  to quiesce network activity, and use
+ 	 * the unregistration of the per-net loopback device as a trigger
+ 	 * to start that cleanup.
+ 	 */
+ 	if (event == NETDEV_UNREGISTER_FINAL &&
+ 	    dev->ifindex == LOOPBACK_IFINDEX)
+ 		rds_tcp_kill_sock(dev_net(dev));
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block rds_tcp_dev_notifier = {
+ 	.notifier_call        = rds_tcp_dev_event,
+ 	.priority = -10, /* must be called after other network notifiers */
+ };
+ 
+ /* when sysctl is used to modify some kernel socket parameters,this
+  * function  resets the RDS connections in that netns  so that we can
+  * restart with new parameters.  The assumption is that such reset
+  * events are few and far-between.
+  */
+ static void rds_tcp_sysctl_reset(struct net *net)
+ {
+ 	struct rds_tcp_connection *tc, *_tc;
+ 
+ 	spin_lock_irq(&rds_tcp_conn_lock);
+ 	list_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {
+ 		struct net *c_net = read_pnet(&tc->conn->c_net);
+ 
+ 		if (net != c_net || !tc->t_sock)
+ 			continue;
+ 
+ 		rds_conn_drop(tc->conn); /* reconnect with new parameters */
+ 	}
+ 	spin_unlock_irq(&rds_tcp_conn_lock);
+ }
+ 
+ static int rds_tcp_skbuf_handler(struct ctl_table *ctl, int write,
+ 				 void __user *buffer, size_t *lenp,
+ 				 loff_t *fpos)
+ {
+ 	struct net *net = current->nsproxy->net_ns;
+ 	int err;
+ 
+ 	err = proc_dointvec_minmax(ctl, write, buffer, lenp, fpos);
+ 	if (err < 0) {
+ 		pr_warn("Invalid input. Must be >= %d\n",
+ 			*(int *)(ctl->extra1));
+ 		return err;
+ 	}
+ 	if (write)
+ 		rds_tcp_sysctl_reset(net);
+ 	return 0;
+ }
+ 
+ static void rds_tcp_exit(void)
+ {
+ 	rds_info_deregister_func(RDS_INFO_TCP_SOCKETS, rds_tcp_tc_info);
+ 	unregister_pernet_subsys(&rds_tcp_net_ops);
+ 	if (unregister_netdevice_notifier(&rds_tcp_dev_notifier))
+ 		pr_warn("could not unregister rds_tcp_dev_notifier\n");
+ 	rds_tcp_destroy_conns();
+ 	rds_trans_unregister(&rds_tcp_transport);
+ 	rds_tcp_recv_exit();
+ 	kmem_cache_destroy(rds_tcp_conn_slab);
+ }
+ module_exit(rds_tcp_exit);
+ 
++>>>>>>> c6a58ffed536 (RDS: TCP: Add sysctl tunables for sndbuf/rcvbuf on rds-tcp socket)
  static int rds_tcp_init(void)
  {
  	int ret;
* Unmerged path net/rds/tcp.c
