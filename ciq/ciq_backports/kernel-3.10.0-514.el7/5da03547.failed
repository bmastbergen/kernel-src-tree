net/mlx4_en: Port aggregation configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Moni Shoua <monis@mellanox.com>
commit 5da0354726e4a6ae2e25c1fa2feb77585d997b05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5da03547.failed

Capture NETDEV events generated by the bonding driver and based on that
make decisions of how to configure port aggregation in the mlx4 core driver.

This includes setting the V2P port table and re-creating the interested
interfaces in bonded/non-bonded mode.

	Signed-off-by: Moni Shoua <monis@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5da0354726e4a6ae2e25c1fa2feb77585d997b05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 3018dc400ecd,028937b2a199..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -2471,85 -2442,178 +2472,260 @@@ static const struct net_device_ops mlx4
  #endif
  };
  
++<<<<<<< HEAD
 +void mlx4_en_update_pfc_stats_bitmap(struct mlx4_dev *dev,
 +				     struct mlx4_en_stats_bitmap *stats_bitmap,
 +				     u8 rx_ppp, u8 rx_pause,
 +				     u8 tx_ppp, u8 tx_pause)
 +{
 +	int last_i = NUM_MAIN_STATS + NUM_PORT_STATS + NUM_PF_STATS;
 +
 +	if (!mlx4_is_slave(dev) &&
 +	    (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN)) {
 +		mutex_lock(&stats_bitmap->mutex);
 +		bitmap_clear(stats_bitmap->bitmap, last_i, NUM_FLOW_STATS);
 +
 +		if (rx_ppp)
 +			bitmap_set(stats_bitmap->bitmap, last_i,
 +				   NUM_FLOW_PRIORITY_STATS_RX);
 +		last_i += NUM_FLOW_PRIORITY_STATS_RX;
 +
 +		if (rx_pause && !(rx_ppp))
 +			bitmap_set(stats_bitmap->bitmap, last_i,
 +				   NUM_FLOW_STATS_RX);
 +		last_i += NUM_FLOW_STATS_RX;
 +
 +		if (tx_ppp)
 +			bitmap_set(stats_bitmap->bitmap, last_i,
 +				   NUM_FLOW_PRIORITY_STATS_TX);
 +		last_i += NUM_FLOW_PRIORITY_STATS_TX;
 +
 +		if (tx_pause && !(tx_ppp))
 +			bitmap_set(stats_bitmap->bitmap, last_i,
 +				   NUM_FLOW_STATS_TX);
 +		last_i += NUM_FLOW_STATS_TX;
 +
 +		mutex_unlock(&stats_bitmap->mutex);
 +	}
 +}
 +
 +void mlx4_en_set_stats_bitmap(struct mlx4_dev *dev,
 +			      struct mlx4_en_stats_bitmap *stats_bitmap,
 +			      u8 rx_ppp, u8 rx_pause,
 +			      u8 tx_ppp, u8 tx_pause)
 +{
 +	int last_i = 0;
 +
 +	mutex_init(&stats_bitmap->mutex);
 +	bitmap_zero(stats_bitmap->bitmap, NUM_ALL_STATS);
 +
 +	if (mlx4_is_slave(dev)) {
 +		bitmap_set(stats_bitmap->bitmap, last_i +
 +					 MLX4_FIND_NETDEV_STAT(rx_packets), 1);
 +		bitmap_set(stats_bitmap->bitmap, last_i +
 +					 MLX4_FIND_NETDEV_STAT(tx_packets), 1);
 +		bitmap_set(stats_bitmap->bitmap, last_i +
 +					 MLX4_FIND_NETDEV_STAT(rx_bytes), 1);
 +		bitmap_set(stats_bitmap->bitmap, last_i +
 +					 MLX4_FIND_NETDEV_STAT(tx_bytes), 1);
 +		bitmap_set(stats_bitmap->bitmap, last_i +
 +					 MLX4_FIND_NETDEV_STAT(rx_dropped), 1);
 +		bitmap_set(stats_bitmap->bitmap, last_i +
 +					 MLX4_FIND_NETDEV_STAT(tx_dropped), 1);
 +	} else {
 +		bitmap_set(stats_bitmap->bitmap, last_i, NUM_MAIN_STATS);
 +	}
 +	last_i += NUM_MAIN_STATS;
 +
 +	bitmap_set(stats_bitmap->bitmap, last_i, NUM_PORT_STATS);
 +	last_i += NUM_PORT_STATS;
 +
 +	if (mlx4_is_master(dev))
 +		bitmap_set(stats_bitmap->bitmap, last_i,
 +			   NUM_PF_STATS);
 +	last_i += NUM_PF_STATS;
 +
 +	mlx4_en_update_pfc_stats_bitmap(dev, stats_bitmap,
 +					rx_ppp, rx_pause,
 +					tx_ppp, tx_pause);
 +	last_i += NUM_FLOW_STATS;
 +
 +	if (!mlx4_is_slave(dev))
 +		bitmap_set(stats_bitmap->bitmap, last_i, NUM_PKT_STATS);
++=======
+ struct mlx4_en_bond {
+ 	struct work_struct work;
+ 	struct mlx4_en_priv *priv;
+ 	int is_bonded;
+ 	struct mlx4_port_map port_map;
+ };
+ 
+ static void mlx4_en_bond_work(struct work_struct *work)
+ {
+ 	struct mlx4_en_bond *bond = container_of(work,
+ 						     struct mlx4_en_bond,
+ 						     work);
+ 	int err = 0;
+ 	struct mlx4_dev *dev = bond->priv->mdev->dev;
+ 
+ 	if (bond->is_bonded) {
+ 		if (!mlx4_is_bonded(dev)) {
+ 			err = mlx4_bond(dev);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to bond device\n");
+ 		}
+ 		if (!err) {
+ 			err = mlx4_port_map_set(dev, &bond->port_map);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to set port map [%d][%d]: %d\n",
+ 				       bond->port_map.port1,
+ 				       bond->port_map.port2,
+ 				       err);
+ 		}
+ 	} else if (mlx4_is_bonded(dev)) {
+ 		err = mlx4_unbond(dev);
+ 		if (err)
+ 			en_err(bond->priv, "Fail to unbond device\n");
+ 	}
+ 	dev_put(bond->priv->dev);
+ 	kfree(bond);
+ }
+ 
+ static int mlx4_en_queue_bond_work(struct mlx4_en_priv *priv, int is_bonded,
+ 				   u8 v2p_p1, u8 v2p_p2)
+ {
+ 	struct mlx4_en_bond *bond = NULL;
+ 
+ 	bond = kzalloc(sizeof(*bond), GFP_ATOMIC);
+ 	if (!bond)
+ 		return -ENOMEM;
+ 
+ 	INIT_WORK(&bond->work, mlx4_en_bond_work);
+ 	bond->priv = priv;
+ 	bond->is_bonded = is_bonded;
+ 	bond->port_map.port1 = v2p_p1;
+ 	bond->port_map.port2 = v2p_p2;
+ 	dev_hold(priv->dev);
+ 	queue_work(priv->mdev->workqueue, &bond->work);
+ 	return 0;
+ }
+ 
+ int mlx4_en_netdev_event(struct notifier_block *this,
+ 			 unsigned long event, void *ptr)
+ {
+ 	struct net_device *ndev = netdev_notifier_info_to_dev(ptr);
+ 	u8 port = 0;
+ 	struct mlx4_en_dev *mdev;
+ 	struct mlx4_dev *dev;
+ 	int i, num_eth_ports = 0;
+ 	bool do_bond = true;
+ 	struct mlx4_en_priv *priv;
+ 	u8 v2p_port1 = 0;
+ 	u8 v2p_port2 = 0;
+ 
+ 	if (!net_eq(dev_net(ndev), &init_net))
+ 		return NOTIFY_DONE;
+ 
+ 	mdev = container_of(this, struct mlx4_en_dev, nb);
+ 	dev = mdev->dev;
+ 
+ 	/* Go into this mode only when two network devices set on two ports
+ 	 * of the same mlx4 device are slaves of the same bonding master
+ 	 */
+ 	mlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {
+ 		++num_eth_ports;
+ 		if (!port && (mdev->pndev[i] == ndev))
+ 			port = i;
+ 		mdev->upper[i] = mdev->pndev[i] ?
+ 			netdev_master_upper_dev_get(mdev->pndev[i]) : NULL;
+ 		/* condition not met: network device is a slave */
+ 		if (!mdev->upper[i])
+ 			do_bond = false;
+ 		if (num_eth_ports < 2)
+ 			continue;
+ 		/* condition not met: same master */
+ 		if (mdev->upper[i] != mdev->upper[i-1])
+ 			do_bond = false;
+ 	}
+ 	/* condition not met: 2 salves */
+ 	do_bond = (num_eth_ports ==  2) ? do_bond : false;
+ 
+ 	/* handle only events that come with enough info */
+ 	if ((do_bond && (event != NETDEV_BONDING_INFO)) || !port)
+ 		return NOTIFY_DONE;
+ 
+ 	priv = netdev_priv(ndev);
+ 	if (do_bond) {
+ 		struct netdev_notifier_bonding_info *notifier_info = ptr;
+ 		struct netdev_bonding_info *bonding_info =
+ 			&notifier_info->bonding_info;
+ 
+ 		/* required mode 1, 2 or 4 */
+ 		if ((bonding_info->master.bond_mode != BOND_MODE_ACTIVEBACKUP) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_XOR) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_8023AD))
+ 			do_bond = false;
+ 
+ 		/* require exactly 2 slaves */
+ 		if (bonding_info->master.num_slaves != 2)
+ 			do_bond = false;
+ 
+ 		/* calc v2p */
+ 		if (do_bond) {
+ 			if (bonding_info->master.bond_mode ==
+ 			    BOND_MODE_ACTIVEBACKUP) {
+ 				/* in active-backup mode virtual ports are
+ 				 * mapped to the physical port of the active
+ 				 * slave */
+ 				if (bonding_info->slave.state ==
+ 				    BOND_STATE_BACKUP) {
+ 					if (port == 1) {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					} else {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					}
+ 				} else { /* BOND_STATE_ACTIVE */
+ 					if (port == 1) {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					} else {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					}
+ 				}
+ 			} else { /* Active-Active */
+ 				/* in active-active mode a virtual port is
+ 				 * mapped to the native physical port if and only
+ 				 * if the physical port is up */
+ 				__s8 link = bonding_info->slave.link;
+ 
+ 				if (port == 1)
+ 					v2p_port2 = 2;
+ 				else
+ 					v2p_port1 = 1;
+ 				if ((link == BOND_LINK_UP) ||
+ 				    (link == BOND_LINK_FAIL)) {
+ 					if (port == 1)
+ 						v2p_port1 = 1;
+ 					else
+ 						v2p_port2 = 2;
+ 				} else { /* BOND_LINK_DOWN || BOND_LINK_BACK */
+ 					if (port == 1)
+ 						v2p_port1 = 2;
+ 					else
+ 						v2p_port2 = 1;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	mlx4_en_queue_bond_work(priv, do_bond,
+ 				v2p_port1, v2p_port2);
+ 
+ 	return NOTIFY_DONE;
++>>>>>>> 5da0354726e4 (net/mlx4_en: Port aggregation configuration)
  }
  
  int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_main.c b/drivers/net/ethernet/mellanox/mlx4/en_main.c
index 23cf1f23e56a..24cec682c301 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_main.c
@@ -216,6 +216,8 @@ static void mlx4_en_remove(struct mlx4_dev *dev, void *endev_ptr)
 	iounmap(mdev->uar_map);
 	mlx4_uar_free(dev, &mdev->priv_uar);
 	mlx4_pd_free(dev, mdev->priv_pdn);
+	if (mdev->nb.notifier_call)
+		unregister_netdevice_notifier(&mdev->nb);
 	kfree(mdev);
 }
 
@@ -296,6 +298,12 @@ static void *mlx4_en_add(struct mlx4_dev *dev)
 		if (mlx4_en_init_netdev(mdev, i, &mdev->profile.prof[i]))
 			mdev->pndev[i] = NULL;
 	}
+	/* register notifier */
+	mdev->nb.notifier_call = mlx4_en_netdev_event;
+	if (register_netdevice_notifier(&mdev->nb)) {
+		mdev->nb.notifier_call = NULL;
+		mlx4_err(mdev, "Failed to create notifier\n");
+	}
 
 	return mdev;
 
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index c4364116c964..6b9208e3070e 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@ -375,6 +375,7 @@ struct mlx4_en_dev {
 	struct pci_dev		*pdev;
 	struct mutex		state_lock;
 	struct net_device       *pndev[MLX4_MAX_PORTS + 1];
+	struct net_device       *upper[MLX4_MAX_PORTS + 1];
 	u32                     port_cnt;
 	bool			device_up;
 	struct mlx4_en_profile  profile;
@@ -395,6 +396,7 @@ struct mlx4_en_dev {
 	unsigned long		overflow_period;
 	struct ptp_clock	*ptp_clock;
 	struct ptp_clock_info	ptp_clock_info;
+	struct notifier_block	nb;
 };
 
 
@@ -710,6 +712,9 @@ void mlx4_en_update_pfc_stats_bitmap(struct mlx4_dev *dev,
 				     u8 rx_ppp, u8 rx_pause,
 				     u8 tx_ppp, u8 tx_pause);
 
+int mlx4_en_netdev_event(struct notifier_block *this,
+			 unsigned long event, void *ptr);
+
 /*
  * Functions for time stamping
  */
