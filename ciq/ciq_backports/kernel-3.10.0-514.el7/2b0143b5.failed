VFS: normal filesystems (and lustre): d_inode() annotations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [fs] vfs: normal filesystems and lustre d_inode() annotations - CIFS only (Sachin Prabhu) [1337587]
Rebuild_FUZZ: 88.19%
commit-author David Howells <dhowells@redhat.com>
commit 2b0143b5c986be1ce8408b3aadc4709e0a94429d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2b0143b5.failed

that's the bulk of filesystem drivers dealing with inodes of their own

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 2b0143b5c986be1ce8408b3aadc4709e0a94429d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/lustre/lustre/llite/dcache.c
#	drivers/staging/lustre/lustre/llite/file.c
#	drivers/staging/lustre/lustre/llite/llite_internal.h
#	drivers/staging/lustre/lustre/llite/llite_lib.c
#	drivers/staging/lustre/lustre/llite/llite_nfs.c
#	drivers/staging/lustre/lustre/llite/namei.c
#	drivers/staging/lustre/lustre/llite/statahead.c
#	drivers/staging/lustre/lustre/llite/symlink.c
#	drivers/staging/lustre/lustre/llite/xattr.c
#	fs/9p/vfs_inode.c
#	fs/affs/amigaffs.c
#	fs/affs/namei.c
#	fs/afs/dir.c
#	fs/autofs4/expire.c
#	fs/autofs4/root.c
#	fs/befs/linuxvfs.c
#	fs/btrfs/xattr.c
#	fs/ceph/debugfs.c
#	fs/ceph/dir.c
#	fs/ceph/file.c
#	fs/ceph/xattr.c
#	fs/cifs/readdir.c
#	fs/coda/dir.c
#	fs/coda/inode.c
#	fs/configfs/dir.c
#	fs/configfs/file.c
#	fs/configfs/inode.c
#	fs/debugfs/inode.c
#	fs/ecryptfs/inode.c
#	fs/ecryptfs/mmap.c
#	fs/ext3/super.c
#	fs/ext4/namei.c
#	fs/f2fs/namei.c
#	fs/f2fs/xattr.c
#	fs/fuse/dir.c
#	fs/fuse/inode.c
#	fs/gfs2/inode.c
#	fs/hfsplus/dir.c
#	fs/hfsplus/xattr.h
#	fs/jffs2/dir.c
#	fs/jffs2/fs.c
#	fs/kernfs/dir.c
#	fs/kernfs/inode.c
#	fs/ncpfs/dir.c
#	fs/ncpfs/inode.c
#	fs/ncpfs/ioctl.c
#	fs/nfs/dir.c
#	fs/nfs/nfs3acl.c
#	fs/nfs/nfs3proc.c
#	fs/nfs/pagelist.c
#	fs/nfs/read.c
#	fs/nfsd/nfs2acl.c
#	fs/nfsd/nfs3acl.c
#	fs/nfsd/nfs4acl.c
#	fs/nfsd/nfs4recover.c
#	fs/nfsd/nfsfh.c
#	fs/ocfs2/dcache.c
#	fs/ocfs2/file.c
#	fs/ocfs2/namei.c
#	fs/proc/base.c
#	fs/proc/generic.c
#	fs/proc/inode.c
#	fs/proc/namespaces.c
#	fs/proc/thread_self.c
#	fs/pstore/inode.c
#	fs/reiserfs/dir.c
#	fs/reiserfs/super.c
#	fs/reiserfs/xattr.c
#	fs/ubifs/xattr.c
#	fs/udf/namei.c
#	fs/xfs/xfs_iops.c
diff --cc fs/9p/vfs_inode.c
index c05c0a842783,703342e309f5..000000000000
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@@ -880,9 -881,10 +880,9 @@@ v9fs_vfs_atomic_open(struct inode *dir
  	}
  
  	v9fs_invalidate_inode_attr(dir);
- 	v9inode = V9FS_I(dentry->d_inode);
+ 	v9inode = V9FS_I(d_inode(dentry));
  	mutex_lock(&v9inode->v_mutex);
 -	if ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&
 -	    !v9inode->writeback_fid &&
 +	if (v9ses->cache && !v9inode->writeback_fid &&
  	    ((flags & O_ACCMODE) != O_RDONLY)) {
  		/*
  		 * clone a fid and add it to writeback_fid
@@@ -905,10 -907,8 +905,15 @@@
  		goto error;
  
  	file->private_data = fid;
++<<<<<<< HEAD
 +#ifdef CONFIG_9P_FSCACHE
 +	if (v9ses->cache)
 +		v9fs_cache_inode_set_cookie(dentry->d_inode, file);
 +#endif
++=======
+ 	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)
+ 		v9fs_cache_inode_set_cookie(d_inode(dentry), file);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	*opened |= FILE_CREATED;
  out:
@@@ -1060,10 -1059,9 +1065,10 @@@ v9fs_vfs_getattr(struct vfsmount *mnt, 
  	struct p9_wstat *st;
  
  	p9_debug(P9_DEBUG_VFS, "dentry: %p\n", dentry);
 +	err = -EPERM;
  	v9ses = v9fs_dentry2v9ses(dentry);
  	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {
- 		generic_fillattr(dentry->d_inode, stat);
+ 		generic_fillattr(d_inode(dentry), stat);
  		return 0;
  	}
  	fid = v9fs_fid_lookup(dentry);
@@@ -1129,8 -1127,8 +1134,13 @@@ static int v9fs_vfs_setattr(struct dent
  	}
  
  	/* Write all dirty data */
++<<<<<<< HEAD
 +	if (S_ISREG(dentry->d_inode->i_mode))
 +		filemap_write_and_wait(dentry->d_inode->i_mapping);
++=======
+ 	if (d_is_reg(dentry))
+ 		filemap_write_and_wait(d_inode(dentry)->i_mapping);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	retval = p9_client_wstat(fid, &wstat);
  	if (retval < 0)
diff --cc fs/affs/amigaffs.c
index d9a43674cb94,40eb5814b98c..000000000000
--- a/fs/affs/amigaffs.c
+++ b/fs/affs/amigaffs.c
@@@ -461,14 -458,22 +461,24 @@@ affs_error(struct super_block *sb, cons
  void
  affs_warning(struct super_block *sb, const char *function, const char *fmt, ...)
  {
 -	struct va_format vaf;
 -	va_list args;
 +	va_list	 args;
  
 -	va_start(args, fmt);
 -	vaf.fmt = fmt;
 -	vaf.va = &args;
 -	pr_warn("(device %s): %s(): %pV\n", sb->s_id, function, &vaf);
 +	va_start(args,fmt);
 +	vsnprintf(ErrorBuffer,sizeof(ErrorBuffer),fmt,args);
  	va_end(args);
++<<<<<<< HEAD
++=======
+ }
+ 
+ bool
+ affs_nofilenametruncate(const struct dentry *dentry)
+ {
+ 	struct inode *inode = d_inode(dentry);
+ 	return AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
 +	printk(KERN_WARNING "AFFS warning (device %s): %s(): %s\n", sb->s_id,
 +		function,ErrorBuffer);
  }
  
  /* Check if the name is valid for a affs object. */
diff --cc fs/affs/namei.c
index c36cbb4537a2,372100288ee5..000000000000
--- a/fs/affs/namei.c
+++ b/fs/affs/namei.c
@@@ -237,9 -249,8 +237,14 @@@ affs_lookup(struct inode *dir, struct d
  int
  affs_unlink(struct inode *dir, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	pr_debug("AFFS: unlink(dir=%d, %lu \"%.*s\")\n", (u32)dir->i_ino,
 +		 dentry->d_inode->i_ino,
 +		 (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("%s(dir=%lu, %lu \"%pd\")\n", __func__, dir->i_ino,
+ 		 d_inode(dentry)->i_ino, dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	return affs_remove_header(dentry);
  }
@@@ -306,9 -317,8 +311,14 @@@ affs_mkdir(struct inode *dir, struct de
  int
  affs_rmdir(struct inode *dir, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	pr_debug("AFFS: rmdir(dir=%u, %lu \"%.*s\")\n", (u32)dir->i_ino,
 +		 dentry->d_inode->i_ino,
 +		 (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("%s(dir=%lu, %lu \"%pd\")\n", __func__, dir->i_ino,
+ 		 d_inode(dentry)->i_ino, dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	return affs_remove_header(dentry);
  }
@@@ -391,10 -401,10 +401,10 @@@ err
  int
  affs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
  {
- 	struct inode *inode = old_dentry->d_inode;
+ 	struct inode *inode = d_inode(old_dentry);
  
 -	pr_debug("%s(%lu, %lu, \"%pd\")\n", __func__, inode->i_ino, dir->i_ino,
 -		 dentry);
 +	pr_debug("AFFS: link(%u, %u, \"%.*s\")\n", (u32)inode->i_ino, (u32)dir->i_ino,
 +		 (int)dentry->d_name.len,dentry->d_name.name);
  
  	return affs_add_entry(dir, inode, dentry, ST_LINKFILE);
  }
diff --cc fs/afs/dir.c
index 7a465ed04444,e10e17788f06..000000000000
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@@ -526,10 -502,10 +526,10 @@@ static struct dentry *afs_lookup(struc
  
  	vnode = AFS_FS_I(dir);
  
 -	_enter("{%x:%u},%p{%pd},",
 -	       vnode->fid.vid, vnode->fid.vnode, dentry, dentry);
 +	_enter("{%x:%u},%p{%s},",
 +	       vnode->fid.vid, vnode->fid.vnode, dentry, dentry->d_name.name);
  
- 	ASSERTCMP(dentry->d_inode, ==, NULL);
+ 	ASSERTCMP(d_inode(dentry), ==, NULL);
  
  	if (dentry->d_name.len >= AFSNAMEMAX) {
  		_leave(" = -ENAMETOOLONG");
@@@ -610,14 -586,14 +610,20 @@@ static int afs_d_revalidate(struct dent
  	if (flags & LOOKUP_RCU)
  		return -ECHILD;
  
- 	vnode = AFS_FS_I(dentry->d_inode);
+ 	vnode = AFS_FS_I(d_inode(dentry));
  
++<<<<<<< HEAD
 +	if (dentry->d_inode)
 +		_enter("{v={%x:%u} n=%s fl=%lx},",
 +		       vnode->fid.vid, vnode->fid.vnode, dentry->d_name.name,
++=======
+ 	if (d_really_is_positive(dentry))
+ 		_enter("{v={%x:%u} n=%pd fl=%lx},",
+ 		       vnode->fid.vid, vnode->fid.vnode, dentry,
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		       vnode->flags);
  	else
 -		_enter("{neg n=%pd}", dentry);
 +		_enter("{neg n=%s}", dentry->d_name.name);
  
  	key = afs_request_key(AFS_FS_S(dentry->d_sb)->volume->cell);
  	if (IS_ERR(key))
@@@ -625,10 -601,7 +631,14 @@@
  
  	/* lock down the parent dentry so we can peer at it */
  	parent = dget_parent(dentry);
++<<<<<<< HEAD
 +	if (!parent->d_inode)
 +		goto out_bad;
 +
 +	dir = AFS_FS_I(parent->d_inode);
++=======
+ 	dir = AFS_FS_I(d_inode(parent));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	/* validate the parent directory */
  	if (test_bit(AFS_VNODE_MODIFIED, &dir->flags))
@@@ -650,11 -623,11 +660,17 @@@
  	switch (ret) {
  	case 0:
  		/* the filename maps to something */
- 		if (!dentry->d_inode)
+ 		if (d_really_is_negative(dentry))
  			goto out_bad;
++<<<<<<< HEAD
 +		if (is_bad_inode(dentry->d_inode)) {
 +			printk("kAFS: afs_d_revalidate: %s/%s has bad inode\n",
 +			       parent->d_name.name, dentry->d_name.name);
++=======
+ 		if (is_bad_inode(d_inode(dentry))) {
+ 			printk("kAFS: afs_d_revalidate: %pd2 has bad inode\n",
+ 			       dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			goto out_bad;
  		}
  
@@@ -671,10 -644,10 +687,10 @@@
  		 * been deleted and replaced, and the original vnode ID has
  		 * been reused */
  		if (fid.unique != vnode->fid.unique) {
 -			_debug("%pd: file deleted (uq %u -> %u I:%u)",
 -			       dentry, fid.unique,
 +			_debug("%s: file deleted (uq %u -> %u I:%u)",
 +			       dentry->d_name.name, fid.unique,
  			       vnode->fid.unique,
- 			       dentry->d_inode->i_generation);
+ 			       d_inode(dentry)->i_generation);
  			spin_lock(&vnode->lock);
  			set_bit(AFS_VNODE_DELETED, &vnode->flags);
  			spin_unlock(&vnode->lock);
@@@ -684,8 -657,8 +700,13 @@@
  
  	case -ENOENT:
  		/* the filename is unknown */
++<<<<<<< HEAD
 +		_debug("%s: dirent not found", dentry->d_name.name);
 +		if (dentry->d_inode)
++=======
+ 		_debug("%pd: dirent not found", dentry);
+ 		if (d_really_is_positive(dentry))
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			goto not_found;
  		goto out_valid;
  
@@@ -1026,17 -977,13 +1047,17 @@@ static int afs_link(struct dentry *from
  	struct key *key;
  	int ret;
  
- 	vnode = AFS_FS_I(from->d_inode);
+ 	vnode = AFS_FS_I(d_inode(from));
  	dvnode = AFS_FS_I(dir);
  
 -	_enter("{%x:%u},{%x:%u},{%pd}",
 +	_enter("{%x:%u},{%x:%u},{%s}",
  	       vnode->fid.vid, vnode->fid.vnode,
  	       dvnode->fid.vid, dvnode->fid.vnode,
 -	       dentry);
 +	       dentry->d_name.name);
 +
 +	ret = -ENAMETOOLONG;
 +	if (dentry->d_name.len >= AFSNAMEMAX)
 +		goto error;
  
  	key = afs_request_key(dvnode->volume->cell);
  	if (IS_ERR(key)) {
diff --cc fs/autofs4/expire.c
index 394e90b02c5e,1cebc3c52fa5..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -346,6 -336,87 +346,90 @@@ out
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ /* Check if 'dentry' should expire, or return a nearby
+  * dentry that is suitable.
+  * If returned dentry is different from arg dentry,
+  * then a dget() reference was taken, else not.
+  */
+ static struct dentry *should_expire(struct dentry *dentry,
+ 				    struct vfsmount *mnt,
+ 				    unsigned long timeout,
+ 				    int how)
+ {
+ 	int do_now = how & AUTOFS_EXP_IMMEDIATE;
+ 	int exp_leaves = how & AUTOFS_EXP_LEAVES;
+ 	struct autofs_info *ino = autofs4_dentry_ino(dentry);
+ 	unsigned int ino_count;
+ 
+ 	/* No point expiring a pending mount */
+ 	if (ino->flags & AUTOFS_INF_PENDING)
+ 		return NULL;
+ 
+ 	/*
+ 	 * Case 1: (i) indirect mount or top level pseudo direct mount
+ 	 *	   (autofs-4.1).
+ 	 *	   (ii) indirect mount with offset mount, check the "/"
+ 	 *	   offset (autofs-5.0+).
+ 	 */
+ 	if (d_mountpoint(dentry)) {
+ 		DPRINTK("checking mountpoint %p %pd", dentry, dentry);
+ 
+ 		/* Can we umount this guy */
+ 		if (autofs4_mount_busy(mnt, dentry))
+ 			return NULL;
+ 
+ 		/* Can we expire this guy */
+ 		if (autofs4_can_expire(dentry, timeout, do_now))
+ 			return dentry;
+ 		return NULL;
+ 	}
+ 
+ 	if (d_really_is_positive(dentry) && d_is_symlink(dentry)) {
+ 		DPRINTK("checking symlink %p %pd", dentry, dentry);
+ 		/*
+ 		 * A symlink can't be "busy" in the usual sense so
+ 		 * just check last used for expire timeout.
+ 		 */
+ 		if (autofs4_can_expire(dentry, timeout, do_now))
+ 			return dentry;
+ 		return NULL;
+ 	}
+ 
+ 	if (simple_empty(dentry))
+ 		return NULL;
+ 
+ 	/* Case 2: tree mount, expire iff entire tree is not busy */
+ 	if (!exp_leaves) {
+ 		/* Path walk currently on this dentry? */
+ 		ino_count = atomic_read(&ino->count) + 1;
+ 		if (d_count(dentry) > ino_count)
+ 			return NULL;
+ 
+ 		if (!autofs4_tree_busy(mnt, dentry, timeout, do_now))
+ 			return dentry;
+ 	/*
+ 	 * Case 3: pseudo direct mount, expire individual leaves
+ 	 *	   (autofs-4.1).
+ 	 */
+ 	} else {
+ 		/* Path walk currently on this dentry? */
+ 		struct dentry *expired;
+ 		ino_count = atomic_read(&ino->count) + 1;
+ 		if (d_count(dentry) > ino_count)
+ 			return NULL;
+ 
+ 		expired = autofs4_check_leaves(mnt, dentry, timeout, do_now);
+ 		if (expired) {
+ 			if (expired == dentry)
+ 				dput(dentry);
+ 			return expired;
+ 		}
+ 	}
+ 	return NULL;
+ }
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  /*
   * Find an eligible tree to time-out
   * A tree is eligible if :-
diff --cc fs/autofs4/root.c
index 22bfeaf10e21,c6d7d3dbd52a..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -360,7 -371,7 +360,11 @@@ static struct vfsmount *autofs4_d_autom
  	 * having d_mountpoint() true, so there's no need to call back
  	 * to the daemon.
  	 */
++<<<<<<< HEAD
 +	if (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)) {
++=======
+ 	if (d_really_is_positive(dentry) && d_is_symlink(dentry)) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		spin_unlock(&sbi->fs_lock);
  		goto done;
  	}
@@@ -441,6 -446,29 +445,32 @@@ static int autofs4_d_manage(struct dent
  	if (status)
  		return status;
  
++<<<<<<< HEAD
++=======
+ 	if (rcu_walk) {
+ 		/* We don't need fs_lock in rcu_walk mode,
+ 		 * just testing 'AUTOFS_INFO_NO_RCU' is enough.
+ 		 * simple_empty() takes a spinlock, so leave it
+ 		 * to last.
+ 		 * We only return -EISDIR when certain this isn't
+ 		 * a mount-trap.
+ 		 */
+ 		struct inode *inode;
+ 		if (ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU))
+ 			return 0;
+ 		if (d_mountpoint(dentry))
+ 			return 0;
+ 		inode = d_inode_rcu(dentry);
+ 		if (inode && S_ISLNK(inode->i_mode))
+ 			return -EISDIR;
+ 		if (list_empty(&dentry->d_subdirs))
+ 			return 0;
+ 		if (!simple_empty(dentry))
+ 			return -EISDIR;
+ 		return 0;
+ 	}
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	spin_lock(&sbi->fs_lock);
  	/*
  	 * If the dentry has been selected for expire while we slept
@@@ -457,7 -485,7 +487,11 @@@
  		 * an incorrect ELOOP error return.
  		 */
  		if ((!d_mountpoint(dentry) && !simple_empty(dentry)) ||
++<<<<<<< HEAD
 +		    (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)))
++=======
+ 		    (d_really_is_positive(dentry) && d_is_symlink(dentry)))
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			status = -EISDIR;
  	}
  	spin_unlock(&sbi->fs_lock);
diff --cc fs/befs/linuxvfs.c
index f95dddced968,d3cb8774765f..000000000000
--- a/fs/befs/linuxvfs.c
+++ b/fs/befs/linuxvfs.c
@@@ -473,47 -471,40 +473,60 @@@ befs_destroy_inodecache(void
  static void *
  befs_follow_link(struct dentry *dentry, struct nameidata *nd)
  {
++<<<<<<< HEAD
 +	befs_inode_info *befs_ino = BEFS_I(dentry->d_inode);
++=======
+ 	struct super_block *sb = dentry->d_sb;
+ 	befs_inode_info *befs_ino = BEFS_I(d_inode(dentry));
+ 	befs_data_stream *data = &befs_ino->i_data.ds;
+ 	befs_off_t len = data->size;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	char *link;
  
 -	if (len == 0) {
 -		befs_error(sb, "Long symlink with illegal length");
 -		link = ERR_PTR(-EIO);
 -	} else {
 -		befs_debug(sb, "Follow long symlink");
 +	if (befs_ino->i_flags & BEFS_LONG_SYMLINK) {
 +		struct super_block *sb = dentry->d_sb;
 +		befs_data_stream *data = &befs_ino->i_data.ds;
 +		befs_off_t len = data->size;
  
 -		link = kmalloc(len, GFP_NOFS);
 -		if (!link) {
 -			link = ERR_PTR(-ENOMEM);
 -		} else if (befs_read_lsymlink(sb, data, link, len) != len) {
 -			kfree(link);
 -			befs_error(sb, "Failed to read entire long symlink");
 +		if (len == 0) {
 +			befs_error(sb, "Long symlink with illegal length");
  			link = ERR_PTR(-EIO);
  		} else {
 -			link[len - 1] = '\0';
 +			befs_debug(sb, "Follow long symlink");
 +
 +			link = kmalloc(len, GFP_NOFS);
 +			if (!link) {
 +				link = ERR_PTR(-ENOMEM);
 +			} else if (befs_read_lsymlink(sb, data, link, len) != len) {
 +				kfree(link);
 +				befs_error(sb, "Failed to read entire long symlink");
 +				link = ERR_PTR(-EIO);
 +			} else {
 +				link[len - 1] = '\0';
 +			}
  		}
 +	} else {
 +		link = befs_ino->i_data.symlink;
  	}
 +
  	nd_set_link(nd, link);
  	return NULL;
  }
  
 -
 -static void *
 -befs_fast_follow_link(struct dentry *dentry, struct nameidata *nd)
 +static void befs_put_link(struct dentry *dentry, struct nameidata *nd, void *p)
  {
++<<<<<<< HEAD
 +	befs_inode_info *befs_ino = BEFS_I(dentry->d_inode);
 +	if (befs_ino->i_flags & BEFS_LONG_SYMLINK) {
 +		char *link = nd_get_link(nd);
 +		if (!IS_ERR(link))
 +			kfree(link);
 +	}
++=======
+ 	befs_inode_info *befs_ino = BEFS_I(d_inode(dentry));
+ 	nd_set_link(nd, befs_ino->i_data.symlink);
+ 	return NULL;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  
  /*
diff --cc fs/btrfs/xattr.c
index 13f71dbda553,4cca14ecb660..000000000000
--- a/fs/btrfs/xattr.c
+++ b/fs/btrfs/xattr.c
@@@ -409,17 -388,15 +409,27 @@@ ssize_t btrfs_getxattr(struct dentry *d
  	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
  		return generic_getxattr(dentry, name, buffer, size);
  
++<<<<<<< HEAD
 +	ret = btrfs_is_valid_xattr(name);
 +	if (ret)
 +		return ret;
 +	return __btrfs_getxattr(dentry->d_inode, name, buffer, size);
++=======
+ 	if (!btrfs_is_valid_xattr(name))
+ 		return -EOPNOTSUPP;
+ 	return __btrfs_getxattr(d_inode(dentry), name, buffer, size);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  
  int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,
  		   size_t size, int flags)
  {
++<<<<<<< HEAD
 +	struct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;
 +	int ret;
++=======
+ 	struct btrfs_root *root = BTRFS_I(d_inode(dentry))->root;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	/*
  	 * The permission on security.* and system.* is not checked
@@@ -436,12 -413,11 +446,12 @@@
  	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
  		return generic_setxattr(dentry, name, value, size, flags);
  
 -	if (!btrfs_is_valid_xattr(name))
 -		return -EOPNOTSUPP;
 +	ret = btrfs_is_valid_xattr(name);
 +	if (ret)
 +		return ret;
  
  	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
- 		return btrfs_set_prop(dentry->d_inode, name,
+ 		return btrfs_set_prop(d_inode(dentry), name,
  				      value, size, flags);
  
  	if (size == 0)
@@@ -453,8 -429,7 +463,12 @@@
  
  int btrfs_removexattr(struct dentry *dentry, const char *name)
  {
++<<<<<<< HEAD
 +	struct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;
 +	int ret;
++=======
+ 	struct btrfs_root *root = BTRFS_I(d_inode(dentry))->root;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	/*
  	 * The permission on security.* and system.* is not checked
@@@ -471,15 -446,14 +485,15 @@@
  	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
  		return generic_removexattr(dentry, name);
  
 -	if (!btrfs_is_valid_xattr(name))
 -		return -EOPNOTSUPP;
 +	ret = btrfs_is_valid_xattr(name);
 +	if (ret)
 +		return ret;
  
  	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
- 		return btrfs_set_prop(dentry->d_inode, name,
+ 		return btrfs_set_prop(d_inode(dentry), name,
  				      NULL, 0, XATTR_REPLACE);
  
- 	return __btrfs_setxattr(NULL, dentry->d_inode, name, NULL, 0,
+ 	return __btrfs_setxattr(NULL, d_inode(dentry), name, NULL, 0,
  				XATTR_REPLACE);
  }
  
diff --cc fs/ceph/debugfs.c
index 5d5a4c8c8496,31f831471ed2..000000000000
--- a/fs/ceph/debugfs.c
+++ b/fs/ceph/debugfs.c
@@@ -83,10 -83,9 +83,16 @@@ static int mdsc_show(struct seq_file *s
  			if (IS_ERR(path))
  				path = NULL;
  			spin_lock(&req->r_dentry->d_lock);
++<<<<<<< HEAD
 +			seq_printf(s, " #%llx/%.*s (%s)",
 +				   ceph_ino(req->r_dentry->d_parent->d_inode),
 +				   req->r_dentry->d_name.len,
 +				   req->r_dentry->d_name.name,
++=======
+ 			seq_printf(s, " #%llx/%pd (%s)",
+ 				   ceph_ino(d_inode(req->r_dentry->d_parent)),
+ 				   req->r_dentry,
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  				   path ? path : "");
  			spin_unlock(&req->r_dentry->d_lock);
  			kfree(path);
diff --cc fs/ceph/dir.c
index 67bdd35eda74,173fc598c7f1..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -117,13 -117,12 +117,19 @@@ static int fpos_cmp(loff_t l, loff_t r
   * defined IFF we hold CEPH_CAP_FILE_SHARED (which will be revoked by
   * the MDS if/when the directory is modified).
   */
 -static int __dcache_readdir(struct file *file,  struct dir_context *ctx,
 +static int __dcache_readdir(struct file *filp,
 +			    void *dirent, filldir_t filldir,
  			    u32 shared_gen)
  {
++<<<<<<< HEAD
 +	struct ceph_file_info *fi = filp->private_data;
 +	struct dentry *parent = filp->f_dentry;
 +	struct inode *dir = parent->d_inode;
++=======
+ 	struct ceph_file_info *fi = file->private_data;
+ 	struct dentry *parent = file->f_path.dentry;
+ 	struct inode *dir = d_inode(parent);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct list_head *p;
  	struct dentry *dentry, *last;
  	struct ceph_dentry_info *di;
@@@ -162,18 -161,18 +168,30 @@@ more
  		}
  		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
  		if (di->lease_shared_gen == shared_gen &&
++<<<<<<< HEAD
 +		    !d_unhashed(dentry) && dentry->d_inode &&
 +		    ceph_snap(dentry->d_inode) != CEPH_SNAPDIR &&
 +		    ceph_ino(dentry->d_inode) != CEPH_INO_CEPH &&
 +		    fpos_cmp(filp->f_pos, di->offset) <= 0)
 +			break;
 +		dout(" skipping %p %.*s at %llu (%llu)%s%s\n", dentry,
 +		     dentry->d_name.len, dentry->d_name.name, di->offset,
 +		     filp->f_pos, d_unhashed(dentry) ? " unhashed" : "",
 +		     !dentry->d_inode ? " null" : "");
++=======
+ 		    !d_unhashed(dentry) && d_really_is_positive(dentry) &&
+ 		    ceph_snap(d_inode(dentry)) != CEPH_SNAPDIR &&
+ 		    ceph_ino(d_inode(dentry)) != CEPH_INO_CEPH &&
+ 		    fpos_cmp(ctx->pos, di->offset) <= 0)
+ 			break;
+ 		dout(" skipping %p %pd at %llu (%llu)%s%s\n", dentry,
+ 		     dentry, di->offset,
+ 		     ctx->pos, d_unhashed(dentry) ? " unhashed" : "",
+ 		     !d_inode(dentry) ? " null" : "");
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		spin_unlock(&dentry->d_lock);
  		p = p->prev;
 -		dentry = list_entry(p, struct dentry, d_child);
 +		dentry = list_entry(p, struct dentry, d_u.d_child);
  		di = ceph_dentry(dentry);
  	}
  
@@@ -189,16 -188,13 +207,26 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	dout(" %llu (%llu) dentry %p %.*s %p\n", di->offset, filp->f_pos,
 +	     dentry, dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
 +	filp->f_pos = di->offset;
 +	err = filldir(dirent, dentry->d_name.name,
 +		      dentry->d_name.len, di->offset,
 +		      ceph_translate_ino(dentry->d_sb, dentry->d_inode->i_ino),
 +		      dentry->d_inode->i_mode >> 12);
 +
 +	if (last) {
 +		if (err < 0) {
++=======
+ 	dout(" %llu (%llu) dentry %p %pd %p\n", di->offset, ctx->pos,
+ 	     dentry, dentry, d_inode(dentry));
+ 	if (!dir_emit(ctx, dentry->d_name.name,
+ 		      dentry->d_name.len,
+ 		      ceph_translate_ino(dentry->d_sb, d_inode(dentry)->i_ino),
+ 		      d_inode(dentry)->i_mode >> 12)) {
+ 		if (last) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			/* remember our position */
  			fi->dentry = last;
  			fi->next_offset = fpos_off(di->offset);
@@@ -727,8 -723,12 +755,15 @@@ static int ceph_mknod(struct inode *dir
  	if (!err && !req->r_reply_info.head->is_dentry)
  		err = ceph_handle_notrace_create(dir, dentry);
  	ceph_mdsc_put_request(req);
++<<<<<<< HEAD
 +	if (err)
++=======
+ out:
+ 	if (!err)
+ 		ceph_init_inode_acls(d_inode(dentry), &acls);
+ 	else
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		d_drop(dentry);
 -	ceph_release_acls_info(&acls);
  	return err;
  }
  
@@@ -814,8 -820,11 +849,14 @@@ static int ceph_mkdir(struct inode *dir
  		err = ceph_handle_notrace_create(dir, dentry);
  	ceph_mdsc_put_request(req);
  out:
++<<<<<<< HEAD
 +	if (err < 0)
++=======
+ 	if (!err)
+ 		ceph_init_inode_acls(d_inode(dentry), &acls);
+ 	else
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		d_drop(dentry);
 -	ceph_release_acls_info(&acls);
  	return err;
  }
  
@@@ -1069,19 -1073,18 +1110,29 @@@ static int ceph_d_revalidate(struct den
  	if (flags & LOOKUP_RCU)
  		return -ECHILD;
  
++<<<<<<< HEAD
 +	dout("d_revalidate %p '%.*s' inode %p offset %lld\n", dentry,
 +	     dentry->d_name.len, dentry->d_name.name, dentry->d_inode,
 +	     ceph_dentry(dentry)->offset);
++=======
+ 	dout("d_revalidate %p '%pd' inode %p offset %lld\n", dentry,
+ 	     dentry, d_inode(dentry), ceph_dentry(dentry)->offset);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	dir = ceph_get_dentry_parent_inode(dentry);
  
  	/* always trust cached snapped dentries, snapdir dentry */
  	if (ceph_snap(dir) != CEPH_NOSNAP) {
++<<<<<<< HEAD
 +		dout("d_revalidate %p '%.*s' inode %p is SNAPPED\n", dentry,
 +		     dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
++=======
+ 		dout("d_revalidate %p '%pd' inode %p is SNAPPED\n", dentry,
+ 		     dentry, d_inode(dentry));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		valid = 1;
- 	} else if (dentry->d_inode &&
- 		   ceph_snap(dentry->d_inode) == CEPH_SNAPDIR) {
+ 	} else if (d_really_is_positive(dentry) &&
+ 		   ceph_snap(d_inode(dentry)) == CEPH_SNAPDIR) {
  		valid = 1;
  	} else if (dentry_lease_is_valid(dentry) ||
  		   dir_lease_is_valid(dir, dentry)) {
diff --cc fs/ceph/file.c
index 0c3070bb755c,3b6b522b4b31..000000000000
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@@ -261,14 -290,15 +261,23 @@@ int ceph_atomic_open(struct inode *dir
  		dn = NULL;
  	}
  	if (err)
++<<<<<<< HEAD
 +		goto out_err;
 +	if (dn || dentry->d_inode == NULL || S_ISLNK(dentry->d_inode->i_mode)) {
++=======
+ 		goto out_req;
+ 	if (dn || d_really_is_negative(dentry) || d_is_symlink(dentry)) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		/* make vfs retry on splice, ENOENT, or symlink */
  		dout("atomic_open finish_no_open on dn %p\n", dn);
  		err = finish_no_open(file, dn);
  	} else {
  		dout("atomic_open finish_open on dn %p\n", dn);
  		if (req->r_op == CEPH_MDS_OP_CREATE && req->r_reply_info.has_create_ino) {
++<<<<<<< HEAD
++=======
+ 			ceph_init_inode_acls(d_inode(dentry), &acls);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			*opened |= FILE_CREATED;
  		}
  		err = finish_open(file, dentry, ceph_open, opened);
diff --cc fs/ceph/xattr.c
index 4ec7a267abe6,e448766ce549..000000000000
--- a/fs/ceph/xattr.c
+++ b/fs/ceph/xattr.c
@@@ -758,9 -770,18 +758,21 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ ssize_t ceph_getxattr(struct dentry *dentry, const char *name, void *value,
+ 		      size_t size)
+ {
+ 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
+ 		return generic_getxattr(dentry, name, value, size);
+ 
+ 	return __ceph_getxattr(d_inode(dentry), name, value, size);
+ }
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  ssize_t ceph_listxattr(struct dentry *dentry, char *names, size_t size)
  {
- 	struct inode *inode = dentry->d_inode;
+ 	struct inode *inode = d_inode(dentry);
  	struct ceph_inode_info *ci = ceph_inode(inode);
  	struct ceph_vxattr *vxattrs = ceph_inode_vxattrs(inode);
  	u32 vir_namelen = 0;
@@@ -884,13 -898,12 +896,13 @@@ out
  	return err;
  }
  
 -int __ceph_setxattr(struct dentry *dentry, const char *name,
 -			const void *value, size_t size, int flags)
 +int ceph_setxattr(struct dentry *dentry, const char *name,
 +		  const void *value, size_t size, int flags)
  {
- 	struct inode *inode = dentry->d_inode;
+ 	struct inode *inode = d_inode(dentry);
  	struct ceph_vxattr *vxattr;
  	struct ceph_inode_info *ci = ceph_inode(inode);
 +	struct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;
  	int issued;
  	int err;
  	int dirty = 0;
@@@ -1001,6 -992,21 +1013,24 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ int ceph_setxattr(struct dentry *dentry, const char *name,
+ 		  const void *value, size_t size, int flags)
+ {
+ 	if (ceph_snap(d_inode(dentry)) != CEPH_NOSNAP)
+ 		return -EROFS;
+ 
+ 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
+ 		return generic_setxattr(dentry, name, value, size, flags);
+ 
+ 	if (size == 0)
+ 		value = "";  /* empty EA, do not remove */
+ 
+ 	return __ceph_setxattr(dentry, name, value, size, flags);
+ }
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  static int ceph_send_removexattr(struct dentry *dentry, const char *name)
  {
  	struct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);
@@@ -1026,12 -1030,11 +1056,12 @@@
  	return err;
  }
  
 -int __ceph_removexattr(struct dentry *dentry, const char *name)
 +int ceph_removexattr(struct dentry *dentry, const char *name)
  {
- 	struct inode *inode = dentry->d_inode;
+ 	struct inode *inode = d_inode(dentry);
  	struct ceph_vxattr *vxattr;
  	struct ceph_inode_info *ci = ceph_inode(inode);
 +	struct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;
  	int issued;
  	int err;
  	int required_blob_size;
@@@ -1111,3 -1095,14 +1141,16 @@@ do_sync_unlocked
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ int ceph_removexattr(struct dentry *dentry, const char *name)
+ {
+ 	if (ceph_snap(d_inode(dentry)) != CEPH_NOSNAP)
+ 		return -EROFS;
+ 
+ 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
+ 		return generic_removexattr(dentry, name);
+ 
+ 	return __ceph_removexattr(dentry, name);
+ }
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
diff --cc fs/cifs/readdir.c
index 2c9d7be88ceb,b4a47237486b..000000000000
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@@ -88,9 -88,7 +88,13 @@@ cifs_prime_dcache(struct dentry *parent
  		return;
  
  	if (dentry) {
++<<<<<<< HEAD
 +		int err;
 +
 +		inode = dentry->d_inode;
++=======
+ 		inode = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		if (inode) {
  			/*
  			 * If we're generating inode numbers, then we don't
diff --cc fs/coda/dir.c
index c424e27b42f9,fda9f4311212..000000000000
--- a/fs/coda/dir.c
+++ b/fs/coda/dir.c
@@@ -360,8 -303,8 +360,13 @@@ static int coda_rename(struct inode *ol
  			     coda_i2f(new_dir), old_length, new_length,
  			     (const char *) old_name, (const char *)new_name);
  	if (!error) {
++<<<<<<< HEAD
 +		if (new_dentry->d_inode) {
 +			if (S_ISDIR(new_dentry->d_inode->i_mode)) {
++=======
+ 		if (d_really_is_positive(new_dentry)) {
+ 			if (d_is_dir(new_dentry)) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  				coda_dir_drop_nlink(old_dir);
  				coda_dir_inc_nlink(new_dir);
  			}
@@@ -544,8 -449,8 +549,13 @@@ static int coda_dentry_revalidate(struc
  	if (flags & LOOKUP_RCU)
  		return -ECHILD;
  
++<<<<<<< HEAD
 +	inode = de->d_inode;
 +	if (!inode || coda_isroot(inode))
++=======
+ 	inode = d_inode(de);
+ 	if (!inode || is_root_inode(inode))
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		goto out;
  	if (is_bad_inode(inode))
  		goto bad;
diff --cc fs/coda/inode.c
index 43a5b38fc8d3,cac1390b87a3..000000000000
--- a/fs/coda/inode.c
+++ b/fs/coda/inode.c
@@@ -257,9 -257,9 +257,13 @@@ static void coda_evict_inode(struct ino
  
  int coda_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
  {
++<<<<<<< HEAD
 +	int err = coda_revalidate_inode(dentry);
++=======
+ 	int err = coda_revalidate_inode(d_inode(dentry));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	if (!err)
- 		generic_fillattr(dentry->d_inode, stat);
+ 		generic_fillattr(d_inode(dentry), stat);
  	return err;
  }
  
diff --cc fs/configfs/dir.c
index 8e466317b895,c81ce7f200a6..000000000000
--- a/fs/configfs/dir.c
+++ b/fs/configfs/dir.c
@@@ -313,11 -269,37 +313,33 @@@ static int create_dir(struct config_ite
   *	until it is validated by configfs_dir_set_ready()
   */
  
 -static int configfs_create_dir(struct config_item *item, struct dentry *dentry)
 +static int configfs_create_dir(struct config_item * item, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	int error = create_dir(item, dentry);
 +	if (!error)
++=======
+ 	int error;
+ 	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;
+ 	struct dentry *p = dentry->d_parent;
+ 
+ 	BUG_ON(!item);
+ 
+ 	error = configfs_dirent_exists(p->d_fsdata, dentry->d_name.name);
+ 	if (unlikely(error))
+ 		return error;
+ 
+ 	error = configfs_make_dirent(p->d_fsdata, dentry, item, mode,
+ 				     CONFIGFS_DIR | CONFIGFS_USET_CREATING);
+ 	if (unlikely(error))
+ 		return error;
+ 
+ 	configfs_set_dir_dirent_depth(p->d_fsdata, dentry->d_fsdata);
+ 	error = configfs_create(dentry, mode, init_dir);
+ 	if (!error) {
+ 		inc_nlink(d_inode(p));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		item->ci_dentry = dentry;
 -	} else {
 -		struct configfs_dirent *sd = dentry->d_fsdata;
 -		if (sd) {
 -			spin_lock(&configfs_dirent_lock);
 -			list_del_init(&sd->s_sibling);
 -			spin_unlock(&configfs_dirent_lock);
 -			configfs_put(sd);
 -		}
 -	}
  	return error;
  }
  
@@@ -393,10 -375,10 +415,10 @@@ static void remove_dir(struct dentry * 
  	list_del_init(&sd->s_sibling);
  	spin_unlock(&configfs_dirent_lock);
  	configfs_put(sd);
- 	if (d->d_inode)
- 		simple_rmdir(parent->d_inode,d);
+ 	if (d_really_is_positive(d))
+ 		simple_rmdir(d_inode(parent),d);
  
 -	pr_debug(" o %pd removing done (%d)\n", d, d_count(d));
 +	pr_debug(" o %s removing done (%d)\n",d->d_name.name, d_count(d));
  
  	dput(parent);
  }
@@@ -1544,84 -1522,66 +1566,109 @@@ static inline unsigned char dt_type(str
  	return (sd->s_mode >> 12) & 15;
  }
  
 -static int configfs_readdir(struct file *file, struct dir_context *ctx)
 +static int configfs_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
 -	struct dentry *dentry = file->f_path.dentry;
 +	struct dentry *dentry = filp->f_path.dentry;
  	struct super_block *sb = dentry->d_sb;
  	struct configfs_dirent * parent_sd = dentry->d_fsdata;
 -	struct configfs_dirent *cursor = file->private_data;
 +	struct configfs_dirent *cursor = filp->private_data;
  	struct list_head *p, *q = &cursor->s_sibling;
  	ino_t ino = 0;
 +	int i = filp->f_pos;
  
 -	if (!dir_emit_dots(file, ctx))
 -		return 0;
 -	if (ctx->pos == 2) {
 -		spin_lock(&configfs_dirent_lock);
 -		list_move(q, &parent_sd->s_children);
 -		spin_unlock(&configfs_dirent_lock);
 -	}
 -	for (p = q->next; p != &parent_sd->s_children; p = p->next) {
 -		struct configfs_dirent *next;
 -		const char *name;
 -		int len;
 -		struct inode *inode = NULL;
 -
 -		next = list_entry(p, struct configfs_dirent, s_sibling);
 -		if (!next->s_element)
 -			continue;
 -
 -		name = configfs_get_name(next);
 -		len = strlen(name);
 +	switch (i) {
 +		case 0:
 +			ino = dentry->d_inode->i_ino;
 +			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		case 1:
 +			ino = parent_ino(dentry);
 +			if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		default:
 +			if (filp->f_pos == 2) {
 +				spin_lock(&configfs_dirent_lock);
 +				list_move(q, &parent_sd->s_children);
 +				spin_unlock(&configfs_dirent_lock);
 +			}
 +			for (p=q->next; p!= &parent_sd->s_children; p=p->next) {
 +				struct configfs_dirent *next;
 +				const char * name;
 +				int len;
 +				struct inode *inode = NULL;
  
 +				next = list_entry(p, struct configfs_dirent,
 +						   s_sibling);
 +				if (!next->s_element)
 +					continue;
 +
 +				name = configfs_get_name(next);
 +				len = strlen(name);
 +
++<<<<<<< HEAD
 +				/*
 +				 * We'll have a dentry and an inode for
 +				 * PINNED items and for open attribute
 +				 * files.  We lock here to prevent a race
 +				 * with configfs_d_iput() clearing
 +				 * s_dentry before calling iput().
 +				 *
 +				 * Why do we go to the trouble?  If
 +				 * someone has an attribute file open,
 +				 * the inode number should match until
 +				 * they close it.  Beyond that, we don't
 +				 * care.
 +				 */
 +				spin_lock(&configfs_dirent_lock);
 +				dentry = next->s_dentry;
 +				if (dentry)
 +					inode = dentry->d_inode;
 +				if (inode)
 +					ino = inode->i_ino;
 +				spin_unlock(&configfs_dirent_lock);
 +				if (!inode)
 +					ino = iunique(sb, 2);
++=======
+ 		/*
+ 		 * We'll have a dentry and an inode for
+ 		 * PINNED items and for open attribute
+ 		 * files.  We lock here to prevent a race
+ 		 * with configfs_d_iput() clearing
+ 		 * s_dentry before calling iput().
+ 		 *
+ 		 * Why do we go to the trouble?  If
+ 		 * someone has an attribute file open,
+ 		 * the inode number should match until
+ 		 * they close it.  Beyond that, we don't
+ 		 * care.
+ 		 */
+ 		spin_lock(&configfs_dirent_lock);
+ 		dentry = next->s_dentry;
+ 		if (dentry)
+ 			inode = d_inode(dentry);
+ 		if (inode)
+ 			ino = inode->i_ino;
+ 		spin_unlock(&configfs_dirent_lock);
+ 		if (!inode)
+ 			ino = iunique(sb, 2);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
 -		if (!dir_emit(ctx, name, len, ino, dt_type(next)))
 -			return 0;
 +				if (filldir(dirent, name, len, filp->f_pos, ino,
 +						 dt_type(next)) < 0)
 +					return 0;
  
 -		spin_lock(&configfs_dirent_lock);
 -		list_move(q, p);
 -		spin_unlock(&configfs_dirent_lock);
 -		p = q;
 -		ctx->pos++;
 +				spin_lock(&configfs_dirent_lock);
 +				list_move(q, p);
 +				spin_unlock(&configfs_dirent_lock);
 +				p = q;
 +				filp->f_pos++;
 +			}
  	}
  	return 0;
  }
@@@ -1638,7 -1598,7 +1685,11 @@@ static loff_t configfs_dir_lseek(struc
  			if (offset >= 0)
  				break;
  		default:
++<<<<<<< HEAD
 +			mutex_unlock(&file_inode(file)->i_mutex);
++=======
+ 			mutex_unlock(&d_inode(dentry)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			return -EINVAL;
  	}
  	if (offset != file->f_pos) {
@@@ -1695,14 -1654,10 +1746,14 @@@ int configfs_register_subsystem(struct 
  	sd = root->d_fsdata;
  	link_group(to_config_group(sd->s_element), group);
  
- 	mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_PARENT);
+ 	mutex_lock_nested(&d_inode(root)->i_mutex, I_MUTEX_PARENT);
  
 +	name.name = group->cg_item.ci_name;
 +	name.len = strlen(name.name);
 +	name.hash = full_name_hash(name.name, name.len);
 +
  	err = -ENOMEM;
 -	dentry = d_alloc_name(root, group->cg_item.ci_name);
 +	dentry = d_alloc(root, &name);
  	if (dentry) {
  		d_add(dentry, NULL);
  
diff --cc fs/configfs/file.c
index 2b6cb23dd14e,403269ffcdf3..000000000000
--- a/fs/configfs/file.c
+++ b/fs/configfs/file.c
@@@ -336,9 -321,16 +336,18 @@@ int configfs_add_file(struct dentry * d
  
  int configfs_create_file(struct config_item * item, const struct configfs_attribute * attr)
  {
 -	struct dentry *dir = item->ci_dentry;
 -	struct configfs_dirent *parent_sd = dir->d_fsdata;
 -	umode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;
 -	int error = 0;
 +	BUG_ON(!item || !item->ci_dentry || !attr);
  
++<<<<<<< HEAD
 +	return configfs_add_file(item->ci_dentry, attr,
 +				 CONFIGFS_ITEM_ATTR);
++=======
+ 	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_NORMAL);
+ 	error = configfs_make_dirent(parent_sd, NULL, (void *) attr, mode,
+ 				     CONFIGFS_ITEM_ATTR);
+ 	mutex_unlock(&d_inode(dir)->i_mutex);
+ 
+ 	return error;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  
diff --cc fs/configfs/inode.c
index a9d35b0e06cf,8d89f5fd0331..000000000000
--- a/fs/configfs/inode.c
+++ b/fs/configfs/inode.c
@@@ -250,7 -236,7 +250,11 @@@ void configfs_drop_dentry(struct config
  
  	if (dentry) {
  		spin_lock(&dentry->d_lock);
++<<<<<<< HEAD
 +		if (!(d_unhashed(dentry) && dentry->d_inode)) {
++=======
+ 		if (!d_unhashed(dentry) && d_really_is_positive(dentry)) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			dget_dlock(dentry);
  			__d_drop(dentry);
  			spin_unlock(&dentry->d_lock);
@@@ -282,15 -268,5 +286,15 @@@ void configfs_hash_and_remove(struct de
  			break;
  		}
  	}
- 	mutex_unlock(&dir->d_inode->i_mutex);
+ 	mutex_unlock(&d_inode(dir)->i_mutex);
  }
 +
 +int __init configfs_inode_init(void)
 +{
 +	return bdi_init(&configfs_backing_dev_info);
 +}
 +
 +void configfs_inode_exit(void)
 +{
 +	bdi_destroy(&configfs_backing_dev_info);
 +}
diff --cc fs/debugfs/inode.c
index c7c83ff0f752,61dfe45fdb68..000000000000
--- a/fs/debugfs/inode.c
+++ b/fs/debugfs/inode.c
@@@ -249,6 -181,19 +249,22 @@@ static const struct super_operations de
  	.statfs		= simple_statfs,
  	.remount_fs	= debugfs_remount,
  	.show_options	= debugfs_show_options,
++<<<<<<< HEAD
++=======
+ 	.evict_inode	= debugfs_evict_inode,
+ };
+ 
+ static struct vfsmount *debugfs_automount(struct path *path)
+ {
+ 	struct vfsmount *(*f)(void *);
+ 	f = (struct vfsmount *(*)(void *))path->dentry->d_fsdata;
+ 	return f(d_inode(path->dentry)->i_private);
+ }
+ 
+ static const struct dentry_operations debugfs_dops = {
+ 	.d_delete = always_delete_dentry,
+ 	.d_automount = debugfs_automount,
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  };
  
  static int debug_fill_super(struct super_block *sb, void *data, int silent)
@@@ -323,33 -267,28 +339,56 @@@ static struct dentry *__create_file(con
  	if (!parent)
  		parent = debugfs_mount->mnt_root;
  
- 	mutex_lock(&parent->d_inode->i_mutex);
+ 	mutex_lock(&d_inode(parent)->i_mutex);
  	dentry = lookup_one_len(name, parent, strlen(name));
++<<<<<<< HEAD
 +	if (!IS_ERR(dentry)) {
 +		switch (mode & S_IFMT) {
 +		case S_IFDIR:
 +			error = debugfs_mkdir(parent->d_inode, dentry, mode);
 +					      
 +			break;
 +		case S_IFLNK:
 +			error = debugfs_link(parent->d_inode, dentry, mode,
 +					     data);
 +			break;
 +		default:
 +			error = debugfs_create(parent->d_inode, dentry, mode,
 +					       data, fops);
 +			break;
 +		}
++=======
+ 	if (!IS_ERR(dentry) && d_really_is_positive(dentry)) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		dput(dentry);
 -		dentry = ERR_PTR(-EEXIST);
 +	} else
 +		error = PTR_ERR(dentry);
 +	mutex_unlock(&parent->d_inode->i_mutex);
 +
 +	if (error) {
 +		dentry = NULL;
 +		simple_release_fs(&debugfs_mount, &debugfs_mount_count);
  	}
++<<<<<<< HEAD
 +exit:
++=======
+ 	if (IS_ERR(dentry))
+ 		mutex_unlock(&d_inode(parent)->i_mutex);
+ 	return dentry;
+ }
+ 
+ static struct dentry *failed_creating(struct dentry *dentry)
+ {
+ 	mutex_unlock(&d_inode(dentry->d_parent)->i_mutex);
+ 	dput(dentry);
+ 	simple_release_fs(&debugfs_mount, &debugfs_mount_count);
+ 	return NULL;
+ }
+ 
+ static struct dentry *end_creating(struct dentry *dentry)
+ {
+ 	mutex_unlock(&d_inode(dentry->d_parent)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	return dentry;
  }
  
@@@ -383,19 -322,71 +422,83 @@@ struct dentry *debugfs_create_file(cons
  				   struct dentry *parent, void *data,
  				   const struct file_operations *fops)
  {
 -	struct dentry *dentry;
 -	struct inode *inode;
 +	switch (mode & S_IFMT) {
 +	case S_IFREG:
 +	case 0:
 +		break;
 +	default:
 +		BUG();
 +	}
  
++<<<<<<< HEAD
 +	return __create_file(name, mode, parent, data, fops);
++=======
+ 	if (!(mode & S_IFMT))
+ 		mode |= S_IFREG;
+ 	BUG_ON(!S_ISREG(mode));
+ 	dentry = start_creating(name, parent);
+ 
+ 	if (IS_ERR(dentry))
+ 		return NULL;
+ 
+ 	inode = debugfs_get_inode(dentry->d_sb);
+ 	if (unlikely(!inode))
+ 		return failed_creating(dentry);
+ 
+ 	inode->i_mode = mode;
+ 	inode->i_fop = fops ? fops : &debugfs_file_operations;
+ 	inode->i_private = data;
+ 	d_instantiate(dentry, inode);
+ 	fsnotify_create(d_inode(dentry->d_parent), dentry);
+ 	return end_creating(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  EXPORT_SYMBOL_GPL(debugfs_create_file);
  
  /**
++<<<<<<< HEAD
++=======
+  * debugfs_create_file_size - create a file in the debugfs filesystem
+  * @name: a pointer to a string containing the name of the file to create.
+  * @mode: the permission that the file should have.
+  * @parent: a pointer to the parent dentry for this file.  This should be a
+  *          directory dentry if set.  If this parameter is NULL, then the
+  *          file will be created in the root of the debugfs filesystem.
+  * @data: a pointer to something that the caller will want to get to later
+  *        on.  The inode.i_private pointer will point to this value on
+  *        the open() call.
+  * @fops: a pointer to a struct file_operations that should be used for
+  *        this file.
+  * @file_size: initial file size
+  *
+  * This is the basic "create a file" function for debugfs.  It allows for a
+  * wide range of flexibility in creating a file, or a directory (if you want
+  * to create a directory, the debugfs_create_dir() function is
+  * recommended to be used instead.)
+  *
+  * This function will return a pointer to a dentry if it succeeds.  This
+  * pointer must be passed to the debugfs_remove() function when the file is
+  * to be removed (no automatic cleanup happens if your module is unloaded,
+  * you are responsible here.)  If an error occurs, %NULL will be returned.
+  *
+  * If debugfs is not enabled in the kernel, the value -%ENODEV will be
+  * returned.
+  */
+ struct dentry *debugfs_create_file_size(const char *name, umode_t mode,
+ 					struct dentry *parent, void *data,
+ 					const struct file_operations *fops,
+ 					loff_t file_size)
+ {
+ 	struct dentry *de = debugfs_create_file(name, mode, parent, data, fops);
+ 
+ 	if (de)
+ 		d_inode(de)->i_size = file_size;
+ 	return de;
+ }
+ EXPORT_SYMBOL_GPL(debugfs_create_file_size);
+ 
+ /**
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
   * debugfs_create_dir - create a directory in the debugfs filesystem
   * @name: a pointer to a string containing the name of the directory to
   *        create.
@@@ -415,8 -406,26 +518,31 @@@
   */
  struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)
  {
++<<<<<<< HEAD
 +	return __create_file(name, S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO,
 +				   parent, NULL, NULL);
++=======
+ 	struct dentry *dentry = start_creating(name, parent);
+ 	struct inode *inode;
+ 
+ 	if (IS_ERR(dentry))
+ 		return NULL;
+ 
+ 	inode = debugfs_get_inode(dentry->d_sb);
+ 	if (unlikely(!inode))
+ 		return failed_creating(dentry);
+ 
+ 	inode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
+ 	inode->i_op = &simple_dir_inode_operations;
+ 	inode->i_fop = &simple_dir_operations;
+ 
+ 	/* directory inodes start off with i_nlink == 2 (for "." entry) */
+ 	inc_nlink(inode);
+ 	d_instantiate(dentry, inode);
+ 	inc_nlink(d_inode(dentry->d_parent));
+ 	fsnotify_mkdir(d_inode(dentry->d_parent), dentry);
+ 	return end_creating(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  EXPORT_SYMBOL_GPL(debugfs_create_dir);
  
@@@ -465,23 -520,14 +591,34 @@@ static int __debugfs_remove(struct dent
  	int ret = 0;
  
  	if (debugfs_positive(dentry)) {
++<<<<<<< HEAD
 +		if (dentry->d_inode) {
 +			dget(dentry);
 +			switch (dentry->d_inode->i_mode & S_IFMT) {
 +			case S_IFDIR:
 +				ret = simple_rmdir(parent->d_inode, dentry);
 +				break;
 +			case S_IFLNK:
 +				kfree(dentry->d_inode->i_private);
 +				/* fall through */
 +			default:
 +				simple_unlink(parent->d_inode, dentry);
 +				break;
 +			}
 +			if (!ret)
 +				d_delete(dentry);
 +			dput(dentry);
 +		}
++=======
+ 		dget(dentry);
+ 		if (d_is_dir(dentry))
+ 			ret = simple_rmdir(d_inode(parent), dentry);
+ 		else
+ 			simple_unlink(d_inode(parent), dentry);
+ 		if (!ret)
+ 			d_delete(dentry);
+ 		dput(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	}
  	return ret;
  }
@@@ -544,32 -590,50 +681,49 @@@ void debugfs_remove_recursive(struct de
  
  	parent = dentry;
   down:
++<<<<<<< HEAD
 +	mutex_lock(&parent->d_inode->i_mutex);
 +	list_for_each_entry_safe(child, next, &parent->d_subdirs, d_u.d_child) {
++=======
+ 	mutex_lock(&d_inode(parent)->i_mutex);
+  loop:
+ 	/*
+ 	 * The parent->d_subdirs is protected by the d_lock. Outside that
+ 	 * lock, the child can be unlinked and set to be freed which can
+ 	 * use the d_u.d_child as the rcu head and corrupt this list.
+ 	 */
+ 	spin_lock(&parent->d_lock);
+ 	list_for_each_entry(child, &parent->d_subdirs, d_child) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		if (!debugfs_positive(child))
  			continue;
  
  		/* perhaps simple_empty(child) makes more sense */
  		if (!list_empty(&child->d_subdirs)) {
++<<<<<<< HEAD
 +			mutex_unlock(&parent->d_inode->i_mutex);
++=======
+ 			spin_unlock(&parent->d_lock);
+ 			mutex_unlock(&d_inode(parent)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			parent = child;
  			goto down;
  		}
 -
 -		spin_unlock(&parent->d_lock);
 -
 + up:
  		if (!__debugfs_remove(child, parent))
  			simple_release_fs(&debugfs_mount, &debugfs_mount_count);
 -
 -		/*
 -		 * The parent->d_lock protects agaist child from unlinking
 -		 * from d_subdirs. When releasing the parent->d_lock we can
 -		 * no longer trust that the next pointer is valid.
 -		 * Restart the loop. We'll skip this one with the
 -		 * debugfs_positive() check.
 -		 */
 -		goto loop;
  	}
 -	spin_unlock(&parent->d_lock);
  
- 	mutex_unlock(&parent->d_inode->i_mutex);
+ 	mutex_unlock(&d_inode(parent)->i_mutex);
  	child = parent;
  	parent = parent->d_parent;
- 	mutex_lock(&parent->d_inode->i_mutex);
+ 	mutex_lock(&d_inode(parent)->i_mutex);
  
 -	if (child != dentry)
 -		/* go up */
 -		goto loop;
 +	if (child != dentry) {
 +		next = list_entry(child->d_u.d_child.next, struct dentry,
 +					d_u.d_child);
 +		goto up;
 +	}
  
  	if (!__debugfs_remove(child, parent))
  		simple_release_fs(&debugfs_mount, &debugfs_mount_count);
@@@ -625,8 -689,8 +779,13 @@@ struct dentry *debugfs_rename(struct de
  		goto exit;
  	}
  	d_move(old_dentry, dentry);
++<<<<<<< HEAD
 +	fsnotify_move(old_dir->d_inode, new_dir->d_inode, old_name,
 +		S_ISDIR(old_dentry->d_inode->i_mode),
++=======
+ 	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,
+ 		d_is_dir(old_dentry),
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		NULL, old_dentry);
  	fsnotify_oldname_free(old_name);
  	unlock_rename(new_dir, old_dir);
diff --cc fs/ecryptfs/inode.c
index fef4763df8be,fc850b55db67..000000000000
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@@ -192,30 -189,23 +192,34 @@@ ecryptfs_do_create(struct inode *direct
  
  	lower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);
  	lower_dir_dentry = lock_parent(lower_dentry);
++<<<<<<< HEAD
 +	if (IS_ERR(lower_dir_dentry)) {
 +		ecryptfs_printk(KERN_ERR, "Error locking directory of "
 +				"dentry\n");
 +		inode = ERR_CAST(lower_dir_dentry);
 +		goto out;
 +	}
 +	rc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, true);
++=======
+ 	rc = vfs_create(d_inode(lower_dir_dentry), lower_dentry, mode, true);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	if (rc) {
  		printk(KERN_ERR "%s: Failure to create dentry in lower fs; "
  		       "rc = [%d]\n", __func__, rc);
  		inode = ERR_PTR(rc);
  		goto out_lock;
  	}
- 	inode = __ecryptfs_get_inode(lower_dentry->d_inode,
+ 	inode = __ecryptfs_get_inode(d_inode(lower_dentry),
  				     directory_inode->i_sb);
  	if (IS_ERR(inode)) {
- 		vfs_unlink(lower_dir_dentry->d_inode, lower_dentry, NULL);
+ 		vfs_unlink(d_inode(lower_dir_dentry), lower_dentry, NULL);
  		goto out_lock;
  	}
- 	fsstack_copy_attr_times(directory_inode, lower_dir_dentry->d_inode);
- 	fsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);
+ 	fsstack_copy_attr_times(directory_inode, d_inode(lower_dir_dentry));
+ 	fsstack_copy_inode_size(directory_inode, d_inode(lower_dir_dentry));
  out_lock:
  	unlock_dir(lower_dir_dentry);
 +out:
  	return inode;
  }
  
@@@ -361,10 -351,10 +365,10 @@@ static int ecryptfs_lookup_interpose(st
  	BUG_ON(!d_count(lower_dentry));
  
  	ecryptfs_set_dentry_private(dentry, dentry_info);
 -	dentry_info->lower_path.mnt = lower_mnt;
 -	dentry_info->lower_path.dentry = lower_dentry;
 +	ecryptfs_set_dentry_lower(dentry, lower_dentry);
 +	ecryptfs_set_dentry_lower_mnt(dentry, lower_mnt);
  
- 	if (!lower_dentry->d_inode) {
+ 	if (d_really_is_negative(lower_dentry)) {
  		/* We want to add because we couldn't find in lower */
  		d_add(dentry, NULL);
  		return 0;
@@@ -418,11 -408,11 +422,11 @@@ static struct dentry *ecryptfs_lookup(s
  	if (IS_ERR(lower_dentry)) {
  		rc = PTR_ERR(lower_dentry);
  		ecryptfs_printk(KERN_DEBUG, "%s: lookup_one_len() returned "
 -				"[%d] on lower_dentry = [%pd]\n", __func__, rc,
 -				ecryptfs_dentry);
 +				"[%d] on lower_dentry = [%s]\n", __func__, rc,
 +				ecryptfs_dentry->d_name.name);
  		goto out;
  	}
- 	if (lower_dentry->d_inode)
+ 	if (d_really_is_positive(lower_dentry))
  		goto interpose;
  	mount_crypt_stat = &ecryptfs_superblock_to_private(
  				ecryptfs_dentry->d_sb)->mount_crypt_stat;
@@@ -668,13 -658,11 +672,13 @@@ static int ecryptfs_readlink_lower(stru
  	int rc;
  
  	lower_buf = kmalloc(PATH_MAX, GFP_KERNEL);
 -	if (!lower_buf)
 -		return ERR_PTR(-ENOMEM);
 +	if (!lower_buf) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
  	old_fs = get_fs();
  	set_fs(get_ds());
- 	rc = lower_dentry->d_inode->i_op->readlink(lower_dentry,
+ 	rc = d_inode(lower_dentry)->i_op->readlink(lower_dentry,
  						   (char __user *)lower_buf,
  						   PATH_MAX);
  	set_fs(old_fs);
@@@ -689,15 -677,12 +693,15 @@@ out
  
  static void *ecryptfs_follow_link(struct dentry *dentry, struct nameidata *nd)
  {
 -	size_t len;
 -	char *buf = ecryptfs_readlink_lower(dentry, &len);
 -	if (IS_ERR(buf))
 +	char *buf;
 +	size_t len = PATH_MAX;
 +	int rc;
 +
 +	rc = ecryptfs_readlink_lower(dentry, &buf, &len);
 +	if (rc)
  		goto out;
- 	fsstack_copy_attr_atime(dentry->d_inode,
- 				ecryptfs_dentry_to_lower(dentry)->d_inode);
+ 	fsstack_copy_attr_atime(d_inode(dentry),
+ 				d_inode(ecryptfs_dentry_to_lower(dentry)));
  	buf[len] = '\0';
  out:
  	nd_set_link(nd, buf);
@@@ -1042,8 -1029,8 +1046,13 @@@ ecryptfs_setxattr(struct dentry *dentry
  	}
  
  	rc = vfs_setxattr(lower_dentry, name, value, size, flags);
++<<<<<<< HEAD
 +	if (!rc)
 +		fsstack_copy_attr_all(dentry->d_inode, lower_dentry->d_inode);
++=======
+ 	if (!rc && d_really_is_positive(dentry))
+ 		fsstack_copy_attr_all(d_inode(dentry), d_inode(lower_dentry));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  out:
  	return rc;
  }
diff --cc fs/ecryptfs/mmap.c
index 564a1fa34b99,cf208522998e..000000000000
--- a/fs/ecryptfs/mmap.c
+++ b/fs/ecryptfs/mmap.c
@@@ -419,8 -419,8 +419,13 @@@ static int ecryptfs_write_inode_size_to
  	ssize_t size;
  	void *xattr_virt;
  	struct dentry *lower_dentry =
++<<<<<<< HEAD
 +		ecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_dentry;
 +	struct inode *lower_inode = lower_dentry->d_inode;
++=======
+ 		ecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;
+ 	struct inode *lower_inode = d_inode(lower_dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	int rc;
  
  	if (!lower_inode->i_op->getxattr || !lower_inode->i_op->setxattr) {
diff --cc fs/ext3/super.c
index 32559ee74f5c,30abbab2c65b..000000000000
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@@ -1118,6 -1148,41 +1118,44 @@@ static int parse_options (char *options
  				return 0;
  			*journal_devnum = option;
  			break;
++<<<<<<< HEAD
++=======
+ 		case Opt_journal_path:
+ 			if (is_remount) {
+ 				ext3_msg(sb, KERN_ERR, "error: cannot specify "
+ 				       "journal on remount");
+ 				return 0;
+ 			}
+ 
+ 			journal_path = match_strdup(&args[0]);
+ 			if (!journal_path) {
+ 				ext3_msg(sb, KERN_ERR, "error: could not dup "
+ 					"journal device string");
+ 				return 0;
+ 			}
+ 
+ 			error = kern_path(journal_path, LOOKUP_FOLLOW, &path);
+ 			if (error) {
+ 				ext3_msg(sb, KERN_ERR, "error: could not find "
+ 					"journal device path: error %d", error);
+ 				kfree(journal_path);
+ 				return 0;
+ 			}
+ 
+ 			journal_inode = d_inode(path.dentry);
+ 			if (!S_ISBLK(journal_inode->i_mode)) {
+ 				ext3_msg(sb, KERN_ERR, "error: journal path %s "
+ 					"is not a block device", journal_path);
+ 				path_put(&path);
+ 				kfree(journal_path);
+ 				return 0;
+ 			}
+ 
+ 			*journal_devnum = new_encode_dev(journal_inode->i_rdev);
+ 			path_put(&path);
+ 			kfree(journal_path);
+ 			break;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		case Opt_noload:
  			set_opt (sbi->s_mount_opt, NOLOAD);
  			break;
diff --cc fs/ext4/namei.c
index 06be148622f8,e086eebe335e..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -1890,8 -1864,8 +1890,13 @@@ out_frames
  static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
  			  struct inode *inode)
  {
++<<<<<<< HEAD
 +	struct inode *dir = dentry->d_parent->d_inode;
 +	struct buffer_head *bh = NULL;
++=======
+ 	struct inode *dir = d_inode(dentry->d_parent);
+ 	struct buffer_head *bh;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct ext4_dir_entry_2 *de;
  	struct ext4_dir_entry_tail *t;
  	struct super_block *sb;
diff --cc fs/f2fs/namei.c
index 47abc9722b17,ed7404706ca4..000000000000
--- a/fs/f2fs/namei.c
+++ b/fs/f2fs/namei.c
@@@ -165,10 -150,9 +165,16 @@@ out
  static int f2fs_link(struct dentry *old_dentry, struct inode *dir,
  		struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct inode *inode = old_dentry->d_inode;
 +	struct super_block *sb = dir->i_sb;
 +	struct f2fs_sb_info *sbi = F2FS_SB(sb);
 +	int err, ilock;
++=======
+ 	struct inode *inode = d_inode(old_dentry);
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(dir);
+ 	int err;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	f2fs_balance_fs(sbi);
  
@@@ -232,9 -213,8 +238,14 @@@ static struct dentry *f2fs_lookup(struc
  
  static int f2fs_unlink(struct inode *dir, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct super_block *sb = dir->i_sb;
 +	struct f2fs_sb_info *sbi = F2FS_SB(sb);
 +	struct inode *inode = dentry->d_inode;
++=======
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(dir);
+ 	struct inode *inode = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct f2fs_dir_entry *de;
  	struct page *page;
  	int err = -ENOENT;
@@@ -396,12 -373,11 +407,18 @@@ out
  static int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,
  			struct inode *new_dir, struct dentry *new_dentry)
  {
++<<<<<<< HEAD
 +	struct super_block *sb = old_dir->i_sb;
 +	struct f2fs_sb_info *sbi = F2FS_SB(sb);
 +	struct inode *old_inode = old_dentry->d_inode;
 +	struct inode *new_inode = new_dentry->d_inode;
++=======
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);
+ 	struct inode *old_inode = d_inode(old_dentry);
+ 	struct inode *new_inode = d_inode(new_dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct page *old_dir_page;
 -	struct page *old_page, *new_page;
 +	struct page *old_page;
  	struct f2fs_dir_entry *old_dir_entry = NULL;
  	struct f2fs_dir_entry *old_entry;
  	struct f2fs_dir_entry *new_entry;
@@@ -488,6 -497,213 +505,216 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,
+ 			     struct inode *new_dir, struct dentry *new_dentry)
+ {
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);
+ 	struct inode *old_inode = d_inode(old_dentry);
+ 	struct inode *new_inode = d_inode(new_dentry);
+ 	struct page *old_dir_page, *new_dir_page;
+ 	struct page *old_page, *new_page;
+ 	struct f2fs_dir_entry *old_dir_entry = NULL, *new_dir_entry = NULL;
+ 	struct f2fs_dir_entry *old_entry, *new_entry;
+ 	int old_nlink = 0, new_nlink = 0;
+ 	int err = -ENOENT;
+ 
+ 	f2fs_balance_fs(sbi);
+ 
+ 	old_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);
+ 	if (!old_entry)
+ 		goto out;
+ 
+ 	new_entry = f2fs_find_entry(new_dir, &new_dentry->d_name, &new_page);
+ 	if (!new_entry)
+ 		goto out_old;
+ 
+ 	/* prepare for updating ".." directory entry info later */
+ 	if (old_dir != new_dir) {
+ 		if (S_ISDIR(old_inode->i_mode)) {
+ 			err = -EIO;
+ 			old_dir_entry = f2fs_parent_dir(old_inode,
+ 							&old_dir_page);
+ 			if (!old_dir_entry)
+ 				goto out_new;
+ 		}
+ 
+ 		if (S_ISDIR(new_inode->i_mode)) {
+ 			err = -EIO;
+ 			new_dir_entry = f2fs_parent_dir(new_inode,
+ 							&new_dir_page);
+ 			if (!new_dir_entry)
+ 				goto out_old_dir;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * If cross rename between file and directory those are not
+ 	 * in the same directory, we will inc nlink of file's parent
+ 	 * later, so we should check upper boundary of its nlink.
+ 	 */
+ 	if ((!old_dir_entry || !new_dir_entry) &&
+ 				old_dir_entry != new_dir_entry) {
+ 		old_nlink = old_dir_entry ? -1 : 1;
+ 		new_nlink = -old_nlink;
+ 		err = -EMLINK;
+ 		if ((old_nlink > 0 && old_inode->i_nlink >= F2FS_LINK_MAX) ||
+ 			(new_nlink > 0 && new_inode->i_nlink >= F2FS_LINK_MAX))
+ 			goto out_new_dir;
+ 	}
+ 
+ 	f2fs_lock_op(sbi);
+ 
+ 	err = update_dent_inode(old_inode, &new_dentry->d_name);
+ 	if (err)
+ 		goto out_unlock;
+ 
+ 	err = update_dent_inode(new_inode, &old_dentry->d_name);
+ 	if (err)
+ 		goto out_undo;
+ 
+ 	/* update ".." directory entry info of old dentry */
+ 	if (old_dir_entry)
+ 		f2fs_set_link(old_inode, old_dir_entry, old_dir_page, new_dir);
+ 
+ 	/* update ".." directory entry info of new dentry */
+ 	if (new_dir_entry)
+ 		f2fs_set_link(new_inode, new_dir_entry, new_dir_page, old_dir);
+ 
+ 	/* update directory entry info of old dir inode */
+ 	f2fs_set_link(old_dir, old_entry, old_page, new_inode);
+ 
+ 	down_write(&F2FS_I(old_inode)->i_sem);
+ 	file_lost_pino(old_inode);
+ 	up_write(&F2FS_I(old_inode)->i_sem);
+ 
+ 	update_inode_page(old_inode);
+ 
+ 	old_dir->i_ctime = CURRENT_TIME;
+ 	if (old_nlink) {
+ 		down_write(&F2FS_I(old_dir)->i_sem);
+ 		if (old_nlink < 0)
+ 			drop_nlink(old_dir);
+ 		else
+ 			inc_nlink(old_dir);
+ 		up_write(&F2FS_I(old_dir)->i_sem);
+ 	}
+ 	mark_inode_dirty(old_dir);
+ 	update_inode_page(old_dir);
+ 
+ 	/* update directory entry info of new dir inode */
+ 	f2fs_set_link(new_dir, new_entry, new_page, old_inode);
+ 
+ 	down_write(&F2FS_I(new_inode)->i_sem);
+ 	file_lost_pino(new_inode);
+ 	up_write(&F2FS_I(new_inode)->i_sem);
+ 
+ 	update_inode_page(new_inode);
+ 
+ 	new_dir->i_ctime = CURRENT_TIME;
+ 	if (new_nlink) {
+ 		down_write(&F2FS_I(new_dir)->i_sem);
+ 		if (new_nlink < 0)
+ 			drop_nlink(new_dir);
+ 		else
+ 			inc_nlink(new_dir);
+ 		up_write(&F2FS_I(new_dir)->i_sem);
+ 	}
+ 	mark_inode_dirty(new_dir);
+ 	update_inode_page(new_dir);
+ 
+ 	f2fs_unlock_op(sbi);
+ 
+ 	if (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))
+ 		f2fs_sync_fs(sbi->sb, 1);
+ 	return 0;
+ out_undo:
+ 	/* Still we may fail to recover name info of f2fs_inode here */
+ 	update_dent_inode(old_inode, &old_dentry->d_name);
+ out_unlock:
+ 	f2fs_unlock_op(sbi);
+ out_new_dir:
+ 	if (new_dir_entry) {
+ 		f2fs_dentry_kunmap(new_inode, new_dir_page);
+ 		f2fs_put_page(new_dir_page, 0);
+ 	}
+ out_old_dir:
+ 	if (old_dir_entry) {
+ 		f2fs_dentry_kunmap(old_inode, old_dir_page);
+ 		f2fs_put_page(old_dir_page, 0);
+ 	}
+ out_new:
+ 	f2fs_dentry_kunmap(new_dir, new_page);
+ 	f2fs_put_page(new_page, 0);
+ out_old:
+ 	f2fs_dentry_kunmap(old_dir, old_page);
+ 	f2fs_put_page(old_page, 0);
+ out:
+ 	return err;
+ }
+ 
+ static int f2fs_rename2(struct inode *old_dir, struct dentry *old_dentry,
+ 			struct inode *new_dir, struct dentry *new_dentry,
+ 			unsigned int flags)
+ {
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))
+ 		return -EINVAL;
+ 
+ 	if (flags & RENAME_EXCHANGE) {
+ 		return f2fs_cross_rename(old_dir, old_dentry,
+ 					 new_dir, new_dentry);
+ 	}
+ 	/*
+ 	 * VFS has already handled the new dentry existence case,
+ 	 * here, we just deal with "RENAME_NOREPLACE" as regular rename.
+ 	 */
+ 	return f2fs_rename(old_dir, old_dentry, new_dir, new_dentry);
+ }
+ 
+ static int f2fs_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)
+ {
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(dir);
+ 	struct inode *inode;
+ 	int err;
+ 
+ 	inode = f2fs_new_inode(dir, mode);
+ 	if (IS_ERR(inode))
+ 		return PTR_ERR(inode);
+ 
+ 	inode->i_op = &f2fs_file_inode_operations;
+ 	inode->i_fop = &f2fs_file_operations;
+ 	inode->i_mapping->a_ops = &f2fs_dblock_aops;
+ 
+ 	f2fs_lock_op(sbi);
+ 	err = acquire_orphan_inode(sbi);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = f2fs_do_tmpfile(inode, dir);
+ 	if (err)
+ 		goto release_out;
+ 
+ 	/*
+ 	 * add this non-linked tmpfile to orphan list, in this way we could
+ 	 * remove all unused data of tmpfile after abnormal power-off.
+ 	 */
+ 	add_orphan_inode(sbi, inode->i_ino);
+ 	f2fs_unlock_op(sbi);
+ 
+ 	alloc_nid_done(sbi, inode->i_ino);
+ 	d_tmpfile(dentry, inode);
+ 	unlock_new_inode(inode);
+ 	return 0;
+ 
+ release_out:
+ 	release_orphan_inode(sbi);
+ out:
+ 	handle_failed_inode(inode);
+ 	return err;
+ }
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  const struct inode_operations f2fs_dir_inode_operations = {
  	.create		= f2fs_create,
  	.lookup		= f2fs_lookup,
diff --cc fs/f2fs/xattr.c
index 0b02dce31356,62c82f35087e..000000000000
--- a/fs/f2fs/xattr.c
+++ b/fs/f2fs/xattr.c
@@@ -75,8 -83,7 +75,12 @@@ static int f2fs_xattr_generic_get(struc
  	}
  	if (strcmp(name, "") == 0)
  		return -EINVAL;
++<<<<<<< HEAD
 +	return f2fs_getxattr(dentry->d_inode, type, name,
 +			buffer, size);
++=======
+ 	return f2fs_getxattr(d_inode(dentry), type, name, buffer, size, NULL);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  
  static int f2fs_xattr_generic_set(struct dentry *dentry, const char *name,
@@@ -99,7 -108,8 +103,12 @@@
  	if (strcmp(name, "") == 0)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	return f2fs_setxattr(dentry->d_inode, type, name, value, size);
++=======
+ 	return f2fs_setxattr(d_inode(dentry), type, name,
+ 					value, size, NULL, flags);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  
  static size_t f2fs_xattr_advise_list(struct dentry *dentry, char *list,
@@@ -255,11 -442,8 +264,15 @@@ cleanup
  
  ssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
 +	struct f2fs_inode_info *fi = F2FS_I(inode);
++=======
+ 	struct inode *inode = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct f2fs_xattr_entry *entry;
 +	struct page *page;
  	void *base_addr;
  	int error = 0;
  	size_t rest = buffer_size;
diff --cc fs/fuse/dir.c
index 07254ac422e9,0572bca49f15..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -182,9 -189,10 +182,9 @@@ static int fuse_dentry_revalidate(struc
  	struct inode *inode;
  	struct dentry *parent;
  	struct fuse_conn *fc;
 -	struct fuse_inode *fi;
  	int ret;
  
- 	inode = ACCESS_ONCE(entry->d_inode);
+ 	inode = d_inode_rcu(entry);
  	if (inode && is_bad_inode(inode))
  		goto invalid;
  	else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
@@@ -219,17 -220,15 +219,21 @@@
  		attr_version = fuse_get_attr_version(fc);
  
  		parent = dget_parent(entry);
++<<<<<<< HEAD
 +		fuse_lookup_init(fc, req, get_node_id(parent->d_inode),
++=======
+ 		fuse_lookup_init(fc, &args, get_node_id(d_inode(parent)),
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  				 &entry->d_name, &outarg);
 -		ret = fuse_simple_request(fc, &args);
 +		fuse_request_send(fc, req);
  		dput(parent);
 +		err = req->out.h.error;
 +		fuse_put_request(fc, req);
  		/* Zero nodeid is same as -ENOENT */
 -		if (!ret && !outarg.nodeid)
 -			ret = -ENOENT;
 -		if (!ret) {
 -			fi = get_fuse_inode(inode);
 +		if (!err && !outarg.nodeid)
 +			err = -ENOENT;
 +		if (!err) {
 +			struct fuse_inode *fi = get_fuse_inode(inode);
  			if (outarg.nodeid != get_node_id(inode)) {
  				fuse_queue_forget(fc, forget, outarg.nodeid, 1);
  				goto invalid;
@@@ -247,10 -248,13 +251,10 @@@
  				       attr_version);
  		fuse_change_entry_timeout(entry, &outarg);
  	} else if (inode) {
 -		fi = get_fuse_inode(inode);
 -		if (flags & LOOKUP_RCU) {
 -			if (test_bit(FUSE_I_INIT_RDPLUS, &fi->state))
 -				return -ECHILD;
 -		} else if (test_and_clear_bit(FUSE_I_INIT_RDPLUS, &fi->state)) {
 +		fc = get_fuse_conn(inode);
 +		if (fc->readdirplus_auto) {
  			parent = dget_parent(entry);
- 			fuse_advise_use_readdirplus(parent->d_inode);
+ 			fuse_advise_use_readdirplus(d_inode(parent));
  			dput(parent);
  		}
  	}
@@@ -699,20 -644,16 +703,20 @@@ static int fuse_unlink(struct inode *di
  {
  	int err;
  	struct fuse_conn *fc = get_fuse_conn(dir);
 -	FUSE_ARGS(args);
 -
 -	args.in.h.opcode = FUSE_UNLINK;
 -	args.in.h.nodeid = get_node_id(dir);
 -	args.in.numargs = 1;
 -	args.in.args[0].size = entry->d_name.len + 1;
 -	args.in.args[0].value = entry->d_name.name;
 -	err = fuse_simple_request(fc, &args);
 +	struct fuse_req *req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	req->in.h.opcode = FUSE_UNLINK;
 +	req->in.h.nodeid = get_node_id(dir);
 +	req->in.numargs = 1;
 +	req->in.args[0].size = entry->d_name.len + 1;
 +	req->in.args[0].value = entry->d_name.name;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
  	if (!err) {
- 		struct inode *inode = entry->d_inode;
+ 		struct inode *inode = d_inode(entry);
  		struct fuse_inode *fi = get_fuse_inode(inode);
  
  		spin_lock(&fc->lock);
@@@ -738,20 -680,16 +742,20 @@@ static int fuse_rmdir(struct inode *dir
  {
  	int err;
  	struct fuse_conn *fc = get_fuse_conn(dir);
 -	FUSE_ARGS(args);
 -
 -	args.in.h.opcode = FUSE_RMDIR;
 -	args.in.h.nodeid = get_node_id(dir);
 -	args.in.numargs = 1;
 -	args.in.args[0].size = entry->d_name.len + 1;
 -	args.in.args[0].value = entry->d_name.name;
 -	err = fuse_simple_request(fc, &args);
 +	struct fuse_req *req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	req->in.h.opcode = FUSE_RMDIR;
 +	req->in.h.nodeid = get_node_id(dir);
 +	req->in.numargs = 1;
 +	req->in.args[0].size = entry->d_name.len + 1;
 +	req->in.args[0].value = entry->d_name.name;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
  	if (!err) {
- 		clear_nlink(entry->d_inode);
+ 		clear_nlink(d_inode(entry));
  		fuse_invalidate_attr(dir);
  		fuse_invalidate_entry_cache(entry);
  	} else if (err == -EINTR)
@@@ -775,24 -709,24 +779,33 @@@ static int fuse_rename_common(struct in
  	memset(&inarg, 0, argsize);
  	inarg.newdir = get_node_id(newdir);
  	inarg.flags = flags;
 -	args.in.h.opcode = opcode;
 -	args.in.h.nodeid = get_node_id(olddir);
 -	args.in.numargs = 3;
 -	args.in.args[0].size = argsize;
 -	args.in.args[0].value = &inarg;
 -	args.in.args[1].size = oldent->d_name.len + 1;
 -	args.in.args[1].value = oldent->d_name.name;
 -	args.in.args[2].size = newent->d_name.len + 1;
 -	args.in.args[2].value = newent->d_name.name;
 -	err = fuse_simple_request(fc, &args);
 +	req->in.h.opcode = opcode;
 +	req->in.h.nodeid = get_node_id(olddir);
 +	req->in.numargs = 3;
 +	req->in.args[0].size = argsize;
 +	req->in.args[0].value = &inarg;
 +	req->in.args[1].size = oldent->d_name.len + 1;
 +	req->in.args[1].value = oldent->d_name.name;
 +	req->in.args[2].size = newent->d_name.len + 1;
 +	req->in.args[2].value = newent->d_name.name;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
  	if (!err) {
  		/* ctime changes */
++<<<<<<< HEAD
 +		fuse_invalidate_attr(oldent->d_inode);
 +
 +		if (flags & RENAME_EXCHANGE) {
 +			fuse_invalidate_attr(newent->d_inode);
++=======
+ 		fuse_invalidate_attr(d_inode(oldent));
+ 		fuse_update_ctime(d_inode(oldent));
+ 
+ 		if (flags & RENAME_EXCHANGE) {
+ 			fuse_invalidate_attr(d_inode(newent));
+ 			fuse_update_ctime(d_inode(newent));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		}
  
  		fuse_invalidate_attr(olddir);
@@@ -800,9 -734,10 +813,13 @@@
  			fuse_invalidate_attr(newdir);
  
  		/* newent will end up negative */
- 		if (!(flags & RENAME_EXCHANGE) && newent->d_inode) {
- 			fuse_invalidate_attr(newent->d_inode);
+ 		if (!(flags & RENAME_EXCHANGE) && d_really_is_positive(newent)) {
+ 			fuse_invalidate_attr(d_inode(newent));
  			fuse_invalidate_entry_cache(newent);
++<<<<<<< HEAD
++=======
+ 			fuse_update_ctime(d_inode(newent));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		}
  	} else if (err == -EINTR) {
  		/* If request was interrupted, DEITY only knows if the
@@@ -861,11 -788,9 +878,11 @@@ static int fuse_link(struct dentry *ent
  {
  	int err;
  	struct fuse_link_in inarg;
- 	struct inode *inode = entry->d_inode;
+ 	struct inode *inode = d_inode(entry);
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	FUSE_ARGS(args);
 +	struct fuse_req *req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
  
  	memset(&inarg, 0, sizeof(inarg));
  	inarg.oldnodeid = get_node_id(inode);
@@@ -1450,34 -1367,30 +1467,34 @@@ static int fuse_readdir(struct file *fi
  
  static char *read_link(struct dentry *dentry)
  {
- 	struct inode *inode = dentry->d_inode;
+ 	struct inode *inode = d_inode(dentry);
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	FUSE_ARGS(args);
 +	struct fuse_req *req = fuse_get_req_nopages(fc);
  	char *link;
 -	ssize_t ret;
 +
 +	if (IS_ERR(req))
 +		return ERR_CAST(req);
  
  	link = (char *) __get_free_page(GFP_KERNEL);
 -	if (!link)
 -		return ERR_PTR(-ENOMEM);
 -
 -	args.in.h.opcode = FUSE_READLINK;
 -	args.in.h.nodeid = get_node_id(inode);
 -	args.out.argvar = 1;
 -	args.out.numargs = 1;
 -	args.out.args[0].size = PAGE_SIZE - 1;
 -	args.out.args[0].value = link;
 -	ret = fuse_simple_request(fc, &args);
 -	if (ret < 0) {
 -		free_page((unsigned long) link);
 -		link = ERR_PTR(ret);
 -	} else {
 -		link[ret] = '\0';
 +	if (!link) {
 +		link = ERR_PTR(-ENOMEM);
 +		goto out;
  	}
 -	fuse_invalidate_atime(inode);
 +	req->in.h.opcode = FUSE_READLINK;
 +	req->in.h.nodeid = get_node_id(inode);
 +	req->out.argvar = 1;
 +	req->out.numargs = 1;
 +	req->out.args[0].size = PAGE_SIZE - 1;
 +	req->out.args[0].value = link;
 +	fuse_request_send(fc, req);
 +	if (req->out.h.error) {
 +		free_page((unsigned long) link);
 +		link = ERR_PTR(req->out.h.error);
 +	} else
 +		link[req->out.args[0].size] = '\0';
 + out:
 +	fuse_put_request(fc, req);
 +	fuse_invalidate_attr(inode); /* atime changed */
  	return link;
  }
  
@@@ -1770,9 -1738,9 +1787,9 @@@ static int fuse_getattr(struct vfsmoun
  static int fuse_setxattr(struct dentry *entry, const char *name,
  			 const void *value, size_t size, int flags)
  {
- 	struct inode *inode = entry->d_inode;
+ 	struct inode *inode = d_inode(entry);
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	FUSE_ARGS(args);
 +	struct fuse_req *req;
  	struct fuse_setxattr_in inarg;
  	int err;
  
@@@ -1810,9 -1774,9 +1827,9 @@@
  static ssize_t fuse_getxattr(struct dentry *entry, const char *name,
  			     void *value, size_t size)
  {
- 	struct inode *inode = entry->d_inode;
+ 	struct inode *inode = d_inode(entry);
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	FUSE_ARGS(args);
 +	struct fuse_req *req;
  	struct fuse_getxattr_in inarg;
  	struct fuse_getxattr_out outarg;
  	ssize_t ret;
@@@ -1859,9 -1815,9 +1876,9 @@@
  
  static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
  {
- 	struct inode *inode = entry->d_inode;
+ 	struct inode *inode = d_inode(entry);
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	FUSE_ARGS(args);
 +	struct fuse_req *req;
  	struct fuse_getxattr_in inarg;
  	struct fuse_getxattr_out outarg;
  	ssize_t ret;
@@@ -1909,9 -1857,9 +1926,9 @@@
  
  static int fuse_removexattr(struct dentry *entry, const char *name)
  {
- 	struct inode *inode = entry->d_inode;
+ 	struct inode *inode = d_inode(entry);
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	FUSE_ARGS(args);
 +	struct fuse_req *req;
  	int err;
  
  	if (fc->no_removexattr)
diff --cc fs/fuse/inode.c
index 378ca42a7b8d,082ac1c97f39..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -417,23 -418,16 +417,33 @@@ static int fuse_statfs(struct dentry *d
  		return 0;
  	}
  
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
  	memset(&outarg, 0, sizeof(outarg));
++<<<<<<< HEAD
 +	req->in.numargs = 0;
 +	req->in.h.opcode = FUSE_STATFS;
 +	req->in.h.nodeid = get_node_id(dentry->d_inode);
 +	req->out.numargs = 1;
 +	req->out.args[0].size =
 +		fc->minor < 4 ? FUSE_COMPAT_STATFS_SIZE : sizeof(outarg);
 +	req->out.args[0].value = &outarg;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
++=======
+ 	args.in.numargs = 0;
+ 	args.in.h.opcode = FUSE_STATFS;
+ 	args.in.h.nodeid = get_node_id(d_inode(dentry));
+ 	args.out.numargs = 1;
+ 	args.out.args[0].size = sizeof(outarg);
+ 	args.out.args[0].value = &outarg;
+ 	err = fuse_simple_request(fc, &args);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	if (!err)
  		convert_fuse_statfs(buf, &outarg.st);
 +	fuse_put_request(fc, req);
  	return err;
  }
  
diff --cc fs/gfs2/inode.c
index 4b5ce5a448da,e301850255d1..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -1187,12 -1241,9 +1187,18 @@@ static int gfs2_atomic_open(struct inod
  		return PTR_ERR(d);
  	if (d != NULL)
  		dentry = d;
++<<<<<<< HEAD
 +	if (dentry->d_inode) {
 +		if (!(*opened & FILE_OPENED)) {
 +			if (d == NULL)
 +				dget(dentry);
 +			return finish_no_open(file, dentry);
 +		}
++=======
+ 	if (d_really_is_positive(dentry)) {
+ 		if (!(*opened & FILE_OPENED))
+ 			return finish_no_open(file, d);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		dput(d);
  		return 0;
  	}
diff --cc fs/hfsplus/dir.c
index a37ac934732f,e7ef1c72ef3d..000000000000
--- a/fs/hfsplus/dir.c
+++ b/fs/hfsplus/dir.c
@@@ -502,8 -529,8 +502,13 @@@ static int hfsplus_rename(struct inode 
  	int res;
  
  	/* Unlink destination if it already exists */
++<<<<<<< HEAD
 +	if (new_dentry->d_inode) {
 +		if (S_ISDIR(new_dentry->d_inode->i_mode))
++=======
+ 	if (d_really_is_positive(new_dentry)) {
+ 		if (d_is_dir(new_dentry))
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			res = hfsplus_rmdir(new_dir, new_dentry);
  		else
  			res = hfsplus_unlink(new_dir, new_dentry);
diff --cc fs/hfsplus/xattr.h
index 847b695b984d,a1629cfe37d3..000000000000
--- a/fs/hfsplus/xattr.h
+++ b/fs/hfsplus/xattr.h
@@@ -26,16 -24,22 +26,27 @@@ int __hfsplus_setxattr(struct inode *in
  static inline int hfsplus_setxattr(struct dentry *dentry, const char *name,
  			const void *value, size_t size, int flags)
  {
- 	return __hfsplus_setxattr(dentry->d_inode, name, value, size, flags);
+ 	return __hfsplus_setxattr(d_inode(dentry), name, value, size, flags);
  }
  
 -ssize_t __hfsplus_getxattr(struct inode *inode, const char *name,
 +ssize_t hfsplus_getxattr(struct dentry *dentry, const char *name,
  			void *value, size_t size);
  
++<<<<<<< HEAD
++=======
+ static inline ssize_t hfsplus_getxattr(struct dentry *dentry,
+ 					const char *name,
+ 					void *value,
+ 					size_t size)
+ {
+ 	return __hfsplus_getxattr(d_inode(dentry), name, value, size);
+ }
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  ssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size);
  
 +int hfsplus_removexattr(struct dentry *dentry, const char *name);
 +
  int hfsplus_init_security(struct inode *inode, struct inode *dir,
  				const struct qstr *qstr);
  
diff --cc fs/jffs2/dir.c
index acd46a4160cb,1ba5c97943b8..000000000000
--- a/fs/jffs2/dir.c
+++ b/fs/jffs2/dir.c
@@@ -789,9 -770,9 +789,15 @@@ static int jffs2_rename (struct inode *
  	 * the VFS can't check whether the victim is empty. The filesystem
  	 * needs to do that for itself.
  	 */
++<<<<<<< HEAD
 +	if (new_dentry->d_inode) {
 +		victim_f = JFFS2_INODE_INFO(new_dentry->d_inode);
 +		if (S_ISDIR(new_dentry->d_inode->i_mode)) {
++=======
+ 	if (d_really_is_positive(new_dentry)) {
+ 		victim_f = JFFS2_INODE_INFO(d_inode(new_dentry));
+ 		if (d_is_dir(new_dentry)) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			struct jffs2_full_dirent *fd;
  
  			mutex_lock(&victim_f->sem);
@@@ -826,10 -807,10 +832,15 @@@
  
  	if (victim_f) {
  		/* There was a victim. Kill it off nicely */
++<<<<<<< HEAD
 +		if (S_ISDIR(new_dentry->d_inode->i_mode))
 +			clear_nlink(new_dentry->d_inode);
++=======
+ 		if (d_is_dir(new_dentry))
+ 			clear_nlink(d_inode(new_dentry));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		else
- 			drop_nlink(new_dentry->d_inode);
+ 			drop_nlink(d_inode(new_dentry));
  		/* Don't oops if the victim was a dirent pointing to an
  		   inode which didn't exist. */
  		if (victim_f->inocache) {
@@@ -855,10 -836,10 +866,15 @@@
  
  	if (ret) {
  		/* Oh shit. We really ought to make a single node which can do both atomically */
- 		struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_dentry->d_inode);
+ 		struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(old_dentry));
  		mutex_lock(&f->sem);
++<<<<<<< HEAD
 +		inc_nlink(old_dentry->d_inode);
 +		if (f->inocache && !S_ISDIR(old_dentry->d_inode->i_mode))
++=======
+ 		inc_nlink(d_inode(old_dentry));
+ 		if (f->inocache && !d_is_dir(old_dentry))
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			f->inocache->pino_nlink++;
  		mutex_unlock(&f->sem);
  
diff --cc fs/jffs2/fs.c
index 00ed6c64a579,fe5ea080b4ec..000000000000
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@@ -190,9 -190,10 +190,13 @@@ int jffs2_do_setattr (struct inode *ino
  
  int jffs2_setattr(struct dentry *dentry, struct iattr *iattr)
  {
++<<<<<<< HEAD
++=======
+ 	struct inode *inode = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	int rc;
  
 -	rc = inode_change_ok(inode, iattr);
 +	rc = inode_change_ok(dentry->d_inode, iattr);
  	if (rc)
  		return rc;
  
diff --cc fs/ncpfs/dir.c
index 6642f8b600ac,80021c709af9..000000000000
--- a/fs/ncpfs/dir.c
+++ b/fs/ncpfs/dir.c
@@@ -385,49 -386,9 +385,49 @@@ finished
  	return val;
  }
  
 +static struct dentry *
 +ncp_dget_fpos(struct dentry *dentry, struct dentry *parent, unsigned long fpos)
 +{
 +	struct dentry *dent = dentry;
 +	struct list_head *next;
 +
 +	if (d_validate(dent, parent)) {
 +		if (dent->d_name.len <= NCP_MAXPATHLEN &&
 +		    (unsigned long)dent->d_fsdata == fpos) {
 +			if (!dent->d_inode) {
 +				dput(dent);
 +				dent = NULL;
 +			}
 +			return dent;
 +		}
 +		dput(dent);
 +	}
 +
 +	/* If a pointer is invalid, we search the dentry. */
 +	spin_lock(&parent->d_lock);
 +	next = parent->d_subdirs.next;
 +	while (next != &parent->d_subdirs) {
 +		dent = list_entry(next, struct dentry, d_u.d_child);
 +		if ((unsigned long)dent->d_fsdata == fpos) {
 +			if (dent->d_inode)
 +				dget(dent);
 +			else
 +				dent = NULL;
 +			spin_unlock(&parent->d_lock);
 +			goto out;
 +		}
 +		next = next->next;
 +	}
 +	spin_unlock(&parent->d_lock);
 +	return NULL;
 +
 +out:
 +	return dent;
 +}
 +
  static time_t ncp_obtain_mtime(struct dentry *dentry)
  {
- 	struct inode *inode = dentry->d_inode;
+ 	struct inode *inode = d_inode(dentry);
  	struct ncp_server *server = NCP_SERVER(inode);
  	struct nw_info_struct i;
  
@@@ -440,10 -401,24 +440,28 @@@
  	return ncp_date_dos2unix(i.modifyTime, i.modifyDate);
  }
  
 -static inline void
 -ncp_invalidate_dircache_entries(struct dentry *parent)
 +static int ncp_readdir(struct file *filp, void *dirent, filldir_t filldir)
  {
++<<<<<<< HEAD
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct inode *inode = dentry->d_inode;
++=======
+ 	struct ncp_server *server = NCP_SERVER(d_inode(parent));
+ 	struct dentry *dentry;
+ 
+ 	spin_lock(&parent->d_lock);
+ 	list_for_each_entry(dentry, &parent->d_subdirs, d_child) {
+ 		dentry->d_fsdata = NULL;
+ 		ncp_age_dentry(server, dentry);
+ 	}
+ 	spin_unlock(&parent->d_lock);
+ }
+ 
+ static int ncp_readdir(struct file *file, struct dir_context *ctx)
+ {
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct inode *inode = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct page *page = NULL;
  	struct ncp_server *server = NCP_SERVER(inode);
  	union  ncp_dir_cache *cache = NULL;
@@@ -513,21 -478,32 +531,38 @@@
  		}
  		while (ctl.idx < NCP_DIRCACHE_SIZE) {
  			struct dentry *dent;
 -			bool over;
 +			int res;
  
 -			spin_lock(&dentry->d_lock);
 -			if (!(NCP_FINFO(inode)->flags & NCPI_DIR_CACHE)) { 
 -				spin_unlock(&dentry->d_lock);
 +			dent = ncp_dget_fpos(ctl.cache->dentry[ctl.idx],
 +						dentry, filp->f_pos);
 +			if (!dent)
  				goto invalid_cache;
++<<<<<<< HEAD
 +			res = filldir(dirent, dent->d_name.name,
 +					dent->d_name.len, filp->f_pos,
 +					dent->d_inode->i_ino, DT_UNKNOWN);
++=======
+ 			}
+ 			dent = ctl.cache->dentry[ctl.idx];
+ 			if (unlikely(!lockref_get_not_dead(&dent->d_lockref))) {
+ 				spin_unlock(&dentry->d_lock);
+ 				goto invalid_cache;
+ 			}
+ 			spin_unlock(&dentry->d_lock);
+ 			if (d_really_is_negative(dent)) {
+ 				dput(dent);
+ 				goto invalid_cache;
+ 			}
+ 			over = !dir_emit(ctx, dent->d_name.name,
+ 					dent->d_name.len,
+ 					d_inode(dent)->i_ino, DT_UNKNOWN);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			dput(dent);
 -			if (over)
 +			if (res)
  				goto finished;
 -			ctx->pos += 1;
 +			filp->f_pos += 1;
  			ctl.idx += 1;
 -			if (ctx->pos > ctl.head.end)
 +			if (filp->f_pos > ctl.head.end)
  				goto finished;
  		}
  		if (ctl.page) {
@@@ -588,13 -567,20 +623,28 @@@ out
  	return result;
  }
  
++<<<<<<< HEAD
++=======
+ static void ncp_d_prune(struct dentry *dentry)
+ {
+ 	if (!dentry->d_fsdata)	/* not referenced from page cache */
+ 		return;
+ 	NCP_FINFO(d_inode(dentry->d_parent))->flags &= ~NCPI_DIR_CACHE;
+ }
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  static int
 -ncp_fill_cache(struct file *file, struct dir_context *ctx,
 +ncp_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
  		struct ncp_cache_control *ctrl, struct ncp_entry_info *entry,
  		int inval_childs)
  {
++<<<<<<< HEAD
 +	struct dentry *newdent, *dentry = filp->f_path.dentry;
 +	struct inode *dir = dentry->d_inode;
++=======
+ 	struct dentry *newdent, *dentry = file->f_path.dentry;
+ 	struct inode *dir = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct ncp_cache_control ctl = *ctrl;
  	struct qstr qname;
  	int valid = 0;
@@@ -645,9 -631,13 +695,9 @@@
  			d_instantiate(newdent, inode);
  			if (!hashed)
  				d_rehash(newdent);
 -		} else {
 -			spin_lock(&dentry->d_lock);
 -			NCP_FINFO(inode)->flags &= ~NCPI_DIR_CACHE;
 -			spin_unlock(&dentry->d_lock);
  		}
  	} else {
- 		struct inode *inode = newdent->d_inode;
+ 		struct inode *inode = d_inode(newdent);
  
  		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
  		ncp_update_inode2(inode, entry);
@@@ -675,8 -659,13 +725,18 @@@
  			ctl.cache = kmap(ctl.page);
  	}
  	if (ctl.cache) {
++<<<<<<< HEAD
 +		ctl.cache->dentry[ctl.idx] = newdent;
 +		valid = 1;
++=======
+ 		if (d_really_is_positive(newdent)) {
+ 			newdent->d_fsdata = newdent;
+ 			ctl.cache->dentry[ctl.idx] = newdent;
+ 			ino = d_inode(newdent)->i_ino;
+ 			ncp_new_dentry(newdent);
+ 		}
+  		valid = 1;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	}
  	dput(newdent);
  end_advance:
@@@ -836,10 -815,10 +896,14 @@@ int ncp_conn_logged_in(struct super_blo
  				NCP_FINFO(ino)->DosDirNum = DosDirNum;
  				result = 0;
  			} else {
++<<<<<<< HEAD
 +				DPRINTK("ncpfs: sb->s_root->d_inode == NULL!\n");
++=======
+ 				ncp_dbg(1, "d_inode(sb->s_root) == NULL!\n");
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			}
  		} else {
 -			ncp_dbg(1, "sb->s_root == NULL!\n");
 +			DPRINTK("ncpfs: sb->s_root == NULL!\n");
  		}
  	} else
  		result = 0;
diff --cc fs/ncpfs/inode.c
index 1e049e94df01,9605a2f63549..000000000000
--- a/fs/ncpfs/inode.c
+++ b/fs/ncpfs/inode.c
@@@ -891,6 -877,10 +891,13 @@@ int ncp_notify_change(struct dentry *de
  	if (!server)	/* How this could happen? */
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	result = -EPERM;
+ 	if (IS_DEADDIR(d_inode(dentry)))
+ 		goto out;
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	/* ageing the dentry to force validation */
  	ncp_age_dentry(server, dentry);
  
diff --cc fs/ncpfs/ioctl.c
index 60426ccb3b65,79b113048eac..000000000000
--- a/fs/ncpfs/ioctl.c
+++ b/fs/ncpfs/ioctl.c
@@@ -385,9 -384,9 +385,13 @@@ static long __ncp_ioctl(struct inode *i
  						sr.namespace = server->name_space[sr.volNumber];
  						result = 0;
  					} else
++<<<<<<< HEAD
 +						DPRINTK("ncpfs: s_root->d_inode==NULL\n");
++=======
+ 						ncp_dbg(1, "d_inode(s_root)==NULL\n");
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  				} else
 -					ncp_dbg(1, "s_root==NULL\n");
 +					DPRINTK("ncpfs: s_root==NULL\n");
  			} else {
  				sr.volNumber = -1;
  				sr.namespace = 0;
@@@ -440,7 -439,7 +444,11 @@@
  							NCP_FINFO(s_inode)->DosDirNum = dosde;
  							server->root_setuped = 1;
  						} else {
++<<<<<<< HEAD
 +							DPRINTK("ncpfs: s_root->d_inode==NULL\n");
++=======
+ 							ncp_dbg(1, "d_inode(s_root)==NULL\n");
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  							result = -EIO;
  						}
  					} else {
diff --cc fs/nfs/dir.c
index 1a1f738833f3,1e51ecd61854..000000000000
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@@ -496,13 -496,12 +495,13 @@@ void nfs_prime_dcache(struct dentry *pa
  			goto out;
  		if (nfs_same_file(dentry, entry)) {
  			nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
- 			status = nfs_refresh_inode(dentry->d_inode, entry->fattr);
+ 			status = nfs_refresh_inode(d_inode(dentry), entry->fattr);
  			if (!status)
- 				nfs_setsecurity(dentry->d_inode, entry->fattr, entry->label);
+ 				nfs_setsecurity(d_inode(dentry), entry->fattr, entry->label);
  			goto out;
  		} else {
 -			d_invalidate(dentry);
 +			if (d_invalidate(dentry) != 0)
 +				goto out;
  			dput(dentry);
  		}
  	}
@@@ -866,13 -866,13 +865,18 @@@ static bool nfs_dir_mapping_need_revali
     last cookie cache takes care of the common case of reading the
     whole directory.
   */
 -static int nfs_readdir(struct file *file, struct dir_context *ctx)
 +static int nfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
  {
++<<<<<<< HEAD
 +	struct dentry	*dentry = filp->f_path.dentry;
 +	struct inode	*inode = dentry->d_inode;
++=======
+ 	struct dentry	*dentry = file->f_path.dentry;
+ 	struct inode	*inode = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	nfs_readdir_descriptor_t my_desc,
  			*desc = &my_desc;
 -	struct nfs_open_dir_context *dir_ctx = file->private_data;
 +	struct nfs_open_dir_context *dir_ctx = filp->private_data;
  	int res = 0;
  
  	dfprintk(FILE, "NFS: readdir(%pD2) starting at cookie %llu\n",
diff --cc fs/nfs/nfs3acl.c
index f2d1c3ad1bca,1ebe2fc7cda2..000000000000
--- a/fs/nfs/nfs3acl.c
+++ b/fs/nfs/nfs3acl.c
@@@ -418,27 -246,51 +418,59 @@@ fail
  	return PTR_ERR(alloc);
  }
  
 -const struct xattr_handler *nfs3_xattr_handlers[] = {
 -	&posix_acl_access_xattr_handler,
 -	&posix_acl_default_xattr_handler,
 -	NULL,
 -};
 -
 -static int
 -nfs3_list_one_acl(struct inode *inode, int type, const char *name, void *data,
 -		size_t size, ssize_t *result)
 +int nfs3_proc_set_default_acl(struct inode *dir, struct inode *inode,
 +		umode_t mode)
  {
 -	struct posix_acl *acl;
 -	char *p = data + *result;
 +	struct posix_acl *dfacl, *acl;
 +	int error = 0;
  
 -	acl = get_acl(inode, type);
 -	if (IS_ERR_OR_NULL(acl))
 +	dfacl = nfs3_proc_getacl(dir, ACL_TYPE_DEFAULT);
 +	if (IS_ERR(dfacl)) {
 +		error = PTR_ERR(dfacl);
 +		return (error == -EOPNOTSUPP) ? 0 : error;
 +	}
 +	if (!dfacl)
  		return 0;
 -
 +	acl = posix_acl_dup(dfacl);
 +	error = posix_acl_create(&acl, GFP_KERNEL, &mode);
 +	if (error < 0)
 +		goto out_release_dfacl;
 +	error = nfs3_proc_setacls(inode, acl, S_ISDIR(inode->i_mode) ?
 +						      dfacl : NULL);
  	posix_acl_release(acl);
++<<<<<<< HEAD
 +out_release_dfacl:
 +	posix_acl_release(dfacl);
 +	return error;
++=======
+ 
+ 	*result += strlen(name);
+ 	*result += 1;
+ 	if (!size)
+ 		return 0;
+ 	if (*result > size)
+ 		return -ERANGE;
+ 
+ 	strcpy(p, name);
+ 	return 0;
+ }
+ 
+ ssize_t
+ nfs3_listxattr(struct dentry *dentry, char *data, size_t size)
+ {
+ 	struct inode *inode = d_inode(dentry);
+ 	ssize_t result = 0;
+ 	int error;
+ 
+ 	error = nfs3_list_one_acl(inode, ACL_TYPE_ACCESS,
+ 			POSIX_ACL_XATTR_ACCESS, data, size, &result);
+ 	if (error)
+ 		return error;
+ 
+ 	error = nfs3_list_one_acl(inode, ACL_TYPE_DEFAULT,
+ 			POSIX_ACL_XATTR_DEFAULT, data, size, &result);
+ 	if (error)
+ 		return error;
+ 	return result;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
diff --cc fs/nfs/nfs3proc.c
index 97a342275449,cb28cceefebe..000000000000
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@@ -383,12 -386,17 +383,21 @@@ nfs3_proc_create(struct inode *dir, str
  		 * not sure this buys us anything (and I'd have
  		 * to revamp the NFSv3 XDR code) */
  		status = nfs3_proc_setattr(dentry, data->res.fattr, sattr);
- 		nfs_post_op_update_inode(dentry->d_inode, data->res.fattr);
+ 		nfs_post_op_update_inode(d_inode(dentry), data->res.fattr);
  		dprintk("NFS reply setattr (post-create): %d\n", status);
  		if (status != 0)
 -			goto out_release_acls;
 +			goto out;
  	}
++<<<<<<< HEAD
 +	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
++=======
+ 
+ 	status = nfs3_proc_setacls(d_inode(dentry), acl, default_acl);
+ 
+ out_release_acls:
+ 	posix_acl_release(acl);
+ 	posix_acl_release(default_acl);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  out:
  	nfs3_free_createdata(data);
  	dprintk("NFS reply create: %d\n", status);
@@@ -558,9 -568,13 +567,17 @@@ nfs3_proc_mkdir(struct inode *dir, stru
  
  	status = nfs3_do_create(dir, dentry, data);
  	if (status != 0)
 -		goto out_release_acls;
 +		goto out;
  
++<<<<<<< HEAD
 +	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
++=======
+ 	status = nfs3_proc_setacls(d_inode(dentry), acl, default_acl);
+ 
+ out_release_acls:
+ 	posix_acl_release(acl);
+ 	posix_acl_release(default_acl);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  out:
  	nfs3_free_createdata(data);
  	dprintk("NFS reply mkdir: %d\n", status);
@@@ -697,8 -713,13 +714,18 @@@ nfs3_proc_mknod(struct inode *dir, stru
  
  	status = nfs3_do_create(dir, dentry, data);
  	if (status != 0)
++<<<<<<< HEAD
 +		goto out;
 +	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
++=======
+ 		goto out_release_acls;
+ 
+ 	status = nfs3_proc_setacls(d_inode(dentry), acl, default_acl);
+ 
+ out_release_acls:
+ 	posix_acl_release(acl);
+ 	posix_acl_release(default_acl);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  out:
  	nfs3_free_createdata(data);
  	dprintk("NFS reply mknod: %d\n", status);
diff --cc fs/nfs/pagelist.c
index e9e1ba73f39d,282b39369510..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -945,7 -938,10 +945,14 @@@ static bool nfs_can_coalesce_requests(s
  	if (prev) {
  		if (!nfs_match_open_context(req->wb_context, prev->wb_context))
  			return false;
++<<<<<<< HEAD
 +		if (req->wb_context->dentry->d_inode->i_flock != NULL &&
++=======
+ 		flctx = d_inode(req->wb_context->dentry)->i_flctx;
+ 		if (flctx != NULL &&
+ 		    !(list_empty_careful(&flctx->flc_posix) &&
+ 		      list_empty_careful(&flctx->flc_flock)) &&
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		    !nfs_match_lock_context(req->wb_lock_context,
  					    prev->wb_lock_context))
  			return false;
diff --cc fs/nfs/read.c
index 6f6a775856ca,a5b7427c3754..000000000000
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@@ -120,10 -117,10 +120,14 @@@ int nfs_readpage_async(struct nfs_open_
  
  static void nfs_readpage_release(struct nfs_page *req)
  {
++<<<<<<< HEAD
 +	struct inode *d_inode = req->wb_context->dentry->d_inode;
++=======
+ 	struct inode *inode = d_inode(req->wb_context->dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
 -	dprintk("NFS: read done (%s/%llu %d@%lld)\n", inode->i_sb->s_id,
 -		(unsigned long long)NFS_FILEID(inode), req->wb_bytes,
 +	dprintk("NFS: read done (%s/%llu %d@%lld)\n", d_inode->i_sb->s_id,
 +		(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,
  		(long long)req_offset(req));
  
  	if (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {
diff --cc fs/nfsd/nfs2acl.c
index 233c3ddbe528,d54701f6dc78..000000000000
--- a/fs/nfsd/nfs2acl.c
+++ b/fs/nfsd/nfs2acl.c
@@@ -41,6 -42,8 +41,11 @@@ static __be32 nfsacld_proc_getacl(struc
  	if (nfserr)
  		RETURN_STATUS(nfserr);
  
++<<<<<<< HEAD
++=======
+ 	inode = d_inode(fh->fh_dentry);
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	if (argp->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT))
  		RETURN_STATUS(nfserr_inval);
  	resp->mask = argp->mask;
@@@ -110,19 -100,32 +115,26 @@@ static __be32 nfsacld_proc_setacl(struc
  
  	fh = fh_copy(&resp->fh, &argp->fh);
  	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
 -	if (nfserr)
 -		goto out;
  
++<<<<<<< HEAD
 +	if (!nfserr) {
 +		nfserr = nfserrno( nfsd_set_posix_acl(
 +			fh, ACL_TYPE_ACCESS, argp->acl_access) );
 +	}
 +	if (!nfserr) {
 +		nfserr = nfserrno( nfsd_set_posix_acl(
 +			fh, ACL_TYPE_DEFAULT, argp->acl_default) );
 +	}
 +	if (!nfserr) {
 +		nfserr = fh_getattr(fh, &resp->stat);
++=======
+ 	inode = d_inode(fh->fh_dentry);
+ 	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
+ 		error = -EOPNOTSUPP;
+ 		goto out_errno;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	}
  
 -	error = fh_want_write(fh);
 -	if (error)
 -		goto out_errno;
 -
 -	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
 -	if (error)
 -		goto out_drop_write;
 -	error = inode->i_op->set_acl(inode, argp->acl_default,
 -				     ACL_TYPE_DEFAULT);
 -	if (error)
 -		goto out_drop_write;
 -
 -	fh_drop_write(fh);
 -
 -	nfserr = fh_getattr(fh, &resp->stat);
 -
 -out:
  	/* argp->acl_{access,default} may have been allocated in
  	   nfssvc_decode_setaclargs. */
  	posix_acl_release(argp->acl_access);
diff --cc fs/nfsd/nfs3acl.c
index 1e15ff187776,882b1a14bc3e..000000000000
--- a/fs/nfsd/nfs3acl.c
+++ b/fs/nfsd/nfs3acl.c
@@@ -38,6 -39,8 +38,11 @@@ static __be32 nfsd3_proc_getacl(struct 
  	if (nfserr)
  		RETURN_STATUS(nfserr);
  
++<<<<<<< HEAD
++=======
+ 	inode = d_inode(fh->fh_dentry);
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	if (argp->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT))
  		RETURN_STATUS(nfserr_inval);
  	resp->mask = argp->mask;
@@@ -101,16 -90,31 +106,23 @@@ static __be32 nfsd3_proc_setacl(struct 
  
  	fh = fh_copy(&resp->fh, &argp->fh);
  	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
 -	if (nfserr)
 -		goto out;
  
++<<<<<<< HEAD
 +	if (!nfserr) {
 +		nfserr = nfserrno( nfsd_set_posix_acl(
 +			fh, ACL_TYPE_ACCESS, argp->acl_access) );
 +	}
 +	if (!nfserr) {
 +		nfserr = nfserrno( nfsd_set_posix_acl(
 +			fh, ACL_TYPE_DEFAULT, argp->acl_default) );
++=======
+ 	inode = d_inode(fh->fh_dentry);
+ 	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
+ 		error = -EOPNOTSUPP;
+ 		goto out_errno;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	}
  
 -	error = fh_want_write(fh);
 -	if (error)
 -		goto out_errno;
 -
 -	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
 -	if (error)
 -		goto out_drop_write;
 -	error = inode->i_op->set_acl(inode, argp->acl_default,
 -				     ACL_TYPE_DEFAULT);
 -
 -out_drop_write:
 -	fh_drop_write(fh);
 -out_errno:
 -	nfserr = nfserrno(error);
 -out:
  	/* argp->acl_{access,default} may have been allocated in
  	   nfs3svc_decode_setaclargs. */
  	posix_acl_release(argp->acl_access);
diff --cc fs/nfsd/nfs4acl.c
index aa0310ceb620,64466dcc71d1..000000000000
--- a/fs/nfsd/nfs4acl.c
+++ b/fs/nfsd/nfs4acl.c
@@@ -130,37 -135,55 +130,44 @@@ static short ace2type(struct nfs4_ace *
  static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,
  				unsigned int);
  
 -int
 -nfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,
 -		struct nfs4_acl **acl)
 +struct nfs4_acl *
 +nfs4_acl_posix_to_nfsv4(struct posix_acl *pacl, struct posix_acl *dpacl,
 +			unsigned int flags)
  {
++<<<<<<< HEAD
 +	struct nfs4_acl *acl;
++=======
+ 	struct inode *inode = d_inode(dentry);
+ 	int error = 0;
+ 	struct posix_acl *pacl = NULL, *dpacl = NULL;
+ 	unsigned int flags = 0;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	int size = 0;
  
 -	pacl = get_acl(inode, ACL_TYPE_ACCESS);
 -	if (!pacl)
 -		pacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
 -
 -	if (IS_ERR(pacl))
 -		return PTR_ERR(pacl);
 -
 -	/* allocate for worst case: one (deny, allow) pair each: */
 -	size += 2 * pacl->a_count;
 -
 -	if (S_ISDIR(inode->i_mode)) {
 -		flags = NFS4_ACL_DIR;
 -		dpacl = get_acl(inode, ACL_TYPE_DEFAULT);
 -		if (IS_ERR(dpacl)) {
 -			error = PTR_ERR(dpacl);
 -			goto rel_pacl;
 -		}
 -
 -		if (dpacl)
 -			size += 2 * dpacl->a_count;
 +	if (pacl) {
 +		if (posix_acl_valid(pacl) < 0)
 +			return ERR_PTR(-EINVAL);
 +		size += 2*pacl->a_count;
  	}
 -
 -	*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);
 -	if (*acl == NULL) {
 -		error = -ENOMEM;
 -		goto out;
 +	if (dpacl) {
 +		if (posix_acl_valid(dpacl) < 0)
 +			return ERR_PTR(-EINVAL);
 +		size += 2*dpacl->a_count;
  	}
 -	(*acl)->naces = 0;
  
 -	_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);
 +	/* Allocate for worst case: one (deny, allow) pair each: */
 +	acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);
 +	if (acl == NULL)
 +		return ERR_PTR(-ENOMEM);
 +	acl->naces = 0;
 +
 +	if (pacl)
 +		_posix_to_nfsv4_one(pacl, acl, flags & ~NFS4_ACL_TYPE_DEFAULT);
  
  	if (dpacl)
 -		_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);
 +		_posix_to_nfsv4_one(dpacl, acl, flags | NFS4_ACL_TYPE_DEFAULT);
  
 -out:
 -	posix_acl_release(dpacl);
 -rel_pacl:
 -	posix_acl_release(pacl);
 -	return error;
 +	return acl;
  }
  
  struct posix_acl_summary {
@@@ -786,6 -811,57 +793,60 @@@ out_estate
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ __be32
+ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
+ 		struct nfs4_acl *acl)
+ {
+ 	__be32 error;
+ 	int host_error;
+ 	struct dentry *dentry;
+ 	struct inode *inode;
+ 	struct posix_acl *pacl = NULL, *dpacl = NULL;
+ 	unsigned int flags = 0;
+ 
+ 	/* Get inode */
+ 	error = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);
+ 	if (error)
+ 		return error;
+ 
+ 	dentry = fhp->fh_dentry;
+ 	inode = d_inode(dentry);
+ 
+ 	if (!inode->i_op->set_acl || !IS_POSIXACL(inode))
+ 		return nfserr_attrnotsupp;
+ 
+ 	if (S_ISDIR(inode->i_mode))
+ 		flags = NFS4_ACL_DIR;
+ 
+ 	host_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);
+ 	if (host_error == -EINVAL)
+ 		return nfserr_attrnotsupp;
+ 	if (host_error < 0)
+ 		goto out_nfserr;
+ 
+ 	host_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);
+ 	if (host_error < 0)
+ 		goto out_release;
+ 
+ 	if (S_ISDIR(inode->i_mode)) {
+ 		host_error = inode->i_op->set_acl(inode, dpacl,
+ 						  ACL_TYPE_DEFAULT);
+ 	}
+ 
+ out_release:
+ 	posix_acl_release(pacl);
+ 	posix_acl_release(dpacl);
+ out_nfserr:
+ 	if (host_error == -EOPNOTSUPP)
+ 		return nfserr_attrnotsupp;
+ 	else
+ 		return nfserrno(host_error);
+ }
+ 
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  static short
  ace2type(struct nfs4_ace *ace)
  {
diff --cc fs/nfsd/nfs4recover.c
index 1c3da0a51e1e,d88ea7b9a85c..000000000000
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@@ -275,11 -284,11 +275,17 @@@ nfsd4_list_rec_dir(recdir_func *f, stru
  		return status;
  	}
  
++<<<<<<< HEAD
 +	status = vfs_readdir(nn->rec_file, nfsd4_build_namelist, &names);
 +	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
 +	while (!list_empty(&names)) {
++=======
+ 	status = iterate_dir(nn->rec_file, &ctx.ctx);
+ 	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
+ 	while (!list_empty(&ctx.names)) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		struct name_list *entry;
 -		entry = list_entry(ctx.names.next, struct name_list, list);
 +		entry = list_entry(names.next, struct name_list, list);
  		if (!status) {
  			struct dentry *dentry;
  			dentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);
diff --cc fs/nfsd/nfsfh.c
index 88026fc6a981,350041a40fe5..000000000000
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@@ -412,9 -412,9 +412,15 @@@ static inline void _fh_update_old(struc
  				  struct svc_export *exp,
  				  struct knfsd_fh *fh)
  {
++<<<<<<< HEAD
 +	fh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);
 +	fh->ofh_generation = dentry->d_inode->i_generation;
 +	if (S_ISDIR(dentry->d_inode->i_mode) ||
++=======
+ 	fh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);
+ 	fh->ofh_generation = d_inode(dentry)->i_generation;
+ 	if (d_is_dir(dentry) ||
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))
  		fh->ofh_dirino = 0;
  }
diff --cc fs/ocfs2/dcache.c
index ef999729e274,290373024d9d..000000000000
--- a/fs/ocfs2/dcache.c
+++ b/fs/ocfs2/dcache.c
@@@ -70,9 -69,10 +70,16 @@@ static int ocfs2_dentry_revalidate(stru
  	 */
  	if (inode == NULL) {
  		unsigned long gen = (unsigned long) dentry->d_fsdata;
++<<<<<<< HEAD
 +		unsigned long pgen =
 +			OCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;
 +
++=======
+ 		unsigned long pgen;
+ 		spin_lock(&dentry->d_lock);
+ 		pgen = OCFS2_I(d_inode(dentry->d_parent))->ip_dir_lock_gen;
+ 		spin_unlock(&dentry->d_lock);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		trace_ocfs2_dentry_revalidate_negative(dentry->d_name.len,
  						       dentry->d_name.name,
  						       pgen, gen);
diff --cc fs/ocfs2/file.c
index 2bcf1677a59b,d8b670cbd909..000000000000
--- a/fs/ocfs2/file.c
+++ b/fs/ocfs2/file.c
@@@ -2095,8 -2114,11 +2095,16 @@@ static int ocfs2_prepare_inode_for_writ
  {
  	int ret = 0, meta_level = 0;
  	struct dentry *dentry = file->f_path.dentry;
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	loff_t saved_pos = 0, end;
++=======
+ 	struct inode *inode = d_inode(dentry);
+ 	loff_t end;
+ 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+ 	int full_coherency = !(osb->s_mount_opt &
+ 		OCFS2_MOUNT_COHERENCY_BUFFERED);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	/*
  	 * We start with a read level meta lock and only jump to an ex
diff --cc fs/ocfs2/namei.c
index b4a5cdf9dbc5,c0727037c6f9..000000000000
--- a/fs/ocfs2/namei.c
+++ b/fs/ocfs2/namei.c
@@@ -636,9 -689,11 +636,14 @@@ static int ocfs2_link(struct dentry *ol
  		      struct dentry *dentry)
  {
  	handle_t *handle;
++<<<<<<< HEAD
 +	struct inode *inode = old_dentry->d_inode;
++=======
+ 	struct inode *inode = d_inode(old_dentry);
+ 	struct inode *old_dir = d_inode(old_dentry->d_parent);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	int err;
  	struct buffer_head *fe_bh = NULL;
 -	struct buffer_head *old_dir_bh = NULL;
  	struct buffer_head *parent_fe_bh = NULL;
  	struct ocfs2_dinode *fe = NULL;
  	struct ocfs2_super *osb = OCFS2_SB(dir->i_sb);
@@@ -791,7 -878,8 +796,12 @@@ static int ocfs2_unlink(struct inode *d
  {
  	int status;
  	int child_locked = 0;
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
++=======
+ 	bool is_unlinkable = false;
+ 	struct inode *inode = d_inode(dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct inode *orphan_dir = NULL;
  	struct ocfs2_super *osb = OCFS2_SB(dir->i_sb);
  	u64 blkno;
@@@ -1266,9 -1451,10 +1276,9 @@@ static int ocfs2_rename(struct inode *o
  				mlog_errno(status);
  				goto bail;
  			}
 -			should_add_orphan = true;
  		}
  	} else {
- 		BUG_ON(new_dentry->d_parent->d_inode != new_dir);
+ 		BUG_ON(d_inode(new_dentry->d_parent) != new_dir);
  
  		status = ocfs2_check_dir_for_entry(new_dir,
  						   new_dentry->d_name.name,
diff --cc fs/proc/base.c
index e5ccc0b19999,a3d6b559178b..000000000000
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@@ -1826,7 -1579,7 +1826,11 @@@ int pid_delete_dentry(const struct dent
  	 * If so, then don't put the dentry on the lru list,
  	 * kill it immediately.
  	 */
++<<<<<<< HEAD
 +	return !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;
++=======
+ 	return proc_inode_is_dead(d_inode(dentry));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  
  const struct dentry_operations pid_dentry_operations =
@@@ -1853,42 -1606,30 +1857,56 @@@ int proc_fill_cache(struct file *filp, 
  	const char *name, int len,
  	instantiate_t instantiate, struct task_struct *task, const void *ptr)
  {
 -	struct dentry *child, *dir = file->f_path.dentry;
 -	struct qstr qname = QSTR_INIT(name, len);
 +	struct dentry *child, *dir = filp->f_path.dentry;
  	struct inode *inode;
 -	unsigned type;
 -	ino_t ino;
 +	struct qstr qname;
 +	ino_t ino = 0;
 +	unsigned type = DT_UNKNOWN;
 +
 +	qname.name = name;
 +	qname.len  = len;
 +	qname.hash = full_name_hash(name, len);
  
 -	child = d_hash_and_lookup(dir, &qname);
 +	child = d_lookup(dir, &qname);
  	if (!child) {
++<<<<<<< HEAD
 +		struct dentry *new;
 +		new = d_alloc(dir, &qname);
 +		if (new) {
 +			child = instantiate(dir->d_inode, new, task, ptr);
 +			if (child)
 +				dput(new);
 +			else
 +				child = new;
 +		}
 +	}
 +	if (!child || IS_ERR(child) || !child->d_inode)
 +		goto end_instantiate;
 +	inode = child->d_inode;
 +	if (inode) {
 +		ino = inode->i_ino;
 +		type = inode->i_mode >> 12;
 +	}
++=======
+ 		child = d_alloc(dir, &qname);
+ 		if (!child)
+ 			goto end_instantiate;
+ 		if (instantiate(d_inode(dir), child, task, ptr) < 0) {
+ 			dput(child);
+ 			goto end_instantiate;
+ 		}
+ 	}
+ 	inode = d_inode(child);
+ 	ino = inode->i_ino;
+ 	type = inode->i_mode >> 12;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	dput(child);
 -	return dir_emit(ctx, name, len, ino, type);
 -
  end_instantiate:
 -	return dir_emit(ctx, name, len, 1, DT_UNKNOWN);
 +	if (!ino)
 +		ino = find_inode_number(dir, &qname);
 +	if (!ino)
 +		ino = 1;
 +	return filldir(dirent, name, len, filp->f_pos, ino, type);
  }
  
  #ifdef CONFIG_CHECKPOINT_RESTORE
@@@ -3154,44 -2838,32 +3172,58 @@@ retry
  	return iter;
  }
  
 -#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)
 +#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 1)
 +
 +static int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
 +	struct tgid_iter iter)
 +{
 +	char name[PROC_NUMBUF];
 +	int len = snprintf(name, sizeof(name), "%d", iter.tgid);
 +	return proc_fill_cache(filp, dirent, filldir, name, len,
 +				proc_pid_instantiate, iter.task, NULL);
 +}
 +
 +static int fake_filldir(void *buf, const char *name, int namelen,
 +			loff_t offset, u64 ino, unsigned d_type)
 +{
 +	return 0;
 +}
  
  /* for the /proc/ directory itself, after non-process stuff has been done */
 -int proc_pid_readdir(struct file *file, struct dir_context *ctx)
 +int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
  	struct tgid_iter iter;
 -	struct pid_namespace *ns = file_inode(file)->i_sb->s_fs_info;
 -	loff_t pos = ctx->pos;
 +	struct pid_namespace *ns;
 +	filldir_t __filldir;
 +	loff_t pos = filp->f_pos;
  
  	if (pos >= PID_MAX_LIMIT + TGID_OFFSET)
 -		return 0;
 +		goto out;
  
++<<<<<<< HEAD
 +	if (pos == TGID_OFFSET - 1) {
 +		if (proc_fill_cache(filp, dirent, filldir, "self", 4,
 +					NULL, NULL, NULL) < 0)
 +			goto out;
 +		iter.tgid = 0;
 +	} else {
 +		iter.tgid = pos - TGID_OFFSET;
++=======
+ 	if (pos == TGID_OFFSET - 2) {
+ 		struct inode *inode = d_inode(ns->proc_self);
+ 		if (!dir_emit(ctx, "self", 4, inode->i_ino, DT_LNK))
+ 			return 0;
+ 		ctx->pos = pos = pos + 1;
+ 	}
+ 	if (pos == TGID_OFFSET - 1) {
+ 		struct inode *inode = d_inode(ns->proc_thread_self);
+ 		if (!dir_emit(ctx, "thread-self", 11, inode->i_ino, DT_LNK))
+ 			return 0;
+ 		ctx->pos = pos = pos + 1;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	}
 -	iter.tgid = pos - TGID_OFFSET;
  	iter.task = NULL;
 +	ns = filp->f_dentry->d_sb->s_fs_info;
  	for (iter = next_tgid(ns, iter);
  	     iter.task;
  	     iter.tgid += 1, iter = next_tgid(ns, iter)) {
diff --cc fs/proc/generic.c
index a2596afffae6,df6327a2b865..000000000000
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@@ -58,8 -120,8 +58,13 @@@ static int proc_notify_change(struct de
  static int proc_getattr(struct vfsmount *mnt, struct dentry *dentry,
  			struct kstat *stat)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct proc_dir_entry *de = PROC_I(inode)->pde;
++=======
+ 	struct inode *inode = d_inode(dentry);
+ 	struct proc_dir_entry *de = PDE(inode);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	if (de && de->nlink)
  		set_nlink(inode, de->nlink);
  
diff --cc fs/proc/inode.c
index 8d35dac92daf,8272aaba1bb0..000000000000
--- a/fs/proc/inode.c
+++ b/fs/proc/inode.c
@@@ -373,6 -394,26 +373,29 @@@ static const struct file_operations pro
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ static void *proc_follow_link(struct dentry *dentry, struct nameidata *nd)
+ {
+ 	struct proc_dir_entry *pde = PDE(d_inode(dentry));
+ 	if (unlikely(!use_pde(pde)))
+ 		return ERR_PTR(-EINVAL);
+ 	nd_set_link(nd, pde->data);
+ 	return pde;
+ }
+ 
+ static void proc_put_link(struct dentry *dentry, struct nameidata *nd, void *p)
+ {
+ 	unuse_pde(p);
+ }
+ 
+ const struct inode_operations proc_link_inode_operations = {
+ 	.readlink	= generic_readlink,
+ 	.follow_link	= proc_follow_link,
+ 	.put_link	= proc_put_link,
+ };
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  struct inode *proc_get_inode(struct super_block *sb, struct proc_dir_entry *de)
  {
  	struct inode *inode = new_inode_pseudo(sb);
diff --cc fs/proc/namespaces.c
index 54bdc6701e9f,e512642dbbdc..000000000000
--- a/fs/proc/namespaces.c
+++ b/fs/proc/namespaces.c
@@@ -34,89 -30,10 +34,94 @@@ static const struct proc_ns_operations 
  	&mntns_operations,
  };
  
 +static const struct file_operations ns_file_operations = {
 +	.llseek		= no_llseek,
 +};
 +
 +static const struct inode_operations ns_inode_operations = {
 +	.setattr	= proc_setattr,
 +};
 +
 +static int ns_delete_dentry(const struct dentry *dentry)
 +{
 +	/* Don't cache namespace inodes when not in use */
 +	return 1;
 +}
 +
 +static char *ns_dname(struct dentry *dentry, char *buffer, int buflen)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	const struct proc_ns_operations *ns_ops = PROC_I(inode)->ns.ns_ops;
 +
 +	return dynamic_dname(dentry, buffer, buflen, "%s:[%lu]",
 +		ns_ops->name, inode->i_ino);
 +}
 +
 +const struct dentry_operations ns_dentry_operations =
 +{
 +	.d_delete	= ns_delete_dentry,
 +	.d_dname	= ns_dname,
 +};
 +
 +static struct dentry *proc_ns_get_dentry(struct super_block *sb,
 +	struct task_struct *task, const struct proc_ns_operations *ns_ops)
 +{
 +	struct dentry *dentry, *result;
 +	struct inode *inode;
 +	struct proc_inode *ei;
 +	struct qstr qname = { .name = "", };
 +	void *ns;
 +
 +	ns = ns_ops->get(task);
 +	if (!ns)
 +		return ERR_PTR(-ENOENT);
 +
 +	dentry = d_alloc_pseudo(sb, &qname);
 +	if (!dentry) {
 +		ns_ops->put(ns);
 +		return ERR_PTR(-ENOMEM);
 +	}
 +
 +	inode = iget_locked(sb, ns_ops->inum(ns));
 +	if (!inode) {
 +		dput(dentry);
 +		ns_ops->put(ns);
 +		return ERR_PTR(-ENOMEM);
 +	}
 +
 +	ei = PROC_I(inode);
 +	if (inode->i_state & I_NEW) {
 +		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 +		inode->i_op = &ns_inode_operations;
 +		inode->i_mode = S_IFREG | S_IRUGO;
 +		inode->i_fop = &ns_file_operations;
 +		ei->ns.ns_ops = ns_ops;
 +		ei->ns.ns = ns;
 +		unlock_new_inode(inode);
 +	} else {
 +		ns_ops->put(ns);
 +	}
 +
 +	d_set_d_op(dentry, &ns_dentry_operations);
 +	result = d_instantiate_unique(dentry, inode);
 +	if (result) {
 +		dput(dentry);
 +		dentry = result;
 +	}
 +
 +	return dentry;
 +}
 +
  static void *proc_ns_follow_link(struct dentry *dentry, struct nameidata *nd)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct super_block *sb = inode->i_sb;
 +	struct proc_inode *ei = PROC_I(inode);
++=======
+ 	struct inode *inode = d_inode(dentry);
+ 	const struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct task_struct *task;
  	struct path ns_path;
  	void *error = ERR_PTR(-EACCES);
@@@ -146,13 -53,11 +151,18 @@@ out
  
  static int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int buflen)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct proc_inode *ei = PROC_I(inode);
 +	const struct proc_ns_operations *ns_ops = ei->ns.ns_ops;
++=======
+ 	struct inode *inode = d_inode(dentry);
+ 	const struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct task_struct *task;
 +	void *ns;
  	char name[50];
 -	int res = -EACCES;
 +	int len = -EACCES;
  
  	task = get_proc_task(inode);
  	if (!task)
diff --cc fs/pstore/inode.c
index 808c88d636e2,9f73797f95a6..000000000000
--- a/fs/pstore/inode.c
+++ b/fs/pstore/inode.c
@@@ -173,7 -190,12 +173,16 @@@ static const struct file_operations pst
   */
  static int pstore_unlink(struct inode *dir, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct pstore_private *p = dentry->d_inode->i_private;
++=======
+ 	struct pstore_private *p = d_inode(dentry)->i_private;
+ 	int err;
+ 
+ 	err = pstore_check_syslog_permissions(p);
+ 	if (err)
+ 		return err;
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	if (p->psi->erase)
  		p->psi->erase(p->type, p->id, p->count,
@@@ -346,11 -373,10 +355,11 @@@ int pstore_mkfile(enum pstore_type_id t
  		break;
  	}
  
- 	mutex_lock(&root->d_inode->i_mutex);
+ 	mutex_lock(&d_inode(root)->i_mutex);
  
 +	rc = -ENOSPC;
  	dentry = d_alloc_name(root, name);
 -	if (!dentry)
 +	if (IS_ERR(dentry))
  		goto fail_lockedalloc;
  
  	memcpy(private->data, data, size);
diff --cc fs/reiserfs/dir.c
index 6c2d136561cb,4a024e2ceb9f..000000000000
--- a/fs/reiserfs/dir.c
+++ b/fs/reiserfs/dir.c
@@@ -50,19 -50,19 +50,25 @@@ static int reiserfs_dir_fsync(struct fi
  
  #define store_ih(where,what) copy_item_head (where, what)
  
 -static inline bool is_privroot_deh(struct inode *dir, struct reiserfs_de_head *deh)
 +static inline bool is_privroot_deh(struct dentry *dir,
 +				   struct reiserfs_de_head *deh)
  {
++<<<<<<< HEAD
 +	struct dentry *privroot = REISERFS_SB(dir->d_sb)->priv_root;
 +	return (dir == dir->d_parent && privroot->d_inode &&
 +	        deh->deh_objectid == INODE_PKEY(privroot->d_inode)->k_objectid);
++=======
+ 	struct dentry *privroot = REISERFS_SB(dir->i_sb)->priv_root;
+ 	return (d_really_is_positive(privroot) &&
+ 	        deh->deh_objectid == INODE_PKEY(d_inode(privroot))->k_objectid);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  }
  
 -int reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)
 +int reiserfs_readdir_dentry(struct dentry *dentry, void *dirent,
 +			   filldir_t filldir, loff_t *pos)
  {
 -
 -	/* key of current position in the directory (key of directory entry) */
 -	struct cpu_key pos_key;
 -
 +	struct inode *inode = dentry->d_inode;
 +	struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
  	INITIALIZE_PATH(path_to_entry);
  	struct buffer_head *bh;
  	int item_num, entry_num;
diff --cc fs/reiserfs/super.c
index e2e202a07b31,558ef2ce1bdd..000000000000
--- a/fs/reiserfs/super.c
+++ b/fs/reiserfs/super.c
@@@ -1597,71 -1683,60 +1597,71 @@@ static __u32 find_hash_out(struct super
  	struct cpu_key key;
  	INITIALIZE_PATH(path);
  	struct reiserfs_dir_entry de;
 -	struct reiserfs_de_head *deh;
  	__u32 hash = DEFAULT_HASH;
 -	__u32 deh_hashval, teahash, r5hash, yurahash;
  
- 	inode = s->s_root->d_inode;
+ 	inode = d_inode(s->s_root);
  
 -	make_cpu_key(&key, inode, ~0, TYPE_DIRENTRY, 3);
 -	retval = search_by_entry_key(s, &key, &path, &de);
 -	if (retval == IO_ERROR) {
 -		pathrelse(&path);
 -		return UNSET_HASH;
 -	}
 -	if (retval == NAME_NOT_FOUND)
 -		de.de_entry_num--;
 -
 -	set_de_name_and_namelen(&de);
 -	deh = de.de_deh + de.de_entry_num;
 +	do {			// Some serious "goto"-hater was there ;)
 +		u32 teahash, r5hash, yurahash;
  
 -	if (deh_offset(deh) == DOT_DOT_OFFSET) {
 -		/* allow override in this case */
 -		if (reiserfs_rupasov_hash(s))
 +		make_cpu_key(&key, inode, ~0, TYPE_DIRENTRY, 3);
 +		retval = search_by_entry_key(s, &key, &path, &de);
 +		if (retval == IO_ERROR) {
 +			pathrelse(&path);
 +			return UNSET_HASH;
 +		}
 +		if (retval == NAME_NOT_FOUND)
 +			de.de_entry_num--;
 +		set_de_name_and_namelen(&de);
 +		if (deh_offset(&(de.de_deh[de.de_entry_num])) == DOT_DOT_OFFSET) {
 +			/* allow override in this case */
 +			if (reiserfs_rupasov_hash(s)) {
 +				hash = YURA_HASH;
 +			}
 +			reiserfs_info(s, "FS seems to be empty, autodetect "
 +					 "is using the default hash\n");
 +			break;
 +		}
 +		r5hash = GET_HASH_VALUE(r5_hash(de.de_name, de.de_namelen));
 +		teahash = GET_HASH_VALUE(keyed_hash(de.de_name, de.de_namelen));
 +		yurahash = GET_HASH_VALUE(yura_hash(de.de_name, de.de_namelen));
 +		if (((teahash == r5hash)
 +		     &&
 +		     (GET_HASH_VALUE(deh_offset(&(de.de_deh[de.de_entry_num])))
 +		      == r5hash)) || ((teahash == yurahash)
 +				      && (yurahash ==
 +					  GET_HASH_VALUE(deh_offset
 +							 (&
 +							  (de.
 +							   de_deh[de.
 +								  de_entry_num])))))
 +		    || ((r5hash == yurahash)
 +			&& (yurahash ==
 +			    GET_HASH_VALUE(deh_offset
 +					   (&(de.de_deh[de.de_entry_num])))))) {
 +			reiserfs_warning(s, "reiserfs-2506", "Unable to "
 +					 "automatically detect hash function. "
 +					 "Please mount with -o "
 +					 "hash={tea,rupasov,r5}");
 +			hash = UNSET_HASH;
 +			break;
 +		}
 +		if (GET_HASH_VALUE(deh_offset(&(de.de_deh[de.de_entry_num]))) ==
 +		    yurahash)
  			hash = YURA_HASH;
 -		reiserfs_info(s, "FS seems to be empty, autodetect is using the default hash\n");
 -		goto out;
 -	}
 -
 -	deh_hashval = GET_HASH_VALUE(deh_offset(deh));
 -	r5hash = GET_HASH_VALUE(r5_hash(de.de_name, de.de_namelen));
 -	teahash = GET_HASH_VALUE(keyed_hash(de.de_name, de.de_namelen));
 -	yurahash = GET_HASH_VALUE(yura_hash(de.de_name, de.de_namelen));
 -
 -	if ((teahash == r5hash && deh_hashval == r5hash) ||
 -	    (teahash == yurahash && deh_hashval == yurahash) ||
 -	    (r5hash == yurahash && deh_hashval == yurahash)) {
 -		reiserfs_warning(s, "reiserfs-2506",
 -				 "Unable to automatically detect hash "
 -				 "function. Please mount with -o "
 -				 "hash={tea,rupasov,r5}");
 -		hash = UNSET_HASH;
 -		goto out;
 -	}
 +		else if (GET_HASH_VALUE
 +			 (deh_offset(&(de.de_deh[de.de_entry_num]))) == teahash)
 +			hash = TEA_HASH;
 +		else if (GET_HASH_VALUE
 +			 (deh_offset(&(de.de_deh[de.de_entry_num]))) == r5hash)
 +			hash = R5_HASH;
 +		else {
 +			reiserfs_warning(s, "reiserfs-2506",
 +					 "Unrecognised hash function");
 +			hash = UNSET_HASH;
 +		}
 +	} while (0);
  
 -	if (deh_hashval == yurahash)
 -		hash = YURA_HASH;
 -	else if (deh_hashval == teahash)
 -		hash = TEA_HASH;
 -	else if (deh_hashval == r5hash)
 -		hash = R5_HASH;
 -	else {
 -		reiserfs_warning(s, "reiserfs-2506",
 -				 "Unrecognised hash function");
 -		hash = UNSET_HASH;
 -	}
 -out:
  	pathrelse(&path);
  	return hash;
  }
@@@ -2234,8 -2347,11 +2234,16 @@@ static int reiserfs_quota_on(struct sup
  		err = -EXDEV;
  		goto out;
  	}
++<<<<<<< HEAD
 +	inode = path->dentry->d_inode;
 +	/* We must not pack tails for quota files on reiserfs for quota IO to work */
++=======
+ 	inode = d_inode(path->dentry);
+ 	/*
+ 	 * We must not pack tails for quota files on reiserfs for quota
+ 	 * IO to work
+ 	 */
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	if (!(REISERFS_I(inode)->i_flags & i_nopack_mask)) {
  		err = reiserfs_unpack(inode, NULL);
  		if (err) {
diff --cc fs/reiserfs/xattr.c
index 821bcf70e467,e87f9b52bf06..000000000000
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@@ -79,12 -84,12 +79,16 @@@ static int xattr_mkdir(struct inode *di
  static int xattr_unlink(struct inode *dir, struct dentry *dentry)
  {
  	int error;
 -
  	BUG_ON(!mutex_is_locked(&dir->i_mutex));
  
++<<<<<<< HEAD
 +	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
 +					I_MUTEX_CHILD, dir->i_sb);
++=======
+ 	mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	error = dir->i_op->unlink(dir, dentry);
- 	mutex_unlock(&dentry->d_inode->i_mutex);
+ 	mutex_unlock(&d_inode(dentry)->i_mutex);
  
  	if (!error)
  		d_delete(dentry);
@@@ -94,14 -99,14 +98,18 @@@
  static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
  {
  	int error;
 -
  	BUG_ON(!mutex_is_locked(&dir->i_mutex));
  
++<<<<<<< HEAD
 +	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
 +					I_MUTEX_CHILD, dir->i_sb);
++=======
+ 	mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	error = dir->i_op->rmdir(dir, dentry);
  	if (!error)
- 		dentry->d_inode->i_flags |= S_DEAD;
- 	mutex_unlock(&dentry->d_inode->i_mutex);
+ 		d_inode(dentry)->i_flags |= S_DEAD;
+ 	mutex_unlock(&d_inode(dentry)->i_mutex);
  	if (!error)
  		d_delete(dentry);
  
@@@ -114,18 -119,20 +122,23 @@@ static struct dentry *open_xa_root(stru
  {
  	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
  	struct dentry *xaroot;
++<<<<<<< HEAD
 +	if (!privroot->d_inode)
++=======
+ 
+ 	if (d_really_is_negative(privroot))
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		return ERR_PTR(-ENODATA);
  
- 	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
+ 	mutex_lock_nested(&d_inode(privroot)->i_mutex, I_MUTEX_XATTR);
  
  	xaroot = dget(REISERFS_SB(sb)->xattr_root);
  	if (!xaroot)
  		xaroot = ERR_PTR(-ENODATA);
- 	else if (!xaroot->d_inode) {
+ 	else if (d_really_is_negative(xaroot)) {
  		int err = -ENODATA;
 -
  		if (xattr_may_create(flags))
- 			err = xattr_mkdir(privroot->d_inode, xaroot, 0700);
+ 			err = xattr_mkdir(d_inode(privroot), xaroot, 0700);
  		if (err) {
  			dput(xaroot);
  			xaroot = ERR_PTR(err);
@@@ -149,13 -156,14 +162,13 @@@ static struct dentry *open_xa_dir(cons
  		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
  		 inode->i_generation);
  
- 	mutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);
+ 	mutex_lock_nested(&d_inode(xaroot)->i_mutex, I_MUTEX_XATTR);
  
  	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
- 	if (!IS_ERR(xadir) && !xadir->d_inode) {
+ 	if (!IS_ERR(xadir) && d_really_is_negative(xadir)) {
  		int err = -ENODATA;
 -
  		if (xattr_may_create(flags))
- 			err = xattr_mkdir(xaroot->d_inode, xadir, 0700);
+ 			err = xattr_mkdir(d_inode(xaroot), xadir, 0700);
  		if (err) {
  			dput(xadir);
  			xadir = ERR_PTR(err);
@@@ -177,12 -188,14 +190,17 @@@ struct reiserfs_dentry_buf 
  };
  
  static int
 -fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
 -		   loff_t offset, u64 ino, unsigned int d_type)
 +fill_with_dentries(void *buf, const char *name, int namelen, loff_t offset,
 +		    u64 ino, unsigned int d_type)
  {
 -	struct reiserfs_dentry_buf *dbuf =
 -		container_of(ctx, struct reiserfs_dentry_buf, ctx);
 +	struct reiserfs_dentry_buf *dbuf = buf;
  	struct dentry *dentry;
++<<<<<<< HEAD
 +	WARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));
++=======
+ 
+ 	WARN_ON_ONCE(!mutex_is_locked(&d_inode(dbuf->xadir)->i_mutex));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
  		return -ENOSPC;
@@@ -194,12 -207,12 +212,12 @@@
  	dentry = lookup_one_len(name, dbuf->xadir, namelen);
  	if (IS_ERR(dentry)) {
  		return PTR_ERR(dentry);
- 	} else if (!dentry->d_inode) {
+ 	} else if (d_really_is_negative(dentry)) {
  		/* A directory entry exists, but no file? */
  		reiserfs_error(dentry->d_sb, "xattr-20003",
 -			       "Corrupted directory: xattr %pd listed but "
 -			       "not found for file %pd.\n",
 -			       dentry, dbuf->xadir);
 +			       "Corrupted directory: xattr %s listed but "
 +			       "not found for file %s.\n",
 +			       dentry->d_name.name, dbuf->xadir->d_name.name);
  		dput(dentry);
  		return -EIO;
  	}
@@@ -236,42 -248,36 +254,52 @@@ static int reiserfs_for_each_xattr(stru
  	dir = open_xa_dir(inode, XATTR_REPLACE);
  	if (IS_ERR(dir)) {
  		err = PTR_ERR(dir);
 +		reiserfs_write_lock(inode->i_sb);
  		goto out;
- 	} else if (!dir->d_inode) {
+ 	} else if (d_really_is_negative(dir)) {
  		err = 0;
 +		reiserfs_write_lock(inode->i_sb);
  		goto out_dir;
  	}
  
- 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
+ 	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
  
 +	reiserfs_write_lock(inode->i_sb);
 +
  	buf.xadir = dir;
++<<<<<<< HEAD
 +	err = reiserfs_readdir_dentry(dir, &buf, fill_with_dentries, &pos);
 +	while ((err == 0 || err == -ENOSPC) && buf.count) {
 +		err = 0;
 +
 +		for (i = 0; i < buf.count && buf.dentries[i]; i++) {
 +			int lerr = 0;
++=======
+ 	while (1) {
+ 		err = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);
+ 		if (err)
+ 			break;
+ 		if (!buf.count)
+ 			break;
+ 		for (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			struct dentry *dentry = buf.dentries[i];
  
 -			if (!d_is_dir(dentry))
 -				err = action(dentry, data);
 +			if (err == 0 && !S_ISDIR(dentry->d_inode->i_mode))
 +				lerr = action(dentry, data);
  
  			dput(dentry);
  			buf.dentries[i] = NULL;
 +			err = lerr ?: err;
  		}
 -		if (err)
 -			break;
  		buf.count = 0;
 +		if (!err)
 +			err = reiserfs_readdir_dentry(dir, &buf,
 +						      fill_with_dentries, &pos);
  	}
- 	mutex_unlock(&dir->d_inode->i_mutex);
+ 	mutex_unlock(&d_inode(dir)->i_mutex);
  
 +	/* Clean up after a failed readdir */
  	cleanup_dentry_buf(&buf);
  
  	if (!err) {
@@@ -283,15 -291,20 +311,26 @@@
  		int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
  			     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
  		struct reiserfs_transaction_handle th;
 -
 -		reiserfs_write_lock(inode->i_sb);
  		err = journal_begin(&th, inode->i_sb, blocks);
 -		reiserfs_write_unlock(inode->i_sb);
  		if (!err) {
  			int jerror;
++<<<<<<< HEAD
 +			reiserfs_mutex_lock_nested_safe(
 +					  &dir->d_parent->d_inode->i_mutex,
 +					  I_MUTEX_XATTR, inode->i_sb);
 +			err = action(dir, data);
 +			jerror = journal_end(&th, inode->i_sb, blocks);
 +			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
++=======
+ 
+ 			mutex_lock_nested(&d_inode(dir->d_parent)->i_mutex,
+ 					  I_MUTEX_XATTR);
+ 			err = action(dir, data);
+ 			reiserfs_write_lock(inode->i_sb);
+ 			jerror = journal_end(&th);
+ 			reiserfs_write_unlock(inode->i_sb);
+ 			mutex_unlock(&d_inode(dir->d_parent)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			err = jerror ?: err;
  		}
  	}
@@@ -306,10 -319,10 +345,10 @@@ out
  
  static int delete_one_xattr(struct dentry *dentry, void *data)
  {
- 	struct inode *dir = dentry->d_parent->d_inode;
+ 	struct inode *dir = d_inode(dentry->d_parent);
  
  	/* This is the xattr dir, handle specially. */
 -	if (d_is_dir(dentry))
 +	if (S_ISDIR(dentry->d_inode->i_mode))
  		return xattr_rmdir(dir, dentry);
  
  	return xattr_unlink(dir, dentry);
@@@ -456,10 -476,8 +495,15 @@@ static int lookup_and_delete_xattr(stru
  		goto out_dput;
  	}
  
++<<<<<<< HEAD
 +	if (dentry->d_inode) {
 +		reiserfs_write_lock(inode->i_sb);
 +		err = xattr_unlink(xadir->d_inode, dentry);
 +		reiserfs_write_unlock(inode->i_sb);
++=======
+ 	if (d_really_is_positive(dentry)) {
+ 		err = xattr_unlink(d_inode(xadir), dentry);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		update_ctime(inode);
  	}
  
@@@ -565,13 -580,11 +609,18 @@@ reiserfs_xattr_set_handle(struct reiser
  			.ia_valid = ATTR_SIZE | ATTR_CTIME,
  		};
  
++<<<<<<< HEAD
 +		reiserfs_write_unlock(inode->i_sb);
 +		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
 +		inode_dio_wait(dentry->d_inode);
 +		reiserfs_write_lock(inode->i_sb);
++=======
+ 		mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_XATTR);
+ 		inode_dio_wait(d_inode(dentry));
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  		err = reiserfs_setattr(dentry, &newattrs);
- 		mutex_unlock(&dentry->d_inode->i_mutex);
+ 		mutex_unlock(&d_inode(dentry)->i_mutex);
  	} else
  		update_ctime(inode);
  out_unlock:
@@@ -791,9 -808,10 +840,9 @@@ reiserfs_setxattr(struct dentry *dentry
  int reiserfs_removexattr(struct dentry *dentry, const char *name)
  {
  	const struct xattr_handler *handler;
 -
  	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
  
- 	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+ 	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
  		return -EOPNOTSUPP;
  
  	return handler->set(dentry, name, NULL, 0, XATTR_REPLACE, handler->flags);
@@@ -867,9 -890,9 +916,15 @@@ ssize_t reiserfs_listxattr(struct dentr
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 +	err = reiserfs_readdir_dentry(dir, &buf, listxattr_filler, &pos);
 +	mutex_unlock(&dir->d_inode->i_mutex);
++=======
+ 	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
+ 	err = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);
+ 	mutex_unlock(&d_inode(dir)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	if (!err)
  		err = buf.pos;
@@@ -882,7 -905,8 +937,12 @@@ out
  static int create_privroot(struct dentry *dentry)
  {
  	int err;
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_parent->d_inode;
++=======
+ 	struct inode *inode = d_inode(dentry->d_parent);
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
  
  	err = xattr_mkdir(inode, dentry, 0700);
@@@ -969,7 -997,7 +1029,11 @@@ int reiserfs_lookup_privroot(struct sup
  	int err = 0;
  
  	/* If we don't have the privroot located yet - go find it */
++<<<<<<< HEAD
 +	reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
++=======
+ 	mutex_lock(&d_inode(s->s_root)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
  				strlen(PRIVROOT_NAME));
  	if (!IS_ERR(dentry)) {
@@@ -996,17 -1026,18 +1060,26 @@@ int reiserfs_xattr_init(struct super_bl
  	if (err)
  		goto error;
  
++<<<<<<< HEAD
 +	if (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {
 +		reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
++=======
+ 	if (d_really_is_negative(privroot) && !(mount_flags & MS_RDONLY)) {
+ 		mutex_lock(&d_inode(s->s_root)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		err = create_privroot(REISERFS_SB(s)->priv_root);
- 		mutex_unlock(&s->s_root->d_inode->i_mutex);
+ 		mutex_unlock(&d_inode(s->s_root)->i_mutex);
  	}
  
- 	if (privroot->d_inode) {
+ 	if (d_really_is_positive(privroot)) {
  		s->s_xattr = reiserfs_xattr_handlers;
++<<<<<<< HEAD
 +		reiserfs_mutex_lock_safe(&privroot->d_inode->i_mutex, s);
++=======
+ 		mutex_lock(&d_inode(privroot)->i_mutex);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  		if (!REISERFS_SB(s)->xattr_root) {
  			struct dentry *dentry;
 -
  			dentry = lookup_one_len(XAROOT_NAME, privroot,
  						strlen(XAROOT_NAME));
  			if (!IS_ERR(dentry))
diff --cc fs/ubifs/xattr.c
index 0f7139bdb2c2,dd2d872189da..000000000000
--- a/fs/ubifs/xattr.c
+++ b/fs/ubifs/xattr.c
@@@ -356,6 -360,15 +356,18 @@@ out_free
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ int ubifs_setxattr(struct dentry *dentry, const char *name,
+ 		   const void *value, size_t size, int flags)
+ {
+ 	dbg_gen("xattr '%s', host ino %lu ('%pd'), size %zd",
+ 		name, d_inode(dentry)->i_ino, dentry, size);
+ 
+ 	return setxattr(d_inode(dentry), name, value, size, flags);
+ }
+ 
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  ssize_t ubifs_getxattr(struct dentry *dentry, const char *name, void *buf,
  		       size_t size)
  {
diff --cc fs/udf/namei.c
index 102c072c6bbf,b159b769bf51..000000000000
--- a/fs/udf/namei.c
+++ b/fs/udf/namei.c
@@@ -550,32 -549,18 +550,37 @@@ static int udf_delete_entry(struct inod
  	return udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);
  }
  
 -static int udf_add_nondir(struct dentry *dentry, struct inode *inode)
 +static int udf_create(struct inode *dir, struct dentry *dentry, umode_t mode,
 +		      bool excl)
  {
++<<<<<<< HEAD
++=======
+ 	struct udf_inode_info *iinfo = UDF_I(inode);
+ 	struct inode *dir = d_inode(dentry->d_parent);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  	struct udf_fileident_bh fibh;
 +	struct inode *inode;
  	struct fileIdentDesc cfi, *fi;
  	int err;
 +	struct udf_inode_info *iinfo;
 +
 +	inode = udf_new_inode(dir, mode, &err);
 +	if (!inode) {
 +		return err;
 +	}
 +
 +	iinfo = UDF_I(inode);
 +	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)
 +		inode->i_data.a_ops = &udf_adinicb_aops;
 +	else
 +		inode->i_data.a_ops = &udf_aops;
 +	inode->i_op = &udf_file_inode_operations;
 +	inode->i_fop = &udf_file_operations;
 +	mark_inode_dirty(inode);
  
  	fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);
 -	if (unlikely(!fi)) {
 +	if (!fi) {
  		inode_dec_link_count(inode);
 -		unlock_new_inode(inode);
  		iput(inode);
  		return err;
  	}
@@@ -1197,21 -1175,19 +1202,32 @@@ static struct dentry *udf_get_parent(st
  	struct fileIdentDesc cfi;
  	struct udf_fileident_bh fibh;
  
++<<<<<<< HEAD
 +	if (!udf_find_entry(child->d_inode, &dotdot, &fibh, &cfi))
 +		goto out_unlock;
++=======
+ 	if (!udf_find_entry(d_inode(child), &dotdot, &fibh, &cfi))
+ 		return ERR_PTR(-EACCES);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	if (fibh.sbh != fibh.ebh)
  		brelse(fibh.ebh);
  	brelse(fibh.sbh);
  
  	tloc = lelb_to_cpu(cfi.icb.extLocation);
++<<<<<<< HEAD
 +	inode = udf_iget(child->d_inode->i_sb, &tloc);
 +	if (!inode)
 +		goto out_unlock;
++=======
+ 	inode = udf_iget(d_inode(child)->i_sb, &tloc);
+ 	if (IS_ERR(inode))
+ 		return ERR_CAST(inode);
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  
  	return d_obtain_alias(inode);
 +out_unlock:
 +	return ERR_PTR(-EACCES);
  }
  
  
diff --cc fs/xfs/xfs_iops.c
index dad796405688,54b95232d946..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -954,13 -975,9 +954,18 @@@ xfs_vn_setattr
  		uint		iolock = XFS_IOLOCK_EXCL;
  
  		xfs_ilock(ip, iolock);
++<<<<<<< HEAD
 +		error = xfs_break_layouts(dentry->d_inode, &iolock, true);
 +		if (!error) {
 +			xfs_ilock(ip, XFS_MMAPLOCK_EXCL);
 +			iolock |= XFS_MMAPLOCK_EXCL;
 +
++=======
+ 		error = xfs_break_layouts(d_inode(dentry), &iolock);
+ 		if (!error)
++>>>>>>> 2b0143b5c986 (VFS: normal filesystems (and lustre): d_inode() annotations)
  			error = xfs_setattr_size(ip, iattr);
 +		}
  		xfs_iunlock(ip, iolock);
  	} else {
  		error = xfs_setattr_nonsize(ip, iattr, 0);
* Unmerged path drivers/staging/lustre/lustre/llite/dcache.c
* Unmerged path drivers/staging/lustre/lustre/llite/file.c
* Unmerged path drivers/staging/lustre/lustre/llite/llite_internal.h
* Unmerged path drivers/staging/lustre/lustre/llite/llite_lib.c
* Unmerged path drivers/staging/lustre/lustre/llite/llite_nfs.c
* Unmerged path drivers/staging/lustre/lustre/llite/namei.c
* Unmerged path drivers/staging/lustre/lustre/llite/statahead.c
* Unmerged path drivers/staging/lustre/lustre/llite/symlink.c
* Unmerged path drivers/staging/lustre/lustre/llite/xattr.c
* Unmerged path fs/kernfs/dir.c
* Unmerged path fs/kernfs/inode.c
* Unmerged path fs/proc/thread_self.c
* Unmerged path drivers/staging/lustre/lustre/llite/dcache.c
* Unmerged path drivers/staging/lustre/lustre/llite/file.c
* Unmerged path drivers/staging/lustre/lustre/llite/llite_internal.h
* Unmerged path drivers/staging/lustre/lustre/llite/llite_lib.c
* Unmerged path drivers/staging/lustre/lustre/llite/llite_nfs.c
* Unmerged path drivers/staging/lustre/lustre/llite/namei.c
* Unmerged path drivers/staging/lustre/lustre/llite/statahead.c
* Unmerged path drivers/staging/lustre/lustre/llite/symlink.c
* Unmerged path drivers/staging/lustre/lustre/llite/xattr.c
diff --git a/fs/9p/acl.c b/fs/9p/acl.c
index 7af425f53bee..2e54b369902b 100644
--- a/fs/9p/acl.c
+++ b/fs/9p/acl.c
@@ -247,7 +247,7 @@ static int v9fs_xattr_get_acl(struct dentry *dentry, const char *name,
 	if ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)
 		return v9fs_remote_get_acl(dentry, name, buffer, size, type);
 
-	acl = v9fs_get_cached_acl(dentry->d_inode, type);
+	acl = v9fs_get_cached_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
@@ -285,7 +285,7 @@ static int v9fs_xattr_set_acl(struct dentry *dentry, const char *name,
 	int retval;
 	struct posix_acl *acl;
 	struct v9fs_session_info *v9ses;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (strcmp(name, "") != 0)
 		return -EINVAL;
diff --git a/fs/9p/vfs_dentry.c b/fs/9p/vfs_dentry.c
index f039b104a98e..d185d090b88b 100644
--- a/fs/9p/vfs_dentry.c
+++ b/fs/9p/vfs_dentry.c
@@ -70,7 +70,7 @@ static int v9fs_cached_dentry_delete(const struct dentry *dentry)
 		 dentry->d_name.name, dentry);
 
 	/* Don't cache negative dentries */
-	if (!dentry->d_inode)
+	if (d_really_is_negative(dentry))
 		return 1;
 	return 0;
 }
@@ -100,7 +100,7 @@ static int v9fs_lookup_revalidate(struct dentry *dentry, unsigned int flags)
 	if (flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if (!inode)
 		goto out_valid;
 
* Unmerged path fs/9p/vfs_inode.c
diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c
index a7c481402c46..b67b9ff16bd3 100644
--- a/fs/9p/vfs_inode_dotl.c
+++ b/fs/9p/vfs_inode_dotl.c
@@ -267,7 +267,7 @@ v9fs_vfs_atomic_open_dotl(struct inode *dir, struct dentry *dentry,
 	}
 
 	/* Only creates */
-	if (!(flags & O_CREAT) || dentry->d_inode)
+	if (!(flags & O_CREAT) || d_really_is_positive(dentry))
 		return	finish_no_open(file, res);
 
 	v9ses = v9fs_inode2v9ses(dir);
@@ -486,7 +486,7 @@ v9fs_vfs_getattr_dotl(struct vfsmount *mnt, struct dentry *dentry,
 	err = -EPERM;
 	v9ses = v9fs_dentry2v9ses(dentry);
 	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {
-		generic_fillattr(dentry->d_inode, stat);
+		generic_fillattr(d_inode(dentry), stat);
 		return 0;
 	}
 	fid = v9fs_fid_lookup(dentry);
@@ -501,8 +501,8 @@ v9fs_vfs_getattr_dotl(struct vfsmount *mnt, struct dentry *dentry,
 	if (IS_ERR(st))
 		return PTR_ERR(st);
 
-	v9fs_stat2inode_dotl(st, dentry->d_inode);
-	generic_fillattr(dentry->d_inode, stat);
+	v9fs_stat2inode_dotl(st, d_inode(dentry));
+	generic_fillattr(d_inode(dentry), stat);
 	/* Change block size to what the server returned */
 	stat->blksize = st->st_blksize;
 
@@ -563,7 +563,7 @@ int v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)
 	struct v9fs_session_info *v9ses;
 	struct p9_fid *fid;
 	struct p9_iattr_dotl p9attr;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	p9_debug(P9_DEBUG_VFS, "\n");
 
@@ -807,10 +807,10 @@ v9fs_vfs_link_dotl(struct dentry *old_dentry, struct inode *dir,
 		if (IS_ERR(fid))
 			return PTR_ERR(fid);
 
-		v9fs_refresh_inode_dotl(fid, old_dentry->d_inode);
+		v9fs_refresh_inode_dotl(fid, d_inode(old_dentry));
 	}
-	ihold(old_dentry->d_inode);
-	d_instantiate(dentry, old_dentry->d_inode);
+	ihold(d_inode(old_dentry));
+	d_instantiate(dentry, d_inode(old_dentry));
 
 	return err;
 }
diff --git a/fs/9p/vfs_super.c b/fs/9p/vfs_super.c
index 2756dcd5de6e..b7abf232c983 100644
--- a/fs/9p/vfs_super.c
+++ b/fs/9p/vfs_super.c
@@ -168,8 +168,8 @@ static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,
 			retval = PTR_ERR(st);
 			goto release_sb;
 		}
-		root->d_inode->i_ino = v9fs_qid2ino(&st->qid);
-		v9fs_stat2inode_dotl(st, root->d_inode);
+		d_inode(root)->i_ino = v9fs_qid2ino(&st->qid);
+		v9fs_stat2inode_dotl(st, d_inode(root));
 		kfree(st);
 	} else {
 		struct p9_wstat *st = NULL;
@@ -179,8 +179,8 @@ static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,
 			goto release_sb;
 		}
 
-		root->d_inode->i_ino = v9fs_qid2ino(&st->qid);
-		v9fs_stat2inode(st, root->d_inode, sb);
+		d_inode(root)->i_ino = v9fs_qid2ino(&st->qid);
+		v9fs_stat2inode(st, d_inode(root), sb);
 
 		p9stat_free(st);
 		kfree(st);
diff --git a/fs/adfs/inode.c b/fs/adfs/inode.c
index b9acadafa4a1..335055d828e4 100644
--- a/fs/adfs/inode.c
+++ b/fs/adfs/inode.c
@@ -298,7 +298,7 @@ out:
 int
 adfs_notify_change(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	unsigned int ia_valid = attr->ia_valid;
 	int error;
* Unmerged path fs/affs/amigaffs.c
diff --git a/fs/affs/inode.c b/fs/affs/inode.c
index 96df91e8c334..8df0eebdc8ce 100644
--- a/fs/affs/inode.c
+++ b/fs/affs/inode.c
@@ -217,7 +217,7 @@ affs_write_inode(struct inode *inode, struct writeback_control *wbc)
 int
 affs_notify_change(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	pr_debug("AFFS: notify_change(%lu,0x%x)\n",inode->i_ino,attr->ia_valid);
* Unmerged path fs/affs/namei.c
* Unmerged path fs/afs/dir.c
diff --git a/fs/afs/inode.c b/fs/afs/inode.c
index 294671288449..0572ac0361e2 100644
--- a/fs/afs/inode.c
+++ b/fs/afs/inode.c
@@ -379,7 +379,7 @@ int afs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 {
 	struct inode *inode;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	_enter("{ ino=%lu v=%u }", inode->i_ino, inode->i_generation);
 
@@ -458,7 +458,7 @@ void afs_evict_inode(struct inode *inode)
  */
 int afs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));
 	struct key *key;
 	int ret;
 
diff --git a/fs/afs/mntpt.c b/fs/afs/mntpt.c
index 9682c33d5daf..e47182c8092f 100644
--- a/fs/afs/mntpt.c
+++ b/fs/afs/mntpt.c
@@ -148,7 +148,7 @@ static struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)
 
 	_enter("{%s}", mntpt->d_name.name);
 
-	BUG_ON(!mntpt->d_inode);
+	BUG_ON(!d_inode(mntpt));
 
 	ret = -ENOMEM;
 	devname = (char *) get_zeroed_page(GFP_KERNEL);
@@ -159,7 +159,7 @@ static struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)
 	if (!options)
 		goto error_no_options;
 
-	vnode = AFS_FS_I(mntpt->d_inode);
+	vnode = AFS_FS_I(d_inode(mntpt));
 	if (test_bit(AFS_VNODE_PSEUDODIR, &vnode->flags)) {
 		/* if the directory is a pseudo directory, use the d_name */
 		static const char afs_root_cell[] = ":root.cell.";
@@ -183,14 +183,14 @@ static struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)
 		}
 	} else {
 		/* read the contents of the AFS special symlink */
-		loff_t size = i_size_read(mntpt->d_inode);
+		loff_t size = i_size_read(d_inode(mntpt));
 		char *buf;
 
 		ret = -EINVAL;
 		if (size > PAGE_SIZE - 1)
 			goto error_no_page;
 
-		page = read_mapping_page(mntpt->d_inode->i_mapping, 0, NULL);
+		page = read_mapping_page(d_inode(mntpt)->i_mapping, 0, NULL);
 		if (IS_ERR(page)) {
 			ret = PTR_ERR(page);
 			goto error_no_page;
diff --git a/fs/afs/super.c b/fs/afs/super.c
index c4861557e385..1fb4a5129f7d 100644
--- a/fs/afs/super.c
+++ b/fs/afs/super.c
@@ -529,7 +529,7 @@ static void afs_destroy_inode(struct inode *inode)
 static int afs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct afs_volume_status vs;
-	struct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));
 	struct key *key;
 	int ret;
 
diff --git a/fs/autofs4/autofs_i.h b/fs/autofs4/autofs_i.h
index 39f197cfd416..728414c453cc 100644
--- a/fs/autofs4/autofs_i.h
+++ b/fs/autofs4/autofs_i.h
@@ -294,12 +294,12 @@ static inline u32 autofs4_get_dev(struct autofs_sb_info *sbi)
 
 static inline u64 autofs4_get_ino(struct autofs_sb_info *sbi)
 {
-	return sbi->sb->s_root->d_inode->i_ino;
+	return d_inode(sbi->sb->s_root)->i_ino;
 }
 
 static inline int simple_positive(struct dentry *dentry)
 {
-	return dentry->d_inode && !d_unhashed(dentry);
+	return d_really_is_positive(dentry) && !d_unhashed(dentry);
 }
 
 static inline void __autofs4_add_expiring(struct dentry *dentry)
* Unmerged path fs/autofs4/expire.c
diff --git a/fs/autofs4/inode.c b/fs/autofs4/inode.c
index d7bd395ab586..1e2f0b6500e9 100644
--- a/fs/autofs4/inode.c
+++ b/fs/autofs4/inode.c
@@ -71,7 +71,7 @@ void autofs4_kill_sb(struct super_block *sb)
 static int autofs4_show_options(struct seq_file *m, struct dentry *root)
 {
 	struct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);
-	struct inode *root_inode = root->d_sb->s_root->d_inode;
+	struct inode *root_inode = d_inode(root->d_sb->s_root);
 
 	if (!sbi)
 		return 0;
@@ -352,8 +352,8 @@ struct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)
 
 	inode->i_mode = mode;
 	if (sb->s_root) {
-		inode->i_uid = sb->s_root->d_inode->i_uid;
-		inode->i_gid = sb->s_root->d_inode->i_gid;
+		inode->i_uid = d_inode(sb->s_root)->i_uid;
+		inode->i_gid = d_inode(sb->s_root)->i_gid;
 	}
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	inode->i_ino = get_next_ino();
* Unmerged path fs/autofs4/root.c
diff --git a/fs/autofs4/symlink.c b/fs/autofs4/symlink.c
index 1e8ea192be2b..de58cc7b8076 100644
--- a/fs/autofs4/symlink.c
+++ b/fs/autofs4/symlink.c
@@ -18,7 +18,7 @@ static void *autofs4_follow_link(struct dentry *dentry, struct nameidata *nd)
 	struct autofs_info *ino = autofs4_dentry_ino(dentry);
 	if (ino && !autofs4_oz_mode(sbi))
 		ino->last_used = jiffies;
-	nd_set_link(nd, dentry->d_inode->i_private);
+	nd_set_link(nd, d_inode(dentry)->i_private);
 	return NULL;
 }
 
diff --git a/fs/autofs4/waitq.c b/fs/autofs4/waitq.c
index 309ca6bcbb09..7c773863b6ea 100644
--- a/fs/autofs4/waitq.c
+++ b/fs/autofs4/waitq.c
@@ -328,7 +328,7 @@ static int validate_request(struct autofs_wait_queue **wait,
 		 * continue on and create a new request.
 		 */
 		if (!IS_ROOT(dentry)) {
-			if (dentry->d_inode && d_unhashed(dentry)) {
+			if (d_really_is_positive(dentry) && d_unhashed(dentry)) {
 				struct dentry *parent = dentry->d_parent;
 				new = d_lookup(parent, &dentry->d_name);
 				if (new)
@@ -370,7 +370,7 @@ int autofs4_wait(struct autofs_sb_info *sbi, struct dentry *dentry,
 	if (pid == 0 || tgid == 0)
 		return -ENOENT;
 
-	if (!dentry->d_inode) {
+	if (d_really_is_negative(dentry)) {
 		/*
 		 * A wait for a negative dentry is invalid for certain
 		 * cases. A direct or offset mount "always" has its mount
* Unmerged path fs/befs/linuxvfs.c
diff --git a/fs/bfs/dir.c b/fs/bfs/dir.c
index 3f422f6bb5ca..802e2cdb094e 100644
--- a/fs/bfs/dir.c
+++ b/fs/bfs/dir.c
@@ -162,7 +162,7 @@ static struct dentry *bfs_lookup(struct inode *dir, struct dentry *dentry,
 static int bfs_link(struct dentry *old, struct inode *dir,
 						struct dentry *new)
 {
-	struct inode *inode = old->d_inode;
+	struct inode *inode = d_inode(old);
 	struct bfs_sb_info *info = BFS_SB(inode->i_sb);
 	int err;
 
@@ -185,7 +185,7 @@ static int bfs_link(struct dentry *old, struct inode *dir,
 static int bfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = -ENOENT;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh;
 	struct bfs_dirent *de;
 	struct bfs_sb_info *info = BFS_SB(inode->i_sb);
@@ -225,7 +225,7 @@ static int bfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	int error = -ENOENT;
 
 	old_bh = new_bh = NULL;
-	old_inode = old_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
 	if (S_ISDIR(old_inode->i_mode))
 		return -EINVAL;
 
@@ -240,7 +240,7 @@ static int bfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		goto end_rename;
 
 	error = -EPERM;
-	new_inode = new_dentry->d_inode;
+	new_inode = d_inode(new_dentry);
 	new_bh = bfs_find_entry(new_dir, 
 				new_dentry->d_name.name, 
 				new_dentry->d_name.len, &new_de);
diff --git a/fs/btrfs/export.c b/fs/btrfs/export.c
index a1a5dd417083..2513a7f53334 100644
--- a/fs/btrfs/export.c
+++ b/fs/btrfs/export.c
@@ -152,7 +152,7 @@ static struct dentry *btrfs_fh_to_dentry(struct super_block *sb, struct fid *fh,
 
 static struct dentry *btrfs_get_parent(struct dentry *child)
 {
-	struct inode *dir = child->d_inode;
+	struct inode *dir = d_inode(child);
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_path *path;
 	struct extent_buffer *leaf;
@@ -220,8 +220,8 @@ fail:
 static int btrfs_get_name(struct dentry *parent, char *name,
 			  struct dentry *child)
 {
-	struct inode *inode = child->d_inode;
-	struct inode *dir = parent->d_inode;
+	struct inode *inode = d_inode(child);
+	struct inode *dir = d_inode(parent);
 	struct btrfs_path *path;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_inode_ref *iref;
diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index fffea6628b71..eb4f01e57d93 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -1910,7 +1910,7 @@ static int start_ordered_ops(struct inode *inode, loff_t start, loff_t end)
 int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_trans_handle *trans;
 	struct btrfs_log_ctx ctx;
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index b10a2ff95b5d..a6f63c5dacd6 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -4067,16 +4067,16 @@ static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_trans_handle *trans;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int ret;
 
 	trans = __unlink_start_trans(dir);
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
 
-	btrfs_record_unlink_dir(trans, dir, dentry->d_inode, 0);
+	btrfs_record_unlink_dir(trans, dir, d_inode(dentry), 0);
 
-	ret = btrfs_unlink_inode(trans, root, dir, dentry->d_inode,
+	ret = btrfs_unlink_inode(trans, root, dir, d_inode(dentry),
 				 dentry->d_name.name, dentry->d_name.len);
 	if (ret)
 		goto out;
@@ -4175,7 +4175,7 @@ out:
 
 static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = 0;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_trans_handle *trans;
@@ -4202,7 +4202,7 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 		goto out;
 
 	/* now the directory is empty */
-	err = btrfs_unlink_inode(trans, root, dir, dentry->d_inode,
+	err = btrfs_unlink_inode(trans, root, dir, d_inode(dentry),
 				 dentry->d_name.name, dentry->d_name.len);
 	if (!err)
 		btrfs_i_size_write(inode, 0);
@@ -4917,7 +4917,7 @@ static int btrfs_setsize(struct inode *inode, struct iattr *attr)
 
 static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	int err;
 
@@ -5579,10 +5579,10 @@ struct inode *btrfs_lookup_dentry(struct inode *dir, struct dentry *dentry)
 static int btrfs_dentry_delete(const struct dentry *dentry)
 {
 	struct btrfs_root *root;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (!inode && !IS_ROOT(dentry))
-		inode = dentry->d_parent->d_inode;
+		inode = d_inode(dentry->d_parent);
 
 	if (inode) {
 		root = BTRFS_I(inode)->root;
@@ -6391,7 +6391,7 @@ static int btrfs_link(struct dentry *old_dentry, struct inode *dir,
 {
 	struct btrfs_trans_handle *trans = NULL;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	u64 index;
 	int err;
 	int drop_inode = 0;
@@ -9129,7 +9129,7 @@ static int btrfs_getattr(struct vfsmount *mnt,
 			 struct dentry *dentry, struct kstat *stat)
 {
 	u64 delalloc_bytes;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	u32 blocksize = inode->i_sb->s_blocksize;
 
 	generic_fillattr(inode, stat);
@@ -9150,8 +9150,8 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = BTRFS_I(old_dir)->root;
 	struct btrfs_root *dest = BTRFS_I(new_dir)->root;
-	struct inode *new_inode = new_dentry->d_inode;
-	struct inode *old_inode = old_dentry->d_inode;
+	struct inode *new_inode = d_inode(new_dentry);
+	struct inode *old_inode = d_inode(old_dentry);
 	struct timespec ctime = CURRENT_TIME;
 	u64 index = 0;
 	u64 root_objectid;
@@ -9263,7 +9263,7 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 					old_dentry->d_name.len);
 	} else {
 		ret = __btrfs_unlink_inode(trans, root, old_dir,
-					old_dentry->d_inode,
+					d_inode(old_dentry),
 					old_dentry->d_name.name,
 					old_dentry->d_name.len);
 		if (!ret)
@@ -9287,12 +9287,12 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			BUG_ON(new_inode->i_nlink == 0);
 		} else {
 			ret = btrfs_unlink_inode(trans, dest, new_dir,
-						 new_dentry->d_inode,
+						 d_inode(new_dentry),
 						 new_dentry->d_name.name,
 						 new_dentry->d_name.len);
 		}
 		if (!ret && new_inode->i_nlink == 0)
-			ret = btrfs_orphan_add(trans, new_dentry->d_inode);
+			ret = btrfs_orphan_add(trans, d_inode(new_dentry));
 		if (ret) {
 			btrfs_abort_transaction(trans, root, ret);
 			goto out_fail;
diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index a3d5303147f4..eb1319f97590 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -726,7 +726,7 @@ static int create_snapshot(struct btrfs_root *root, struct inode *dir,
 	if (ret)
 		goto fail;
 
-	inode = btrfs_lookup_dentry(dentry->d_parent->d_inode, dentry);
+	inode = btrfs_lookup_dentry(d_inode(dentry->d_parent), dentry);
 	if (IS_ERR(inode)) {
 		ret = PTR_ERR(inode);
 		goto fail;
@@ -770,10 +770,10 @@ static int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)
 {
 	int error;
 
-	if (!victim->d_inode)
+	if (d_really_is_negative(victim))
 		return -ENOENT;
 
-	BUG_ON(victim->d_parent->d_inode != dir);
+	BUG_ON(d_inode(victim->d_parent) != dir);
 	audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);
 
 	error = inode_permission(dir, MAY_WRITE | MAY_EXEC);
@@ -781,8 +781,8 @@ static int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)
 		return error;
 	if (IS_APPEND(dir))
 		return -EPERM;
-	if (check_sticky(dir, victim->d_inode) || IS_APPEND(victim->d_inode) ||
-	    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))
+	if (check_sticky(dir, d_inode(victim)) || IS_APPEND(d_inode(victim)) ||
+	    IS_IMMUTABLE(d_inode(victim)) || IS_SWAPFILE(d_inode(victim)))
 		return -EPERM;
 	if (isdir) {
 		if (!S_ISDIR(victim->d_inode->i_mode))
@@ -801,7 +801,7 @@ static int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)
 /* copy of may_create in fs/namei.c() */
 static inline int btrfs_may_create(struct inode *dir, struct dentry *child)
 {
-	if (child->d_inode)
+	if (d_really_is_positive(child))
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
@@ -819,7 +819,7 @@ static noinline int btrfs_mksubvol(struct path *parent,
 				   u64 *async_transid, bool readonly,
 				   struct btrfs_qgroup_inherit *inherit)
 {
-	struct inode *dir  = parent->dentry->d_inode;
+	struct inode *dir  = d_inode(parent->dentry);
 	struct dentry *dentry;
 	int error;
 
@@ -833,7 +833,7 @@ static noinline int btrfs_mksubvol(struct path *parent,
 		goto out_unlock;
 
 	error = -EEXIST;
-	if (dentry->d_inode)
+	if (d_really_is_positive(dentry))
 		goto out_dput;
 
 	error = btrfs_may_create(dir, dentry);
@@ -2329,7 +2329,7 @@ static noinline int btrfs_ioctl_snap_destroy(struct file *file,
 {
 	struct dentry *parent = file->f_path.dentry;
 	struct dentry *dentry;
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct inode *inode;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_root *dest = NULL;
@@ -2368,12 +2368,12 @@ static noinline int btrfs_ioctl_snap_destroy(struct file *file,
 		goto out_unlock_dir;
 	}
 
-	if (!dentry->d_inode) {
+	if (d_really_is_negative(dentry)) {
 		err = -ENOENT;
 		goto out_dput;
 	}
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	dest = BTRFS_I(inode)->root;
 	if (!capable(CAP_SYS_ADMIN)) {
 		/*
diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b9c239bde181..20271aacf9e8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -928,7 +928,7 @@ setup_root:
 	 * a reference to the dentry.  We will have already gotten a reference
 	 * to the inode in btrfs_fill_super so we're good to go.
 	 */
-	if (!new && sb->s_root->d_inode == inode) {
+	if (!new && d_inode(sb->s_root) == inode) {
 		iput(inode);
 		return dget(sb->s_root);
 	}
@@ -1238,7 +1238,7 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 	/* mount_subtree() drops our reference on the vfsmount. */
 	mnt = NULL;
 
-	if (!IS_ERR(root) && !is_subvolume_inode(root->d_inode)) {
+	if (!IS_ERR(root) && !is_subvolume_inode(d_inode(root))) {
 		struct super_block *s = root->d_sb;
 		dput(root);
 		root = ERR_PTR(-EINVAL);
@@ -1937,8 +1937,8 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);
 	buf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);
 	/* Mask in the root object ID too, to disambiguate subvols */
-	buf->f_fsid.val[0] ^= BTRFS_I(dentry->d_inode)->root->objectid >> 32;
-	buf->f_fsid.val[1] ^= BTRFS_I(dentry->d_inode)->root->objectid;
+	buf->f_fsid.val[0] ^= BTRFS_I(d_inode(dentry))->root->objectid >> 32;
+	buf->f_fsid.val[1] ^= BTRFS_I(d_inode(dentry))->root->objectid;
 
 	return 0;
 }
diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c
index c0078dbfaffa..4368dc864463 100644
--- a/fs/btrfs/tree-log.c
+++ b/fs/btrfs/tree-log.c
@@ -4746,9 +4746,9 @@ static noinline int check_parent_dirs_for_sync(struct btrfs_trans_handle *trans,
 			goto out;
 
 	if (!S_ISDIR(inode->i_mode)) {
-		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
+		if (!parent || d_really_is_negative(parent) || sb != d_inode(parent)->i_sb)
 			goto out;
-		inode = parent->d_inode;
+		inode = d_inode(parent);
 	}
 
 	while (1) {
@@ -4774,7 +4774,7 @@ static noinline int check_parent_dirs_for_sync(struct btrfs_trans_handle *trans,
 			break;
 		}
 
-		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
+		if (!parent || d_really_is_negative(parent) || sb != d_inode(parent)->i_sb)
 			break;
 
 		if (IS_ROOT(parent))
@@ -4783,7 +4783,7 @@ static noinline int check_parent_dirs_for_sync(struct btrfs_trans_handle *trans,
 		parent = dget_parent(parent);
 		dput(old_parent);
 		old_parent = parent;
-		inode = parent->d_inode;
+		inode = d_inode(parent);
 
 	}
 	dput(old_parent);
@@ -4869,10 +4869,10 @@ static int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,
 	}
 
 	while (1) {
-		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
+		if (!parent || d_really_is_negative(parent) || sb != d_inode(parent)->i_sb)
 			break;
 
-		inode = parent->d_inode;
+		inode = d_inode(parent);
 		if (root != BTRFS_I(inode)->root)
 			break;
 
@@ -4934,7 +4934,7 @@ int btrfs_log_dentry_safe(struct btrfs_trans_handle *trans,
 	struct dentry *parent = dget_parent(dentry);
 	int ret;
 
-	ret = btrfs_log_inode_parent(trans, root, dentry->d_inode, parent,
+	ret = btrfs_log_inode_parent(trans, root, d_inode(dentry), parent,
 				     start, end, 0, ctx);
 	dput(parent);
 
* Unmerged path fs/btrfs/xattr.c
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index f05879a2377f..e383698d7f58 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -3570,7 +3570,7 @@ int ceph_encode_inode_release(void **p, struct inode *inode,
 int ceph_encode_dentry_release(void **p, struct dentry *dentry,
 			       int mds, int drop, int unless)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct ceph_mds_request_release *rel = *p;
 	struct ceph_dentry_info *di = ceph_dentry(dentry);
 	int force = 0;
* Unmerged path fs/ceph/debugfs.c
* Unmerged path fs/ceph/dir.c
diff --git a/fs/ceph/export.c b/fs/ceph/export.c
index 8d7d782f4382..fe02ae7f056a 100644
--- a/fs/ceph/export.c
+++ b/fs/ceph/export.c
@@ -136,8 +136,8 @@ static struct dentry *__get_parent(struct super_block *sb,
 		return ERR_CAST(req);
 
 	if (child) {
-		req->r_inode = child->d_inode;
-		ihold(child->d_inode);
+		req->r_inode = d_inode(child);
+		ihold(d_inode(child));
 	} else {
 		req->r_ino1 = (struct ceph_vino) {
 			.ino = ino,
@@ -164,7 +164,7 @@ static struct dentry *__get_parent(struct super_block *sb,
 		return ERR_PTR(err);
 	}
 	dout("__get_parent ino %llx parent %p ino %llx.%llx\n",
-	     child ? ceph_ino(child->d_inode) : ino,
+	     child ? ceph_ino(d_inode(child)) : ino,
 	     dentry, ceph_vinop(inode));
 	return dentry;
 }
@@ -172,11 +172,11 @@ static struct dentry *__get_parent(struct super_block *sb,
 static struct dentry *ceph_get_parent(struct dentry *child)
 {
 	/* don't re-export snaps */
-	if (ceph_snap(child->d_inode) != CEPH_NOSNAP)
+	if (ceph_snap(d_inode(child)) != CEPH_NOSNAP)
 		return ERR_PTR(-EINVAL);
 
 	dout("get_parent %p ino %llx.%llx\n",
-	     child, ceph_vinop(child->d_inode));
+	     child, ceph_vinop(d_inode(child)));
 	return __get_parent(child->d_sb, child, 0);
 }
 
@@ -209,32 +209,32 @@ static int ceph_get_name(struct dentry *parent, char *name,
 	struct ceph_mds_request *req;
 	int err;
 
-	mdsc = ceph_inode_to_client(child->d_inode)->mdsc;
+	mdsc = ceph_inode_to_client(d_inode(child))->mdsc;
 	req = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPNAME,
 				       USE_ANY_MDS);
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	mutex_lock(&parent->d_inode->i_mutex);
+	mutex_lock(&d_inode(parent)->i_mutex);
 
-	req->r_inode = child->d_inode;
-	ihold(child->d_inode);
-	req->r_ino2 = ceph_vino(parent->d_inode);
-	req->r_locked_dir = parent->d_inode;
+	req->r_inode = d_inode(child);
+	ihold(d_inode(child));
+	req->r_ino2 = ceph_vino(d_inode(parent));
+	req->r_locked_dir = d_inode(parent);
 	req->r_num_caps = 2;
 	err = ceph_mdsc_do_request(mdsc, NULL, req);
 
-	mutex_unlock(&parent->d_inode->i_mutex);
+	mutex_unlock(&d_inode(parent)->i_mutex);
 
 	if (!err) {
 		struct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;
 		memcpy(name, rinfo->dname, rinfo->dname_len);
 		name[rinfo->dname_len] = 0;
 		dout("get_name %p ino %llx.%llx name %s\n",
-		     child, ceph_vinop(child->d_inode), name);
+		     child, ceph_vinop(d_inode(child)), name);
 	} else {
 		dout("get_name %p ino %llx.%llx err %d\n",
-		     child, ceph_vinop(child->d_inode), err);
+		     child, ceph_vinop(d_inode(child)), err);
 	}
 
 	ceph_mdsc_put_request(req);
* Unmerged path fs/ceph/file.c
diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c
index a649a586cda7..fc0d6320e55d 100644
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@ -927,7 +927,7 @@ static void update_dentry_lease(struct dentry *dentry,
 	     dentry, duration, ttl);
 
 	/* make lease_rdcache_gen match directory */
-	dir = dentry->d_parent->d_inode;
+	dir = d_inode(dentry->d_parent);
 	di->lease_shared_gen = ceph_inode(dir)->i_shared_gen;
 
 	if (duration == 0)
@@ -967,7 +967,7 @@ static struct dentry *splice_dentry(struct dentry *dn, struct inode *in,
 {
 	struct dentry *realdn;
 
-	BUG_ON(dn->d_inode);
+	BUG_ON(d_inode(dn));
 
 	/* dn must be unhashed */
 	if (!d_unhashed(dn))
@@ -985,13 +985,13 @@ static struct dentry *splice_dentry(struct dentry *dn, struct inode *in,
 		     "inode %p ino %llx.%llx\n",
 		     dn, d_count(dn),
 		     realdn, d_count(realdn),
-		     realdn->d_inode, ceph_vinop(realdn->d_inode));
+		     d_inode(realdn), ceph_vinop(d_inode(realdn)));
 		dput(dn);
 		dn = realdn;
 	} else {
 		BUG_ON(!ceph_dentry(dn));
 		dout("dn %p attached to %p ino %llx.%llx\n",
-		     dn, dn->d_inode, ceph_vinop(dn->d_inode));
+		     dn, d_inode(dn), ceph_vinop(d_inode(dn)));
 	}
 	if ((!prehash || *prehash) && d_unhashed(dn))
 		d_rehash(dn);
@@ -1112,11 +1112,11 @@ retry_lookup:
 					dput(parent);
 					goto done;
 				}
-			} else if (dn->d_inode &&
-				   (ceph_ino(dn->d_inode) != vino.ino ||
-				    ceph_snap(dn->d_inode) != vino.snap)) {
+			} else if (d_really_is_positive(dn) &&
+				   (ceph_ino(d_inode(dn)) != vino.ino ||
+				    ceph_snap(d_inode(dn)) != vino.snap)) {
 				dout(" dn %p points to wrong inode %p\n",
-				     dn, dn->d_inode);
+				     dn, d_inode(dn));
 				d_delete(dn);
 				dput(dn);
 				goto retry_lookup;
@@ -1170,7 +1170,7 @@ retry_lookup:
 
 		BUG_ON(!dn);
 		BUG_ON(!dir);
-		BUG_ON(dn->d_parent->d_inode != dir);
+		BUG_ON(d_inode(dn->d_parent) != dir);
 		BUG_ON(ceph_ino(dir) !=
 		       le64_to_cpu(rinfo->diri.in->ino));
 		BUG_ON(ceph_snap(dir) !=
@@ -1224,7 +1224,7 @@ retry_lookup:
 		/* null dentry? */
 		if (!rinfo->head->is_target) {
 			dout("fill_trace null dentry\n");
-			if (dn->d_inode) {
+			if (d_really_is_positive(dn)) {
 				ceph_dir_clear_ordered(dir);
 				dout("d_delete %p\n", dn);
 				d_delete(dn);
@@ -1241,7 +1241,7 @@ retry_lookup:
 		}
 
 		/* attach proper inode */
-		if (!dn->d_inode) {
+		if (d_really_is_negative(dn)) {
 			ceph_dir_clear_ordered(dir);
 			ihold(in);
 			dn = splice_dentry(dn, in, &have_lease);
@@ -1250,9 +1250,9 @@ retry_lookup:
 				goto done;
 			}
 			req->r_dentry = dn;  /* may have spliced */
-		} else if (dn->d_inode && dn->d_inode != in) {
+		} else if (d_really_is_positive(dn) && d_inode(dn) != in) {
 			dout(" %p links to %p %llx.%llx, not %llx.%llx\n",
-			     dn, dn->d_inode, ceph_vinop(dn->d_inode),
+			     dn, d_inode(dn), ceph_vinop(d_inode(dn)),
 			     ceph_vinop(in));
 			have_lease = false;
 		}
@@ -1352,7 +1352,7 @@ int ceph_readdir_prepopulate(struct ceph_mds_request *req,
 		return readdir_prepopulate_inodes_only(req, session);
 
 	if (le32_to_cpu(rinfo->head->op) == CEPH_MDS_OP_LSSNAP) {
-		snapdir = ceph_get_snapdir(parent->d_inode);
+		snapdir = ceph_get_snapdir(d_inode(parent));
 		parent = d_find_alias(snapdir);
 		dout("readdir_prepopulate %d items under SNAPDIR dn %p\n",
 		     rinfo->dir_nr, parent);
@@ -1360,7 +1360,7 @@ int ceph_readdir_prepopulate(struct ceph_mds_request *req,
 		dout("readdir_prepopulate %d items under dn %p\n",
 		     rinfo->dir_nr, parent);
 		if (rinfo->dir_dir)
-			ceph_fill_dirfrag(parent->d_inode, rinfo->dir_dir);
+			ceph_fill_dirfrag(d_inode(parent), rinfo->dir_dir);
 	}
 
 	/* FIXME: release caps/leases if error occurs */
@@ -1394,11 +1394,11 @@ retry_lookup:
 				err = ret;
 				goto out;
 			}
-		} else if (dn->d_inode &&
-			   (ceph_ino(dn->d_inode) != vino.ino ||
-			    ceph_snap(dn->d_inode) != vino.snap)) {
+		} else if (d_really_is_positive(dn) &&
+			   (ceph_ino(d_inode(dn)) != vino.ino ||
+			    ceph_snap(d_inode(dn)) != vino.snap)) {
 			dout(" dn %p points to wrong inode %p\n",
-			     dn, dn->d_inode);
+			     dn, d_inode(dn));
 			d_delete(dn);
 			dput(dn);
 			goto retry_lookup;
@@ -1412,8 +1412,8 @@ retry_lookup:
 		}
 
 		/* inode */
-		if (dn->d_inode) {
-			in = dn->d_inode;
+		if (d_really_is_positive(dn)) {
+			in = d_inode(dn);
 		} else {
 			in = ceph_get_inode(parent->d_sb, vino);
 			if (IS_ERR(in)) {
@@ -1429,13 +1429,13 @@ retry_lookup:
 			       req->r_request_started, -1,
 			       &req->r_caps_reservation) < 0) {
 			pr_err("fill_inode badness on %p\n", in);
-			if (!dn->d_inode)
+			if (d_really_is_negative(dn))
 				iput(in);
 			d_drop(dn);
 			goto next_item;
 		}
 
-		if (!dn->d_inode) {
+		if (d_really_is_negative(dn)) {
 			struct dentry *realdn = splice_dentry(dn, in, NULL);
 			if (IS_ERR(realdn)) {
 				err = PTR_ERR(realdn);
@@ -1682,7 +1682,7 @@ retry:
  */
 static void *ceph_sym_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ceph_inode_info *ci = ceph_inode(dentry->d_inode);
+	struct ceph_inode_info *ci = ceph_inode(d_inode(dentry));
 	nd_set_link(nd, ci->i_symlink);
 	return NULL;
 }
@@ -1703,7 +1703,7 @@ static const struct inode_operations ceph_symlink_iops = {
  */
 int ceph_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	const unsigned int ia_valid = attr->ia_valid;
 	struct ceph_mds_request *req;
@@ -1984,7 +1984,7 @@ int ceph_permission(struct inode *inode, int mask)
 int ceph_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		 struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	int err;
 
diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c
index ed1203ecdcf6..0cb3791005d9 100644
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@ -693,7 +693,7 @@ static struct dentry *get_nonsnap_parent(struct dentry *dentry)
 	 * except to resplice to another snapdir, and either the old or new
 	 * result is a valid result.
 	 */
-	while (!IS_ROOT(dentry) && ceph_snap(dentry->d_inode) != CEPH_NOSNAP)
+	while (!IS_ROOT(dentry) && ceph_snap(d_inode(dentry)) != CEPH_NOSNAP)
 		dentry = dentry->d_parent;
 	return dentry;
 }
@@ -730,20 +730,20 @@ static int __choose_mds(struct ceph_mds_client *mdsc,
 	} else if (req->r_dentry) {
 		/* ignore race with rename; old or new d_parent is okay */
 		struct dentry *parent = req->r_dentry->d_parent;
-		struct inode *dir = parent->d_inode;
+		struct inode *dir = d_inode(parent);
 
 		if (dir->i_sb != mdsc->fsc->sb) {
 			/* not this fs! */
-			inode = req->r_dentry->d_inode;
+			inode = d_inode(req->r_dentry);
 		} else if (ceph_snap(dir) != CEPH_NOSNAP) {
 			/* direct snapped/virtual snapdir requests
 			 * based on parent dir inode */
 			struct dentry *dn = get_nonsnap_parent(parent);
-			inode = dn->d_inode;
+			inode = d_inode(dn);
 			dout("__choose_mds using nonsnap parent %p\n", inode);
 		} else {
 			/* dentry target */
-			inode = req->r_dentry->d_inode;
+			inode = d_inode(req->r_dentry);
 			if (!inode || mode == USE_AUTH_MDS) {
 				/* dir + name */
 				inode = dir;
@@ -1753,7 +1753,7 @@ retry:
 	seq = read_seqbegin(&rename_lock);
 	rcu_read_lock();
 	for (temp = dentry; !IS_ROOT(temp);) {
-		struct inode *inode = temp->d_inode;
+		struct inode *inode = d_inode(temp);
 		if (inode && ceph_snap(inode) == CEPH_SNAPDIR)
 			len++;  /* slash only */
 		else if (stop_on_nosnap && inode &&
@@ -1777,7 +1777,7 @@ retry:
 		struct inode *inode;
 
 		spin_lock(&temp->d_lock);
-		inode = temp->d_inode;
+		inode = d_inode(temp);
 		if (inode && ceph_snap(inode) == CEPH_SNAPDIR) {
 			dout("build_path path+%d: %p SNAPDIR\n",
 			     pos, temp);
@@ -1811,7 +1811,7 @@ retry:
 		goto retry;
 	}
 
-	*base = ceph_ino(temp->d_inode);
+	*base = ceph_ino(d_inode(temp));
 	*plen = len;
 	dout("build_path on %p %d built %llx '%.*s'\n",
 	     dentry, d_count(dentry), *base, len, path);
@@ -1824,8 +1824,8 @@ static int build_dentry_path(struct dentry *dentry,
 {
 	char *path;
 
-	if (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP) {
-		*pino = ceph_ino(dentry->d_parent->d_inode);
+	if (ceph_snap(d_inode(dentry->d_parent)) == CEPH_NOSNAP) {
+		*pino = ceph_ino(d_inode(dentry->d_parent));
 		*ppath = dentry->d_name.name;
 		*ppathlen = dentry->d_name.len;
 		return 0;
@@ -1966,7 +1966,7 @@ static struct ceph_msg *create_request_message(struct ceph_mds_client *mdsc,
 	releases = 0;
 	if (req->r_inode_drop)
 		releases += ceph_encode_inode_release(&p,
-		      req->r_inode ? req->r_inode : req->r_dentry->d_inode,
+		      req->r_inode ? req->r_inode : d_inode(req->r_dentry),
 		      mds, req->r_inode_drop, req->r_inode_unless, 0);
 	if (req->r_dentry_drop)
 		releases += ceph_encode_dentry_release(&p, req->r_dentry,
@@ -1976,7 +1976,7 @@ static struct ceph_msg *create_request_message(struct ceph_mds_client *mdsc,
 		       mds, req->r_old_dentry_drop, req->r_old_dentry_unless);
 	if (req->r_old_inode_drop)
 		releases += ceph_encode_inode_release(&p,
-		      req->r_old_dentry->d_inode,
+		      d_inode(req->r_old_dentry),
 		      mds, req->r_old_inode_drop, req->r_old_inode_unless, 0);
 
 	if (drop_cap_releases) {
diff --git a/fs/ceph/super.c b/fs/ceph/super.c
index 9acdf48b8d6b..fe04b64364ef 100644
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@ -54,7 +54,7 @@ static void ceph_put_super(struct super_block *s)
 
 static int ceph_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
-	struct ceph_fs_client *fsc = ceph_inode_to_client(dentry->d_inode);
+	struct ceph_fs_client *fsc = ceph_inode_to_client(d_inode(dentry));
 	struct ceph_monmap *monmap = fsc->client->monc.monmap;
 	struct ceph_statfs st;
 	u64 fsid;
@@ -927,7 +927,7 @@ static struct dentry *ceph_mount(struct file_system_type *fs_type,
 	if (IS_ERR(res))
 		goto out_splat;
 	dout("root %p inode %p ino %llx.%llx\n", res,
-	     res->d_inode, ceph_vinop(res->d_inode));
+	     d_inode(res), ceph_vinop(d_inode(res)));
 	return res;
 
 out_splat:
* Unmerged path fs/ceph/xattr.c
diff --git a/fs/cifs/cifs_dfs_ref.c b/fs/cifs/cifs_dfs_ref.c
index b8602f199815..430e0348c99e 100644
--- a/fs/cifs/cifs_dfs_ref.c
+++ b/fs/cifs/cifs_dfs_ref.c
@@ -301,7 +301,7 @@ static struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)
 	if (full_path == NULL)
 		goto cdda_exit;
 
-	cifs_sb = CIFS_SB(mntpt->d_inode->i_sb);
+	cifs_sb = CIFS_SB(d_inode(mntpt)->i_sb);
 	tlink = cifs_sb_tlink(cifs_sb);
 	if (IS_ERR(tlink)) {
 		mnt = ERR_CAST(tlink);
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 94c2329f6f2c..0ab9991ceafd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -606,7 +606,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	p = s = full_path;
 
 	do {
-		struct inode *dir = dentry->d_inode;
+		struct inode *dir = d_inode(dentry);
 		struct dentry *child;
 
 		if (!dir) {
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index fa13d5e79f64..84650a51c7c4 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -1898,7 +1898,7 @@ static void
 cifs_writev_requeue(struct cifs_writedata *wdata)
 {
 	int i, rc = 0;
-	struct inode *inode = wdata->cfile->dentry->d_inode;
+	struct inode *inode = d_inode(wdata->cfile->dentry);
 	struct TCP_Server_Info *server;
 	unsigned int rest_len;
 
@@ -1981,7 +1981,7 @@ cifs_writev_complete(struct work_struct *work)
 {
 	struct cifs_writedata *wdata = container_of(work,
 						struct cifs_writedata, work);
-	struct inode *inode = wdata->cfile->dentry->d_inode;
+	struct inode *inode = d_inode(wdata->cfile->dentry);
 	int i = 0;
 
 	if (wdata->result == 0) {
diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c
index b72bc29cba23..338d56936f6a 100644
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -745,13 +745,13 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
 		goto lookup_out;
 	}
 
-	if (direntry->d_inode != NULL) {
+	if (d_really_is_positive(direntry)) {
 		cifs_dbg(FYI, "non-NULL inode in lookup\n");
 	} else {
 		cifs_dbg(FYI, "NULL inode in lookup\n");
 	}
 	cifs_dbg(FYI, "Full path: %s inode = 0x%p\n",
-		 full_path, direntry->d_inode);
+		 full_path, d_inode(direntry));
 
 	if (pTcon->unix_ext) {
 		rc = cifs_get_inode_info_unix(&newInode, full_path,
@@ -792,7 +792,7 @@ cifs_d_revalidate(struct dentry *direntry, unsigned int flags)
 	if (flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	if (direntry->d_inode) {
+	if (d_really_is_positive(direntry)) {
 		if (cifs_revalidate_dentry(direntry))
 			return 0;
 		else {
@@ -803,7 +803,7 @@ cifs_d_revalidate(struct dentry *direntry, unsigned int flags)
 			 * attributes will have been updated by
 			 * cifs_revalidate_dentry().
 			 */
-			if (IS_AUTOMOUNT(direntry->d_inode) &&
+			if (IS_AUTOMOUNT(d_inode(direntry)) &&
 			   !(direntry->d_flags & DCACHE_NEED_AUTOMOUNT)) {
 				spin_lock(&direntry->d_lock);
 				direntry->d_flags |= DCACHE_NEED_AUTOMOUNT;
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index d8c52b4862c1..a07318008fc7 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -272,7 +272,7 @@ cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,
 		  struct tcon_link *tlink, __u32 oplock)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct cifsInodeInfo *cinode = CIFS_I(inode);
 	struct cifsFileInfo *cfile;
 	struct cifs_fid_locks *fdlocks;
@@ -356,7 +356,7 @@ cifsFileInfo_get(struct cifsFileInfo *cifs_file)
  */
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
-	struct inode *inode = cifs_file->dentry->d_inode;
+	struct inode *inode = d_inode(cifs_file->dentry);
 	struct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);
 	struct TCP_Server_Info *server = tcon->ses->server;
 	struct cifsInodeInfo *cifsi = CIFS_I(inode);
@@ -385,7 +385,7 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 
 	if (list_empty(&cifsi->openFileList)) {
 		cifs_dbg(FYI, "closing last open instance for inode %p\n",
-			 cifs_file->dentry->d_inode);
+			 d_inode(cifs_file->dentry));
 		/*
 		 * In strict cache mode we need invalidate mapping on the last
 		 * close  because it may cause a error when we open this file
@@ -571,7 +571,7 @@ static int
 cifs_relock_file(struct cifsFileInfo *cfile)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
 	int rc = 0;
 
@@ -619,7 +619,7 @@ cifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)
 		return rc;
 	}
 
-	inode = cfile->dentry->d_inode;
+	inode = d_inode(cfile->dentry);
 	cifs_sb = CIFS_SB(inode->i_sb);
 	tcon = tlink_tcon(cfile->tlink);
 	server = tcon->ses->server;
@@ -873,7 +873,7 @@ cifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,
 {
 	bool rc = false;
 	struct cifs_fid_locks *cur;
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 
 	list_for_each_entry(cur, &cinode->llist, llist) {
 		rc = cifs_find_fid_lock_conflict(cur, offset, length, type,
@@ -898,7 +898,7 @@ cifs_lock_test(struct cifsFileInfo *cfile, __u64 offset, __u64 length,
 {
 	int rc = 0;
 	struct cifsLockInfo *conf_lock;
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;
 	bool exist;
 
@@ -926,7 +926,7 @@ cifs_lock_test(struct cifsFileInfo *cfile, __u64 offset, __u64 length,
 static void
 cifs_lock_add(struct cifsFileInfo *cfile, struct cifsLockInfo *lock)
 {
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	down_write(&cinode->lock_sem);
 	list_add_tail(&lock->llist, &cfile->llist->locks);
 	up_write(&cinode->lock_sem);
@@ -943,7 +943,7 @@ cifs_lock_add_if(struct cifsFileInfo *cfile, struct cifsLockInfo *lock,
 		 bool wait)
 {
 	struct cifsLockInfo *conf_lock;
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	bool exist;
 	int rc = 0;
 
@@ -1129,7 +1129,7 @@ struct lock_to_push {
 static int
 cifs_push_posix_locks(struct cifsFileInfo *cfile)
 {
-	struct inode *inode = cfile->dentry->d_inode;
+	struct inode *inode = d_inode(cfile->dentry);
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
 	struct file_lock *flock, **before;
 	unsigned int count = 0, i = 0;
@@ -1219,7 +1219,7 @@ static int
 cifs_push_locks(struct cifsFileInfo *cfile)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
 	int rc = 0;
 
@@ -1387,7 +1387,7 @@ cifs_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 	unsigned int max_num, num, max_buf;
 	LOCKING_ANDX_RANGE *buf, *cur;
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct cifsLockInfo *li, *tmp;
 	__u64 length = 1 + flock->fl_end - flock->fl_start;
 	struct list_head tmp_llist;
@@ -1493,7 +1493,7 @@ cifs_setlk(struct file *file, struct file_lock *flock, __u32 type,
 	struct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
 	struct TCP_Server_Info *server = tcon->ses->server;
-	struct inode *inode = cfile->dentry->d_inode;
+	struct inode *inode = d_inode(cfile->dentry);
 
 	if (posix_lck) {
 		int posix_lock_type;
@@ -1648,7 +1648,7 @@ cifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,
 	struct TCP_Server_Info *server;
 	unsigned int xid;
 	struct dentry *dentry = open_file->dentry;
-	struct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);
+	struct cifsInodeInfo *cifsi = CIFS_I(d_inode(dentry));
 	struct cifs_io_parms io_parms;
 
 	cifs_sb = CIFS_SB(dentry->d_sb);
@@ -1681,7 +1681,7 @@ cifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,
 					break;
 			}
 
-			len = min(server->ops->wp_retry_size(dentry->d_inode),
+			len = min(server->ops->wp_retry_size(d_inode(dentry)),
 				  (unsigned int)write_size - total_written);
 			/* iov[0] is reserved for smb header */
 			iov[1].iov_base = (char *)write_data + total_written;
@@ -1701,9 +1701,9 @@ cifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,
 				return rc;
 			}
 		} else {
-			spin_lock(&dentry->d_inode->i_lock);
+			spin_lock(&d_inode(dentry)->i_lock);
 			cifs_update_eof(cifsi, *offset, bytes_written);
-			spin_unlock(&dentry->d_inode->i_lock);
+			spin_unlock(&d_inode(dentry)->i_lock);
 			*offset += bytes_written;
 		}
 	}
@@ -1711,12 +1711,12 @@ cifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,
 	cifs_stats_bytes_written(tcon, total_written);
 
 	if (total_written > 0) {
-		spin_lock(&dentry->d_inode->i_lock);
-		if (*offset > dentry->d_inode->i_size)
-			i_size_write(dentry->d_inode, *offset);
-		spin_unlock(&dentry->d_inode->i_lock);
+		spin_lock(&d_inode(dentry)->i_lock);
+		if (*offset > d_inode(dentry)->i_size)
+			i_size_write(d_inode(dentry), *offset);
+		spin_unlock(&d_inode(dentry)->i_lock);
 	}
-	mark_inode_dirty_sync(dentry->d_inode);
+	mark_inode_dirty_sync(d_inode(dentry));
 	free_xid(xid);
 	return total_written;
 }
@@ -2411,7 +2411,7 @@ cifs_uncached_writev_complete(struct work_struct *work)
 {
 	struct cifs_writedata *wdata = container_of(work,
 					struct cifs_writedata, work);
-	struct inode *inode = wdata->cfile->dentry->d_inode;
+	struct inode *inode = d_inode(wdata->cfile->dentry);
 	struct cifsInodeInfo *cifsi = CIFS_I(inode);
 
 	spin_lock(&inode->i_lock);
@@ -3845,7 +3845,7 @@ void cifs_oplock_break(struct work_struct *work)
 {
 	struct cifsFileInfo *cfile = container_of(work, struct cifsFileInfo,
 						  oplock_break);
-	struct inode *inode = cfile->dentry->d_inode;
+	struct inode *inode = d_inode(cfile->dentry);
 	struct cifsInodeInfo *cinode = CIFS_I(inode);
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
 	struct TCP_Server_Info *server = tcon->ses->server;
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index 5e1a25971732..4326b3534432 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -1068,7 +1068,7 @@ cifs_rename_pending_delete(const char *full_path, struct dentry *dentry,
 	int rc;
 	struct cifs_fid fid;
 	struct cifs_open_parms oparms;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct cifsInodeInfo *cifsInode = CIFS_I(inode);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct tcon_link *tlink;
@@ -1197,7 +1197,7 @@ cifs_drop_nlink(struct inode *inode)
 }
 
 /*
- * If dentry->d_inode is null (usually meaning the cached dentry
+ * If d_inode(dentry) is null (usually meaning the cached dentry
  * is a negative dentry) then we would attempt a standard SMB delete, but
  * if that fails we can not attempt the fall back mechanisms on EACCESS
  * but will return the EACCESS to the caller. Note that the VFS does not call
@@ -1208,7 +1208,7 @@ int cifs_unlink(struct inode *dir, struct dentry *dentry)
 	int rc = 0;
 	unsigned int xid;
 	char *full_path = NULL;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct cifsInodeInfo *cifs_inode;
 	struct super_block *sb = dir->i_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
@@ -1552,13 +1552,13 @@ int cifs_rmdir(struct inode *inode, struct dentry *direntry)
 	cifs_put_tlink(tlink);
 
 	if (!rc) {
-		spin_lock(&direntry->d_inode->i_lock);
-		i_size_write(direntry->d_inode, 0);
-		clear_nlink(direntry->d_inode);
-		spin_unlock(&direntry->d_inode->i_lock);
+		spin_lock(&d_inode(direntry)->i_lock);
+		i_size_write(d_inode(direntry), 0);
+		clear_nlink(d_inode(direntry));
+		spin_unlock(&d_inode(direntry)->i_lock);
 	}
 
-	cifsInode = CIFS_I(direntry->d_inode);
+	cifsInode = CIFS_I(d_inode(direntry));
 	/* force revalidate to go get info when needed */
 	cifsInode->time = 0;
 
@@ -1569,7 +1569,7 @@ int cifs_rmdir(struct inode *inode, struct dentry *direntry)
 	 */
 	cifsInode->time = 0;
 
-	direntry->d_inode->i_ctime = inode->i_ctime = inode->i_mtime =
+	d_inode(direntry)->i_ctime = inode->i_ctime = inode->i_mtime =
 		current_fs_time(inode->i_sb);
 
 rmdir_exit:
@@ -1728,7 +1728,7 @@ cifs_rename2(struct inode *source_dir, struct dentry *source_dentry,
 
 unlink_target:
 	/* Try unlinking the target dentry if it's not negative */
-	if (target_dentry->d_inode && (rc == -EACCES || rc == -EEXIST)) {
+	if (d_really_is_positive(target_dentry) && (rc == -EACCES || rc == -EEXIST)) {
 		if (d_is_dir(target_dentry))
 			tmprc = cifs_rmdir(target_dir, target_dentry);
 		else
@@ -1868,7 +1868,7 @@ int cifs_revalidate_dentry_attr(struct dentry *dentry)
 {
 	unsigned int xid;
 	int rc = 0;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = dentry->d_sb;
 	char *full_path = NULL;
 
@@ -1920,7 +1920,7 @@ int cifs_revalidate_file(struct file *filp)
 int cifs_revalidate_dentry(struct dentry *dentry)
 {
 	int rc;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	rc = cifs_revalidate_dentry_attr(dentry);
 	if (rc)
@@ -1934,7 +1934,7 @@ int cifs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int rc;
 
 	/*
@@ -2111,7 +2111,7 @@ cifs_setattr_unix(struct dentry *direntry, struct iattr *attrs)
 	int rc;
 	unsigned int xid;
 	char *full_path = NULL;
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	struct cifsInodeInfo *cifsInode = CIFS_I(inode);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct tcon_link *tlink;
@@ -2252,7 +2252,7 @@ cifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)
 	unsigned int xid;
 	kuid_t uid = INVALID_UID;
 	kgid_t gid = INVALID_GID;
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifsInodeInfo *cifsInode = CIFS_I(inode);
 	char *full_path = NULL;
@@ -2410,7 +2410,7 @@ cifs_setattr_exit:
 int
 cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 {
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifs_tcon *pTcon = cifs_sb_master_tcon(cifs_sb);
 
diff --git a/fs/cifs/link.c b/fs/cifs/link.c
index 2ec6037f61c7..252e672d5604 100644
--- a/fs/cifs/link.c
+++ b/fs/cifs/link.c
@@ -586,12 +586,12 @@ cifs_hardlink(struct dentry *old_file, struct inode *inode,
 	 * if source file is cached (oplocked) revalidate will not go to server
 	 * until the file is closed or oplock broken so update nlinks locally
 	 */
-	if (old_file->d_inode) {
-		cifsInode = CIFS_I(old_file->d_inode);
+	if (d_really_is_positive(old_file)) {
+		cifsInode = CIFS_I(d_inode(old_file));
 		if (rc == 0) {
-			spin_lock(&old_file->d_inode->i_lock);
-			inc_nlink(old_file->d_inode);
-			spin_unlock(&old_file->d_inode->i_lock);
+			spin_lock(&d_inode(old_file)->i_lock);
+			inc_nlink(d_inode(old_file));
+			spin_unlock(&d_inode(old_file)->i_lock);
 
 			/*
 			 * parent dir timestamps will update from srv within a
@@ -629,7 +629,7 @@ cifs_hl_exit:
 void *
 cifs_follow_link(struct dentry *direntry, struct nameidata *nd)
 {
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	int rc = -ENOMEM;
 	unsigned int xid;
 	char *full_path = NULL;
diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c
index 92ea2f3dfb9b..f2a59e93463a 100644
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@ -473,7 +473,7 @@ is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)
 					continue;
 
 				cifs_dbg(FYI, "file id match, oplock break\n");
-				pCifsInode = CIFS_I(netfile->dentry->d_inode);
+				pCifsInode = CIFS_I(d_inode(netfile->dentry));
 
 				set_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,
 					&pCifsInode->flags);
* Unmerged path fs/cifs/readdir.c
diff --git a/fs/cifs/smb1ops.c b/fs/cifs/smb1ops.c
index d2979036a4c7..7bfdd6066276 100644
--- a/fs/cifs/smb1ops.c
+++ b/fs/cifs/smb1ops.c
@@ -722,7 +722,7 @@ cifs_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 static void
 cifs_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)
 {
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	cfile->fid.netfid = fid->netfid;
 	cifs_set_oplock_level(cinode, oplock);
 	cinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);
diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 7198eac5dddd..2ab297dae5a7 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -95,7 +95,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 	unsigned int max_num, num = 0, max_buf;
 	struct smb2_lock_element *buf, *cur;
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct cifsLockInfo *li, *tmp;
 	__u64 length = 1 + flock->fl_end - flock->fl_start;
 	struct list_head tmp_llist;
@@ -231,7 +231,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	unsigned int xid;
 	unsigned int max_num, max_buf;
 	struct smb2_lock_element *buf;
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct cifs_fid_locks *fdlocks;
 
 	xid = get_xid();
diff --git a/fs/cifs/smb2misc.c b/fs/cifs/smb2misc.c
index 689f035915cf..11c22148e94b 100644
--- a/fs/cifs/smb2misc.c
+++ b/fs/cifs/smb2misc.c
@@ -453,7 +453,7 @@ smb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp,
 
 	list_for_each(tmp, &tcon->openFileList) {
 		cfile = list_entry(tmp, struct cifsFileInfo, tlist);
-		cinode = CIFS_I(cfile->dentry->d_inode);
+		cinode = CIFS_I(d_inode(cfile->dentry));
 
 		if (memcmp(cinode->lease_key, rsp->LeaseKey,
 							SMB2_LEASE_KEY_SIZE))
@@ -590,7 +590,7 @@ smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)
 					continue;
 
 				cifs_dbg(FYI, "file id match, oplock break\n");
-				cinode = CIFS_I(cfile->dentry->d_inode);
+				cinode = CIFS_I(d_inode(cfile->dentry));
 
 				if (!CIFS_CACHE_WRITE(cinode) &&
 				    rsp->OplockLevel == SMB2_OPLOCK_LEVEL_NONE)
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index eab05e1aa587..54daee5ad4c1 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -524,7 +524,7 @@ smb2_print_stats(struct seq_file *m, struct cifs_tcon *tcon)
 static void
 smb2_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)
 {
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;
 
 	cfile->fid.persistent_fid = fid->persistent_fid;
@@ -793,7 +793,7 @@ smb2_set_file_size(const unsigned int xid, struct cifs_tcon *tcon,
 	 * If extending file more than one page make sparse. Many Linux fs
 	 * make files sparse by default when extending via ftruncate
 	 */
-	inode = cfile->dentry->d_inode;
+	inode = d_inode(cfile->dentry);
 
 	if (!set_alloc && (size > inode->i_size + 8192)) {
 		__u8 set_sparse = 1;
@@ -1032,7 +1032,7 @@ static long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,
 
 	xid = get_xid();
 
-	inode = cfile->dentry->d_inode;
+	inode = d_inode(cfile->dentry);
 	cifsi = CIFS_I(inode);
 
 	/* if file not oplocked can't be sure whether asking to extend size */
@@ -1083,7 +1083,7 @@ static long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,
 
 	xid = get_xid();
 
-	inode = cfile->dentry->d_inode;
+	inode = d_inode(cfile->dentry);
 	cifsi = CIFS_I(inode);
 
 	/* Need to make file sparse, if not already, before freeing range. */
@@ -1115,7 +1115,7 @@ static long smb3_simple_falloc(struct file *file, struct cifs_tcon *tcon,
 
 	xid = get_xid();
 
-	inode = cfile->dentry->d_inode;
+	inode = d_inode(cfile->dentry);
 	cifsi = CIFS_I(inode);
 
 	/* if file not oplocked can't be sure whether asking to extend size */
diff --git a/fs/cifs/xattr.c b/fs/cifs/xattr.c
index 72a4d10653d6..ff9e1f8b16a4 100644
--- a/fs/cifs/xattr.c
+++ b/fs/cifs/xattr.c
@@ -50,9 +50,9 @@ int cifs_removexattr(struct dentry *direntry, const char *ea_name)
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
@@ -111,9 +111,9 @@ int cifs_setxattr(struct dentry *direntry, const char *ea_name,
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
@@ -177,12 +177,12 @@ int cifs_setxattr(struct dentry *direntry, const char *ea_name,
 			memcpy(pacl, ea_value, value_size);
 			if (pTcon->ses->server->ops->set_acl)
 				rc = pTcon->ses->server->ops->set_acl(pacl,
-						value_size, direntry->d_inode,
+						value_size, d_inode(direntry),
 						full_path, CIFS_ACL_DACL);
 			else
 				rc = -EOPNOTSUPP;
 			if (rc == 0) /* force revalidate of the inode */
-				CIFS_I(direntry->d_inode)->time = 0;
+				CIFS_I(d_inode(direntry))->time = 0;
 			kfree(pacl);
 		}
 #else
@@ -246,9 +246,9 @@ ssize_t cifs_getxattr(struct dentry *direntry, const char *ea_name,
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
@@ -324,7 +324,7 @@ ssize_t cifs_getxattr(struct dentry *direntry, const char *ea_name,
 				goto get_ea_exit; /* rc already EOPNOTSUPP */
 
 			pacl = pTcon->ses->server->ops->get_acl(cifs_sb,
-					direntry->d_inode, full_path, &acllen);
+					d_inode(direntry), full_path, &acllen);
 			if (IS_ERR(pacl)) {
 				rc = PTR_ERR(pacl);
 				cifs_dbg(VFS, "%s: error %zd getting sec desc\n",
@@ -382,9 +382,9 @@ ssize_t cifs_listxattr(struct dentry *direntry, char *data, size_t buf_size)
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
diff --git a/fs/coda/cache.c b/fs/coda/cache.c
index 1da168c61d35..727a9a4d539d 100644
--- a/fs/coda/cache.c
+++ b/fs/coda/cache.c
@@ -94,8 +94,8 @@ static void coda_flag_children(struct dentry *parent, int flag)
 	spin_lock(&parent->d_lock);
 	list_for_each_entry(de, &parent->d_subdirs, d_u.d_child) {
 		/* don't know what to do with negative dentries */
-		if (de->d_inode ) 
-			coda_flag_inode(de->d_inode, flag);
+		if (d_inode(de) ) 
+			coda_flag_inode(d_inode(de), flag);
 	}
 	spin_unlock(&parent->d_lock);
 	return; 
* Unmerged path fs/coda/dir.c
* Unmerged path fs/coda/inode.c
diff --git a/fs/coda/pioctl.c b/fs/coda/pioctl.c
index 3f5de96bbb58..483309c09388 100644
--- a/fs/coda/pioctl.c
+++ b/fs/coda/pioctl.c
@@ -72,7 +72,7 @@ static long coda_pioctl(struct file *filp, unsigned int cmd,
 	if (error)
 		return error;
 
-	target_inode = path.dentry->d_inode;
+	target_inode = d_inode(path.dentry);
 
 	/* return if it is not a Coda inode */
 	if (target_inode->i_sb != inode->i_sb) {
diff --git a/fs/coda/upcall.c b/fs/coda/upcall.c
index 3a731976dc5e..f523dfce7fbf 100644
--- a/fs/coda/upcall.c
+++ b/fs/coda/upcall.c
@@ -820,8 +820,8 @@ int coda_downcall(struct venus_comm *vcp, int opcode, union outputArgs *out)
 	case CODA_FLUSH:
 		coda_cache_clear_all(sb);
 		shrink_dcache_sb(sb);
-		if (sb->s_root->d_inode)
-			coda_flag_inode(sb->s_root->d_inode, C_FLUSH);
+		if (d_really_is_positive(sb->s_root))
+			coda_flag_inode(d_inode(sb->s_root), C_FLUSH);
 		break;
 
 	case CODA_PURGEUSER:
* Unmerged path fs/configfs/dir.c
* Unmerged path fs/configfs/file.c
* Unmerged path fs/configfs/inode.c
diff --git a/fs/debugfs/file.c b/fs/debugfs/file.c
index 42674b3dd39e..f268cdae9005 100644
--- a/fs/debugfs/file.c
+++ b/fs/debugfs/file.c
@@ -45,7 +45,7 @@ const struct file_operations debugfs_file_operations = {
 
 static void *debugfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	nd_set_link(nd, dentry->d_inode->i_private);
+	nd_set_link(nd, d_inode(dentry)->i_private);
 	return NULL;
 }
 
* Unmerged path fs/debugfs/inode.c
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index 61af24e379ad..fa5374870773 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -251,7 +251,7 @@ static int mknod_ptmx(struct super_block *sb)
 	if (!uid_valid(root_uid) || !gid_valid(root_gid))
 		return -EINVAL;
 
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 
 	/* If we have already created ptmx node, return */
 	if (fsi->ptmx_dentry) {
@@ -288,7 +288,7 @@ static int mknod_ptmx(struct super_block *sb)
 	fsi->ptmx_dentry = dentry;
 	rc = 0;
 out:
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 	return rc;
 }
 
@@ -296,7 +296,7 @@ static void update_ptmx_mode(struct pts_fs_info *fsi)
 {
 	struct inode *inode;
 	if (fsi->ptmx_dentry) {
-		inode = fsi->ptmx_dentry->d_inode;
+		inode = d_inode(fsi->ptmx_dentry);
 		inode->i_mode = S_IFCHR|fsi->mount_opts.ptmxmode;
 	}
 }
@@ -617,18 +617,18 @@ struct inode *devpts_pty_new(struct inode *ptmx_inode, dev_t device, int index,
 
 	sprintf(s, "%d", index);
 
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 
 	dentry = d_alloc_name(root, s);
 	if (dentry) {
 		d_add(dentry, inode);
-		fsnotify_create(root->d_inode, dentry);
+		fsnotify_create(d_inode(root), dentry);
 	} else {
 		iput(inode);
 		inode = ERR_PTR(-ENOMEM);
 	}
 
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 
 	return inode;
 }
@@ -673,7 +673,7 @@ void devpts_pty_kill(struct inode *inode)
 
 	BUG_ON(inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));
 
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 
 	dentry = d_find_alias(inode);
 
@@ -682,7 +682,7 @@ void devpts_pty_kill(struct inode *inode)
 	dput(dentry);	/* d_alloc_name() in devpts_pty_new() */
 	dput(dentry);		/* d_find_alias above */
 
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 }
 
 static int __init init_devpts_fs(void)
diff --git a/fs/ecryptfs/crypto.c b/fs/ecryptfs/crypto.c
index f71ec125290d..3fb8a2981f49 100644
--- a/fs/ecryptfs/crypto.c
+++ b/fs/ecryptfs/crypto.c
@@ -1511,7 +1511,7 @@ static int ecryptfs_read_headers_virt(char *page_virt,
 	if (rc)
 		goto out;
 	if (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))
-		ecryptfs_i_size_init(page_virt, ecryptfs_dentry->d_inode);
+		ecryptfs_i_size_init(page_virt, d_inode(ecryptfs_dentry));
 	offset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;
 	rc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),
 				    &bytes_read);
@@ -1610,7 +1610,7 @@ int ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)
 {
 	int rc;
 	char *page_virt;
-	struct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;
+	struct inode *ecryptfs_inode = d_inode(ecryptfs_dentry);
 	struct ecryptfs_crypt_stat *crypt_stat =
 	    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;
 	struct ecryptfs_mount_crypt_stat *mount_crypt_stat =
diff --git a/fs/ecryptfs/dentry.c b/fs/ecryptfs/dentry.c
index bf12ba5dd223..a7c30ce8836c 100644
--- a/fs/ecryptfs/dentry.c
+++ b/fs/ecryptfs/dentry.c
@@ -54,11 +54,11 @@ static int ecryptfs_d_revalidate(struct dentry *dentry, unsigned int flags)
 	if (!lower_dentry->d_op || !lower_dentry->d_op->d_revalidate)
 		goto out;
 	rc = lower_dentry->d_op->d_revalidate(lower_dentry, flags);
-	if (dentry->d_inode) {
+	if (d_really_is_positive(dentry)) {
 		struct inode *lower_inode =
-			ecryptfs_inode_to_lower(dentry->d_inode);
+			ecryptfs_inode_to_lower(d_inode(dentry));
 
-		fsstack_copy_attr_all(dentry->d_inode, lower_inode);
+		fsstack_copy_attr_all(d_inode(dentry), lower_inode);
 	}
 out:
 	return rc;
diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c
index a7abbea2c096..9c8639338d05 100644
--- a/fs/ecryptfs/file.c
+++ b/fs/ecryptfs/file.c
@@ -143,7 +143,7 @@ struct kmem_cache *ecryptfs_file_info_cache;
 
 static int read_or_initialize_metadata(struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ecryptfs_mount_crypt_stat *mount_crypt_stat;
 	struct ecryptfs_crypt_stat *crypt_stat;
 	int rc;
* Unmerged path fs/ecryptfs/inode.c
diff --git a/fs/ecryptfs/kthread.c b/fs/ecryptfs/kthread.c
index f1ea610362c6..866bb18efefe 100644
--- a/fs/ecryptfs/kthread.c
+++ b/fs/ecryptfs/kthread.c
@@ -144,7 +144,7 @@ int ecryptfs_privileged_open(struct file **lower_file,
 	/* Corresponding dput() and mntput() are done when the
 	 * lower file is fput() when all eCryptfs files for the inode are
 	 * released. */
-	flags |= IS_RDONLY(lower_dentry->d_inode) ? O_RDONLY : O_RDWR;
+	flags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;
 	(*lower_file) = dentry_open(&req.path, flags, cred);
 	if (!IS_ERR(*lower_file))
 		goto out;
diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c
index 8b0957e900e5..05cf3485d4ac 100644
--- a/fs/ecryptfs/main.c
+++ b/fs/ecryptfs/main.c
@@ -545,11 +545,11 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 		goto out_free;
 	}
 
-	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
+	if (check_ruid && !uid_eq(d_inode(path.dentry)->i_uid, current_uid())) {
 		rc = -EPERM;
 		printk(KERN_ERR "Mount of device (uid: %d) not owned by "
 		       "requested user (uid: %d)\n",
-			i_uid_read(path.dentry->d_inode),
+			i_uid_read(d_inode(path.dentry)),
 			from_kuid(&init_user_ns, current_uid()));
 		goto out_free;
 	}
@@ -575,7 +575,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 		goto out_free;
 	}
 
-	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
+	inode = ecryptfs_get_inode(d_inode(path.dentry), s);
 	rc = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_free;
* Unmerged path fs/ecryptfs/mmap.c
diff --git a/fs/efivarfs/inode.c b/fs/efivarfs/inode.c
index 7e787fb90293..22421a4abccc 100644
--- a/fs/efivarfs/inode.c
+++ b/fs/efivarfs/inode.c
@@ -145,12 +145,12 @@ out:
 
 static int efivarfs_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct efivar_entry *var = dentry->d_inode->i_private;
+	struct efivar_entry *var = d_inode(dentry)->i_private;
 
 	if (efivar_entry_delete(var))
 		return -EINVAL;
 
-	drop_nlink(dentry->d_inode);
+	drop_nlink(d_inode(dentry));
 	dput(dentry);
 	return 0;
 };
diff --git a/fs/efivarfs/super.c b/fs/efivarfs/super.c
index a8766b880c07..3e4ced314b8e 100644
--- a/fs/efivarfs/super.c
+++ b/fs/efivarfs/super.c
@@ -153,7 +153,7 @@ static int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,
 
 	name[len + EFI_VARIABLE_GUID_LEN+1] = '\0';
 
-	inode = efivarfs_get_inode(sb, root->d_inode, S_IFREG | 0644, 0);
+	inode = efivarfs_get_inode(sb, d_inode(root), S_IFREG | 0644, 0);
 	if (!inode)
 		goto fail_name;
 
diff --git a/fs/efs/namei.c b/fs/efs/namei.c
index 96f66d213a19..8399e1a1a2b6 100644
--- a/fs/efs/namei.c
+++ b/fs/efs/namei.c
@@ -108,9 +108,9 @@ struct dentry *efs_get_parent(struct dentry *child)
 	struct dentry *parent = ERR_PTR(-ENOENT);
 	efs_ino_t ino;
 
-	ino = efs_find_entry(child->d_inode, "..", 2);
+	ino = efs_find_entry(d_inode(child), "..", 2);
 	if (ino)
-		parent = d_obtain_alias(efs_iget(child->d_inode->i_sb, ino));
+		parent = d_obtain_alias(efs_iget(d_inode(child)->i_sb, ino));
 
 	return parent;
 }
diff --git a/fs/exofs/dir.c b/fs/exofs/dir.c
index 46375896cfc0..a2e797649697 100644
--- a/fs/exofs/dir.c
+++ b/fs/exofs/dir.c
@@ -385,7 +385,7 @@ ino_t exofs_parent_ino(struct dentry *child)
 	struct exofs_dir_entry *de;
 	ino_t ino;
 
-	de = exofs_dotdot(child->d_inode, &page);
+	de = exofs_dotdot(d_inode(child), &page);
 	if (!de)
 		return 0;
 
@@ -435,7 +435,7 @@ int exofs_set_link(struct inode *dir, struct exofs_dir_entry *de,
 
 int exofs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const unsigned char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	unsigned chunk_size = exofs_chunk_size(dir);
diff --git a/fs/exofs/inode.c b/fs/exofs/inode.c
index 3bc143b92bc8..cbdc95dfe67b 100644
--- a/fs/exofs/inode.c
+++ b/fs/exofs/inode.c
@@ -1019,7 +1019,7 @@ static int _do_truncate(struct inode *inode, loff_t newsize)
  */
 int exofs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	/* if we are about to modify an object, and it hasn't been
diff --git a/fs/exofs/namei.c b/fs/exofs/namei.c
index 4731fd991efe..db1824ce0414 100644
--- a/fs/exofs/namei.c
+++ b/fs/exofs/namei.c
@@ -141,7 +141,7 @@ out_fail:
 static int exofs_link(struct dentry *old_dentry, struct inode *dir,
 		struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	inode->i_ctime = CURRENT_TIME;
 	inode_inc_link_count(inode);
@@ -191,7 +191,7 @@ out_dir:
 
 static int exofs_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct exofs_dir_entry *de;
 	struct page *page;
 	int err = -ENOENT;
@@ -213,7 +213,7 @@ out:
 
 static int exofs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (exofs_empty_dir(inode)) {
@@ -230,8 +230,8 @@ static int exofs_rmdir(struct inode *dir, struct dentry *dentry)
 static int exofs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct page *dir_page = NULL;
 	struct exofs_dir_entry *dir_de = NULL;
 	struct page *old_page;
diff --git a/fs/exofs/super.c b/fs/exofs/super.c
index 9d9763328734..ffea60a24377 100644
--- a/fs/exofs/super.c
+++ b/fs/exofs/super.c
@@ -958,7 +958,7 @@ static struct dentry *exofs_get_parent(struct dentry *child)
 	if (!ino)
 		return ERR_PTR(-ESTALE);
 
-	return d_obtain_alias(exofs_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(exofs_iget(d_inode(child)->i_sb, ino));
 }
 
 static struct inode *exofs_nfs_get_inode(struct super_block *sb,
diff --git a/fs/exofs/symlink.c b/fs/exofs/symlink.c
index 4dd687c3e747..ee57166d55e0 100644
--- a/fs/exofs/symlink.c
+++ b/fs/exofs/symlink.c
@@ -37,7 +37,7 @@
 
 static void *exofs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct exofs_i_info *oi = exofs_i(dentry->d_inode);
+	struct exofs_i_info *oi = exofs_i(d_inode(dentry));
 
 	nd_set_link(nd, (char *)oi->i_data);
 	return NULL;
diff --git a/fs/ext2/dir.c b/fs/ext2/dir.c
index 4237722bfd27..15962cdbb582 100644
--- a/fs/ext2/dir.c
+++ b/fs/ext2/dir.c
@@ -489,7 +489,7 @@ void ext2_set_link(struct inode *dir, struct ext2_dir_entry_2 *de,
  */
 int ext2_add_link (struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	unsigned chunk_size = ext2_chunk_size(dir);
diff --git a/fs/ext2/ialloc.c b/fs/ext2/ialloc.c
index 7cadd823bb31..9261607db5ea 100644
--- a/fs/ext2/ialloc.c
+++ b/fs/ext2/ialloc.c
@@ -278,7 +278,7 @@ static int find_group_orlov(struct super_block *sb, struct inode *parent)
 	avefreeb = free_blocks / ngroups;
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
-	if ((parent == sb->s_root->d_inode) ||
+	if ((parent == d_inode(sb->s_root)) ||
 	    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {
 		struct ext2_group_desc *best_desc = NULL;
 		int best_ndir = inodes_per_group;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 115fa58bb9ae..24ed1fbde557 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -1542,7 +1542,7 @@ int ext2_write_inode(struct inode *inode, struct writeback_control *wbc)
 
 int ext2_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, iattr);
diff --git a/fs/ext2/namei.c b/fs/ext2/namei.c
index 73b0d9519836..c9ff8b0df729 100644
--- a/fs/ext2/namei.c
+++ b/fs/ext2/namei.c
@@ -80,10 +80,10 @@ static struct dentry *ext2_lookup(struct inode * dir, struct dentry *dentry, uns
 struct dentry *ext2_get_parent(struct dentry *child)
 {
 	struct qstr dotdot = QSTR_INIT("..", 2);
-	unsigned long ino = ext2_inode_by_name(child->d_inode, &dotdot);
+	unsigned long ino = ext2_inode_by_name(d_inode(child), &dotdot);
 	if (!ino)
 		return ERR_PTR(-ENOENT);
-	return d_obtain_alias(ext2_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(ext2_iget(d_inode(child)->i_sb, ino));
 } 
 
 /*
@@ -192,7 +192,7 @@ out_fail:
 static int ext2_link (struct dentry * old_dentry, struct inode * dir,
 	struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int err;
 
 	dquot_initialize(dir);
@@ -259,7 +259,7 @@ out_dir:
 
 static int ext2_unlink(struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct ext2_dir_entry_2 * de;
 	struct page * page;
 	int err = -ENOENT;
@@ -283,7 +283,7 @@ out:
 
 static int ext2_rmdir (struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (ext2_empty_dir(inode)) {
@@ -300,8 +300,8 @@ static int ext2_rmdir (struct inode * dir, struct dentry *dentry)
 static int ext2_rename (struct inode * old_dir, struct dentry * old_dentry,
 	struct inode * new_dir,	struct dentry * new_dentry )
 {
-	struct inode * old_inode = old_dentry->d_inode;
-	struct inode * new_inode = new_dentry->d_inode;
+	struct inode * old_inode = d_inode(old_dentry);
+	struct inode * new_inode = d_inode(new_dentry);
 	struct page * dir_page = NULL;
 	struct ext2_dir_entry_2 * dir_de = NULL;
 	struct page * old_page;
diff --git a/fs/ext2/symlink.c b/fs/ext2/symlink.c
index 565cf817bbf1..20608f17c2e5 100644
--- a/fs/ext2/symlink.c
+++ b/fs/ext2/symlink.c
@@ -23,7 +23,7 @@
 
 static void *ext2_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ext2_inode_info *ei = EXT2_I(dentry->d_inode);
+	struct ext2_inode_info *ei = EXT2_I(d_inode(dentry));
 	nd_set_link(nd, (char *)ei->i_data);
 	return NULL;
 }
diff --git a/fs/ext2/xattr.c b/fs/ext2/xattr.c
index 2d7557db3ae8..7c2b3816b1ac 100644
--- a/fs/ext2/xattr.c
+++ b/fs/ext2/xattr.c
@@ -243,7 +243,7 @@ cleanup:
 static int
 ext2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
 	struct ext2_xattr_entry *entry;
 	char *end;
@@ -319,7 +319,7 @@ cleanup:
 /*
  * Inode operation listxattr()
  *
- * dentry->d_inode->i_mutex: don't care
+ * d_inode(dentry)->i_mutex: don't care
  */
 ssize_t
 ext2_listxattr(struct dentry *dentry, char *buffer, size_t size)
diff --git a/fs/ext2/xattr_security.c b/fs/ext2/xattr_security.c
index cfedb2cb0d8c..235e5d44c797 100644
--- a/fs/ext2/xattr_security.c
+++ b/fs/ext2/xattr_security.c
@@ -28,7 +28,7 @@ ext2_xattr_security_get(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_get(dentry->d_inode, EXT2_XATTR_INDEX_SECURITY, name,
+	return ext2_xattr_get(d_inode(dentry), EXT2_XATTR_INDEX_SECURITY, name,
 			      buffer, size);
 }
 
@@ -38,7 +38,7 @@ ext2_xattr_security_set(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_set(dentry->d_inode, EXT2_XATTR_INDEX_SECURITY, name,
+	return ext2_xattr_set(d_inode(dentry), EXT2_XATTR_INDEX_SECURITY, name,
 			      value, size, flags);
 }
 
diff --git a/fs/ext2/xattr_trusted.c b/fs/ext2/xattr_trusted.c
index 7e192574c001..42b6e9874bcc 100644
--- a/fs/ext2/xattr_trusted.c
+++ b/fs/ext2/xattr_trusted.c
@@ -32,7 +32,7 @@ ext2_xattr_trusted_get(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_get(dentry->d_inode, EXT2_XATTR_INDEX_TRUSTED, name,
+	return ext2_xattr_get(d_inode(dentry), EXT2_XATTR_INDEX_TRUSTED, name,
 			      buffer, size);
 }
 
@@ -42,7 +42,7 @@ ext2_xattr_trusted_set(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_set(dentry->d_inode, EXT2_XATTR_INDEX_TRUSTED, name,
+	return ext2_xattr_set(d_inode(dentry), EXT2_XATTR_INDEX_TRUSTED, name,
 			      value, size, flags);
 }
 
diff --git a/fs/ext2/xattr_user.c b/fs/ext2/xattr_user.c
index f470e44c4b8d..ecdc4605192c 100644
--- a/fs/ext2/xattr_user.c
+++ b/fs/ext2/xattr_user.c
@@ -36,7 +36,7 @@ ext2_xattr_user_get(struct dentry *dentry, const char *name,
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext2_xattr_get(dentry->d_inode, EXT2_XATTR_INDEX_USER,
+	return ext2_xattr_get(d_inode(dentry), EXT2_XATTR_INDEX_USER,
 			      name, buffer, size);
 }
 
@@ -49,7 +49,7 @@ ext2_xattr_user_set(struct dentry *dentry, const char *name,
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
 
-	return ext2_xattr_set(dentry->d_inode, EXT2_XATTR_INDEX_USER,
+	return ext2_xattr_set(d_inode(dentry), EXT2_XATTR_INDEX_USER,
 			      name, value, size, flags);
 }
 
diff --git a/fs/ext3/ialloc.c b/fs/ext3/ialloc.c
index 082afd78b107..97d80f3da457 100644
--- a/fs/ext3/ialloc.c
+++ b/fs/ext3/ialloc.c
@@ -210,7 +210,7 @@ static int find_group_orlov(struct super_block *sb, struct inode *parent)
 	avefreeb = freeb / ngroups;
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
-	if ((parent == sb->s_root->d_inode) ||
+	if ((parent == d_inode(sb->s_root)) ||
 	    (EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {
 		int best_ndir = inodes_per_group;
 		int best_group = -1;
diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c
index 4a9deb6bb224..f7858cb904c7 100644
--- a/fs/ext3/inode.c
+++ b/fs/ext3/inode.c
@@ -3277,7 +3277,7 @@ int ext3_write_inode(struct inode *inode, struct writeback_control *wbc)
  */
 int ext3_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error, rc = 0;
 	const unsigned int ia_valid = attr->ia_valid;
 
diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index cea8ecf3e76e..f360a33b0a4c 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -1049,19 +1049,19 @@ struct dentry *ext3_get_parent(struct dentry *child)
 	struct ext3_dir_entry_2 * de;
 	struct buffer_head *bh;
 
-	bh = ext3_find_entry(child->d_inode, &dotdot, &de);
+	bh = ext3_find_entry(d_inode(child), &dotdot, &de);
 	if (!bh)
 		return ERR_PTR(-ENOENT);
 	ino = le32_to_cpu(de->inode);
 	brelse(bh);
 
-	if (!ext3_valid_inum(child->d_inode->i_sb, ino)) {
-		ext3_error(child->d_inode->i_sb, "ext3_get_parent",
+	if (!ext3_valid_inum(d_inode(child)->i_sb, ino)) {
+		ext3_error(d_inode(child)->i_sb, "ext3_get_parent",
 			   "bad inode number: %lu", ino);
 		return ERR_PTR(-EIO);
 	}
 
-	return d_obtain_alias(ext3_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(ext3_iget(d_inode(child)->i_sb, ino));
 }
 
 #define S_SHIFT 12
@@ -1243,7 +1243,7 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 			     struct inode *inode, struct ext3_dir_entry_2 *de,
 			     struct buffer_head * bh)
 {
-	struct inode	*dir = dentry->d_parent->d_inode;
+	struct inode	*dir = d_inode(dentry->d_parent);
 	const char	*name = dentry->d_name.name;
 	int		namelen = dentry->d_name.len;
 	unsigned long	offset = 0;
@@ -1330,7 +1330,7 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 			    struct inode *inode, struct buffer_head *bh)
 {
-	struct inode	*dir = dentry->d_parent->d_inode;
+	struct inode	*dir = d_inode(dentry->d_parent);
 	const char	*name = dentry->d_name.name;
 	int		namelen = dentry->d_name.len;
 	struct buffer_head *bh2;
@@ -1435,7 +1435,7 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 static int ext3_add_entry (handle_t *handle, struct dentry *dentry,
 	struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct buffer_head * bh;
 	struct ext3_dir_entry_2 *de;
 	struct super_block * sb;
@@ -1489,7 +1489,7 @@ static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	struct dx_entry *entries, *at;
 	struct dx_hash_info hinfo;
 	struct buffer_head * bh;
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct super_block * sb = dir->i_sb;
 	struct ext3_dir_entry_2 *de;
 	int err;
@@ -2073,7 +2073,7 @@ static int ext3_rmdir (struct inode * dir, struct dentry *dentry)
 	/* Initialize quotas before so that eventual writes go in
 	 * separate transaction */
 	dquot_initialize(dir);
-	dquot_initialize(dentry->d_inode);
+	dquot_initialize(d_inode(dentry));
 
 	handle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
@@ -2087,7 +2087,7 @@ static int ext3_rmdir (struct inode * dir, struct dentry *dentry)
 	if (IS_DIRSYNC(dir))
 		handle->h_sync = 1;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
@@ -2135,7 +2135,7 @@ static int ext3_unlink(struct inode * dir, struct dentry *dentry)
 	/* Initialize quotas before so that eventual writes go
 	 * in separate transaction */
 	dquot_initialize(dir);
-	dquot_initialize(dentry->d_inode);
+	dquot_initialize(d_inode(dentry));
 
 	handle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
@@ -2149,7 +2149,7 @@ static int ext3_unlink(struct inode * dir, struct dentry *dentry)
 	if (!bh)
 		goto end_unlink;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
@@ -2290,7 +2290,7 @@ static int ext3_link (struct dentry * old_dentry,
 		struct inode * dir, struct dentry *dentry)
 {
 	handle_t *handle;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int err, retries = 0;
 
 	if (inode->i_nlink >= EXT3_LINK_MAX)
@@ -2348,8 +2348,8 @@ static int ext3_rename (struct inode * old_dir, struct dentry *old_dentry,
 
 	/* Initialize quotas before so that eventual writes go
 	 * in separate transaction */
-	if (new_dentry->d_inode)
-		dquot_initialize(new_dentry->d_inode);
+	if (d_really_is_positive(new_dentry))
+		dquot_initialize(d_inode(new_dentry));
 	handle = ext3_journal_start(old_dir, 2 *
 					EXT3_DATA_TRANS_BLOCKS(old_dir->i_sb) +
 					EXT3_INDEX_EXTRA_TRANS_BLOCKS + 2);
@@ -2366,12 +2366,12 @@ static int ext3_rename (struct inode * old_dir, struct dentry *old_dentry,
 	 *  and merrily kill the link to whatever was created under the
 	 *  same name. Goodbye sticky bit ;-<
 	 */
-	old_inode = old_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
 	retval = -ENOENT;
 	if (!old_bh || le32_to_cpu(old_de->inode) != old_inode->i_ino)
 		goto end_rename;
 
-	new_inode = new_dentry->d_inode;
+	new_inode = d_inode(new_dentry);
 	new_bh = ext3_find_entry(new_dir, &new_dentry->d_name, &new_de);
 	if (new_bh) {
 		if (!new_inode) {
* Unmerged path fs/ext3/super.c
diff --git a/fs/ext3/symlink.c b/fs/ext3/symlink.c
index 6b01c3eab1f3..ea96df3c58db 100644
--- a/fs/ext3/symlink.c
+++ b/fs/ext3/symlink.c
@@ -23,7 +23,7 @@
 
 static void * ext3_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ext3_inode_info *ei = EXT3_I(dentry->d_inode);
+	struct ext3_inode_info *ei = EXT3_I(d_inode(dentry));
 	nd_set_link(nd, (char*)ei->i_data);
 	return NULL;
 }
diff --git a/fs/ext3/xattr.c b/fs/ext3/xattr.c
index b1fc96383e08..e3227c78fd85 100644
--- a/fs/ext3/xattr.c
+++ b/fs/ext3/xattr.c
@@ -137,7 +137,7 @@ ext3_xattr_handler(int name_index)
 /*
  * Inode operation listxattr()
  *
- * dentry->d_inode->i_mutex: don't care
+ * d_inode(dentry)->i_mutex: don't care
  */
 ssize_t
 ext3_listxattr(struct dentry *dentry, char *buffer, size_t size)
@@ -355,7 +355,7 @@ ext3_xattr_list_entries(struct dentry *dentry, struct ext3_xattr_entry *entry,
 static int
 ext3_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
 	int error;
 
@@ -391,7 +391,7 @@ cleanup:
 static int
 ext3_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ext3_xattr_ibody_header *header;
 	struct ext3_inode *raw_inode;
 	struct ext3_iloc iloc;
@@ -432,7 +432,7 @@ ext3_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
 	int i_error, b_error;
 
-	down_read(&EXT3_I(dentry->d_inode)->xattr_sem);
+	down_read(&EXT3_I(d_inode(dentry))->xattr_sem);
 	i_error = ext3_xattr_ibody_list(dentry, buffer, buffer_size);
 	if (i_error < 0) {
 		b_error = 0;
@@ -445,7 +445,7 @@ ext3_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 		if (b_error < 0)
 			i_error = 0;
 	}
-	up_read(&EXT3_I(dentry->d_inode)->xattr_sem);
+	up_read(&EXT3_I(d_inode(dentry))->xattr_sem);
 	return i_error + b_error;
 }
 
diff --git a/fs/ext3/xattr_security.c b/fs/ext3/xattr_security.c
index 3387664ad70e..4ce873e8e41c 100644
--- a/fs/ext3/xattr_security.c
+++ b/fs/ext3/xattr_security.c
@@ -29,7 +29,7 @@ ext3_xattr_security_get(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_get(dentry->d_inode, EXT3_XATTR_INDEX_SECURITY,
+	return ext3_xattr_get(d_inode(dentry), EXT3_XATTR_INDEX_SECURITY,
 			      name, buffer, size);
 }
 
@@ -39,7 +39,7 @@ ext3_xattr_security_set(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_set(dentry->d_inode, EXT3_XATTR_INDEX_SECURITY,
+	return ext3_xattr_set(d_inode(dentry), EXT3_XATTR_INDEX_SECURITY,
 			      name, value, size, flags);
 }
 
diff --git a/fs/ext3/xattr_trusted.c b/fs/ext3/xattr_trusted.c
index d75727cc67fa..206cc66dc285 100644
--- a/fs/ext3/xattr_trusted.c
+++ b/fs/ext3/xattr_trusted.c
@@ -32,7 +32,7 @@ ext3_xattr_trusted_get(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_get(dentry->d_inode, EXT3_XATTR_INDEX_TRUSTED,
+	return ext3_xattr_get(d_inode(dentry), EXT3_XATTR_INDEX_TRUSTED,
 			      name, buffer, size);
 }
 
@@ -42,7 +42,7 @@ ext3_xattr_trusted_set(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_set(dentry->d_inode, EXT3_XATTR_INDEX_TRUSTED, name,
+	return ext3_xattr_set(d_inode(dentry), EXT3_XATTR_INDEX_TRUSTED, name,
 			      value, size, flags);
 }
 
diff --git a/fs/ext3/xattr_user.c b/fs/ext3/xattr_user.c
index 5612af3567e0..021508ad1616 100644
--- a/fs/ext3/xattr_user.c
+++ b/fs/ext3/xattr_user.c
@@ -34,7 +34,7 @@ ext3_xattr_user_get(struct dentry *dentry, const char *name, void *buffer,
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext3_xattr_get(dentry->d_inode, EXT3_XATTR_INDEX_USER,
+	return ext3_xattr_get(d_inode(dentry), EXT3_XATTR_INDEX_USER,
 			      name, buffer, size);
 }
 
@@ -46,7 +46,7 @@ ext3_xattr_user_set(struct dentry *dentry, const char *name,
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext3_xattr_set(dentry->d_inode, EXT3_XATTR_INDEX_USER,
+	return ext3_xattr_set(d_inode(dentry), EXT3_XATTR_INDEX_USER,
 			      name, value, size, flags);
 }
 
diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index 7f7cddac5844..bd805c6af742 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -56,7 +56,7 @@ static int ext4_sync_parent(struct inode *inode)
 		dentry = d_find_any_alias(inode);
 		if (!dentry)
 			break;
-		next = igrab(dentry->d_parent->d_inode);
+		next = igrab(d_inode(dentry->d_parent));
 		dput(dentry);
 		if (!next)
 			break;
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index ac644c31ca67..d8d4f2929cbd 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -444,7 +444,7 @@ static int find_group_orlov(struct super_block *sb, struct inode *parent,
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
 	if (S_ISDIR(mode) &&
-	    ((parent == sb->s_root->d_inode) ||
+	    ((parent == d_inode(sb->s_root)) ||
 	     (ext4_test_inode_flag(parent, EXT4_INODE_TOPDIR)))) {
 		int best_ndir = inodes_per_group;
 		int ret = -1;
diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index 8d39125f3079..45141a9c3750 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -998,7 +998,7 @@ static int ext4_add_dirent_to_inline(handle_t *handle,
 				     struct ext4_iloc *iloc,
 				     void *inline_start, int inline_size)
 {
-	struct inode	*dir = dentry->d_parent->d_inode;
+	struct inode	*dir = d_inode(dentry->d_parent);
 	const char	*name = dentry->d_name.name;
 	int		namelen = dentry->d_name.len;
 	int		err;
@@ -1251,7 +1251,7 @@ int ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,
 	int ret, inline_size;
 	void *inline_start;
 	struct ext4_iloc iloc;
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 
 	ret = ext4_get_inode_loc(dir, &iloc);
 	if (ret)
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 7e00e3fcc247..7e446cc96445 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4483,7 +4483,7 @@ static void ext4_wait_for_tail_page_commit(struct inode *inode)
  */
 int ext4_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error, rc = 0;
 	int orphan = 0;
 	const unsigned int ia_valid = attr->ia_valid;
@@ -4627,7 +4627,7 @@ int ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,
 	struct inode *inode;
 	unsigned long long delalloc_blocks;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	generic_fillattr(inode, stat);
 
 	/*
diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index c3ddf6daad25..b8d214cb952a 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -478,7 +478,7 @@ int ext4_ext_migrate(struct inode *inode)
 		EXT4_INODES_PER_GROUP(inode->i_sb)) + 1;
 	owner[0] = i_uid_read(inode);
 	owner[1] = i_gid_read(inode);
-	tmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,
+	tmp_inode = ext4_new_inode(handle, d_inode(inode->i_sb->s_root),
 				   S_IFREG, NULL, goal, owner);
 	if (IS_ERR(tmp_inode)) {
 		retval = PTR_ERR(tmp_inode);
* Unmerged path fs/ext4/namei.c
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 31618f12ab5f..a269cc177e1e 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1592,7 +1592,7 @@ static int handle_mount_opt(struct super_block *sb, char *opt, int token,
 			return -1;
 		}
 
-		journal_inode = path.dentry->d_inode;
+		journal_inode = d_inode(path.dentry);
 		if (!S_ISBLK(journal_inode->i_mode)) {
 			ext4_msg(sb, KERN_ERR, "error: journal path %s "
 				"is not a block device", journal_path);
@@ -5195,7 +5195,7 @@ static int ext4_write_info(struct super_block *sb, int type)
 	handle_t *handle;
 
 	/* Data block + inode block */
-	handle = ext4_journal_start(sb->s_root->d_inode, EXT4_HT_QUOTA, 2);
+	handle = ext4_journal_start(d_inode(sb->s_root), EXT4_HT_QUOTA, 2);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 	ret = dquot_commit_info(sb, type);
@@ -5243,7 +5243,7 @@ static int ext4_quota_on(struct super_block *sb, int type, int format_id,
 	 * all updates to the file when we bypass pagecache...
 	 */
 	if (EXT4_SB(sb)->s_journal &&
-	    ext4_should_journal_data(path->dentry->d_inode)) {
+	    ext4_should_journal_data(d_inode(path->dentry))) {
 		/*
 		 * We don't need to lock updates but journal_flush() could
 		 * otherwise be livelocked...
diff --git a/fs/ext4/symlink.c b/fs/ext4/symlink.c
index ff3711932018..57f50091b8d1 100644
--- a/fs/ext4/symlink.c
+++ b/fs/ext4/symlink.c
@@ -25,7 +25,7 @@
 
 static void *ext4_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ext4_inode_info *ei = EXT4_I(dentry->d_inode);
+	struct ext4_inode_info *ei = EXT4_I(d_inode(dentry));
 	nd_set_link(nd, (char *) ei->i_data);
 	return NULL;
 }
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index c88aeeb3d46f..e76025323a6d 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -178,7 +178,7 @@ ext4_xattr_handler(int name_index)
 /*
  * Inode operation listxattr()
  *
- * dentry->d_inode->i_mutex: don't care
+ * d_inode(dentry)->i_mutex: don't care
  */
 ssize_t
 ext4_listxattr(struct dentry *dentry, char *buffer, size_t size)
@@ -422,7 +422,7 @@ ext4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,
 static int
 ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
 	int error;
 
@@ -458,7 +458,7 @@ cleanup:
 static int
 ext4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ext4_xattr_ibody_header *header;
 	struct ext4_inode *raw_inode;
 	struct ext4_iloc iloc;
@@ -499,7 +499,7 @@ ext4_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
 	int ret, ret2;
 
-	down_read(&EXT4_I(dentry->d_inode)->xattr_sem);
+	down_read(&EXT4_I(d_inode(dentry))->xattr_sem);
 	ret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);
 	if (ret < 0)
 		goto errout;
@@ -512,7 +512,7 @@ ext4_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 		goto errout;
 	ret += ret2;
 errout:
-	up_read(&EXT4_I(dentry->d_inode)->xattr_sem);
+	up_read(&EXT4_I(d_inode(dentry))->xattr_sem);
 	return ret;
 }
 
diff --git a/fs/ext4/xattr_security.c b/fs/ext4/xattr_security.c
index d2a200624af5..95d90e0560f0 100644
--- a/fs/ext4/xattr_security.c
+++ b/fs/ext4/xattr_security.c
@@ -33,7 +33,7 @@ ext4_xattr_security_get(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,
+	return ext4_xattr_get(d_inode(dentry), EXT4_XATTR_INDEX_SECURITY,
 			      name, buffer, size);
 }
 
@@ -43,7 +43,7 @@ ext4_xattr_security_set(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,
+	return ext4_xattr_set(d_inode(dentry), EXT4_XATTR_INDEX_SECURITY,
 			      name, value, size, flags);
 }
 
diff --git a/fs/ext4/xattr_trusted.c b/fs/ext4/xattr_trusted.c
index 95f1f4ab59a4..891ee2ddfbd6 100644
--- a/fs/ext4/xattr_trusted.c
+++ b/fs/ext4/xattr_trusted.c
@@ -36,7 +36,7 @@ ext4_xattr_trusted_get(struct dentry *dentry, const char *name, void *buffer,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_TRUSTED,
+	return ext4_xattr_get(d_inode(dentry), EXT4_XATTR_INDEX_TRUSTED,
 			      name, buffer, size);
 }
 
@@ -46,7 +46,7 @@ ext4_xattr_trusted_set(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_TRUSTED,
+	return ext4_xattr_set(d_inode(dentry), EXT4_XATTR_INDEX_TRUSTED,
 			      name, value, size, flags);
 }
 
diff --git a/fs/ext4/xattr_user.c b/fs/ext4/xattr_user.c
index 0edb7611ffbe..6ed932b3c043 100644
--- a/fs/ext4/xattr_user.c
+++ b/fs/ext4/xattr_user.c
@@ -37,7 +37,7 @@ ext4_xattr_user_get(struct dentry *dentry, const char *name,
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_USER,
+	return ext4_xattr_get(d_inode(dentry), EXT4_XATTR_INDEX_USER,
 			      name, buffer, size);
 }
 
@@ -49,7 +49,7 @@ ext4_xattr_user_set(struct dentry *dentry, const char *name,
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_USER,
+	return ext4_xattr_set(d_inode(dentry), EXT4_XATTR_INDEX_USER,
 			      name, value, size, flags);
 }
 
diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h
index 20aab02f2a42..773c96516f6d 100644
--- a/fs/f2fs/f2fs.h
+++ b/fs/f2fs/f2fs.h
@@ -921,7 +921,7 @@ bool f2fs_empty_dir(struct inode *);
 
 static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	return __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,
+	return __f2fs_add_link(d_inode(dentry->d_parent), &dentry->d_name,
 				inode);
 }
 
diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c
index 1cae864f8dfc..75f3610bf850 100644
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@ -294,7 +294,7 @@ void f2fs_truncate(struct inode *inode)
 static int f2fs_getattr(struct vfsmount *mnt,
 			 struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	generic_fillattr(inode, stat);
 	stat->blocks <<= 3;
 	return 0;
@@ -333,7 +333,7 @@ static void __setattr_copy(struct inode *inode, const struct iattr *attr)
 
 int f2fs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct f2fs_inode_info *fi = F2FS_I(inode);
 	int err;
 
* Unmerged path fs/f2fs/namei.c
* Unmerged path fs/f2fs/xattr.c
diff --git a/fs/fat/file.c b/fs/fat/file.c
index b0b632e50ddb..dd0b7db0e2d7 100644
--- a/fs/fat/file.c
+++ b/fs/fat/file.c
@@ -303,7 +303,7 @@ void fat_truncate_blocks(struct inode *inode, loff_t offset)
 
 int fat_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	generic_fillattr(inode, stat);
 	stat->blksize = MSDOS_SB(inode->i_sb)->cluster_size;
 
@@ -375,7 +375,7 @@ static int fat_allow_set_time(struct msdos_sb_info *sbi, struct inode *inode)
 int fat_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int ia_valid;
 	int error;
 
diff --git a/fs/fat/namei_msdos.c b/fs/fat/namei_msdos.c
index a783b0e1272a..e68e794c71d2 100644
--- a/fs/fat/namei_msdos.c
+++ b/fs/fat/namei_msdos.c
@@ -310,7 +310,7 @@ out:
 static int msdos_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	struct super_block *sb = dir->i_sb;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct fat_slot_info sinfo;
 	int err;
 
@@ -404,7 +404,7 @@ out:
 /***** Unlink a file */
 static int msdos_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	struct fat_slot_info sinfo;
 	int err;
@@ -442,8 +442,8 @@ static int do_msdos_rename(struct inode *old_dir, unsigned char *old_name,
 	int err, old_attrs, is_dir, update_dotdot, corrupt = 0;
 
 	old_sinfo.bh = sinfo.bh = dotdot_bh = NULL;
-	old_inode = old_dentry->d_inode;
-	new_inode = new_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
+	new_inode = d_inode(new_dentry);
 
 	err = fat_scan(old_dir, old_name, &old_sinfo);
 	if (err) {
diff --git a/fs/fat/namei_vfat.c b/fs/fat/namei_vfat.c
index 6df8d3d885e5..5f647e6e5541 100644
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -35,7 +35,7 @@ static int vfat_revalidate_shortname(struct dentry *dentry)
 {
 	int ret = 1;
 	spin_lock(&dentry->d_lock);
-	if (dentry->d_time != dentry->d_parent->d_inode->i_version)
+	if (dentry->d_time != d_inode(dentry->d_parent)->i_version)
 		ret = 0;
 	spin_unlock(&dentry->d_lock);
 	return ret;
@@ -47,7 +47,7 @@ static int vfat_revalidate(struct dentry *dentry, unsigned int flags)
 		return -ECHILD;
 
 	/* This is not negative dentry. Always valid. */
-	if (dentry->d_inode)
+	if (d_really_is_positive(dentry))
 		return 1;
 	return vfat_revalidate_shortname(dentry);
 }
@@ -67,7 +67,7 @@ static int vfat_revalidate_ci(struct dentry *dentry, unsigned int flags)
 	 * positive dentry isn't good idea. So it's unsupported like
 	 * rename("filename", "FILENAME") for now.
 	 */
-	if (dentry->d_inode)
+	if (d_really_is_positive(dentry))
 		return 1;
 
 	/*
@@ -802,7 +802,7 @@ out:
 
 static int vfat_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = dir->i_sb;
 	struct fat_slot_info sinfo;
 	int err;
@@ -832,7 +832,7 @@ out:
 
 static int vfat_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = dir->i_sb;
 	struct fat_slot_info sinfo;
 	int err;
@@ -915,8 +915,8 @@ static int vfat_rename(struct inode *old_dir, struct dentry *old_dentry,
 	struct super_block *sb = old_dir->i_sb;
 
 	old_sinfo.bh = sinfo.bh = dotdot_bh = NULL;
-	old_inode = old_dentry->d_inode;
-	new_inode = new_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
+	new_inode = d_inode(new_dentry);
 	mutex_lock(&MSDOS_SB(sb)->s_lock);
 	err = vfat_find(old_dir, &old_dentry->d_name, &old_sinfo);
 	if (err)
diff --git a/fs/fat/nfs.c b/fs/fat/nfs.c
index 93e14933dcb6..eb192656fba2 100644
--- a/fs/fat/nfs.c
+++ b/fs/fat/nfs.c
@@ -266,7 +266,7 @@ struct inode *fat_rebuild_parent(struct super_block *sb, int parent_logstart)
  * Find the parent for a directory that is not currently connected to
  * the filesystem root.
  *
- * On entry, the caller holds child_dir->d_inode->i_mutex.
+ * On entry, the caller holds d_inode(child_dir)->i_mutex.
  */
 static struct dentry *fat_get_parent(struct dentry *child_dir)
 {
@@ -276,7 +276,7 @@ static struct dentry *fat_get_parent(struct dentry *child_dir)
 	struct inode *parent_inode = NULL;
 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
 
-	if (!fat_get_dotdot_entry(child_dir->d_inode, &bh, &de)) {
+	if (!fat_get_dotdot_entry(d_inode(child_dir), &bh, &de)) {
 		int parent_logstart = fat_get_start(sbi, de);
 		parent_inode = fat_dget(sb, parent_logstart);
 		if (!parent_inode && sbi->options.nfs == FAT_NFS_NOSTALE_RO)
diff --git a/fs/freevxfs/vxfs_immed.c b/fs/freevxfs/vxfs_immed.c
index c36aeaf92e41..8b9229e2ca5c 100644
--- a/fs/freevxfs/vxfs_immed.c
+++ b/fs/freevxfs/vxfs_immed.c
@@ -76,7 +76,7 @@ const struct address_space_operations vxfs_immed_aops = {
 static void *
 vxfs_immed_follow_link(struct dentry *dp, struct nameidata *np)
 {
-	struct vxfs_inode_info		*vip = VXFS_INO(dp->d_inode);
+	struct vxfs_inode_info		*vip = VXFS_INO(d_inode(dp));
 	nd_set_link(np, vip->vii_immed.vi_immed);
 	return NULL;
 }
diff --git a/fs/fuse/control.c b/fs/fuse/control.c
index a0b0855d00a9..8be554700d63 100644
--- a/fs/fuse/control.c
+++ b/fs/fuse/control.c
@@ -244,7 +244,7 @@ int fuse_ctl_add_conn(struct fuse_conn *fc)
 		return 0;
 
 	parent = fuse_control_sb->s_root;
-	inc_nlink(parent->d_inode);
+	inc_nlink(d_inode(parent));
 	sprintf(name, "%u", fc->dev);
 	parent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,
 				     &simple_dir_inode_operations,
@@ -283,11 +283,11 @@ void fuse_ctl_remove_conn(struct fuse_conn *fc)
 
 	for (i = fc->ctl_ndents - 1; i >= 0; i--) {
 		struct dentry *dentry = fc->ctl_dentry[i];
-		dentry->d_inode->i_private = NULL;
+		d_inode(dentry)->i_private = NULL;
 		d_drop(dentry);
 		dput(dentry);
 	}
-	drop_nlink(fuse_control_sb->s_root->d_inode);
+	drop_nlink(d_inode(fuse_control_sb->s_root));
 }
 
 static int fuse_ctl_fill_super(struct super_block *sb, void *data, int silent)
* Unmerged path fs/fuse/dir.c
* Unmerged path fs/fuse/inode.c
diff --git a/fs/gfs2/dentry.c b/fs/gfs2/dentry.c
index d3a5d4e29ba5..ea7713a782f7 100644
--- a/fs/gfs2/dentry.c
+++ b/fs/gfs2/dentry.c
@@ -48,9 +48,9 @@ static int gfs2_drevalidate(struct dentry *dentry, unsigned int flags)
 		return -ECHILD;
 
 	parent = dget_parent(dentry);
-	sdp = GFS2_SB(parent->d_inode);
-	dip = GFS2_I(parent->d_inode);
-	inode = dentry->d_inode;
+	sdp = GFS2_SB(d_inode(parent));
+	dip = GFS2_I(d_inode(parent));
+	inode = d_inode(dentry);
 
 	if (inode) {
 		if (is_bad_inode(inode))
@@ -68,7 +68,7 @@ static int gfs2_drevalidate(struct dentry *dentry, unsigned int flags)
 			goto fail;
 	} 
 
-	error = gfs2_dir_check(parent->d_inode, &dentry->d_name, ip);
+	error = gfs2_dir_check(d_inode(parent), &dentry->d_name, ip);
 	switch (error) {
 	case 0:
 		if (!inode)
@@ -116,10 +116,10 @@ static int gfs2_dentry_delete(const struct dentry *dentry)
 {
 	struct gfs2_inode *ginode;
 
-	if (!dentry->d_inode)
+	if (d_really_is_negative(dentry))
 		return 0;
 
-	ginode = GFS2_I(dentry->d_inode);
+	ginode = GFS2_I(d_inode(dentry));
 	if (!ginode->i_iopen_gh.gh_gl)
 		return 0;
 
diff --git a/fs/gfs2/export.c b/fs/gfs2/export.c
index 9973df4ff565..5975cec4f064 100644
--- a/fs/gfs2/export.c
+++ b/fs/gfs2/export.c
@@ -49,7 +49,7 @@ static int gfs2_encode_fh(struct inode *inode, __u32 *p, int *len,
 	fh[3] = cpu_to_be32(ip->i_no_addr & 0xFFFFFFFF);
 	*len = GFS2_SMALL_FH_SIZE;
 
-	if (!parent || inode == sb->s_root->d_inode)
+	if (!parent || inode == d_inode(sb->s_root))
 		return *len;
 
 	ip = GFS2_I(parent);
@@ -85,8 +85,8 @@ static int get_name_filldir(void *opaque, const char *name, int length,
 static int gfs2_get_name(struct dentry *parent, char *name,
 			 struct dentry *child)
 {
-	struct inode *dir = parent->d_inode;
-	struct inode *inode = child->d_inode;
+	struct inode *dir = d_inode(parent);
+	struct inode *inode = d_inode(child);
 	struct gfs2_inode *dip, *ip;
 	struct get_name_filldir gnfd;
 	struct gfs2_holder gh;
@@ -124,7 +124,7 @@ static int gfs2_get_name(struct dentry *parent, char *name,
 
 static struct dentry *gfs2_get_parent(struct dentry *child)
 {
-	return d_obtain_alias(gfs2_lookupi(child->d_inode, &gfs2_qdotdot, 1));
+	return d_obtain_alias(gfs2_lookupi(d_inode(child), &gfs2_qdotdot, 1));
 }
 
 static struct dentry *gfs2_get_dentry(struct super_block *sb,
* Unmerged path fs/gfs2/inode.c
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index 902da6b6e2b5..f6a23d5a8e53 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -692,7 +692,7 @@ out_unlock:
 
 static int init_journal(struct gfs2_sbd *sdp, int undo)
 {
-	struct inode *master = sdp->sd_master_dir->d_inode;
+	struct inode *master = d_inode(sdp->sd_master_dir);
 	struct gfs2_holder ji_gh;
 	struct gfs2_inode *ip;
 	int jindex = 1;
@@ -827,7 +827,7 @@ static struct lock_class_key gfs2_quota_imutex_key;
 static int init_inodes(struct gfs2_sbd *sdp, int undo)
 {
 	int error = 0;
-	struct inode *master = sdp->sd_master_dir->d_inode;
+	struct inode *master = d_inode(sdp->sd_master_dir);
 
 	if (undo)
 		goto fail_qinode;
@@ -893,7 +893,7 @@ static int init_per_node(struct gfs2_sbd *sdp, int undo)
 	char buf[30];
 	int error = 0;
 	struct gfs2_inode *ip;
-	struct inode *master = sdp->sd_master_dir->d_inode;
+	struct inode *master = d_inode(sdp->sd_master_dir);
 
 	if (sdp->sd_args.ar_spectator)
 		return 0;
@@ -1398,7 +1398,7 @@ static struct dentry *gfs2_mount_meta(struct file_system_type *fs_type,
 		return ERR_PTR(error);
 	}
 	s = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super, flags,
-		 path.dentry->d_inode->i_sb->s_bdev);
+		 d_inode(path.dentry)->i_sb->s_bdev);
 	path_put(&path);
 	if (IS_ERR(s)) {
 		printk(KERN_WARNING "GFS2: gfs2 mount does not exist\n");
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 7c8f12885717..96f45c30fa21 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -1130,7 +1130,7 @@ static int gfs2_statfs_i(struct gfs2_sbd *sdp, struct gfs2_statfs_change_host *s
 
 static int gfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
-	struct super_block *sb = dentry->d_inode->i_sb;
+	struct super_block *sb = d_inode(dentry)->i_sb;
 	struct gfs2_sbd *sdp = sb->s_fs_info;
 	struct gfs2_statfs_change_host sc;
 	int error;
diff --git a/fs/gfs2/xattr.c b/fs/gfs2/xattr.c
index 80196e27eebe..aa3a35119f52 100644
--- a/fs/gfs2/xattr.c
+++ b/fs/gfs2/xattr.c
@@ -419,7 +419,7 @@ static int ea_list_i(struct gfs2_inode *ip, struct buffer_head *bh,
 
 ssize_t gfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct gfs2_inode *ip = GFS2_I(dentry->d_inode);
+	struct gfs2_inode *ip = GFS2_I(d_inode(dentry));
 	struct gfs2_ea_request er;
 	struct gfs2_holder i_gh;
 	int error;
@@ -585,7 +585,7 @@ out:
 static int gfs2_xattr_get(struct dentry *dentry, const char *name,
 		void *buffer, size_t size, int type)
 {
-	struct gfs2_inode *ip = GFS2_I(dentry->d_inode);
+	struct gfs2_inode *ip = GFS2_I(d_inode(dentry));
 	struct gfs2_ea_location el;
 	int error;
 
@@ -1229,7 +1229,7 @@ int __gfs2_xattr_set(struct inode *inode, const char *name,
 static int gfs2_xattr_set(struct dentry *dentry, const char *name,
 		const void *value, size_t size, int flags, int type)
 {
-	return __gfs2_xattr_set(dentry->d_inode, name, value,
+	return __gfs2_xattr_set(d_inode(dentry), name, value,
 				size, flags, type);
 }
 
diff --git a/fs/hfs/attr.c b/fs/hfs/attr.c
index e057ec542a6a..8d931b157bbe 100644
--- a/fs/hfs/attr.c
+++ b/fs/hfs/attr.c
@@ -16,7 +16,7 @@
 int hfs_setxattr(struct dentry *dentry, const char *name,
 		 const void *value, size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	hfs_cat_rec rec;
 	struct hfs_cat_file *file;
@@ -59,7 +59,7 @@ out:
 ssize_t hfs_getxattr(struct dentry *dentry, const char *name,
 			 void *value, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	hfs_cat_rec rec;
 	struct hfs_cat_file *file;
@@ -105,7 +105,7 @@ out:
 
 ssize_t hfs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))
 		return -EOPNOTSUPP;
diff --git a/fs/hfs/dir.c b/fs/hfs/dir.c
index e0101b6fb0d7..28f622629a5e 100644
--- a/fs/hfs/dir.c
+++ b/fs/hfs/dir.c
@@ -256,7 +256,7 @@ static int hfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
  */
 static int hfs_remove(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int res;
 
 	if (S_ISDIR(inode->i_mode) && inode->i_size != 2)
@@ -288,18 +288,18 @@ static int hfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	int res;
 
 	/* Unlink destination if it already exists */
-	if (new_dentry->d_inode) {
+	if (d_really_is_positive(new_dentry)) {
 		res = hfs_remove(new_dir, new_dentry);
 		if (res)
 			return res;
 	}
 
-	res = hfs_cat_move(old_dentry->d_inode->i_ino,
+	res = hfs_cat_move(d_inode(old_dentry)->i_ino,
 			   old_dir, &old_dentry->d_name,
 			   new_dir, &new_dentry->d_name);
 	if (!res)
 		hfs_cat_build_key(old_dir->i_sb,
-				  (btree_key *)&HFS_I(old_dentry->d_inode)->cat_key,
+				  (btree_key *)&HFS_I(d_inode(old_dentry))->cat_key,
 				  new_dir->i_ino, &new_dentry->d_name);
 	return res;
 }
diff --git a/fs/hfs/inode.c b/fs/hfs/inode.c
index 9e2fecd62f62..084b68c8539e 100644
--- a/fs/hfs/inode.c
+++ b/fs/hfs/inode.c
@@ -600,7 +600,7 @@ static int hfs_file_release(struct inode *inode, struct file *file)
 
 int hfs_inode_setattr(struct dentry *dentry, struct iattr * attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_sb_info *hsb = HFS_SB(inode->i_sb);
 	int error;
 
diff --git a/fs/hfs/sysdep.c b/fs/hfs/sysdep.c
index 91b91fd3a901..2875961fdc10 100644
--- a/fs/hfs/sysdep.c
+++ b/fs/hfs/sysdep.c
@@ -21,7 +21,7 @@ static int hfs_revalidate_dentry(struct dentry *dentry, unsigned int flags)
 	if (flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if(!inode)
 		return 1;
 
* Unmerged path fs/hfsplus/dir.c
diff --git a/fs/hfsplus/inode.c b/fs/hfsplus/inode.c
index 4b4ae8ccc6dc..fe447a79faad 100644
--- a/fs/hfsplus/inode.c
+++ b/fs/hfsplus/inode.c
@@ -300,7 +300,7 @@ static int hfsplus_file_release(struct inode *inode, struct file *file)
 
 static int hfsplus_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff --git a/fs/hfsplus/ioctl.c b/fs/hfsplus/ioctl.c
index d3ff5cc317d7..ac807073c453 100644
--- a/fs/hfsplus/ioctl.c
+++ b/fs/hfsplus/ioctl.c
@@ -26,7 +26,7 @@
 static int hfsplus_ioctl_bless(struct file *file, int __user *user_flags)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);
 	struct hfsplus_vh *vh = sbi->s_vhdr;
 	struct hfsplus_vh *bvh = sbi->s_backup_vhdr;
diff --git a/fs/hfsplus/xattr.c b/fs/hfsplus/xattr.c
index f66346155df5..65aafcb45b34 100644
--- a/fs/hfsplus/xattr.c
+++ b/fs/hfsplus/xattr.c
@@ -417,7 +417,7 @@ static ssize_t hfsplus_listxattr_finder_info(struct dentry *dentry,
 						char *buffer, size_t size)
 {
 	ssize_t res = 0;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	u16 entry_type;
 	u8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];
@@ -485,7 +485,7 @@ ssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
 	ssize_t err;
 	ssize_t res = 0;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	u16 key_len = 0;
 	struct hfsplus_attr_key attr_key;
* Unmerged path fs/hfsplus/xattr.h
diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c
index a24b38350010..2dea60d90d20 100644
--- a/fs/hostfs/hostfs_kern.c
+++ b/fs/hostfs/hostfs_kern.c
@@ -797,7 +797,7 @@ int hostfs_permission(struct inode *ino, int desired)
 
 int hostfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hostfs_iattr attrs;
 	char *name;
 	int err;
diff --git a/fs/hpfs/inode.c b/fs/hpfs/inode.c
index 50a427313835..a4968b598f7a 100644
--- a/fs/hpfs/inode.c
+++ b/fs/hpfs/inode.c
@@ -256,7 +256,7 @@ void hpfs_write_inode_nolock(struct inode *i)
 
 int hpfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error = -EINVAL;
 
 	hpfs_lock(inode->i_sb);
diff --git a/fs/hpfs/namei.c b/fs/hpfs/namei.c
index 1b39afdd86fd..8ebc839b75d2 100644
--- a/fs/hpfs/namei.c
+++ b/fs/hpfs/namei.c
@@ -359,7 +359,7 @@ static int hpfs_unlink(struct inode *dir, struct dentry *dentry)
 	unsigned len = dentry->d_name.len;
 	struct quad_buffer_head qbh;
 	struct hpfs_dirent *de;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	dnode_secno dno;
 	int r;
 	int rep = 0;
@@ -433,7 +433,7 @@ static int hpfs_rmdir(struct inode *dir, struct dentry *dentry)
 	unsigned len = dentry->d_name.len;
 	struct quad_buffer_head qbh;
 	struct hpfs_dirent *de;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	dnode_secno dno;
 	int n_items = 0;
 	int err;
@@ -522,8 +522,8 @@ static int hpfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	unsigned old_len = old_dentry->d_name.len;
 	const unsigned char *new_name = new_dentry->d_name.name;
 	unsigned new_len = new_dentry->d_name.len;
-	struct inode *i = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *i = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct quad_buffer_head qbh, qbh1;
 	struct hpfs_dirent *dep, *nde;
 	struct hpfs_dirent de;
diff --git a/fs/hppfs/hppfs.c b/fs/hppfs/hppfs.c
index cd3e38972c86..e07fa3979f43 100644
--- a/fs/hppfs/hppfs.c
+++ b/fs/hppfs/hppfs.c
@@ -152,9 +152,9 @@ static struct dentry *hppfs_lookup(struct inode *ino, struct dentry *dentry,
 		return ERR_PTR(-ENOENT);
 
 	parent = HPPFS_I(ino)->proc_dentry;
-	mutex_lock(&parent->d_inode->i_mutex);
+	mutex_lock(&d_inode(parent)->i_mutex);
 	proc_dentry = lookup_one_len(name->name, parent, name->len);
-	mutex_unlock(&parent->d_inode->i_mutex);
+	mutex_unlock(&d_inode(parent)->i_mutex);
 
 	if (IS_ERR(proc_dentry))
 		return proc_dentry;
@@ -640,25 +640,25 @@ static const struct super_operations hppfs_sbops = {
 static int hppfs_readlink(struct dentry *dentry, char __user *buffer,
 			  int buflen)
 {
-	struct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
-	return proc_dentry->d_inode->i_op->readlink(proc_dentry, buffer,
+	struct dentry *proc_dentry = HPPFS_I(d_inode(dentry))->proc_dentry;
+	return d_inode(proc_dentry)->i_op->readlink(proc_dentry, buffer,
 						    buflen);
 }
 
 static void *hppfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
+	struct dentry *proc_dentry = HPPFS_I(d_inode(dentry))->proc_dentry;
 
-	return proc_dentry->d_inode->i_op->follow_link(proc_dentry, nd);
+	return d_inode(proc_dentry)->i_op->follow_link(proc_dentry, nd);
 }
 
 static void hppfs_put_link(struct dentry *dentry, struct nameidata *nd,
 			   void *cookie)
 {
-	struct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
+	struct dentry *proc_dentry = HPPFS_I(d_inode(dentry))->proc_dentry;
 
-	if (proc_dentry->d_inode->i_op->put_link)
-		proc_dentry->d_inode->i_op->put_link(proc_dentry, nd, cookie);
+	if (d_inode(proc_dentry)->i_op->put_link)
+		d_inode(proc_dentry)->i_op->put_link(proc_dentry, nd, cookie);
 }
 
 static const struct inode_operations hppfs_dir_iops = {
@@ -673,7 +673,7 @@ static const struct inode_operations hppfs_link_iops = {
 
 static struct inode *get_inode(struct super_block *sb, struct dentry *dentry)
 {
-	struct inode *proc_ino = dentry->d_inode;
+	struct inode *proc_ino = d_inode(dentry);
 	struct inode *inode = new_inode(sb);
 
 	if (!inode) {
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index 7b7a94a0485b..c815add0fe5e 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -420,7 +420,7 @@ static int hugetlb_vmtruncate(struct inode *inode, loff_t offset)
 
 static int hugetlbfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hstate *h = hstate_inode(inode);
 	int error;
 	unsigned int ia_valid = attr->ia_valid;
@@ -615,7 +615,7 @@ static int hugetlbfs_migrate_page(struct address_space *mapping,
 static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);
-	struct hstate *h = hstate_inode(dentry->d_inode);
+	struct hstate *h = hstate_inode(d_inode(dentry));
 
 	buf->f_type = HUGETLBFS_MAGIC;
 	buf->f_bsize = huge_page_size(h);
diff --git a/fs/isofs/export.c b/fs/isofs/export.c
index 12088d8de3fa..0c5f721b4e91 100644
--- a/fs/isofs/export.c
+++ b/fs/isofs/export.c
@@ -44,7 +44,7 @@ static struct dentry *isofs_export_get_parent(struct dentry *child)
 {
 	unsigned long parent_block = 0;
 	unsigned long parent_offset = 0;
-	struct inode *child_inode = child->d_inode;
+	struct inode *child_inode = d_inode(child);
 	struct iso_inode_info *e_child_inode = ISOFS_I(child_inode);
 	struct iso_directory_record *de = NULL;
 	struct buffer_head * bh = NULL;
* Unmerged path fs/jffs2/dir.c
* Unmerged path fs/jffs2/fs.c
diff --git a/fs/jffs2/security.c b/fs/jffs2/security.c
index aca97f35b292..d4b43fb7adb1 100644
--- a/fs/jffs2/security.c
+++ b/fs/jffs2/security.c
@@ -54,7 +54,7 @@ static int jffs2_security_getxattr(struct dentry *dentry, const char *name,
 	if (!strcmp(name, ""))
 		return -EINVAL;
 
-	return do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_SECURITY,
+	return do_jffs2_getxattr(d_inode(dentry), JFFS2_XPREFIX_SECURITY,
 				 name, buffer, size);
 }
 
@@ -64,7 +64,7 @@ static int jffs2_security_setxattr(struct dentry *dentry, const char *name,
 	if (!strcmp(name, ""))
 		return -EINVAL;
 
-	return do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_SECURITY,
+	return do_jffs2_setxattr(d_inode(dentry), JFFS2_XPREFIX_SECURITY,
 				 name, buffer, size, flags);
 }
 
diff --git a/fs/jffs2/super.c b/fs/jffs2/super.c
index 0defb1cc2a35..163af5ed1d9a 100644
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@ -140,14 +140,14 @@ static struct dentry *jffs2_get_parent(struct dentry *child)
 
 	BUG_ON(!S_ISDIR(child->d_inode->i_mode));
 
-	f = JFFS2_INODE_INFO(child->d_inode);
+	f = JFFS2_INODE_INFO(d_inode(child));
 
 	pino = f->inocache->pino_nlink;
 
 	JFFS2_DEBUG("Parent of directory ino #%u is #%u\n",
 		    f->inocache->ino, pino);
 
-	return d_obtain_alias(jffs2_iget(child->d_inode->i_sb, pino));
+	return d_obtain_alias(jffs2_iget(d_inode(child)->i_sb, pino));
 }
 
 static const struct export_operations jffs2_export_ops = {
diff --git a/fs/jffs2/symlink.c b/fs/jffs2/symlink.c
index 6e563332bb24..825c2f3856be 100644
--- a/fs/jffs2/symlink.c
+++ b/fs/jffs2/symlink.c
@@ -32,7 +32,7 @@ const struct inode_operations jffs2_symlink_inode_operations =
 
 static void *jffs2_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(dentry->d_inode);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(dentry));
 	char *p = (char *)f->target;
 
 	/*
diff --git a/fs/jffs2/xattr.c b/fs/jffs2/xattr.c
index 3034e970eb9a..44592a369a69 100644
--- a/fs/jffs2/xattr.c
+++ b/fs/jffs2/xattr.c
@@ -960,7 +960,7 @@ static const struct xattr_handler *xprefix_to_handler(int xprefix) {
 
 ssize_t jffs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
 	struct jffs2_inode_cache *ic = f->inocache;
diff --git a/fs/jffs2/xattr_trusted.c b/fs/jffs2/xattr_trusted.c
index 1c868194c504..ceaf9c693225 100644
--- a/fs/jffs2/xattr_trusted.c
+++ b/fs/jffs2/xattr_trusted.c
@@ -21,7 +21,7 @@ static int jffs2_trusted_getxattr(struct dentry *dentry, const char *name,
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,
+	return do_jffs2_getxattr(d_inode(dentry), JFFS2_XPREFIX_TRUSTED,
 				 name, buffer, size);
 }
 
@@ -30,7 +30,7 @@ static int jffs2_trusted_setxattr(struct dentry *dentry, const char *name,
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,
+	return do_jffs2_setxattr(d_inode(dentry), JFFS2_XPREFIX_TRUSTED,
 				 name, buffer, size, flags);
 }
 
diff --git a/fs/jffs2/xattr_user.c b/fs/jffs2/xattr_user.c
index 916b5c966039..a71391eba514 100644
--- a/fs/jffs2/xattr_user.c
+++ b/fs/jffs2/xattr_user.c
@@ -21,7 +21,7 @@ static int jffs2_user_getxattr(struct dentry *dentry, const char *name,
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_USER,
+	return do_jffs2_getxattr(d_inode(dentry), JFFS2_XPREFIX_USER,
 				 name, buffer, size);
 }
 
@@ -30,7 +30,7 @@ static int jffs2_user_setxattr(struct dentry *dentry, const char *name,
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_USER,
+	return do_jffs2_setxattr(d_inode(dentry), JFFS2_XPREFIX_USER,
 				 name, buffer, size, flags);
 }
 
diff --git a/fs/jfs/file.c b/fs/jfs/file.c
index dd7442c58358..f2baf4607a7c 100644
--- a/fs/jfs/file.c
+++ b/fs/jfs/file.c
@@ -99,7 +99,7 @@ static int jfs_release(struct inode *inode, struct file *file)
 
 int jfs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int rc;
 
 	rc = inode_change_ok(inode, iattr);
diff --git a/fs/jfs/namei.c b/fs/jfs/namei.c
index 25e171702de6..52b8f462772f 100644
--- a/fs/jfs/namei.c
+++ b/fs/jfs/namei.c
@@ -346,7 +346,7 @@ static int jfs_rmdir(struct inode *dip, struct dentry *dentry)
 {
 	int rc;
 	tid_t tid;		/* transaction id */
-	struct inode *ip = dentry->d_inode;
+	struct inode *ip = d_inode(dentry);
 	ino_t ino;
 	struct component_name dname;
 	struct inode *iplist[2];
@@ -472,7 +472,7 @@ static int jfs_unlink(struct inode *dip, struct dentry *dentry)
 {
 	int rc;
 	tid_t tid;		/* transaction id */
-	struct inode *ip = dentry->d_inode;
+	struct inode *ip = d_inode(dentry);
 	ino_t ino;
 	struct component_name dname;	/* object name */
 	struct inode *iplist[2];
@@ -791,7 +791,7 @@ static int jfs_link(struct dentry *old_dentry,
 {
 	int rc;
 	tid_t tid;
-	struct inode *ip = old_dentry->d_inode;
+	struct inode *ip = d_inode(old_dentry);
 	ino_t ino;
 	struct component_name dname;
 	struct btstack btstack;
@@ -880,7 +880,7 @@ static int jfs_symlink(struct inode *dip, struct dentry *dentry,
 	struct component_name dname;
 	int ssize;		/* source pathname size */
 	struct btstack btstack;
-	struct inode *ip = dentry->d_inode;
+	struct inode *ip = d_inode(dentry);
 	unchar *i_fastsymlink;
 	s64 xlen = 0;
 	int bmask = 0, xsize;
@@ -1088,8 +1088,8 @@ static int jfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	dquot_initialize(old_dir);
 	dquot_initialize(new_dir);
 
-	old_ip = old_dentry->d_inode;
-	new_ip = new_dentry->d_inode;
+	old_ip = d_inode(old_dentry);
+	new_ip = d_inode(new_dentry);
 
 	if ((rc = get_UCSname(&old_dname, old_dentry)))
 		goto out1;
@@ -1502,9 +1502,9 @@ struct dentry *jfs_get_parent(struct dentry *dentry)
 	unsigned long parent_ino;
 
 	parent_ino =
-		le32_to_cpu(JFS_IP(dentry->d_inode)->i_dtroot.header.idotdot);
+		le32_to_cpu(JFS_IP(d_inode(dentry))->i_dtroot.header.idotdot);
 
-	return d_obtain_alias(jfs_iget(dentry->d_inode->i_sb, parent_ino));
+	return d_obtain_alias(jfs_iget(d_inode(dentry)->i_sb, parent_ino));
 }
 
 const struct inode_operations jfs_dir_inode_operations = {
@@ -1579,7 +1579,7 @@ static int jfs_ci_revalidate(struct dentry *dentry, unsigned int flags)
 	 * positive dentry isn't good idea. So it's unsupported like
 	 * rename("filename", "FILENAME") for now.
 	 */
-	if (dentry->d_inode)
+	if (d_really_is_positive(dentry))
 		return 1;
 
 	/*
diff --git a/fs/jfs/symlink.c b/fs/jfs/symlink.c
index 205b946d8e0d..80f42bcc4ef1 100644
--- a/fs/jfs/symlink.c
+++ b/fs/jfs/symlink.c
@@ -24,7 +24,7 @@
 
 static void *jfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	char *s = JFS_IP(dentry->d_inode)->i_inline;
+	char *s = JFS_IP(d_inode(dentry))->i_inline;
 	nd_set_link(nd, s);
 	return NULL;
 }
diff --git a/fs/jfs/xattr.c b/fs/jfs/xattr.c
index 42d67f9757bf..5b0fc2476c15 100644
--- a/fs/jfs/xattr.c
+++ b/fs/jfs/xattr.c
@@ -905,7 +905,7 @@ int __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,
 int jfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		 size_t value_len, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct jfs_inode_info *ji = JFS_IP(inode);
 	int rc;
 	tid_t tid;
@@ -920,7 +920,7 @@ int jfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 
 	tid = txBegin(inode->i_sb, 0);
 	mutex_lock(&ji->commit_mutex);
-	rc = __jfs_setxattr(tid, dentry->d_inode, name, value, value_len,
+	rc = __jfs_setxattr(tid, d_inode(dentry), name, value, value_len,
 			    flags);
 	if (!rc)
 		rc = txCommit(tid, 1, &inode, 0);
@@ -999,7 +999,7 @@ ssize_t jfs_getxattr(struct dentry *dentry, const char *name, void *data,
 			return -EOPNOTSUPP;
 	}
 
-	err = __jfs_getxattr(dentry->d_inode, name, data, buf_size);
+	err = __jfs_getxattr(d_inode(dentry), name, data, buf_size);
 
 	return err;
 }
@@ -1016,7 +1016,7 @@ static inline int can_list(struct jfs_ea *ea)
 
 ssize_t jfs_listxattr(struct dentry * dentry, char *data, size_t buf_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	char *buffer;
 	ssize_t size = 0;
 	int xattr_size;
@@ -1069,7 +1069,7 @@ ssize_t jfs_listxattr(struct dentry * dentry, char *data, size_t buf_size)
 
 int jfs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct jfs_inode_info *ji = JFS_IP(inode);
 	int rc;
 	tid_t tid;
@@ -1079,7 +1079,7 @@ int jfs_removexattr(struct dentry *dentry, const char *name)
 
 	tid = txBegin(inode->i_sb, 0);
 	mutex_lock(&ji->commit_mutex);
-	rc = __jfs_setxattr(tid, dentry->d_inode, name, NULL, 0, XATTR_REPLACE);
+	rc = __jfs_setxattr(tid, d_inode(dentry), name, NULL, 0, XATTR_REPLACE);
 	if (!rc)
 		rc = txCommit(tid, 1, &inode, 0);
 	txEnd(tid);
* Unmerged path fs/kernfs/dir.c
* Unmerged path fs/kernfs/inode.c
diff --git a/fs/logfs/dir.c b/fs/logfs/dir.c
index b82751082112..1fb996792e89 100644
--- a/fs/logfs/dir.c
+++ b/fs/logfs/dir.c
@@ -213,7 +213,7 @@ static void abort_transaction(struct inode *inode, struct logfs_transaction *ta)
 static int logfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct logfs_super *super = logfs_super(dir->i_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct logfs_transaction *ta;
 	struct page *page;
 	pgoff_t index;
@@ -271,7 +271,7 @@ static inline int logfs_empty_dir(struct inode *dir)
 
 static int logfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (!logfs_empty_dir(inode))
 		return -ENOTEMPTY;
@@ -556,7 +556,7 @@ static int logfs_symlink(struct inode *dir, struct dentry *dentry,
 static int logfs_link(struct dentry *old_dentry, struct inode *dir,
 		struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 	ihold(inode);
@@ -626,7 +626,7 @@ static int logfs_rename_cross(struct inode *old_dir, struct dentry *old_dentry,
 	/* 2. write target dd */
 	mutex_lock(&super->s_dirop_mutex);
 	logfs_add_transaction(new_dir, ta);
-	err = logfs_write_dir(new_dir, new_dentry, old_dentry->d_inode);
+	err = logfs_write_dir(new_dir, new_dentry, d_inode(old_dentry));
 	if (!err)
 		err = write_inode(new_dir);
 
@@ -677,8 +677,8 @@ static int logfs_rename_target(struct inode *old_dir, struct dentry *old_dentry,
 			       struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct logfs_super *super = logfs_super(old_dir->i_sb);
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	int isdir = S_ISDIR(old_inode->i_mode);
 	struct logfs_disk_dentry dd;
 	struct logfs_transaction *ta;
@@ -738,7 +738,7 @@ out:
 static int logfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			struct inode *new_dir, struct dentry *new_dentry)
 {
-	if (new_dentry->d_inode)
+	if (d_really_is_positive(new_dentry))
 		return logfs_rename_target(old_dir, old_dentry,
 					   new_dir, new_dentry);
 	return logfs_rename_cross(old_dir, old_dentry, new_dir, new_dentry);
diff --git a/fs/logfs/file.c b/fs/logfs/file.c
index c2219a6dd3c8..d9d4f34dc0d7 100644
--- a/fs/logfs/file.c
+++ b/fs/logfs/file.c
@@ -240,7 +240,7 @@ int logfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)
 
 static int logfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = 0;
 
 	err = inode_change_ok(inode, attr);
diff --git a/fs/minix/dir.c b/fs/minix/dir.c
index a9ed6f36e6ea..4431299289c4 100644
--- a/fs/minix/dir.c
+++ b/fs/minix/dir.c
@@ -160,7 +160,7 @@ minix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)
 {
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
-	struct inode * dir = dentry->d_parent->d_inode;
+	struct inode * dir = d_inode(dentry->d_parent);
 	struct super_block * sb = dir->i_sb;
 	struct minix_sb_info * sbi = minix_sb(sb);
 	unsigned long n;
@@ -207,7 +207,7 @@ found:
 
 int minix_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct super_block * sb = dir->i_sb;
diff --git a/fs/minix/file.c b/fs/minix/file.c
index adc6f5494231..cf43a28e6033 100644
--- a/fs/minix/file.c
+++ b/fs/minix/file.c
@@ -25,7 +25,7 @@ const struct file_operations minix_file_operations = {
 
 static int minix_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff --git a/fs/minix/inode.c b/fs/minix/inode.c
index 03aaeb1a694a..4d61d0686f14 100644
--- a/fs/minix/inode.c
+++ b/fs/minix/inode.c
@@ -625,8 +625,8 @@ static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)
 int minix_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct super_block *sb = dentry->d_sb;
-	generic_fillattr(dentry->d_inode, stat);
-	if (INODE_VERSION(dentry->d_inode) == MINIX_V1)
+	generic_fillattr(d_inode(dentry), stat);
+	if (INODE_VERSION(d_inode(dentry)) == MINIX_V1)
 		stat->blocks = (BLOCK_SIZE / 512) * V1_minix_blocks(stat->size, sb);
 	else
 		stat->blocks = (sb->s_blocksize / 512) * V2_minix_blocks(stat->size, sb);
diff --git a/fs/minix/namei.c b/fs/minix/namei.c
index 0db73d9dd668..f9443ecddb7e 100644
--- a/fs/minix/namei.c
+++ b/fs/minix/namei.c
@@ -92,7 +92,7 @@ out_fail:
 static int minix_link(struct dentry * old_dentry, struct inode * dir,
 	struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	inode->i_ctime = CURRENT_TIME_SEC;
 	inode_inc_link_count(inode);
@@ -139,7 +139,7 @@ out_dir:
 static int minix_unlink(struct inode * dir, struct dentry *dentry)
 {
 	int err = -ENOENT;
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct page * page;
 	struct minix_dir_entry * de;
 
@@ -159,7 +159,7 @@ end_unlink:
 
 static int minix_rmdir(struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (minix_empty_dir(inode)) {
@@ -175,8 +175,8 @@ static int minix_rmdir(struct inode * dir, struct dentry *dentry)
 static int minix_rename(struct inode * old_dir, struct dentry *old_dentry,
 			   struct inode * new_dir, struct dentry *new_dentry)
 {
-	struct inode * old_inode = old_dentry->d_inode;
-	struct inode * new_inode = new_dentry->d_inode;
+	struct inode * old_inode = d_inode(old_dentry);
+	struct inode * new_inode = d_inode(new_dentry);
 	struct page * dir_page = NULL;
 	struct minix_dir_entry * dir_de = NULL;
 	struct page * old_page;
* Unmerged path fs/ncpfs/dir.c
* Unmerged path fs/ncpfs/inode.c
* Unmerged path fs/ncpfs/ioctl.c
diff --git a/fs/ncpfs/ncplib_kernel.c b/fs/ncpfs/ncplib_kernel.c
index 981a95617fc9..a7927448f696 100644
--- a/fs/ncpfs/ncplib_kernel.c
+++ b/fs/ncpfs/ncplib_kernel.c
@@ -729,7 +729,7 @@ int
 ncp_del_file_or_subdir2(struct ncp_server *server,
 			struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	__u8  volnum;
 	__le32 dirent;
 
diff --git a/fs/ncpfs/symlink.c b/fs/ncpfs/symlink.c
index 52439ddc8de0..696b1b13a529 100644
--- a/fs/ncpfs/symlink.c
+++ b/fs/ncpfs/symlink.c
@@ -156,7 +156,7 @@ int ncp_symlink(struct inode *dir, struct dentry *dentry, const char *symname) {
 		goto failfree;
 	}
 
-	inode=dentry->d_inode;
+	inode=d_inode(dentry);
 
 	if (ncp_make_open(inode, O_WRONLY))
 		goto failfree;
* Unmerged path fs/nfs/dir.c
diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c
index 4a8b07b63ffa..16272902306e 100644
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@ -413,8 +413,8 @@ static void nfs_direct_complete(struct nfs_direct_req *dreq, bool write)
 static void nfs_direct_readpage_release(struct nfs_page *req)
 {
 	dprintk("NFS: direct read done (%s/%llu %d@%lld)\n",
-		req->wb_context->dentry->d_inode->i_sb->s_id,
-		(unsigned long long)NFS_FILEID(req->wb_context->dentry->d_inode),
+		d_inode(req->wb_context->dentry)->i_sb->s_id,
+		(unsigned long long)NFS_FILEID(d_inode(req->wb_context->dentry)),
 		req->wb_bytes,
 		(long long)req_offset(req));
 	nfs_release_request(req);
diff --git a/fs/nfs/getroot.c b/fs/nfs/getroot.c
index b94f80420a58..9bb4d5afaa2b 100644
--- a/fs/nfs/getroot.c
+++ b/fs/nfs/getroot.c
@@ -56,11 +56,11 @@ static int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *i
 		 * This again causes shrink_dcache_for_umount_subtree() to
 		 * Oops, since the test for IS_ROOT() will fail.
 		 */
-		spin_lock(&sb->s_root->d_inode->i_lock);
+		spin_lock(&d_inode(sb->s_root)->i_lock);
 		spin_lock(&sb->s_root->d_lock);
 		hlist_del_init(&sb->s_root->d_alias);
 		spin_unlock(&sb->s_root->d_lock);
-		spin_unlock(&sb->s_root->d_inode->i_lock);
+		spin_unlock(&d_inode(sb->s_root)->i_lock);
 	}
 	return 0;
 }
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 5652ae6d3794..92fe4f0e5fc6 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -503,7 +503,7 @@ EXPORT_SYMBOL_GPL(nfs_fhget);
 int
 nfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nfs_fattr *fattr;
 	int error = 0;
 
@@ -632,7 +632,7 @@ static void nfs_request_parent_use_readdirplus(struct dentry *dentry)
 	struct dentry *parent;
 
 	parent = dget_parent(dentry);
-	nfs_force_use_readdirplus(parent->d_inode);
+	nfs_force_use_readdirplus(d_inode(parent));
 	dput(parent);
 }
 
@@ -648,7 +648,7 @@ static bool nfs_need_revalidate_inode(struct inode *inode)
 
 int nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int need_atime = NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATIME;
 	int err = 0;
 
@@ -722,7 +722,7 @@ static struct nfs_lock_context *__nfs_find_lock_context(struct nfs_open_context
 struct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)
 {
 	struct nfs_lock_context *res, *new = NULL;
-	struct inode *inode = ctx->dentry->d_inode;
+	struct inode *inode = d_inode(ctx->dentry);
 
 	spin_lock(&inode->i_lock);
 	res = __nfs_find_lock_context(ctx);
@@ -750,7 +750,7 @@ EXPORT_SYMBOL_GPL(nfs_get_lock_context);
 void nfs_put_lock_context(struct nfs_lock_context *l_ctx)
 {
 	struct nfs_open_context *ctx = l_ctx->open_context;
-	struct inode *inode = ctx->dentry->d_inode;
+	struct inode *inode = d_inode(ctx->dentry);
 
 	if (!atomic_dec_and_lock(&l_ctx->count, &inode->i_lock))
 		return;
@@ -777,7 +777,7 @@ void nfs_close_context(struct nfs_open_context *ctx, int is_sync)
 		return;
 	if (!is_sync)
 		return;
-	inode = ctx->dentry->d_inode;
+	inode = d_inode(ctx->dentry);
 	if (!list_empty(&NFS_I(inode)->open_files))
 		return;
 	server = NFS_SERVER(inode);
@@ -824,7 +824,7 @@ EXPORT_SYMBOL_GPL(get_nfs_open_context);
 
 static void __put_nfs_open_context(struct nfs_open_context *ctx, int is_sync)
 {
-	struct inode *inode = ctx->dentry->d_inode;
+	struct inode *inode = d_inode(ctx->dentry);
 	struct super_block *sb = ctx->dentry->d_sb;
 
 	if (!list_empty(&ctx->list)) {
@@ -861,7 +861,7 @@ static void put_nfs_open_context_sync(struct nfs_open_context *ctx)
  */
 void nfs_inode_attach_open_context(struct nfs_open_context *ctx)
 {
-	struct inode *inode = ctx->dentry->d_inode;
+	struct inode *inode = d_inode(ctx->dentry);
 	struct nfs_inode *nfsi = NFS_I(inode);
 
 	spin_lock(&inode->i_lock);
@@ -904,7 +904,7 @@ void nfs_file_clear_open_context(struct file *filp)
 	struct nfs_open_context *ctx = nfs_file_open_context(filp);
 
 	if (ctx) {
-		struct inode *inode = ctx->dentry->d_inode;
+		struct inode *inode = d_inode(ctx->dentry);
 
 		filp->private_data = NULL;
 		spin_lock(&inode->i_lock);
diff --git a/fs/nfs/namespace.c b/fs/nfs/namespace.c
index b5a0afc3ee10..c8162c660c44 100644
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@ -139,7 +139,7 @@ EXPORT_SYMBOL_GPL(nfs_path);
 struct vfsmount *nfs_d_automount(struct path *path)
 {
 	struct vfsmount *mnt;
-	struct nfs_server *server = NFS_SERVER(path->dentry->d_inode);
+	struct nfs_server *server = NFS_SERVER(d_inode(path->dentry));
 	struct nfs_fh *fh = NULL;
 	struct nfs_fattr *fattr = NULL;
 
@@ -180,16 +180,16 @@ out_nofree:
 static int
 nfs_namespace_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	if (NFS_FH(dentry->d_inode)->size != 0)
+	if (NFS_FH(d_inode(dentry))->size != 0)
 		return nfs_getattr(mnt, dentry, stat);
-	generic_fillattr(dentry->d_inode, stat);
+	generic_fillattr(d_inode(dentry), stat);
 	return 0;
 }
 
 static int
 nfs_namespace_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	if (NFS_FH(dentry->d_inode)->size != 0)
+	if (NFS_FH(d_inode(dentry))->size != 0)
 		return nfs_setattr(dentry, attr);
 	return -EACCES;
 }
@@ -279,7 +279,7 @@ struct vfsmount *nfs_submount(struct nfs_server *server, struct dentry *dentry,
 	struct dentry *parent = dget_parent(dentry);
 
 	/* Look it up again to get its attributes */
-	err = server->nfs_client->rpc_ops->lookup(parent->d_inode, &dentry->d_name, fh, fattr, NULL);
+	err = server->nfs_client->rpc_ops->lookup(d_inode(parent), &dentry->d_name, fh, fattr, NULL);
 	dput(parent);
 	if (err != 0)
 		return ERR_PTR(err);
* Unmerged path fs/nfs/nfs3acl.c
* Unmerged path fs/nfs/nfs3proc.c
diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
index d0556aae62bf..78b73f0be783 100644
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@ -1133,7 +1133,7 @@ error:
  */
 static int nfs_probe_destination(struct nfs_server *server)
 {
-	struct inode *inode = server->super->s_root->d_inode;
+	struct inode *inode = d_inode(server->super->s_root);
 	struct nfs_fattr *fattr;
 	int error;
 
diff --git a/fs/nfs/nfs4file.c b/fs/nfs/nfs4file.c
index 75f15320a424..83859b2fa1ad 100644
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@ -51,7 +51,7 @@ nfs4_file_open(struct inode *inode, struct file *filp)
 	openflags &= ~(O_CREAT|O_EXCL);
 
 	parent = dget_parent(dentry);
-	dir = parent->d_inode;
+	dir = d_inode(parent);
 
 	ctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);
 	err = PTR_ERR(ctx);
@@ -79,7 +79,7 @@ nfs4_file_open(struct inode *inode, struct file *filp)
 			goto out_drop;
 		}
 	}
-	if (inode != dentry->d_inode)
+	if (inode != d_inode(dentry))
 		goto out_drop;
 
 	nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
diff --git a/fs/nfs/nfs4namespace.c b/fs/nfs/nfs4namespace.c
index 3d83cb1fdc70..f592672373cb 100644
--- a/fs/nfs/nfs4namespace.c
+++ b/fs/nfs/nfs4namespace.c
@@ -375,7 +375,7 @@ static struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *
 	dprintk("%s: getting locations for %pd2\n",
 		__func__, dentry);
 
-	err = nfs4_proc_fs_locations(client, parent->d_inode, &dentry->d_name, fs_locations, page);
+	err = nfs4_proc_fs_locations(client, d_inode(parent), &dentry->d_name, fs_locations, page);
 	dput(parent);
 	if (err != 0 ||
 	    fs_locations->nlocations <= 0 ||
@@ -396,7 +396,7 @@ struct vfsmount *nfs4_submount(struct nfs_server *server, struct dentry *dentry,
 {
 	rpc_authflavor_t flavor = server->client->cl_auth->au_flavor;
 	struct dentry *parent = dget_parent(dentry);
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct qstr *name = &dentry->d_name;
 	struct rpc_clnt *client;
 	struct vfsmount *mnt;
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 3f8fa33bc34b..108d7ef916e0 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -295,7 +295,7 @@ static void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dent
 		*p++ = xdr_one;                         /* bitmap length */
 		*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */
 		*p++ = htonl(8);              /* attribute buffer length */
-		p = xdr_encode_hyper(p, NFS_FILEID(dentry->d_inode));
+		p = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry)));
 	}
 	
 	*p++ = xdr_one;                                  /* next */
@@ -307,7 +307,7 @@ static void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dent
 	*p++ = xdr_one;                         /* bitmap length */
 	*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */
 	*p++ = htonl(8);              /* attribute buffer length */
-	p = xdr_encode_hyper(p, NFS_FILEID(dentry->d_parent->d_inode));
+	p = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry->d_parent)));
 
 	readdir->pgbase = (char *)p - (char *)start;
 	readdir->count -= readdir->pgbase;
@@ -1076,7 +1076,7 @@ static struct nfs4_opendata *nfs4_opendata_alloc(struct dentry *dentry,
 		gfp_t gfp_mask)
 {
 	struct dentry *parent = dget_parent(dentry);
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct nfs_server *server = NFS_SERVER(dir);
 	struct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
 	struct nfs4_opendata *p;
@@ -1133,7 +1133,7 @@ static struct nfs4_opendata *nfs4_opendata_alloc(struct dentry *dentry,
 	case NFS4_OPEN_CLAIM_FH:
 	case NFS4_OPEN_CLAIM_DELEG_CUR_FH:
 	case NFS4_OPEN_CLAIM_DELEG_PREV_FH:
-		p->o_arg.fh = NFS_FH(dentry->d_inode);
+		p->o_arg.fh = NFS_FH(d_inode(dentry));
 	}
 	if (attrs != NULL && attrs->ia_valid != 0) {
 		__u32 verf[2];
@@ -1922,7 +1922,7 @@ static const struct rpc_call_ops nfs4_open_confirm_ops = {
  */
 static int _nfs4_proc_open_confirm(struct nfs4_opendata *data)
 {
-	struct nfs_server *server = NFS_SERVER(data->dir->d_inode);
+	struct nfs_server *server = NFS_SERVER(d_inode(data->dir));
 	struct rpc_task *task;
 	struct  rpc_message msg = {
 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],
@@ -2082,7 +2082,7 @@ static const struct rpc_call_ops nfs4_open_ops = {
 
 static int nfs4_run_open_task(struct nfs4_opendata *data, int isrecover)
 {
-	struct inode *dir = data->dir->d_inode;
+	struct inode *dir = d_inode(data->dir);
 	struct nfs_server *server = NFS_SERVER(dir);
 	struct nfs_openargs *o_arg = &data->o_arg;
 	struct nfs_openres *o_res = &data->o_res;
@@ -2129,7 +2129,7 @@ static int nfs4_run_open_task(struct nfs4_opendata *data, int isrecover)
 
 static int _nfs4_recover_proc_open(struct nfs4_opendata *data)
 {
-	struct inode *dir = data->dir->d_inode;
+	struct inode *dir = d_inode(data->dir);
 	struct nfs_openres *o_res = &data->o_res;
         int status;
 
@@ -2198,7 +2198,7 @@ static int nfs4_opendata_access(struct rpc_cred *cred,
  */
 static int _nfs4_proc_open(struct nfs4_opendata *data)
 {
-	struct inode *dir = data->dir->d_inode;
+	struct inode *dir = d_inode(data->dir);
 	struct nfs_server *server = NFS_SERVER(dir);
 	struct nfs_openargs *o_arg = &data->o_arg;
 	struct nfs_openres *o_res = &data->o_res;
@@ -2455,7 +2455,7 @@ static int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,
 		set_bit(NFS_STATE_POSIX_LOCKS, &state->flags);
 
 	dentry = opendata->dentry;
-	if (dentry->d_inode == NULL) {
+	if (d_really_is_negative(dentry)) {
 		/* FIXME: Is this d_drop() ever needed? */
 		d_drop(dentry);
 		dentry = d_add_unique(dentry, igrab(state->inode));
@@ -2466,7 +2466,7 @@ static int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,
 			ctx->dentry = dentry;
 		}
 		nfs_set_verifier(dentry,
-				nfs_save_change_attribute(opendata->dir->d_inode));
+				nfs_save_change_attribute(d_inode(opendata->dir)));
 	}
 
 	ret = nfs4_opendata_access(sp->so_cred, opendata, state, fmode, flags);
@@ -2474,7 +2474,7 @@ static int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,
 		goto out;
 
 	ctx->state = state;
-	if (dentry->d_inode == state->inode) {
+	if (d_inode(dentry) == state->inode) {
 		nfs_inode_attach_open_context(ctx);
 		if (read_seqcount_retry(&sp->so_reclaim_seqcount, seq))
 			nfs4_schedule_stateid_recovery(server, state);
@@ -2515,10 +2515,10 @@ static int _nfs4_do_open(struct inode *dir,
 	status = nfs4_recover_expired_lease(server);
 	if (status != 0)
 		goto err_put_state_owner;
-	if (dentry->d_inode != NULL)
-		nfs4_return_incompatible_delegation(dentry->d_inode, fmode);
+	if (d_really_is_positive(dentry))
+		nfs4_return_incompatible_delegation(d_inode(dentry), fmode);
 	status = -ENOMEM;
-	if (dentry->d_inode)
+	if (d_really_is_positive(dentry))
 		claim = NFS4_OPEN_CLAIM_FH;
 	opendata = nfs4_opendata_alloc(dentry, sp, fmode, flags, sattr,
 			label, claim, GFP_KERNEL);
@@ -2541,8 +2541,8 @@ static int _nfs4_do_open(struct inode *dir,
 		}
 		opendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];
 	}
-	if (dentry->d_inode != NULL)
-		opendata->state = nfs4_get_open_state(dentry->d_inode, sp);
+	if (d_really_is_positive(dentry))
+		opendata->state = nfs4_get_open_state(d_inode(dentry), sp);
 
 	status = _nfs4_open_and_get_state(opendata, fmode, flags, ctx);
 	if (status != 0)
@@ -3437,7 +3437,7 @@ static int
 nfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,
 		  struct iattr *sattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct rpc_cred *cred = NULL;
 	struct nfs4_state *state = NULL;
 	struct nfs4_label *label = NULL;
@@ -4055,13 +4055,13 @@ static int nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,
 static int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,
 		u64 cookie, struct page **pages, unsigned int count, int plus)
 {
-	struct inode		*dir = dentry->d_inode;
+	struct inode		*dir = d_inode(dentry);
 	struct nfs4_readdir_arg args = {
 		.fh = NFS_FH(dir),
 		.pages = pages,
 		.pgbase = 0,
 		.count = count,
-		.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,
+		.bitmask = NFS_SERVER(d_inode(dentry))->attr_bitmask,
 		.plus = plus,
 	};
 	struct nfs4_readdir_res res;
@@ -4098,8 +4098,8 @@ static int nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,
 	do {
 		err = _nfs4_proc_readdir(dentry, cred, cookie,
 				pages, count, plus);
-		trace_nfs4_readdir(dentry->d_inode, err);
-		err = nfs4_handle_exception(NFS_SERVER(dentry->d_inode), err,
+		trace_nfs4_readdir(d_inode(dentry), err);
+		err = nfs4_handle_exception(NFS_SERVER(d_inode(dentry)), err,
 				&exception);
 	} while (exception.retry);
 	return err;
@@ -5013,7 +5013,7 @@ nfs4_set_security_label(struct dentry *dentry, const void *buf, size_t buflen)
 	struct nfs4_label ilabel, *olabel = NULL;
 	struct nfs_fattr fattr;
 	struct rpc_cred *cred;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int status;
 
 	if (!nfs_server_capable(inode, NFS_CAP_SECURITY_LABEL))
@@ -5775,7 +5775,7 @@ static void nfs4_lock_done(struct rpc_task *task, void *calldata)
 	data->rpc_status = task->tk_status;
 	switch (task->tk_status) {
 	case 0:
-		renew_lease(NFS_SERVER(data->ctx->dentry->d_inode),
+		renew_lease(NFS_SERVER(d_inode(data->ctx->dentry)),
 				data->timestamp);
 		if (data->arg.new_lock) {
 			data->fl.fl_flags &= ~(FL_SLEEP | FL_ACCESS);
@@ -6218,7 +6218,7 @@ static int nfs4_xattr_set_nfs4_acl(struct dentry *dentry, const char *key,
 	if (strcmp(key, "") != 0)
 		return -EINVAL;
 
-	return nfs4_proc_set_acl(dentry->d_inode, buf, buflen);
+	return nfs4_proc_set_acl(d_inode(dentry), buf, buflen);
 }
 
 static int nfs4_xattr_get_nfs4_acl(struct dentry *dentry, const char *key,
@@ -6227,7 +6227,7 @@ static int nfs4_xattr_get_nfs4_acl(struct dentry *dentry, const char *key,
 	if (strcmp(key, "") != 0)
 		return -EINVAL;
 
-	return nfs4_proc_get_acl(dentry->d_inode, buf, buflen);
+	return nfs4_proc_get_acl(d_inode(dentry), buf, buflen);
 }
 
 static size_t nfs4_xattr_list_nfs4_acl(struct dentry *dentry, char *list,
@@ -6236,7 +6236,7 @@ static size_t nfs4_xattr_list_nfs4_acl(struct dentry *dentry, char *list,
 {
 	size_t len = sizeof(XATTR_NAME_NFSV4_ACL);
 
-	if (!nfs4_server_supports_acls(NFS_SERVER(dentry->d_inode)))
+	if (!nfs4_server_supports_acls(NFS_SERVER(d_inode(dentry))))
 		return 0;
 
 	if (list && len <= list_len)
@@ -6264,7 +6264,7 @@ static int nfs4_xattr_get_nfs4_label(struct dentry *dentry, const char *key,
 				   void *buf, size_t buflen, int type)
 {
 	if (security_ismaclabel(key))
-		return nfs4_get_security_label(dentry->d_inode, buf, buflen);
+		return nfs4_get_security_label(d_inode(dentry), buf, buflen);
 	return -EOPNOTSUPP;
 }
 
@@ -6274,10 +6274,10 @@ static size_t nfs4_xattr_list_nfs4_label(struct dentry *dentry, char *list,
 {
 	size_t len = 0;
 
-	if (nfs_server_capable(dentry->d_inode, NFS_CAP_SECURITY_LABEL)) {
-		len = security_inode_listsecurity(dentry->d_inode, NULL, 0);
+	if (nfs_server_capable(d_inode(dentry), NFS_CAP_SECURITY_LABEL)) {
+		len = security_inode_listsecurity(d_inode(dentry), NULL, 0);
 		if (list && len <= list_len)
-			security_inode_listsecurity(dentry->d_inode, list, len);
+			security_inode_listsecurity(d_inode(dentry), list, len);
 	}
 	return len;
 }
diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
index 0611694af1c6..e98192fa998b 100644
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -1899,7 +1899,7 @@ static int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)
 		goto out;
 	}
 
-	inode = server->super->s_root->d_inode;
+	inode = d_inode(server->super->s_root);
 	result = nfs4_proc_get_locations(inode, locations, page, cred);
 	if (result) {
 		dprintk("<-- %s: failed to retrieve fs_locations: %d\n",
@@ -2018,7 +2018,7 @@ restart:
 
 		rcu_read_unlock();
 
-		inode = server->super->s_root->d_inode;
+		inode = d_inode(server->super->s_root);
 		status = nfs4_proc_fsid_present(inode, cred);
 		if (status != -NFS4ERR_MOVED)
 			goto restart;	/* wasn't this one */
diff --git a/fs/nfs/nfs4trace.h b/fs/nfs/nfs4trace.h
index e86782b3460b..671cf68fe56b 100644
--- a/fs/nfs/nfs4trace.h
+++ b/fs/nfs/nfs4trace.h
@@ -418,7 +418,7 @@ DECLARE_EVENT_CLASS(nfs4_open_event,
 				__entry->fileid = 0;
 				__entry->fhandle = 0;
 			}
-			__entry->dir = NFS_FILEID(ctx->dentry->d_parent->d_inode);
+			__entry->dir = NFS_FILEID(d_inode(ctx->dentry->d_parent));
 			__assign_str(name, ctx->dentry->d_name.name);
 		),
 
@@ -1170,7 +1170,7 @@ TRACE_EVENT(nfs4_layoutget,
 		),
 
 		TP_fast_assign(
-			const struct inode *inode = ctx->dentry->d_inode;
+			const struct inode *inode = d_inode(ctx->dentry);
 			__entry->dev = inode->i_sb->s_dev;
 			__entry->fileid = NFS_FILEID(inode);
 			__entry->fhandle = nfs_fhandle_hash(NFS_FH(inode));
* Unmerged path fs/nfs/pagelist.c
diff --git a/fs/nfs/pnfs.h b/fs/nfs/pnfs.h
index 36a0c1c82c9e..ac2f46664263 100644
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@ -438,7 +438,7 @@ static inline bool
 pnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,
 			 struct nfs_commit_info *cinfo, u32 ds_commit_idx)
 {
-	struct inode *inode = req->wb_context->dentry->d_inode;
+	struct inode *inode = d_inode(req->wb_context->dentry);
 	struct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;
 
 	if (lseg == NULL || ld->mark_request_commit == NULL)
@@ -450,7 +450,7 @@ pnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,
 static inline bool
 pnfs_clear_request_commit(struct nfs_page *req, struct nfs_commit_info *cinfo)
 {
-	struct inode *inode = req->wb_context->dentry->d_inode;
+	struct inode *inode = d_inode(req->wb_context->dentry);
 	struct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;
 
 	if (ld == NULL || ld->clear_request_commit == NULL)
diff --git a/fs/nfs/proc.c b/fs/nfs/proc.c
index c63189acd052..b417bbcd9704 100644
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@ -118,7 +118,7 @@ static int
 nfs_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,
 		 struct iattr *sattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nfs_sattrargs	arg = { 
 		.fh	= NFS_FH(inode),
 		.sattr	= sattr
@@ -487,7 +487,7 @@ static int
 nfs_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,
 		 u64 cookie, struct page **pages, unsigned int count, int plus)
 {
-	struct inode		*dir = dentry->d_inode;
+	struct inode		*dir = d_inode(dentry);
 	struct nfs_readdirargs	arg = {
 		.fh		= NFS_FH(dir),
 		.cookie		= cookie,
* Unmerged path fs/nfs/read.c
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index 1ca3c680d778..30d42e7372a2 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -432,7 +432,7 @@ int nfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct nfs_server *server = NFS_SB(dentry->d_sb);
 	unsigned char blockbits;
 	unsigned long blockres;
-	struct nfs_fh *fh = NFS_FH(dentry->d_inode);
+	struct nfs_fh *fh = NFS_FH(d_inode(dentry));
 	struct nfs_fsstat res;
 	int error = -ENOMEM;
 
@@ -446,7 +446,7 @@ int nfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 		pd_dentry = dget_parent(dentry);
 		if (pd_dentry != NULL) {
-			nfs_zap_caches(pd_dentry->d_inode);
+			nfs_zap_caches(d_inode(pd_dentry));
 			dput(pd_dentry);
 		}
 	}
@@ -2522,7 +2522,7 @@ int nfs_clone_sb_security(struct super_block *s, struct dentry *mntroot,
 			  struct nfs_mount_info *mount_info)
 {
 	/* clone any lsm security options from the parent to the new sb */
-	if (mntroot->d_inode->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops)
+	if (d_inode(mntroot)->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops)
 		return -ESTALE;
 	return security_sb_clone_mnt_opts(mount_info->cloned->sb, s);
 }
diff --git a/fs/nfs/symlink.c b/fs/nfs/symlink.c
index 05c9e02f4153..2d56200655fe 100644
--- a/fs/nfs/symlink.c
+++ b/fs/nfs/symlink.c
@@ -45,7 +45,7 @@ error:
 
 static void *nfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct page *page;
 	void *err;
 
diff --git a/fs/nfs/unlink.c b/fs/nfs/unlink.c
index de54129336c6..fa538b2ba251 100644
--- a/fs/nfs/unlink.c
+++ b/fs/nfs/unlink.c
@@ -143,7 +143,7 @@ static int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct n
 		nfs_free_dname(data);
 		ret = nfs_copy_dname(alias, data);
 		spin_lock(&alias->d_lock);
-		if (ret == 0 && alias->d_inode != NULL &&
+		if (ret == 0 && d_really_is_positive(alias) &&
 		    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {
 			devname_garbage = alias->d_fsdata;
 			alias->d_fsdata = data;
@@ -190,7 +190,7 @@ static int nfs_call_unlink(struct dentry *dentry, struct nfs_unlinkdata *data)
 	parent = dget_parent(dentry);
 	if (parent == NULL)
 		goto out_free;
-	dir = parent->d_inode;
+	dir = d_inode(parent);
 	/* Non-exclusive lock protects against concurrent lookup() calls */
 	spin_lock(&dir->i_lock);
 	if (atomic_inc_not_zero(&NFS_I(dir)->silly_count) == 0) {
@@ -210,21 +210,21 @@ out_free:
 
 void nfs_wait_on_sillyrename(struct dentry *dentry)
 {
-	struct nfs_inode *nfsi = NFS_I(dentry->d_inode);
+	struct nfs_inode *nfsi = NFS_I(d_inode(dentry));
 
 	wait_event(nfsi->waitqueue, atomic_read(&nfsi->silly_count) <= 1);
 }
 
 void nfs_block_sillyrename(struct dentry *dentry)
 {
-	struct nfs_inode *nfsi = NFS_I(dentry->d_inode);
+	struct nfs_inode *nfsi = NFS_I(d_inode(dentry));
 
 	wait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);
 }
 
 void nfs_unblock_sillyrename(struct dentry *dentry)
 {
-	struct inode *dir = dentry->d_inode;
+	struct inode *dir = d_inode(dentry);
 	struct nfs_inode *nfsi = NFS_I(dir);
 	struct nfs_unlinkdata *data;
 
@@ -367,8 +367,8 @@ static void nfs_async_rename_release(void *calldata)
 	struct nfs_renamedata	*data = calldata;
 	struct super_block *sb = data->old_dir->i_sb;
 
-	if (data->old_dentry->d_inode)
-		nfs_mark_for_revalidate(data->old_dentry->d_inode);
+	if (d_really_is_positive(data->old_dentry))
+		nfs_mark_for_revalidate(d_inode(data->old_dentry));
 
 	dput(data->old_dentry);
 	dput(data->new_dentry);
@@ -529,10 +529,10 @@ nfs_sillyrename(struct inode *dir, struct dentry *dentry)
 	if (dentry->d_flags & DCACHE_NFSFS_RENAMED)
 		goto out;
 
-	fileid = NFS_FILEID(dentry->d_inode);
+	fileid = NFS_FILEID(d_inode(dentry));
 
 	/* Return delegation in anticipation of the rename */
-	NFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);
+	NFS_PROTO(d_inode(dentry))->return_delegation(d_inode(dentry));
 
 	sdentry = NULL;
 	do {
@@ -554,7 +554,7 @@ nfs_sillyrename(struct inode *dir, struct dentry *dentry)
 		 */
 		if (IS_ERR(sdentry))
 			goto out;
-	} while (sdentry->d_inode != NULL); /* need negative lookup */
+	} while (d_inode(sdentry) != NULL); /* need negative lookup */
 
 	/* queue unlink first. Can't do this from rpc_release as it
 	 * has to allocate memory
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 7614d127a554..e2b6c276ab53 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -702,7 +702,7 @@ static void nfs_inode_add_request(struct inode *inode, struct nfs_page *req)
  */
 static void nfs_inode_remove_request(struct nfs_page *req)
 {
-	struct inode *inode = req->wb_context->dentry->d_inode;
+	struct inode *inode = d_inode(req->wb_context->dentry);
 	struct nfs_inode *nfsi = NFS_I(inode);
 	struct nfs_page *head;
 
@@ -866,7 +866,7 @@ static void
 nfs_clear_request_commit(struct nfs_page *req)
 {
 	if (test_bit(PG_CLEAN, &req->wb_flags)) {
-		struct inode *inode = req->wb_context->dentry->d_inode;
+		struct inode *inode = d_inode(req->wb_context->dentry);
 		struct nfs_commit_info cinfo;
 
 		nfs_init_cinfo_from_inode(&cinfo, inode);
@@ -1576,7 +1576,7 @@ void nfs_init_commit(struct nfs_commit_data *data,
 		     struct nfs_commit_info *cinfo)
 {
 	struct nfs_page *first = nfs_list_entry(head->next);
-	struct inode *inode = first->wb_context->dentry->d_inode;
+	struct inode *inode = d_inode(first->wb_context->dentry);
 
 	/* Set up the RPC argument and reply structs
 	 * NB: take care not to mess about with data->commit et al. */
@@ -1678,7 +1678,7 @@ static void nfs_commit_release_pages(struct nfs_commit_data *data)
 
 		dprintk("NFS:       commit (%s/%llu %d@%lld)",
 			req->wb_context->dentry->d_sb->s_id,
-			(unsigned long long)NFS_FILEID(req->wb_context->dentry->d_inode),
+			(unsigned long long)NFS_FILEID(d_inode(req->wb_context->dentry)),
 			req->wb_bytes,
 			(long long)req_offset(req));
 		if (status < 0) {
diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index 639d8c2470ca..62a92b814706 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -599,7 +599,7 @@ static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)
 				goto out4;
 		}
 
-		err = check_export(exp.ex_path.dentry->d_inode, &exp.ex_flags,
+		err = check_export(d_inode(exp.ex_path.dentry), &exp.ex_flags,
 				   exp.ex_uuid);
 		if (err)
 			goto out4;
@@ -891,7 +891,7 @@ exp_rootfh(struct net *net, struct auth_domain *clp, char *name,
 		printk("nfsd: exp_rootfh path not found %s", name);
 		return err;
 	}
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 
 	dprintk("nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\n",
 		 name, path.dentry, clp->name,
* Unmerged path fs/nfsd/nfs2acl.c
* Unmerged path fs/nfsd/nfs3acl.c
diff --git a/fs/nfsd/nfs3proc.c b/fs/nfsd/nfs3proc.c
index 12f2aab4f614..7b755b7f785c 100644
--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@ -166,7 +166,7 @@ nfsd3_proc_read(struct svc_rqst *rqstp, struct nfsd3_readargs *argp,
 			   	  rqstp->rq_vec, argp->vlen,
 				  &resp->count);
 	if (nfserr == 0) {
-		struct inode	*inode = resp->fh.fh_dentry->d_inode;
+		struct inode	*inode = d_inode(resp->fh.fh_dentry);
 
 		resp->eof = (argp->offset + resp->count) >= inode->i_size;
 	}
@@ -551,7 +551,7 @@ nfsd3_proc_fsinfo(struct svc_rqst * rqstp, struct nfsd_fhandle    *argp,
 	 * different read/write sizes for file systems known to have
 	 * problems with large blocks */
 	if (nfserr == 0) {
-		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
+		struct super_block *sb = d_inode(argp->fh.fh_dentry)->i_sb;
 
 		/* Note that we don't care for remote fs's here */
 		if (sb->s_magic == MSDOS_SUPER_MAGIC) {
@@ -587,7 +587,7 @@ nfsd3_proc_pathconf(struct svc_rqst * rqstp, struct nfsd_fhandle      *argp,
 	nfserr = fh_verify(rqstp, &argp->fh, 0, NFSD_MAY_NOP);
 
 	if (nfserr == 0) {
-		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
+		struct super_block *sb = d_inode(argp->fh.fh_dentry)->i_sb;
 
 		/* Note that we don't care for remote fs's here */
 		switch (sb->s_magic) {
diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.c
index 39c5eb3ad33a..e4b2b4322553 100644
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@ -146,7 +146,7 @@ static __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)
 	default:
 	case FSIDSOURCE_DEV:
 		p = xdr_encode_hyper(p, (u64)huge_encode_dev
-				     (fhp->fh_dentry->d_inode->i_sb->s_dev));
+				     (d_inode(fhp->fh_dentry)->i_sb->s_dev));
 		break;
 	case FSIDSOURCE_FSID:
 		p = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);
@@ -203,14 +203,14 @@ static __be32 *
 encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 {
 	struct dentry *dentry = fhp->fh_dentry;
-	if (dentry && dentry->d_inode) {
+	if (dentry && d_really_is_positive(dentry)) {
 	        __be32 err;
 		struct kstat stat;
 
 		err = fh_getattr(fhp, &stat);
 		if (!err) {
 			*p++ = xdr_one;		/* attributes follow */
-			lease_get_mtime(dentry->d_inode, &stat.mtime);
+			lease_get_mtime(d_inode(dentry), &stat.mtime);
 			return encode_fattr3(rqstp, p, fhp, &stat);
 		}
 	}
@@ -233,7 +233,7 @@ encode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 {
 	struct dentry	*dentry = fhp->fh_dentry;
 
-	if (dentry && dentry->d_inode && fhp->fh_post_saved) {
+	if (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {
 		if (fhp->fh_pre_saved) {
 			*p++ = xdr_one;
 			p = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);
@@ -260,11 +260,11 @@ void fill_post_wcc(struct svc_fh *fhp)
 		printk("nfsd: inode locked twice during operation.\n");
 
 	err = fh_getattr(fhp, &fhp->fh_post_attr);
-	fhp->fh_post_change = fhp->fh_dentry->d_inode->i_version;
+	fhp->fh_post_change = d_inode(fhp->fh_dentry)->i_version;
 	if (err) {
 		fhp->fh_post_saved = 0;
 		/* Grab the ctime anyway - set_change_info might use it */
-		fhp->fh_post_attr.ctime = fhp->fh_dentry->d_inode->i_ctime;
+		fhp->fh_post_attr.ctime = d_inode(fhp->fh_dentry)->i_ctime;
 	} else
 		fhp->fh_post_saved = 1;
 }
@@ -628,7 +628,7 @@ nfs3svc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,
 					struct nfsd3_attrstat *resp)
 {
 	if (resp->status == 0) {
-		lease_get_mtime(resp->fh.fh_dentry->d_inode,
+		lease_get_mtime(d_inode(resp->fh.fh_dentry),
 				&resp->stat.mtime);
 		p = encode_fattr3(rqstp, p, &resp->fh, &resp->stat);
 	}
@@ -828,7 +828,7 @@ compose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,
 		return rv;
 	if (d_mountpoint(dchild))
 		goto out;
-	if (!dchild->d_inode)
+	if (d_really_is_negative(dchild))
 		goto out;
 	rv = fh_compose(fhp, exp, dchild, &cd->fh);
 out:
* Unmerged path fs/nfsd/nfs4acl.c
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 08ad6b577589..af9ab1f55cf3 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -51,7 +51,7 @@
 static inline void
 nfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)
 {
-	struct inode *inode = resfh->fh_dentry->d_inode;
+	struct inode *inode = d_inode(resfh->fh_dentry);
 	int status;
 
 	mutex_lock(&inode->i_mutex);
@@ -109,7 +109,7 @@ check_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	 * in current environment or not.
 	 */
 	if (bmval[0] & FATTR4_WORD0_ACL) {
-		if (!IS_POSIXACL(dentry->d_inode))
+		if (!IS_POSIXACL(d_inode(dentry)))
 			return nfserr_attrnotsupp;
 	}
 
@@ -208,7 +208,7 @@ do_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfs
 
 static __be32 nfsd_check_obj_isreg(struct svc_fh *fh)
 {
-	umode_t mode = fh->fh_dentry->d_inode->i_mode;
+	umode_t mode = d_inode(fh->fh_dentry)->i_mode;
 
 	if (S_ISREG(mode))
 		return nfs_ok;
@@ -880,7 +880,7 @@ nfsd4_secinfo(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 				    &exp, &dentry);
 	if (err)
 		return err;
-	if (dentry->d_inode == NULL) {
+	if (d_really_is_negative(dentry)) {
 		exp_put(exp);
 		err = nfserr_noent;
 	} else
@@ -1311,7 +1311,7 @@ nfsd4_layoutget(struct svc_rqst *rqstp,
 	if (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))
 		goto out_put_stid;
 
-	nfserr = ops->proc_layoutget(current_fh->fh_dentry->d_inode,
+	nfserr = ops->proc_layoutget(d_inode(current_fh->fh_dentry),
 				     current_fh, lgp);
 	if (nfserr)
 		goto out_put_stid;
@@ -1345,7 +1345,7 @@ nfsd4_layoutcommit(struct svc_rqst *rqstp,
 	ops = nfsd4_layout_verify(current_fh->fh_export, lcp->lc_layout_type);
 	if (!ops)
 		goto out;
-	inode = current_fh->fh_dentry->d_inode;
+	inode = d_inode(current_fh->fh_dentry);
 
 	nfserr = nfserr_inval;
 	if (new_size <= seg->offset) {
* Unmerged path fs/nfsd/nfs4recover.c
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 35a221cf7873..f1ec04a9b9db 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -4523,7 +4523,7 @@ nfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,
 	struct nfs4_ol_stateid *stp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	struct svc_fh *current_fh = &cstate->current_fh;
-	struct inode *ino = current_fh->fh_dentry->d_inode;
+	struct inode *ino = d_inode(current_fh->fh_dentry);
 	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
 	struct file *file = NULL;
 	__be32 status;
@@ -5209,7 +5209,7 @@ lookup_or_create_lock_state(struct nfsd4_compound_state *cstate,
 	struct nfs4_file *fi = ost->st_stid.sc_file;
 	struct nfs4_openowner *oo = openowner(ost->st_stateowner);
 	struct nfs4_client *cl = oo->oo_owner.so_client;
-	struct inode *inode = cstate->current_fh.fh_dentry->d_inode;
+	struct inode *inode = d_inode(cstate->current_fh.fh_dentry);
 	struct nfs4_lockowner *lo;
 	unsigned int strhashval;
 
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 7f583d8e4f4c..6bb402df71a0 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -2280,7 +2280,7 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
 	if ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||
 			bmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {
-		err = security_inode_getsecctx(dentry->d_inode,
+		err = security_inode_getsecctx(d_inode(dentry),
 						&context, &contextlen);
 		contextsupport = (err == 0);
 		if (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {
@@ -2372,7 +2372,7 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
 		p = xdr_reserve_space(xdr, 8);
 		if (!p)
 			goto out_resource;
-		p = encode_change(p, &stat, dentry->d_inode);
+		p = encode_change(p, &stat, d_inode(dentry));
 	}
 	if (bmval0 & FATTR4_WORD0_SIZE) {
 		p = xdr_reserve_space(xdr, 8);
@@ -2795,7 +2795,7 @@ nfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,
 	dentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);
 	if (IS_ERR(dentry))
 		return nfserrno(PTR_ERR(dentry));
-	if (!dentry->d_inode) {
+	if (d_really_is_negative(dentry)) {
 		/*
 		 * nfsd_buffered_readdir drops the i_mutex between
 		 * readdir and calling this callback, leaving a window
@@ -3311,7 +3311,7 @@ static __be32 nfsd4_encode_splice_read(
 	}
 
 	eof = (read->rd_offset + maxcount >=
-	       read->rd_fhp->fh_dentry->d_inode->i_size);
+	       d_inode(read->rd_fhp->fh_dentry)->i_size);
 
 	*(p++) = htonl(eof);
 	*(p++) = htonl(maxcount);
@@ -3388,7 +3388,7 @@ static __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,
 	xdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));
 
 	eof = (read->rd_offset + maxcount >=
-	       read->rd_fhp->fh_dentry->d_inode->i_size);
+	       d_inode(read->rd_fhp->fh_dentry)->i_size);
 
 	tmp = htonl(eof);
 	write_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);
* Unmerged path fs/nfsd/nfsfh.c
diff --git a/fs/nfsd/nfsfh.h b/fs/nfsd/nfsfh.h
index 84cae2079d21..e011d804f7a9 100644
--- a/fs/nfsd/nfsfh.h
+++ b/fs/nfsd/nfsfh.h
@@ -225,7 +225,7 @@ fill_pre_wcc(struct svc_fh *fhp)
 {
 	struct inode    *inode;
 
-	inode = fhp->fh_dentry->d_inode;
+	inode = d_inode(fhp->fh_dentry);
 	if (!fhp->fh_pre_saved) {
 		fhp->fh_pre_mtime = inode->i_mtime;
 		fhp->fh_pre_ctime = inode->i_ctime;
@@ -264,7 +264,7 @@ fh_lock_nested(struct svc_fh *fhp, unsigned int subclass)
 		return;
 	}
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	mutex_lock_nested(&inode->i_mutex, subclass);
 	fill_pre_wcc(fhp);
 	fhp->fh_locked = 1;
@@ -284,7 +284,7 @@ fh_unlock(struct svc_fh *fhp)
 {
 	if (fhp->fh_locked) {
 		fill_post_wcc(fhp);
-		mutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);
+		mutex_unlock(&d_inode(fhp->fh_dentry)->i_mutex);
 		fhp->fh_locked = 0;
 	}
 }
diff --git a/fs/nfsd/nfsproc.c b/fs/nfsd/nfsproc.c
index b8680738f588..aecbcd34d336 100644
--- a/fs/nfsd/nfsproc.c
+++ b/fs/nfsd/nfsproc.c
@@ -223,7 +223,7 @@ nfsd_proc_create(struct svc_rqst *rqstp, struct nfsd_createargs *argp,
 	}
 	fh_init(newfhp, NFS_FHSIZE);
 	nfserr = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);
-	if (!nfserr && !dchild->d_inode)
+	if (!nfserr && d_really_is_negative(dchild))
 		nfserr = nfserr_noent;
 	dput(dchild);
 	if (nfserr) {
@@ -241,7 +241,7 @@ nfsd_proc_create(struct svc_rqst *rqstp, struct nfsd_createargs *argp,
 		}
 	}
 
-	inode = newfhp->fh_dentry->d_inode;
+	inode = d_inode(newfhp->fh_dentry);
 
 	/* Unfudge the mode bits */
 	if (attr->ia_valid & ATTR_MODE) {
diff --git a/fs/nfsd/nfsxdr.c b/fs/nfsd/nfsxdr.c
index 412d7061f9e5..79d964aa8079 100644
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@ -187,7 +187,7 @@ encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,
 	*p++ = htonl((u32) stat->ino);
 	*p++ = htonl((u32) stat->atime.tv_sec);
 	*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);
-	lease_get_mtime(dentry->d_inode, &time); 
+	lease_get_mtime(d_inode(dentry), &time); 
 	*p++ = htonl((u32) time.tv_sec);
 	*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0); 
 	*p++ = htonl((u32) stat->ctime.tv_sec);
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 949ec1c44e44..04378fc2b528 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -174,7 +174,7 @@ int nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)
 		return 1;
 	if (!(exp->ex_flags & NFSEXP_V4ROOT))
 		return 0;
-	return dentry->d_inode != NULL;
+	return d_inode(dentry) != NULL;
 }
 
 __be32
@@ -270,7 +270,7 @@ nfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,
 	 * dentry may be negative, it may need to be updated.
 	 */
 	err = fh_compose(resfh, exp, dentry, fhp);
-	if (!err && !dentry->d_inode)
+	if (!err && d_really_is_negative(dentry))
 		err = nfserr_noent;
 out:
 	dput(dentry);
@@ -284,7 +284,7 @@ out:
 static int
 commit_metadata(struct svc_fh *fhp)
 {
-	struct inode *inode = fhp->fh_dentry->d_inode;
+	struct inode *inode = d_inode(fhp->fh_dentry);
 	const struct export_operations *export_ops = inode->i_sb->s_export_op;
 
 	if (!EX_ISSYNC(fhp->fh_export))
@@ -364,7 +364,7 @@ static __be32
 nfsd_get_write_access(struct svc_rqst *rqstp, struct svc_fh *fhp,
 		struct iattr *iap)
 {
-	struct inode *inode = fhp->fh_dentry->d_inode;
+	struct inode *inode = d_inode(fhp->fh_dentry);
 	int host_err;
 
 	if (iap->ia_size < inode->i_size) {
@@ -426,7 +426,7 @@ nfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,
 	}
 
 	dentry = fhp->fh_dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	/* Ignore any mode updates on symlinks */
 	if (S_ISLNK(inode->i_mode))
@@ -646,7 +646,7 @@ nfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry, struct nfs4_ac
  */
 int nfsd4_is_junction(struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (inode == NULL)
 		return 0;
@@ -672,9 +672,9 @@ __be32 nfsd4_set_nfs4_label(struct svc_rqst *rqstp, struct svc_fh *fhp,
 
 	dentry = fhp->fh_dentry;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	host_error = security_inode_setsecctx(dentry, label->data, label->len);
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 	return nfserrno(host_error);
 }
 #else
@@ -857,7 +857,7 @@ nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,
 
 	path.mnt = fhp->fh_export->ex_path.mnt;
 	path.dentry = fhp->fh_dentry;
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 
 	/* Disallow write access to files with the append-only bit set
 	 * or any access when mandatory locking enabled
@@ -1360,7 +1360,7 @@ nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 		goto out;
 
 	dentry = fhp->fh_dentry;
-	dirp = dentry->d_inode;
+	dirp = d_inode(dentry);
 
 	err = nfserr_notdir;
 	if (!dirp->i_op->lookup)
@@ -1399,7 +1399,7 @@ nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 	 * Make sure the child dentry is still negative ...
 	 */
 	err = nfserr_exist;
-	if (dchild->d_inode) {
+	if (d_really_is_positive(dchild)) {
 		dprintk("nfsd_create: dentry %pd/%pd not negative!\n",
 			dentry, dchild);
 		goto out; 
@@ -1502,7 +1502,7 @@ do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 		goto out;
 
 	dentry = fhp->fh_dentry;
-	dirp = dentry->d_inode;
+	dirp = d_inode(dentry);
 
 	/* Get all the sanity checks out of the way before
 	 * we lock the parent. */
@@ -1525,7 +1525,7 @@ do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 		goto out_nfserr;
 
 	/* If file doesn't exist, check for permissions to create one */
-	if (!dchild->d_inode) {
+	if (d_really_is_negative(dchild)) {
 		err = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);
 		if (err)
 			goto out;
@@ -1546,7 +1546,7 @@ do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 		v_atime = verifier[1]&0x7fffffff;
 	}
 	
-	if (dchild->d_inode) {
+	if (d_really_is_positive(dchild)) {
 		err = 0;
 
 		switch (createmode) {
@@ -1569,17 +1569,17 @@ do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 			}
 			break;
 		case NFS3_CREATE_EXCLUSIVE:
-			if (   dchild->d_inode->i_mtime.tv_sec == v_mtime
-			    && dchild->d_inode->i_atime.tv_sec == v_atime
-			    && dchild->d_inode->i_size  == 0 ) {
+			if (   d_inode(dchild)->i_mtime.tv_sec == v_mtime
+			    && d_inode(dchild)->i_atime.tv_sec == v_atime
+			    && d_inode(dchild)->i_size  == 0 ) {
 				if (created)
 					*created = 1;
 				break;
 			}
 		case NFS4_CREATE_EXCLUSIVE4_1:
-			if (   dchild->d_inode->i_mtime.tv_sec == v_mtime
-			    && dchild->d_inode->i_atime.tv_sec == v_atime
-			    && dchild->d_inode->i_size  == 0 ) {
+			if (   d_inode(dchild)->i_mtime.tv_sec == v_mtime
+			    && d_inode(dchild)->i_atime.tv_sec == v_atime
+			    && d_inode(dchild)->i_size  == 0 ) {
 				if (created)
 					*created = 1;
 				goto set_attr;
@@ -1662,7 +1662,7 @@ nfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)
 
 	path.mnt = fhp->fh_export->ex_path.mnt;
 	path.dentry = fhp->fh_dentry;
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 
 	err = nfserr_inval;
 	if (!inode->i_op->readlink)
@@ -1725,7 +1725,7 @@ nfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,
 	if (IS_ERR(dnew))
 		goto out_nfserr;
 
-	host_err = vfs_symlink(dentry->d_inode, dnew, path);
+	host_err = vfs_symlink(d_inode(dentry), dnew, path);
 	err = nfserrno(host_err);
 	if (!err)
 		err = nfserrno(commit_metadata(fhp));
@@ -1781,7 +1781,7 @@ nfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,
 
 	fh_lock_nested(ffhp, I_MUTEX_PARENT);
 	ddir = ffhp->fh_dentry;
-	dirp = ddir->d_inode;
+	dirp = d_inode(ddir);
 
 	dnew = lookup_one_len(name, ddir, len);
 	host_err = PTR_ERR(dnew);
@@ -1791,7 +1791,7 @@ nfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,
 	dold = tfhp->fh_dentry;
 
 	err = nfserr_noent;
-	if (!dold->d_inode)
+	if (d_really_is_negative(dold))
 		goto out_dput;
 	host_err = vfs_link(dold, dirp, dnew, NULL);
 	if (!host_err) {
@@ -1838,10 +1838,10 @@ nfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,
 		goto out;
 
 	fdentry = ffhp->fh_dentry;
-	fdir = fdentry->d_inode;
+	fdir = d_inode(fdentry);
 
 	tdentry = tfhp->fh_dentry;
-	tdir = tdentry->d_inode;
+	tdir = d_inode(tdentry);
 
 	err = nfserr_perm;
 	if (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))
@@ -1866,7 +1866,7 @@ nfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,
 		goto out_nfserr;
 
 	host_err = -ENOENT;
-	if (!odentry->d_inode)
+	if (d_really_is_negative(odentry))
 		goto out_dput_old;
 	host_err = -EINVAL;
 	if (odentry == trap)
@@ -1939,21 +1939,21 @@ nfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,
 
 	fh_lock_nested(fhp, I_MUTEX_PARENT);
 	dentry = fhp->fh_dentry;
-	dirp = dentry->d_inode;
+	dirp = d_inode(dentry);
 
 	rdentry = lookup_one_len(fname, dentry, flen);
 	host_err = PTR_ERR(rdentry);
 	if (IS_ERR(rdentry))
 		goto out_nfserr;
 
-	if (!rdentry->d_inode) {
+	if (d_really_is_negative(rdentry)) {
 		dput(rdentry);
 		err = nfserr_noent;
 		goto out;
 	}
 
 	if (!type)
-		type = rdentry->d_inode->i_mode & S_IFMT;
+		type = d_inode(rdentry)->i_mode & S_IFMT;
 
 	if (type != S_IFDIR)
 		host_err = vfs_unlink(dirp, rdentry, NULL);
@@ -2159,7 +2159,7 @@ __be32
 nfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,
 					struct dentry *dentry, int acc)
 {
-	struct inode	*inode = dentry->d_inode;
+	struct inode	*inode = d_inode(dentry);
 	int		err;
 
 	if ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index 0bda93e58e1b..056f23a78ffd 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -632,7 +632,7 @@ set_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)
 {
 	BUG_ON(!fhp->fh_pre_saved);
 	cinfo->atomic = fhp->fh_post_saved;
-	cinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);
+	cinfo->change_supported = IS_I_VERSION(d_inode(fhp->fh_dentry));
 
 	cinfo->before_change = fhp->fh_pre_change;
 	cinfo->after_change = fhp->fh_post_change;
diff --git a/fs/nilfs2/dir.c b/fs/nilfs2/dir.c
index f30b017740a7..13882949fc4b 100644
--- a/fs/nilfs2/dir.c
+++ b/fs/nilfs2/dir.c
@@ -447,7 +447,7 @@ void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,
  */
 int nilfs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const unsigned char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	unsigned chunk_size = nilfs_chunk_size(dir);
diff --git a/fs/nilfs2/inode.c b/fs/nilfs2/inode.c
index 4fcb0d232962..1e2bea63865f 100644
--- a/fs/nilfs2/inode.c
+++ b/fs/nilfs2/inode.c
@@ -813,7 +813,7 @@ void nilfs_evict_inode(struct inode *inode)
 int nilfs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
 	struct nilfs_transaction_info ti;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	int err;
 
diff --git a/fs/nilfs2/namei.c b/fs/nilfs2/namei.c
index 9de78f08989e..2bbd0ef1c47e 100644
--- a/fs/nilfs2/namei.c
+++ b/fs/nilfs2/namei.c
@@ -189,7 +189,7 @@ out_fail:
 static int nilfs_link(struct dentry *old_dentry, struct inode *dir,
 		      struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct nilfs_transaction_info ti;
 	int err;
 
@@ -274,7 +274,7 @@ static int nilfs_do_unlink(struct inode *dir, struct dentry *dentry)
 	if (!de)
 		goto out;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	err = -EIO;
 	if (le64_to_cpu(de->inode) != inode->i_ino)
 		goto out;
@@ -309,7 +309,7 @@ static int nilfs_unlink(struct inode *dir, struct dentry *dentry)
 
 	if (!err) {
 		nilfs_mark_inode_dirty(dir);
-		nilfs_mark_inode_dirty(dentry->d_inode);
+		nilfs_mark_inode_dirty(d_inode(dentry));
 		err = nilfs_transaction_commit(dir->i_sb);
 	} else
 		nilfs_transaction_abort(dir->i_sb);
@@ -319,7 +319,7 @@ static int nilfs_unlink(struct inode *dir, struct dentry *dentry)
 
 static int nilfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nilfs_transaction_info ti;
 	int err;
 
@@ -349,8 +349,8 @@ static int nilfs_rmdir(struct inode *dir, struct dentry *dentry)
 static int nilfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			struct inode *new_dir,	struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct page *dir_page = NULL;
 	struct nilfs_dir_entry *dir_de = NULL;
 	struct page *old_page;
@@ -444,13 +444,13 @@ static struct dentry *nilfs_get_parent(struct dentry *child)
 	struct qstr dotdot = QSTR_INIT("..", 2);
 	struct nilfs_root *root;
 
-	ino = nilfs_inode_by_name(child->d_inode, &dotdot);
+	ino = nilfs_inode_by_name(d_inode(child), &dotdot);
 	if (!ino)
 		return ERR_PTR(-ENOENT);
 
-	root = NILFS_I(child->d_inode)->i_root;
+	root = NILFS_I(d_inode(child))->i_root;
 
-	inode = nilfs_iget(child->d_inode->i_sb, root, ino);
+	inode = nilfs_iget(d_inode(child)->i_sb, root, ino);
 	if (IS_ERR(inode))
 		return ERR_CAST(inode);
 
diff --git a/fs/nilfs2/super.c b/fs/nilfs2/super.c
index bd9d1f2cea59..ed70b29fd71d 100644
--- a/fs/nilfs2/super.c
+++ b/fs/nilfs2/super.c
@@ -602,7 +602,7 @@ static int nilfs_unfreeze(struct super_block *sb)
 static int nilfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
-	struct nilfs_root *root = NILFS_I(dentry->d_inode)->i_root;
+	struct nilfs_root *root = NILFS_I(d_inode(dentry))->i_root;
 	struct the_nilfs *nilfs = root->nilfs;
 	u64 id = huge_encode_dev(sb->s_bdev->bd_dev);
 	unsigned long long blocks;
@@ -652,7 +652,7 @@ static int nilfs_show_options(struct seq_file *seq, struct dentry *dentry)
 {
 	struct super_block *sb = dentry->d_sb;
 	struct the_nilfs *nilfs = sb->s_fs_info;
-	struct nilfs_root *root = NILFS_I(dentry->d_inode)->i_root;
+	struct nilfs_root *root = NILFS_I(d_inode(dentry))->i_root;
 
 	if (!nilfs_test_opt(nilfs, BARRIER))
 		seq_puts(seq, ",nobarrier");
@@ -1170,7 +1170,7 @@ static int nilfs_remount(struct super_block *sb, int *flags, char *data)
 
 		sb->s_flags &= ~MS_RDONLY;
 
-		root = NILFS_I(sb->s_root->d_inode)->i_root;
+		root = NILFS_I(d_inode(sb->s_root))->i_root;
 		err = nilfs_attach_log_writer(sb, root);
 		if (err)
 			goto restore_opts;
diff --git a/fs/ntfs/inode.c b/fs/ntfs/inode.c
index bd50adc1e6a7..a8475cf7b75a 100644
--- a/fs/ntfs/inode.c
+++ b/fs/ntfs/inode.c
@@ -2889,7 +2889,7 @@ void ntfs_truncate_vfs(struct inode *vi) {
  */
 int ntfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *vi = dentry->d_inode;
+	struct inode *vi = d_inode(dentry);
 	int err;
 	unsigned int ia_valid = attr->ia_valid;
 
diff --git a/fs/ntfs/namei.c b/fs/ntfs/namei.c
index 436f36037e09..e81547d4927e 100644
--- a/fs/ntfs/namei.c
+++ b/fs/ntfs/namei.c
@@ -292,14 +292,14 @@ const struct inode_operations ntfs_dir_inode_ops = {
  * The code is based on the ext3 ->get_parent() implementation found in
  * fs/ext3/namei.c::ext3_get_parent().
  *
- * Note: ntfs_get_parent() is called with @child_dent->d_inode->i_mutex down.
+ * Note: ntfs_get_parent() is called with @d_inode(child_dent)->i_mutex down.
  *
  * Return the dentry of the parent directory on success or the error code on
  * error (IS_ERR() is true).
  */
 static struct dentry *ntfs_get_parent(struct dentry *child_dent)
 {
-	struct inode *vi = child_dent->d_inode;
+	struct inode *vi = d_inode(child_dent);
 	ntfs_inode *ni = NTFS_I(vi);
 	MFT_RECORD *mrec;
 	ntfs_attr_search_ctx *ctx;
* Unmerged path fs/ocfs2/dcache.c
diff --git a/fs/ocfs2/dir.h b/fs/ocfs2/dir.h
index e683f3deb645..b08020841feb 100644
--- a/fs/ocfs2/dir.h
+++ b/fs/ocfs2/dir.h
@@ -72,7 +72,7 @@ static inline int ocfs2_add_entry(handle_t *handle,
 				  struct buffer_head *parent_fe_bh,
 				  struct ocfs2_dir_lookup_result *lookup)
 {
-	return __ocfs2_add_entry(handle, dentry->d_parent->d_inode,
+	return __ocfs2_add_entry(handle, d_inode(dentry->d_parent),
 				 dentry->d_name.name, dentry->d_name.len,
 				 inode, blkno, parent_fe_bh, lookup);
 }
diff --git a/fs/ocfs2/dlmfs/dlmfs.c b/fs/ocfs2/dlmfs/dlmfs.c
index 12bafb7265ce..9028d1bbc034 100644
--- a/fs/ocfs2/dlmfs/dlmfs.c
+++ b/fs/ocfs2/dlmfs/dlmfs.c
@@ -209,7 +209,7 @@ static int dlmfs_file_release(struct inode *inode,
 static int dlmfs_file_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int error;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	attr->ia_valid &= ~ATTR_SIZE;
 	error = inode_change_ok(inode, attr);
@@ -561,7 +561,7 @@ static int dlmfs_unlink(struct inode *dir,
 			struct dentry *dentry)
 {
 	int status;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	mlog(0, "unlink inode %lu\n", inode->i_ino);
 
diff --git a/fs/ocfs2/export.c b/fs/ocfs2/export.c
index 29651167190d..facf456c481a 100644
--- a/fs/ocfs2/export.c
+++ b/fs/ocfs2/export.c
@@ -147,7 +147,7 @@ static struct dentry *ocfs2_get_parent(struct dentry *child)
 	int status;
 	u64 blkno;
 	struct dentry *parent;
-	struct inode *dir = child->d_inode;
+	struct inode *dir = d_inode(child);
 
 	trace_ocfs2_get_parent(child, child->d_name.len, child->d_name.name,
 			       (unsigned long long)OCFS2_I(dir)->ip_blkno);
* Unmerged path fs/ocfs2/file.c
diff --git a/fs/ocfs2/inode.c b/fs/ocfs2/inode.c
index f1c46a7f9bc5..ebbf6701b53e 100644
--- a/fs/ocfs2/inode.c
+++ b/fs/ocfs2/inode.c
@@ -1196,7 +1196,7 @@ int ocfs2_drop_inode(struct inode *inode)
  */
 int ocfs2_inode_revalidate(struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int status = 0;
 
 	trace_ocfs2_inode_revalidate(inode,
* Unmerged path fs/ocfs2/namei.c
diff --git a/fs/ocfs2/refcounttree.c b/fs/ocfs2/refcounttree.c
index 998b17eda09d..1542cf468722 100644
--- a/fs/ocfs2/refcounttree.c
+++ b/fs/ocfs2/refcounttree.c
@@ -4220,7 +4220,7 @@ static int __ocfs2_reflink(struct dentry *old_dentry,
 			   bool preserve)
 {
 	int ret;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct buffer_head *new_bh = NULL;
 
 	if (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {
@@ -4289,7 +4289,7 @@ static int ocfs2_reflink(struct dentry *old_dentry, struct inode *dir,
 			 struct dentry *new_dentry, bool preserve)
 {
 	int error;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct buffer_head *old_bh = NULL;
 	struct inode *new_orphan_inode = NULL;
 
@@ -4361,7 +4361,7 @@ out:
 /* copied from may_create in VFS. */
 static inline int ocfs2_may_create(struct inode *dir, struct dentry *child)
 {
-	if (child->d_inode)
+	if (d_really_is_positive(child))
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
@@ -4379,7 +4379,7 @@ static inline int ocfs2_may_create(struct inode *dir, struct dentry *child)
 static int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,
 			     struct dentry *new_dentry, bool preserve)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int error;
 
 	if (!inode)
@@ -4467,7 +4467,7 @@ int ocfs2_reflink_ioctl(struct inode *inode,
 	}
 
 	error = ocfs2_vfs_reflink(old_path.dentry,
-				  new_path.dentry->d_inode,
+				  d_inode(new_path.dentry),
 				  new_dentry, preserve);
 out_dput:
 	done_path_create(&new_path, new_dentry);
diff --git a/fs/ocfs2/xattr.c b/fs/ocfs2/xattr.c
index 5b8d94436105..09e5c98830e3 100644
--- a/fs/ocfs2/xattr.c
+++ b/fs/ocfs2/xattr.c
@@ -1014,7 +1014,7 @@ ssize_t ocfs2_listxattr(struct dentry *dentry,
 	int ret = 0, i_ret = 0, b_ret = 0;
 	struct buffer_head *di_bh = NULL;
 	struct ocfs2_dinode *di = NULL;
-	struct ocfs2_inode_info *oi = OCFS2_I(dentry->d_inode);
+	struct ocfs2_inode_info *oi = OCFS2_I(d_inode(dentry));
 
 	if (!ocfs2_supports_xattr(OCFS2_SB(dentry->d_sb)))
 		return -EOPNOTSUPP;
@@ -1022,7 +1022,7 @@ ssize_t ocfs2_listxattr(struct dentry *dentry,
 	if (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))
 		return ret;
 
-	ret = ocfs2_inode_lock(dentry->d_inode, &di_bh, 0);
+	ret = ocfs2_inode_lock(d_inode(dentry), &di_bh, 0);
 	if (ret < 0) {
 		mlog_errno(ret);
 		return ret;
@@ -1031,7 +1031,7 @@ ssize_t ocfs2_listxattr(struct dentry *dentry,
 	di = (struct ocfs2_dinode *)di_bh->b_data;
 
 	down_read(&oi->ip_xattr_sem);
-	i_ret = ocfs2_xattr_ibody_list(dentry->d_inode, di, buffer, size);
+	i_ret = ocfs2_xattr_ibody_list(d_inode(dentry), di, buffer, size);
 	if (i_ret < 0)
 		b_ret = 0;
 	else {
@@ -1039,13 +1039,13 @@ ssize_t ocfs2_listxattr(struct dentry *dentry,
 			buffer += i_ret;
 			size -= i_ret;
 		}
-		b_ret = ocfs2_xattr_block_list(dentry->d_inode, di,
+		b_ret = ocfs2_xattr_block_list(d_inode(dentry), di,
 					       buffer, size);
 		if (b_ret < 0)
 			i_ret = 0;
 	}
 	up_read(&oi->ip_xattr_sem);
-	ocfs2_inode_unlock(dentry->d_inode, 0);
+	ocfs2_inode_unlock(d_inode(dentry), 0);
 
 	brelse(di_bh);
 
@@ -7242,7 +7242,7 @@ static int ocfs2_xattr_security_get(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,
+	return ocfs2_xattr_get(d_inode(dentry), OCFS2_XATTR_INDEX_SECURITY,
 			       name, buffer, size);
 }
 
@@ -7252,7 +7252,7 @@ static int ocfs2_xattr_security_set(struct dentry *dentry, const char *name,
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
 
-	return ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,
+	return ocfs2_xattr_set(d_inode(dentry), OCFS2_XATTR_INDEX_SECURITY,
 			       name, value, size, flags);
 }
 
@@ -7332,7 +7332,7 @@ static int ocfs2_xattr_trusted_get(struct dentry *dentry, const char *name,
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,
+	return ocfs2_xattr_get(d_inode(dentry), OCFS2_XATTR_INDEX_TRUSTED,
 			       name, buffer, size);
 }
 
@@ -7342,7 +7342,7 @@ static int ocfs2_xattr_trusted_set(struct dentry *dentry, const char *name,
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
 
-	return ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,
+	return ocfs2_xattr_set(d_inode(dentry), OCFS2_XATTR_INDEX_TRUSTED,
 			       name, value, size, flags);
 }
 
@@ -7384,7 +7384,7 @@ static int ocfs2_xattr_user_get(struct dentry *dentry, const char *name,
 		return -EINVAL;
 	if (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)
 		return -EOPNOTSUPP;
-	return ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_USER, name,
+	return ocfs2_xattr_get(d_inode(dentry), OCFS2_XATTR_INDEX_USER, name,
 			       buffer, size);
 }
 
@@ -7398,7 +7398,7 @@ static int ocfs2_xattr_user_set(struct dentry *dentry, const char *name,
 	if (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)
 		return -EOPNOTSUPP;
 
-	return ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_USER,
+	return ocfs2_xattr_set(d_inode(dentry), OCFS2_XATTR_INDEX_USER,
 			       name, value, size, flags);
 }
 
diff --git a/fs/omfs/dir.c b/fs/omfs/dir.c
index acbaebcad3a8..36179059874c 100644
--- a/fs/omfs/dir.c
+++ b/fs/omfs/dir.c
@@ -110,7 +110,7 @@ int omfs_make_empty(struct inode *inode, struct super_block *sb)
 
 static int omfs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct omfs_inode *oi;
@@ -155,7 +155,7 @@ out:
 
 static int omfs_delete_entry(struct dentry *dentry)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct inode *dirty;
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
@@ -237,7 +237,7 @@ static int omfs_dir_is_empty(struct inode *inode)
 
 static int omfs_remove(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int ret;
 
 
@@ -375,8 +375,8 @@ out:
 static int omfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *new_inode = new_dentry->d_inode;
-	struct inode *old_inode = old_dentry->d_inode;
+	struct inode *new_inode = d_inode(new_dentry);
+	struct inode *old_inode = d_inode(old_dentry);
 	int err;
 
 	if (new_inode) {
diff --git a/fs/omfs/file.c b/fs/omfs/file.c
index 54d57d6ba68d..f19ac5cadb1c 100644
--- a/fs/omfs/file.c
+++ b/fs/omfs/file.c
@@ -348,7 +348,7 @@ const struct file_operations omfs_file_operations = {
 
 static int omfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
* Unmerged path fs/proc/base.c
diff --git a/fs/proc/fd.c b/fs/proc/fd.c
index cb2a4ae2363a..49b45c495752 100644
--- a/fs/proc/fd.c
+++ b/fs/proc/fd.c
@@ -88,7 +88,7 @@ static int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)
 	if (flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	task = get_proc_task(inode);
 	fd = proc_fd(inode);
 
@@ -150,14 +150,14 @@ static int proc_fd_link(struct dentry *dentry, struct path *path)
 	struct task_struct *task;
 	int ret = -ENOENT;
 
-	task = get_proc_task(dentry->d_inode);
+	task = get_proc_task(d_inode(dentry));
 	if (task) {
 		files = get_files_struct(task);
 		put_task_struct(task);
 	}
 
 	if (files) {
-		int fd = proc_fd(dentry->d_inode);
+		int fd = proc_fd(d_inode(dentry));
 		struct file *fd_file;
 
 		spin_lock(&files->file_lock);
* Unmerged path fs/proc/generic.c
* Unmerged path fs/proc/inode.c
* Unmerged path fs/proc/namespaces.c
diff --git a/fs/proc/proc_net.c b/fs/proc/proc_net.c
index 71b5fcf793a2..855555870a94 100644
--- a/fs/proc/proc_net.c
+++ b/fs/proc/proc_net.c
@@ -142,7 +142,7 @@ static struct dentry *proc_tgid_net_lookup(struct inode *dir,
 static int proc_tgid_net_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct net *net;
 
 	net = get_proc_task_net(inode);
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index 50225d19bbce..b3948e2f6807 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -604,7 +604,7 @@ static int proc_sys_fill_cache(struct file *filp, void *dirent,
 			return -ENOMEM;
 		}
 	}
-	inode = child->d_inode;
+	inode = d_inode(child);
 	ino  = inode->i_ino;
 	type = inode->i_mode >> 12;
 	dput(child);
@@ -727,7 +727,7 @@ static int proc_sys_permission(struct inode *inode, int mask)
 
 static int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	if (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))
@@ -744,7 +744,7 @@ static int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)
 
 static int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ctl_table_header *head = grab_header(inode);
 	struct ctl_table *table = PROC_I(inode)->sysctl_entry;
 
@@ -790,12 +790,12 @@ static int proc_sys_revalidate(struct dentry *dentry, unsigned int flags)
 {
 	if (flags & LOOKUP_RCU)
 		return -ECHILD;
-	return !PROC_I(dentry->d_inode)->sysctl->unregistering;
+	return !PROC_I(d_inode(dentry))->sysctl->unregistering;
 }
 
 static int proc_sys_delete(const struct dentry *dentry)
 {
-	return !!PROC_I(dentry->d_inode)->sysctl->unregistering;
+	return !!PROC_I(d_inode(dentry))->sysctl->unregistering;
 }
 
 static int sysctl_is_seen(struct ctl_table_header *p)
@@ -822,7 +822,7 @@ static int proc_sys_compare(const struct dentry *parent, const struct dentry *de
 	/* Although proc doesn't have negative dentries, rcu-walk means
 	 * that inode here can be NULL */
 	/* AV: can it, indeed? */
-	inode = ACCESS_ONCE(dentry->d_inode);
+	inode = d_inode_rcu(dentry);
 	if (!inode)
 		return 1;
 	if (name->len != len)
diff --git a/fs/proc/root.c b/fs/proc/root.c
index 04ec276c7bab..19af51236dc0 100644
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -190,7 +190,7 @@ void __init proc_root_init(void)
 static int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat
 )
 {
-	generic_fillattr(dentry->d_inode, stat);
+	generic_fillattr(d_inode(dentry), stat);
 	stat->nlink = proc_root.nlink + nr_processes();
 	return 0;
 }
diff --git a/fs/proc/self.c b/fs/proc/self.c
index ffeb202ec942..2d9e8c77050e 100644
--- a/fs/proc/self.c
+++ b/fs/proc/self.c
@@ -46,7 +46,7 @@ static unsigned self_inum;
 
 int proc_setup_self(struct super_block *s)
 {
-	struct inode *root_inode = s->s_root->d_inode;
+	struct inode *root_inode = d_inode(s->s_root);
 	struct pid_namespace *ns = s->s_fs_info;
 	struct dentry *self;
 	
* Unmerged path fs/proc/thread_self.c
* Unmerged path fs/pstore/inode.c
diff --git a/fs/qnx6/inode.c b/fs/qnx6/inode.c
index 8d941edfefa1..94ad2bc51c96 100644
--- a/fs/qnx6/inode.c
+++ b/fs/qnx6/inode.c
@@ -183,7 +183,7 @@ static const char *qnx6_checkroot(struct super_block *s)
 	static char match_root[2][3] = {".\0\0", "..\0"};
 	int i, error = 0;
 	struct qnx6_dir_entry *dir_entry;
-	struct inode *root = s->s_root->d_inode;
+	struct inode *root = d_inode(s->s_root);
 	struct address_space *mapping = root->i_mapping;
 	struct page *page = read_mapping_page(mapping, 0, NULL);
 	if (IS_ERR(page))
diff --git a/fs/ramfs/file-nommu.c b/fs/ramfs/file-nommu.c
index 8d5b438cc188..3a402e124bf3 100644
--- a/fs/ramfs/file-nommu.c
+++ b/fs/ramfs/file-nommu.c
@@ -159,7 +159,7 @@ static int ramfs_nommu_resize(struct inode *inode, loff_t newsize, loff_t size)
  */
 static int ramfs_nommu_setattr(struct dentry *dentry, struct iattr *ia)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int old_ia_valid = ia->ia_valid;
 	int ret = 0;
 
* Unmerged path fs/reiserfs/dir.c
diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c
index a3aae8634a3e..c0d014038124 100644
--- a/fs/reiserfs/inode.c
+++ b/fs/reiserfs/inode.c
@@ -3102,7 +3102,7 @@ static ssize_t reiserfs_direct_IO(int rw, struct kiocb *iocb,
 
 int reiserfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int ia_valid;
 	int depth;
 	int error;
diff --git a/fs/reiserfs/namei.c b/fs/reiserfs/namei.c
index 8567fb847601..e5cc670ac1d1 100644
--- a/fs/reiserfs/namei.c
+++ b/fs/reiserfs/namei.c
@@ -376,7 +376,7 @@ struct dentry *reiserfs_get_parent(struct dentry *child)
 	struct inode *inode = NULL;
 	struct reiserfs_dir_entry de;
 	INITIALIZE_PATH(path_to_entry);
-	struct inode *dir = child->d_inode;
+	struct inode *dir = d_inode(child);
 
 	if (dir->i_nlink == 0) {
 		return ERR_PTR(-ENOENT);
@@ -857,7 +857,7 @@ static int reiserfs_rmdir(struct inode *dir, struct dentry *dentry)
 		goto end_rmdir;
 	}
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	reiserfs_update_inode_transaction(inode);
 	reiserfs_update_inode_transaction(dir);
@@ -924,7 +924,7 @@ static int reiserfs_unlink(struct inode *dir, struct dentry *dentry)
 
 	dquot_initialize(dir);
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	/* in this transaction we can be doing at max two balancings and update
 	 * two stat datas, we change quotas of the owner of the directory and of
@@ -1108,7 +1108,7 @@ static int reiserfs_link(struct dentry *old_dentry, struct inode *dir,
 			 struct dentry *dentry)
 {
 	int retval;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct reiserfs_transaction_handle th;
 	/* We need blocks for transaction + update of quotas for the owners of the directory */
 	int jbegin_count =
@@ -1240,8 +1240,8 @@ static int reiserfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	dquot_initialize(old_dir);
 	dquot_initialize(new_dir);
 
-	old_inode = old_dentry->d_inode;
-	new_dentry_inode = new_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
+	new_dentry_inode = d_inode(new_dentry);
 
 	// make sure, that oldname still exists and points to an object we
 	// are going to rename
* Unmerged path fs/reiserfs/super.c
* Unmerged path fs/reiserfs/xattr.c
diff --git a/fs/reiserfs/xattr.h b/fs/reiserfs/xattr.h
index f59626c5d33b..8cf104faa834 100644
--- a/fs/reiserfs/xattr.h
+++ b/fs/reiserfs/xattr.h
@@ -78,7 +78,7 @@ static inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)
 
 	if ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {
 		nblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);
-		if (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)
+		if (d_really_is_negative(REISERFS_SB(inode->i_sb)->xattr_root))
 			nblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);
 	}
 
diff --git a/fs/reiserfs/xattr_security.c b/fs/reiserfs/xattr_security.c
index 800a3cef6f62..7a89d6e19fae 100644
--- a/fs/reiserfs/xattr_security.c
+++ b/fs/reiserfs/xattr_security.c
@@ -15,10 +15,10 @@ security_get(struct dentry *dentry, const char *name, void *buffer, size_t size,
 	if (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))
 		return -EINVAL;
 
-	if (IS_PRIVATE(dentry->d_inode))
+	if (IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_get(dentry->d_inode, name, buffer, size);
+	return reiserfs_xattr_get(d_inode(dentry), name, buffer, size);
 }
 
 static int
@@ -28,10 +28,10 @@ security_set(struct dentry *dentry, const char *name, const void *buffer,
 	if (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))
 		return -EINVAL;
 
-	if (IS_PRIVATE(dentry->d_inode))
+	if (IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);
+	return reiserfs_xattr_set(d_inode(dentry), name, buffer, size, flags);
 }
 
 static size_t security_list(struct dentry *dentry, char *list, size_t list_len,
@@ -39,7 +39,7 @@ static size_t security_list(struct dentry *dentry, char *list, size_t list_len,
 {
 	const size_t len = namelen + 1;
 
-	if (IS_PRIVATE(dentry->d_inode))
+	if (IS_PRIVATE(d_inode(dentry)))
 		return 0;
 
 	if (list && len <= list_len) {
diff --git a/fs/reiserfs/xattr_trusted.c b/fs/reiserfs/xattr_trusted.c
index a0035719f66b..e8890f6fc6cd 100644
--- a/fs/reiserfs/xattr_trusted.c
+++ b/fs/reiserfs/xattr_trusted.c
@@ -14,10 +14,10 @@ trusted_get(struct dentry *dentry, const char *name, void *buffer, size_t size,
 	if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
 		return -EINVAL;
 
-	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(dentry->d_inode))
+	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_get(dentry->d_inode, name, buffer, size);
+	return reiserfs_xattr_get(d_inode(dentry), name, buffer, size);
 }
 
 static int
@@ -27,10 +27,10 @@ trusted_set(struct dentry *dentry, const char *name, const void *buffer,
 	if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
 		return -EINVAL;
 
-	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(dentry->d_inode))
+	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);
+	return reiserfs_xattr_set(d_inode(dentry), name, buffer, size, flags);
 }
 
 static size_t trusted_list(struct dentry *dentry, char *list, size_t list_size,
@@ -38,7 +38,7 @@ static size_t trusted_list(struct dentry *dentry, char *list, size_t list_size,
 {
 	const size_t len = name_len + 1;
 
-	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(dentry->d_inode))
+	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(d_inode(dentry)))
 		return 0;
 
 	if (list && len <= list_size) {
diff --git a/fs/reiserfs/xattr_user.c b/fs/reiserfs/xattr_user.c
index 8667491ae7c3..a94aca35a838 100644
--- a/fs/reiserfs/xattr_user.c
+++ b/fs/reiserfs/xattr_user.c
@@ -15,7 +15,7 @@ user_get(struct dentry *dentry, const char *name, void *buffer, size_t size,
 		return -EINVAL;
 	if (!reiserfs_xattrs_user(dentry->d_sb))
 		return -EOPNOTSUPP;
-	return reiserfs_xattr_get(dentry->d_inode, name, buffer, size);
+	return reiserfs_xattr_get(d_inode(dentry), name, buffer, size);
 }
 
 static int
@@ -27,7 +27,7 @@ user_set(struct dentry *dentry, const char *name, const void *buffer,
 
 	if (!reiserfs_xattrs_user(dentry->d_sb))
 		return -EOPNOTSUPP;
-	return reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);
+	return reiserfs_xattr_set(d_inode(dentry), name, buffer, size, flags);
 }
 
 static size_t user_list(struct dentry *dentry, char *list, size_t list_size,
diff --git a/fs/squashfs/export.c b/fs/squashfs/export.c
index 5e1101ff276f..8073b6532cf0 100644
--- a/fs/squashfs/export.c
+++ b/fs/squashfs/export.c
@@ -110,7 +110,7 @@ static struct dentry *squashfs_fh_to_parent(struct super_block *sb,
 
 static struct dentry *squashfs_get_parent(struct dentry *child)
 {
-	struct inode *inode = child->d_inode;
+	struct inode *inode = d_inode(child);
 	unsigned int parent_ino = squashfs_i(inode)->parent;
 
 	return squashfs_export_iget(inode->i_sb, parent_ino);
diff --git a/fs/squashfs/xattr.c b/fs/squashfs/xattr.c
index 92fcde7b4d61..e5e0ddf5b143 100644
--- a/fs/squashfs/xattr.c
+++ b/fs/squashfs/xattr.c
@@ -39,7 +39,7 @@ static const struct xattr_handler *squashfs_xattr_handler(int);
 ssize_t squashfs_listxattr(struct dentry *d, char *buffer,
 	size_t buffer_size)
 {
-	struct inode *inode = d->d_inode;
+	struct inode *inode = d_inode(d);
 	struct super_block *sb = inode->i_sb;
 	struct squashfs_sb_info *msblk = sb->s_fs_info;
 	u64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)
@@ -229,7 +229,7 @@ static int squashfs_user_get(struct dentry *d, const char *name, void *buffer,
 	if (name[0] == '\0')
 		return  -EINVAL;
 
-	return squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_USER, name,
+	return squashfs_xattr_get(d_inode(d), SQUASHFS_XATTR_USER, name,
 		buffer, size);
 }
 
@@ -259,7 +259,7 @@ static int squashfs_trusted_get(struct dentry *d, const char *name,
 	if (name[0] == '\0')
 		return  -EINVAL;
 
-	return squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_TRUSTED, name,
+	return squashfs_xattr_get(d_inode(d), SQUASHFS_XATTR_TRUSTED, name,
 		buffer, size);
 }
 
@@ -286,7 +286,7 @@ static int squashfs_security_get(struct dentry *d, const char *name,
 	if (name[0] == '\0')
 		return  -EINVAL;
 
-	return squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_SECURITY, name,
+	return squashfs_xattr_get(d_inode(d), SQUASHFS_XATTR_SECURITY, name,
 		buffer, size);
 }
 
diff --git a/fs/sysv/dir.c b/fs/sysv/dir.c
index 3799e8dac3eb..70b62ca273aa 100644
--- a/fs/sysv/dir.c
+++ b/fs/sysv/dir.c
@@ -137,7 +137,7 @@ struct sysv_dir_entry *sysv_find_entry(struct dentry *dentry, struct page **res_
 {
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
-	struct inode * dir = dentry->d_parent->d_inode;
+	struct inode * dir = d_inode(dentry->d_parent);
 	unsigned long start, n;
 	unsigned long npages = dir_pages(dir);
 	struct page *page = NULL;
@@ -181,7 +181,7 @@ found:
 
 int sysv_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct page *page = NULL;
diff --git a/fs/sysv/file.c b/fs/sysv/file.c
index 9d4dc6831792..9deb639b15dd 100644
--- a/fs/sysv/file.c
+++ b/fs/sysv/file.c
@@ -32,7 +32,7 @@ const struct file_operations sysv_file_operations = {
 
 static int sysv_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff --git a/fs/sysv/itree.c b/fs/sysv/itree.c
index 66bc316927e8..2fde40acf024 100644
--- a/fs/sysv/itree.c
+++ b/fs/sysv/itree.c
@@ -443,7 +443,7 @@ static unsigned sysv_nblocks(struct super_block *s, loff_t size)
 int sysv_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct super_block *s = dentry->d_sb;
-	generic_fillattr(dentry->d_inode, stat);
+	generic_fillattr(d_inode(dentry), stat);
 	stat->blocks = (s->s_blocksize / 512) * sysv_nblocks(s, stat->size);
 	stat->blksize = s->s_blocksize;
 	return 0;
diff --git a/fs/sysv/namei.c b/fs/sysv/namei.c
index 731b2bbcaab3..11e83ed0b4bf 100644
--- a/fs/sysv/namei.c
+++ b/fs/sysv/namei.c
@@ -118,7 +118,7 @@ out_fail:
 static int sysv_link(struct dentry * old_dentry, struct inode * dir, 
 	struct dentry * dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	inode->i_ctime = CURRENT_TIME_SEC;
 	inode_inc_link_count(inode);
@@ -166,7 +166,7 @@ out_dir:
 
 static int sysv_unlink(struct inode * dir, struct dentry * dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct page * page;
 	struct sysv_dir_entry * de;
 	int err = -ENOENT;
@@ -187,7 +187,7 @@ out:
 
 static int sysv_rmdir(struct inode * dir, struct dentry * dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (sysv_empty_dir(inode)) {
@@ -208,8 +208,8 @@ static int sysv_rmdir(struct inode * dir, struct dentry * dentry)
 static int sysv_rename(struct inode * old_dir, struct dentry * old_dentry,
 		  struct inode * new_dir, struct dentry * new_dentry)
 {
-	struct inode * old_inode = old_dentry->d_inode;
-	struct inode * new_inode = new_dentry->d_inode;
+	struct inode * old_inode = d_inode(old_dentry);
+	struct inode * new_inode = d_inode(new_dentry);
 	struct page * dir_page = NULL;
 	struct sysv_dir_entry * dir_de = NULL;
 	struct page * old_page;
diff --git a/fs/sysv/symlink.c b/fs/sysv/symlink.c
index 00d2f8a43e4e..d3fa0d703314 100644
--- a/fs/sysv/symlink.c
+++ b/fs/sysv/symlink.c
@@ -10,7 +10,7 @@
 
 static void *sysv_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	nd_set_link(nd, (char *)SYSV_I(dentry->d_inode)->i_data);
+	nd_set_link(nd, (char *)SYSV_I(d_inode(dentry))->i_data);
 	return NULL;
 }
 
diff --git a/fs/ubifs/dir.c b/fs/ubifs/dir.c
index 605af512aec2..b9a07a93b713 100644
--- a/fs/ubifs/dir.c
+++ b/fs/ubifs/dir.c
@@ -522,7 +522,7 @@ static int ubifs_link(struct dentry *old_dentry, struct inode *dir,
 		      struct dentry *dentry)
 {
 	struct ubifs_info *c = dir->i_sb->s_fs_info;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct ubifs_inode *ui = ubifs_inode(inode);
 	struct ubifs_inode *dir_ui = ubifs_inode(dir);
 	int err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);
@@ -577,7 +577,7 @@ out_cancel:
 static int ubifs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct ubifs_info *c = dir->i_sb->s_fs_info;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ubifs_inode *dir_ui = ubifs_inode(dir);
 	int sz_change = CALC_DENT_SIZE(dentry->d_name.len);
 	int err, budgeted = 1;
@@ -669,7 +669,7 @@ static int check_dir_empty(struct ubifs_info *c, struct inode *dir)
 static int ubifs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	struct ubifs_info *c = dir->i_sb->s_fs_info;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int sz_change = CALC_DENT_SIZE(dentry->d_name.len);
 	int err, budgeted = 1;
 	struct ubifs_inode *dir_ui = ubifs_inode(dir);
@@ -685,7 +685,7 @@ static int ubifs_rmdir(struct inode *dir, struct dentry *dentry)
 		dentry->d_name.name, inode->i_ino, dir->i_ino);
 	ubifs_assert(mutex_is_locked(&dir->i_mutex));
 	ubifs_assert(mutex_is_locked(&inode->i_mutex));
-	err = check_dir_empty(c, dentry->d_inode);
+	err = check_dir_empty(c, d_inode(dentry));
 	if (err)
 		return err;
 
@@ -980,8 +980,8 @@ static int ubifs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct ubifs_info *c = old_dir->i_sb->s_fs_info;
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct ubifs_inode *old_inode_ui = ubifs_inode(old_inode);
 	int err, release, sync = 0, move = (new_dir != old_dir);
 	int is_dir = S_ISDIR(old_inode->i_mode);
@@ -1147,7 +1147,7 @@ int ubifs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		  struct kstat *stat)
 {
 	loff_t size;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ubifs_inode *ui = ubifs_inode(inode);
 
 	mutex_lock(&ui->ui_mutex);
diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c
index 14374530784c..382516351685 100644
--- a/fs/ubifs/file.c
+++ b/fs/ubifs/file.c
@@ -1255,7 +1255,7 @@ static int do_setattr(struct ubifs_info *c, struct inode *inode,
 int ubifs_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int err;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ubifs_info *c = inode->i_sb->s_fs_info;
 
 	dbg_gen("ino %lu, mode %#x, ia_valid %#x",
@@ -1299,7 +1299,7 @@ static void ubifs_invalidatepage(struct page *page, unsigned long offset)
 
 static void *ubifs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ubifs_inode *ui = ubifs_inode(dentry->d_inode);
+	struct ubifs_inode *ui = ubifs_inode(d_inode(dentry));
 
 	nd_set_link(nd, ui->data);
 	return NULL;
diff --git a/fs/ubifs/journal.c b/fs/ubifs/journal.c
index afaad07f3b29..013d6a0b1d0d 100644
--- a/fs/ubifs/journal.c
+++ b/fs/ubifs/journal.c
@@ -926,8 +926,8 @@ int ubifs_jnl_rename(struct ubifs_info *c, const struct inode *old_dir,
 	union ubifs_key key;
 	struct ubifs_dent_node *dent, *dent2;
 	int err, dlen1, dlen2, ilen, lnum, offs, len;
-	const struct inode *old_inode = old_dentry->d_inode;
-	const struct inode *new_inode = new_dentry->d_inode;
+	const struct inode *old_inode = d_inode(old_dentry);
+	const struct inode *new_inode = d_inode(new_dentry);
 	int aligned_dlen1, aligned_dlen2, plen = UBIFS_INO_NODE_SZ;
 	int last_reference = !!(new_inode && new_inode->i_nlink == 0);
 	int move = (old_dir != new_dir);
* Unmerged path fs/ubifs/xattr.c
diff --git a/fs/udf/file.c b/fs/udf/file.c
index 29569dd08168..1e7c234a3a20 100644
--- a/fs/udf/file.c
+++ b/fs/udf/file.c
@@ -257,7 +257,7 @@ const struct file_operations udf_file_operations = {
 
 static int udf_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
* Unmerged path fs/udf/namei.c
diff --git a/fs/ufs/dir.c b/fs/ufs/dir.c
index 3a75ca09c506..c5835c52ffd1 100644
--- a/fs/ufs/dir.c
+++ b/fs/ufs/dir.c
@@ -311,7 +311,7 @@ found:
  */
 int ufs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const unsigned char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct super_block *sb = dir->i_sb;
diff --git a/fs/ufs/namei.c b/fs/ufs/namei.c
index 90d74b8f8eba..effb975c9810 100644
--- a/fs/ufs/namei.c
+++ b/fs/ufs/namei.c
@@ -162,7 +162,7 @@ out_fail:
 static int ufs_link (struct dentry * old_dentry, struct inode * dir,
 	struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int error;
 
 	lock_ufs(dir->i_sb);
@@ -220,7 +220,7 @@ out_dir:
 
 static int ufs_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct ufs_dir_entry *de;
 	struct page *page;
 	int err = -ENOENT;
@@ -242,7 +242,7 @@ out:
 
 static int ufs_rmdir (struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	int err= -ENOTEMPTY;
 
 	lock_ufs(dir->i_sb);
@@ -261,8 +261,8 @@ static int ufs_rmdir (struct inode * dir, struct dentry *dentry)
 static int ufs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		      struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct page *dir_page = NULL;
 	struct ufs_dir_entry * dir_de = NULL;
 	struct page *old_page;
diff --git a/fs/ufs/super.c b/fs/ufs/super.c
index 329f2f53b7ed..84b12b9b8d21 100644
--- a/fs/ufs/super.c
+++ b/fs/ufs/super.c
@@ -149,10 +149,10 @@ static struct dentry *ufs_get_parent(struct dentry *child)
 	struct qstr dot_dot = QSTR_INIT("..", 2);
 	ino_t ino;
 
-	ino = ufs_inode_by_name(child->d_inode, &dot_dot);
+	ino = ufs_inode_by_name(d_inode(child), &dot_dot);
 	if (!ino)
 		return ERR_PTR(-ENOENT);
-	return d_obtain_alias(ufs_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(ufs_iget(d_inode(child)->i_sb, ino));
 }
 
 static const struct export_operations ufs_export_ops = {
diff --git a/fs/ufs/symlink.c b/fs/ufs/symlink.c
index d283628b4778..5b537e2fdda3 100644
--- a/fs/ufs/symlink.c
+++ b/fs/ufs/symlink.c
@@ -34,7 +34,7 @@
 
 static void *ufs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ufs_inode_info *p = UFS_I(dentry->d_inode);
+	struct ufs_inode_info *p = UFS_I(d_inode(dentry));
 	nd_set_link(nd, (char*)p->i_u1.i_symlink);
 	return NULL;
 }
diff --git a/fs/ufs/truncate.c b/fs/ufs/truncate.c
index f04f89fbd4d9..21154704c168 100644
--- a/fs/ufs/truncate.c
+++ b/fs/ufs/truncate.c
@@ -492,7 +492,7 @@ out:
 
 int ufs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int ia_valid = attr->ia_valid;
 	int error;
 
diff --git a/fs/xfs/xfs_export.c b/fs/xfs/xfs_export.c
index b97359ba2648..652cd3c5b58c 100644
--- a/fs/xfs/xfs_export.c
+++ b/fs/xfs/xfs_export.c
@@ -215,7 +215,7 @@ xfs_fs_get_parent(
 	int			error;
 	struct xfs_inode	*cip;
 
-	error = xfs_lookup(XFS_I(child->d_inode), &xfs_name_dotdot, &cip, NULL);
+	error = xfs_lookup(XFS_I(d_inode(child)), &xfs_name_dotdot, &cip, NULL);
 	if (unlikely(error))
 		return ERR_PTR(error);
 
diff --git a/fs/xfs/xfs_filestream.c b/fs/xfs/xfs_filestream.c
index b83fa8c53ee4..c4c130f9bfb6 100644
--- a/fs/xfs/xfs_filestream.c
+++ b/fs/xfs/xfs_filestream.c
@@ -295,7 +295,7 @@ xfs_filestream_get_parent(
 	if (!parent)
 		goto out_dput;
 
-	dir = igrab(parent->d_inode);
+	dir = igrab(d_inode(parent));
 	dput(parent);
 
 out_dput:
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 0642c762e0aa..91de5490287e 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -82,7 +82,7 @@ xfs_find_handle(
 		error = user_lpath((const char __user *)hreq->path, &path);
 		if (error)
 			return error;
-		inode = path.dentry->d_inode;
+		inode = d_inode(path.dentry);
 	}
 	ip = XFS_I(inode);
 
@@ -210,7 +210,7 @@ xfs_open_by_handle(
 	dentry = xfs_handlereq_to_dentry(parfilp, hreq);
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	/* Restrict xfs_open_by_handle to directories & regular files. */
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {
@@ -329,7 +329,7 @@ xfs_readlink_by_handle(
 		goto out_dput;
 	}
 
-	error = xfs_readlink(XFS_I(dentry->d_inode), link);
+	error = xfs_readlink(XFS_I(d_inode(dentry)), link);
 	if (error)
 		goto out_kfree;
 	error = do_readlink(hreq->ohandle, olen, link);
@@ -402,7 +402,7 @@ xfs_fssetdm_by_handle(
 		return PTR_ERR(dentry);
 	}
 
-	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {
+	if (IS_IMMUTABLE(d_inode(dentry)) || IS_APPEND(d_inode(dentry))) {
 		error = -EPERM;
 		goto out;
 	}
@@ -412,7 +412,7 @@ xfs_fssetdm_by_handle(
 		goto out;
 	}
 
-	error = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,
+	error = xfs_set_dmattrs(XFS_I(d_inode(dentry)), fsd.fsd_dmevmask,
 				 fsd.fsd_dmstate);
 
  out:
@@ -455,7 +455,7 @@ xfs_attrlist_by_handle(
 		goto out_dput;
 
 	cursor = (attrlist_cursor_kern_t *)&al_hreq.pos;
-	error = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,
+	error = xfs_attr_list(XFS_I(d_inode(dentry)), kbuf, al_hreq.buflen,
 					al_hreq.flags, cursor);
 	if (error)
 		goto out_kfree;
@@ -588,7 +588,7 @@ xfs_attrmulti_by_handle(
 		switch (ops[i].am_opcode) {
 		case ATTR_OP_GET:
 			ops[i].am_error = xfs_attrmulti_attr_get(
-					dentry->d_inode, attr_name,
+					d_inode(dentry), attr_name,
 					ops[i].am_attrvalue, &ops[i].am_length,
 					ops[i].am_flags);
 			break;
@@ -597,7 +597,7 @@ xfs_attrmulti_by_handle(
 			if (ops[i].am_error)
 				break;
 			ops[i].am_error = xfs_attrmulti_attr_set(
-					dentry->d_inode, attr_name,
+					d_inode(dentry), attr_name,
 					ops[i].am_attrvalue, ops[i].am_length,
 					ops[i].am_flags);
 			mnt_drop_write_file(parfilp);
@@ -607,7 +607,7 @@ xfs_attrmulti_by_handle(
 			if (ops[i].am_error)
 				break;
 			ops[i].am_error = xfs_attrmulti_attr_remove(
-					dentry->d_inode, attr_name,
+					d_inode(dentry), attr_name,
 					ops[i].am_flags);
 			mnt_drop_write_file(parfilp);
 			break;
diff --git a/fs/xfs/xfs_ioctl32.c b/fs/xfs/xfs_ioctl32.c
index 5c5d2ea5f82d..1a05d8ae327d 100644
--- a/fs/xfs/xfs_ioctl32.c
+++ b/fs/xfs/xfs_ioctl32.c
@@ -375,7 +375,7 @@ xfs_compat_attrlist_by_handle(
 		goto out_dput;
 
 	cursor = (attrlist_cursor_kern_t *)&al_hreq.pos;
-	error = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,
+	error = xfs_attr_list(XFS_I(d_inode(dentry)), kbuf, al_hreq.buflen,
 					al_hreq.flags, cursor);
 	if (error)
 		goto out_kfree;
@@ -445,7 +445,7 @@ xfs_compat_attrmulti_by_handle(
 		switch (ops[i].am_opcode) {
 		case ATTR_OP_GET:
 			ops[i].am_error = xfs_attrmulti_attr_get(
-					dentry->d_inode, attr_name,
+					d_inode(dentry), attr_name,
 					compat_ptr(ops[i].am_attrvalue),
 					&ops[i].am_length, ops[i].am_flags);
 			break;
@@ -454,7 +454,7 @@ xfs_compat_attrmulti_by_handle(
 			if (ops[i].am_error)
 				break;
 			ops[i].am_error = xfs_attrmulti_attr_set(
-					dentry->d_inode, attr_name,
+					d_inode(dentry), attr_name,
 					compat_ptr(ops[i].am_attrvalue),
 					ops[i].am_length, ops[i].am_flags);
 			mnt_drop_write_file(parfilp);
@@ -464,7 +464,7 @@ xfs_compat_attrmulti_by_handle(
 			if (ops[i].am_error)
 				break;
 			ops[i].am_error = xfs_attrmulti_attr_remove(
-					dentry->d_inode, attr_name,
+					d_inode(dentry), attr_name,
 					ops[i].am_flags);
 			mnt_drop_write_file(parfilp);
 			break;
@@ -504,7 +504,7 @@ xfs_compat_fssetdm_by_handle(
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
-	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {
+	if (IS_IMMUTABLE(d_inode(dentry)) || IS_APPEND(d_inode(dentry))) {
 		error = -EPERM;
 		goto out;
 	}
@@ -514,7 +514,7 @@ xfs_compat_fssetdm_by_handle(
 		goto out;
 	}
 
-	error = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,
+	error = xfs_set_dmattrs(XFS_I(d_inode(dentry)), fsd.fsd_dmevmask,
 				 fsd.fsd_dmstate);
 
 out:
* Unmerged path fs/xfs/xfs_iops.c
diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c
index 5385dfd365ef..17c170dd3c1c 100644
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -1062,7 +1062,7 @@ xfs_fs_statfs(
 {
 	struct xfs_mount	*mp = XFS_M(dentry->d_sb);
 	xfs_sb_t		*sbp = &mp->m_sb;
-	struct xfs_inode	*ip = XFS_I(dentry->d_inode);
+	struct xfs_inode	*ip = XFS_I(d_inode(dentry));
 	__uint64_t		fakeinos, id;
 	__uint64_t		icount;
 	__uint64_t		ifree;
diff --git a/fs/xfs/xfs_xattr.c b/fs/xfs/xfs_xattr.c
index a1dbcfdc89a5..56f6a5571a0f 100644
--- a/fs/xfs/xfs_xattr.c
+++ b/fs/xfs/xfs_xattr.c
@@ -35,7 +35,7 @@ static int
 xfs_xattr_get(struct dentry *dentry, const char *name,
 		void *value, size_t size, int xflags)
 {
-	struct xfs_inode *ip = XFS_I(dentry->d_inode);
+	struct xfs_inode *ip = XFS_I(d_inode(dentry));
 	int error, asize = size;
 
 	if (strcmp(name, "") == 0)
@@ -57,7 +57,7 @@ static int
 xfs_xattr_set(struct dentry *dentry, const char *name, const void *value,
 		size_t size, int flags, int xflags)
 {
-	struct xfs_inode *ip = XFS_I(dentry->d_inode);
+	struct xfs_inode *ip = XFS_I(d_inode(dentry));
 
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
@@ -197,7 +197,7 @@ xfs_vn_listxattr(struct dentry *dentry, char *data, size_t size)
 {
 	struct xfs_attr_list_context context;
 	struct attrlist_cursor_kern cursor = { 0 };
-	struct inode		*inode = dentry->d_inode;
+	struct inode		*inode = d_inode(dentry);
 	int			error;
 
 	/*
diff --git a/include/trace/events/btrfs.h b/include/trace/events/btrfs.h
index 60903459ddf5..8f1a9e9c5b04 100644
--- a/include/trace/events/btrfs.h
+++ b/include/trace/events/btrfs.h
@@ -405,10 +405,10 @@ TRACE_EVENT(btrfs_sync_file,
 
 	TP_fast_assign(
 		struct dentry *dentry = file->f_path.dentry;
-		struct inode *inode = dentry->d_inode;
+		struct inode *inode = d_inode(dentry);
 
 		__entry->ino		= inode->i_ino;
-		__entry->parent		= dentry->d_parent->d_inode->i_ino;
+		__entry->parent		= d_inode(dentry->d_parent)->i_ino;
 		__entry->datasync	= datasync;
 		__entry->root_objectid	=
 				 BTRFS_I(inode)->root->root_key.objectid;
diff --git a/include/trace/events/ext3.h b/include/trace/events/ext3.h
index 15d11a39be47..cf5ce4adcb65 100644
--- a/include/trace/events/ext3.h
+++ b/include/trace/events/ext3.h
@@ -437,10 +437,10 @@ TRACE_EVENT(ext3_sync_file_enter,
 	TP_fast_assign(
 		struct dentry *dentry = file->f_path.dentry;
 
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ino		= dentry->d_inode->i_ino;
+		__entry->dev		= d_inode(dentry)->i_sb->s_dev;
+		__entry->ino		= d_inode(dentry)->i_ino;
 		__entry->datasync	= datasync;
-		__entry->parent		= dentry->d_parent->d_inode->i_ino;
+		__entry->parent		= d_inode(dentry->d_parent)->i_ino;
 	),
 
 	TP_printk("dev %d,%d ino %lu parent %ld datasync %d ",
@@ -708,9 +708,9 @@ TRACE_EVENT(ext3_unlink_enter,
 
 	TP_fast_assign(
 		__entry->parent		= parent->i_ino;
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->size		= dentry->d_inode->i_size;
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
+		__entry->ino		= d_inode(dentry)->i_ino;
+		__entry->size		= d_inode(dentry)->i_size;
+		__entry->dev		= d_inode(dentry)->i_sb->s_dev;
 	),
 
 	TP_printk("dev %d,%d ino %lu size %lld parent %ld",
@@ -732,8 +732,8 @@ TRACE_EVENT(ext3_unlink_exit,
 	),
 
 	TP_fast_assign(
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
+		__entry->ino		= d_inode(dentry)->i_ino;
+		__entry->dev		= d_inode(dentry)->i_sb->s_dev;
 		__entry->ret		= ret;
 	),
 
diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index 12cd04b9714f..e23f682df2b6 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -851,10 +851,10 @@ TRACE_EVENT(ext4_sync_file_enter,
 	TP_fast_assign(
 		struct dentry *dentry = file->f_path.dentry;
 
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ino		= dentry->d_inode->i_ino;
+		__entry->dev		= d_inode(dentry)->i_sb->s_dev;
+		__entry->ino		= d_inode(dentry)->i_ino;
 		__entry->datasync	= datasync;
-		__entry->parent		= dentry->d_parent->d_inode->i_ino;
+		__entry->parent		= d_inode(dentry->d_parent)->i_ino;
 	),
 
 	TP_printk("dev %d,%d ino %lu parent %lu datasync %d ",
@@ -1432,10 +1432,10 @@ TRACE_EVENT(ext4_unlink_enter,
 	),
 
 	TP_fast_assign(
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ino		= dentry->d_inode->i_ino;
+		__entry->dev		= d_inode(dentry)->i_sb->s_dev;
+		__entry->ino		= d_inode(dentry)->i_ino;
 		__entry->parent		= parent->i_ino;
-		__entry->size		= dentry->d_inode->i_size;
+		__entry->size		= d_inode(dentry)->i_size;
 	),
 
 	TP_printk("dev %d,%d ino %lu size %lld parent %lu",
@@ -1456,8 +1456,8 @@ TRACE_EVENT(ext4_unlink_exit,
 	),
 
 	TP_fast_assign(
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ino		= dentry->d_inode->i_ino;
+		__entry->dev		= d_inode(dentry)->i_sb->s_dev;
+		__entry->ino		= d_inode(dentry)->i_ino;
 		__entry->ret		= ret;
 	),
 
