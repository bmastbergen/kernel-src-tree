ACPI / tables: Add acpi_subtable_proc to ACPI table parsers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [acpi] tables: Add acpi_subtable_proc to ACPI table parsers (Prarit Bhargava) [1242556]
Rebuild_FUZZ: 93.69%
commit-author Lukasz Anaczkowski <lukasz.anaczkowski@intel.com>
commit 9b3fedde27d3d63055c43c05e8254e252e58ba48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9b3fedde.failed

ACPI subtable parsing needs to be extended to allow two or more
handlers to be run in the same ACPI table walk, thus adding
acpi_subtable_proc structure which stores
 () ACPI table id
 () handler that processes table
 () counter how many items has been processed
and passing it to acpi_parse_entries_array() and
acpi_table_parse_entries_array().

This is needed to fix CPU enumeration when APIC/X2APIC entries
are interleaved.

	Signed-off-by: Lukasz Anaczkowski <lukasz.anaczkowski@intel.com>
	Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
	Tested-by: Marc Zyngier <marc.zyngier@arm.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 9b3fedde27d3d63055c43c05e8254e252e58ba48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/tables.c
#	include/linux/acpi.h
diff --cc drivers/acpi/tables.c
index 30a9b1b13b27,c1ff58de99e9..000000000000
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@@ -199,33 -210,46 +199,69 @@@ void acpi_table_print_madt_entry(struc
  	}
  }
  
++<<<<<<< HEAD
 +
 +int __init
 +acpi_table_parse_entries(char *id,
 +			     unsigned long table_size,
 +			     int entry_id,
 +			     acpi_tbl_entry_handler handler,
 +			     unsigned int max_entries)
++=======
+ /**
+  * acpi_parse_entries_array - for each proc_num find a suitable subtable
+  *
+  * @id: table id (for debugging purposes)
+  * @table_size: single entry size
+  * @table_header: where does the table start?
+  * @proc: array of acpi_subtable_proc struct containing entry id
+  *        and associated handler with it
+  * @proc_num: how big proc is?
+  * @max_entries: how many entries can we process?
+  *
+  * For each proc_num find a subtable with proc->id and run proc->handler
+  * on it. Assumption is that there's only single handler for particular
+  * entry id.
+  *
+  * On success returns sum of all matching entries for all proc handlers.
+  * Otherwise, -ENODEV or -EINVAL is returned.
+  */
+ static int __init
+ acpi_parse_entries_array(char *id, unsigned long table_size,
+ 		struct acpi_table_header *table_header,
+ 		struct acpi_subtable_proc *proc, int proc_num,
+ 		unsigned int max_entries)
++>>>>>>> 9b3fedde27d3 (ACPI / tables: Add acpi_subtable_proc to ACPI table parsers)
  {
 +	struct acpi_table_header *table_header = NULL;
  	struct acpi_subtable_header *entry;
++<<<<<<< HEAD
 +	unsigned int count = 0;
 +	unsigned long table_end;
 +	acpi_size tbl_size;
++=======
+ 	unsigned long table_end;
+ 	int count = 0;
+ 	int i;
++>>>>>>> 9b3fedde27d3 (ACPI / tables: Add acpi_subtable_proc to ACPI table parsers)
  
  	if (acpi_disabled)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	if (!handler)
++=======
+ 	if (!id)
++>>>>>>> 9b3fedde27d3 (ACPI / tables: Add acpi_subtable_proc to ACPI table parsers)
  		return -EINVAL;
  
 -	if (!table_size)
 -		return -EINVAL;
 +	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
 +		acpi_get_table_with_size(id, acpi_apic_instance, &table_header, &tbl_size);
 +	else
 +		acpi_get_table_with_size(id, 0, &table_header, &tbl_size);
  
  	if (!table_header) {
 -		pr_warn("%4.4s not present\n", id);
 +		printk(KERN_WARNING PREFIX "%4.4s not present\n", id);
  		return -ENODEV;
  	}
  
@@@ -238,38 -262,107 +274,128 @@@
  
  	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
  	       table_end) {
++<<<<<<< HEAD
 +		if (entry->type == entry_id
 +		    && (!max_entries || count < max_entries)) {
 +			if (handler(entry, table_end))
 +				goto err;
- 
- 			count++;
++=======
+ 		if (max_entries && count >= max_entries)
+ 			break;
+ 
+ 		for (i = 0; i < proc_num; i++) {
+ 			if (entry->type != proc[i].id)
+ 				continue;
+ 			if (!proc->handler || proc[i].handler(entry, table_end))
+ 				return -EINVAL;
++>>>>>>> 9b3fedde27d3 (ACPI / tables: Add acpi_subtable_proc to ACPI table parsers)
+ 
+ 			proc->count++;
+ 			break;
  		}
+ 		if (i != proc_num)
+ 			count++;
  
  		/*
  		 * If entry->length is 0, break from this loop to avoid
  		 * infinite loop.
  		 */
  		if (entry->length == 0) {
++<<<<<<< HEAD
 +			pr_err(PREFIX "[%4.4s:0x%02x] Invalid zero length\n", id, entry_id);
 +			goto err;
++=======
+ 			pr_err("[%4.4s:0x%02x] Invalid zero length\n", id, proc->id);
+ 			return -EINVAL;
++>>>>>>> 9b3fedde27d3 (ACPI / tables: Add acpi_subtable_proc to ACPI table parsers)
  		}
  
  		entry = (struct acpi_subtable_header *)
  		    ((unsigned long)entry + entry->length);
  	}
 -
  	if (max_entries && count > max_entries) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING PREFIX "[%4.4s:0x%02x] ignored %i entries of "
 +		       "%i found\n", id, entry_id, count - max_entries, count);
 +	}
 +
++=======
+ 		pr_warn("[%4.4s:0x%02x] ignored %i entries of %i found\n",
+ 			id, proc->id, count - max_entries, count);
+ 	}
+ 
+ 	return count;
+ }
+ 
+ int __init
+ acpi_parse_entries(char *id,
+ 			unsigned long table_size,
+ 			acpi_tbl_entry_handler handler,
+ 			struct acpi_table_header *table_header,
+ 			int entry_id, unsigned int max_entries)
+ {
+ 	struct acpi_subtable_proc proc = {
+ 		.id		= entry_id,
+ 		.handler	= handler,
+ 	};
+ 
+ 	return acpi_parse_entries_array(id, table_size, table_header,
+ 			&proc, 1, max_entries);
+ }
+ 
+ int __init
+ acpi_table_parse_entries_array(char *id,
+ 			 unsigned long table_size,
+ 			 struct acpi_subtable_proc *proc, int proc_num,
+ 			 unsigned int max_entries)
+ {
+ 	struct acpi_table_header *table_header = NULL;
+ 	acpi_size tbl_size;
+ 	int count;
+ 	u32 instance = 0;
+ 
+ 	if (acpi_disabled)
+ 		return -ENODEV;
+ 
+ 	if (!id)
+ 		return -EINVAL;
+ 
+ 	if (!strncmp(id, ACPI_SIG_MADT, 4))
+ 		instance = acpi_apic_instance;
+ 
+ 	acpi_get_table_with_size(id, instance, &table_header, &tbl_size);
+ 	if (!table_header) {
+ 		pr_warn("%4.4s not present\n", id);
+ 		return -ENODEV;
+ 	}
+ 
+ 	count = acpi_parse_entries_array(id, table_size, table_header,
+ 			proc, proc_num, max_entries);
+ 
++>>>>>>> 9b3fedde27d3 (ACPI / tables: Add acpi_subtable_proc to ACPI table parsers)
  	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
  	return count;
 +err:
 +	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
 +	return -EINVAL;
  }
  
+ int __init
+ acpi_table_parse_entries(char *id,
+ 			unsigned long table_size,
+ 			int entry_id,
+ 			acpi_tbl_entry_handler handler,
+ 			unsigned int max_entries)
+ {
+ 	struct acpi_subtable_proc proc = {
+ 		.id		= entry_id,
+ 		.handler	= handler,
+ 	};
+ 
+ 	return acpi_table_parse_entries_array(id, table_size, &proc, 1,
+ 						max_entries);
+ }
+ 
  int __init
  acpi_table_parse_madt(enum acpi_madt_type id,
  		      acpi_tbl_entry_handler handler, unsigned int max_entries)
diff --cc include/linux/acpi.h
index d0b584048366,b0299f8db660..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -102,6 -127,16 +102,19 @@@ static inline void acpi_initrd_override
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ #define BAD_MADT_ENTRY(entry, end) (					    \
+ 		(!entry) || (unsigned long)entry + sizeof(*entry) > end ||  \
+ 		((struct acpi_subtable_header *)entry)->length < sizeof(*entry))
+ 
+ struct acpi_subtable_proc {
+ 	int id;
+ 	acpi_tbl_entry_handler handler;
+ 	int count;
+ };
+ 
++>>>>>>> 9b3fedde27d3 (ACPI / tables: Add acpi_subtable_proc to ACPI table parsers)
  char * __acpi_map_table (unsigned long phys_addr, unsigned long size);
  void __acpi_unmap_table(char *map, unsigned long size);
  int early_acpi_boot_init(void);
@@@ -112,10 -147,21 +125,17 @@@ int acpi_numa_init (void)
  
  int acpi_table_init (void);
  int acpi_table_parse(char *id, acpi_tbl_table_handler handler);
 -int __init acpi_parse_entries(char *id, unsigned long table_size,
 -			      acpi_tbl_entry_handler handler,
 -			      struct acpi_table_header *table_header,
 -			      int entry_id, unsigned int max_entries);
  int __init acpi_table_parse_entries(char *id, unsigned long table_size,
- 				    int entry_id,
- 				    acpi_tbl_entry_handler handler,
- 				    unsigned int max_entries);
+ 			      int entry_id,
+ 			      acpi_tbl_entry_handler handler,
+ 			      unsigned int max_entries);
+ int __init acpi_table_parse_entries(char *id, unsigned long table_size,
+ 			      int entry_id,
+ 			      acpi_tbl_entry_handler handler,
+ 			      unsigned int max_entries);
+ int __init acpi_table_parse_entries_array(char *id, unsigned long table_size,
+ 			      struct acpi_subtable_proc *proc, int proc_num,
+ 			      unsigned int max_entries);
  int acpi_table_parse_madt(enum acpi_madt_type id,
  			  acpi_tbl_entry_handler handler,
  			  unsigned int max_entries);
* Unmerged path drivers/acpi/tables.c
* Unmerged path include/linux/acpi.h
