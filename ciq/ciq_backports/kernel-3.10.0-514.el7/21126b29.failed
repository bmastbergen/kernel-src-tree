ACPICA: Remove extraneous error message for large number of GPEs.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [acpi] acpica: Remove extraneous error message for large number of GPEs (Prarit Bhargava) [1305532]
Rebuild_FUZZ: 99.22%
commit-author Bob Moore <robert.moore@intel.com>
commit 21126b296e6f5f172e72da7cebb42b87fbd19b3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/21126b29.failed

Fixes a problem where an extraneous error message was emitted during
initialization if there is a GPE block larger than 255 bits. Any
GPE block larger than 120 GPEs could generate the error.

	Signed-off-by: Bob Moore <robert.moore@intel.com>
	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 21126b296e6f5f172e72da7cebb42b87fbd19b3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpica/tbfadt.c
diff --cc drivers/acpi/acpica/tbfadt.c
index 33b00d22300a,41519a958083..000000000000
--- a/drivers/acpi/acpica/tbfadt.c
+++ b/drivers/acpi/acpica/tbfadt.c
@@@ -376,33 -458,13 +388,38 @@@ void acpi_tb_create_local_fadt(struct a
  
  static void acpi_tb_convert_fadt(void)
  {
 -	char *name;
  	struct acpi_generic_address *address64;
  	u32 address32;
++<<<<<<< HEAD
++=======
+ 	u8 length;
+ 	u8 flags;
++>>>>>>> 21126b296e6f (ACPICA: Remove extraneous error message for large number of GPEs.)
  	u32 i;
  
 +	/*
 +	 * Expand the 32-bit FACS and DSDT addresses to 64-bit as necessary.
 +	 * Later code will always use the X 64-bit field. Also, check for an
 +	 * address mismatch between the 32-bit and 64-bit address fields
 +	 * (FIRMWARE_CTRL/X_FIRMWARE_CTRL, DSDT/X_DSDT) which would indicate
 +	 * the presence of two FACS or two DSDT tables.
 +	 */
 +	if (!acpi_gbl_FADT.Xfacs) {
 +		acpi_gbl_FADT.Xfacs = (u64) acpi_gbl_FADT.facs;
 +	} else if (acpi_gbl_FADT.facs &&
 +		   (acpi_gbl_FADT.Xfacs != (u64) acpi_gbl_FADT.facs)) {
 +		ACPI_WARNING((AE_INFO,
 +		    "32/64 FACS address mismatch in FADT - two FACS tables!"));
 +	}
 +
 +	if (!acpi_gbl_FADT.Xdsdt) {
 +		acpi_gbl_FADT.Xdsdt = (u64) acpi_gbl_FADT.dsdt;
 +	} else if (acpi_gbl_FADT.dsdt &&
 +		   (acpi_gbl_FADT.Xdsdt != (u64) acpi_gbl_FADT.dsdt)) {
 +		ACPI_WARNING((AE_INFO,
 +		    "32/64 DSDT address mismatch in FADT - two DSDT tables!"));
 +	}
 +
  	/*
  	 * For ACPI 1.0 FADTs (revision 1 or 2), ensure that reserved fields which
  	 * should be zero are indeed zero. This will workaround BIOSs that
@@@ -551,12 -518,91 +568,88 @@@ static void acpi_tb_validate_fadt(void
  		address64 = ACPI_ADD_PTR(struct acpi_generic_address,
  					 &acpi_gbl_FADT,
  					 fadt_info_table[i].address64);
 -
 -		length = *ACPI_ADD_PTR(u8,
 -				       &acpi_gbl_FADT,
 -				       fadt_info_table[i].length);
 -
 +		length =
 +		    *ACPI_ADD_PTR(u8, &acpi_gbl_FADT,
 +				  fadt_info_table[i].length);
  		name = fadt_info_table[i].name;
+ 		flags = fadt_info_table[i].flags;
+ 
+ 		/*
++<<<<<<< HEAD
++=======
+ 		 * Expand the ACPI 1.0 32-bit addresses to the ACPI 2.0 64-bit "X"
+ 		 * generic address structures as necessary. Later code will always use
+ 		 * the 64-bit address structures.
+ 		 *
+ 		 * November 2013:
+ 		 * Now always use the 64-bit address if it is valid (non-zero), in
+ 		 * accordance with the ACPI specification which states that a 64-bit
+ 		 * address supersedes the 32-bit version. This behavior can be
+ 		 * overridden by the acpi_gbl_use32_bit_fadt_addresses flag.
+ 		 *
+ 		 * During 64-bit address construction and verification,
+ 		 * these cases are handled:
+ 		 *
+ 		 * Address32 zero, Address64 [don't care]   - Use Address64
+ 		 *
+ 		 * Address32 non-zero, Address64 zero       - Copy/use Address32
+ 		 * Address32 non-zero == Address64 non-zero - Use Address64
+ 		 * Address32 non-zero != Address64 non-zero - Warning, use Address64
+ 		 *
+ 		 * Override: if acpi_gbl_use32_bit_fadt_addresses is TRUE, and:
+ 		 * Address32 non-zero != Address64 non-zero - Warning, copy/use Address32
+ 		 *
+ 		 * Note: space_id is always I/O for 32-bit legacy address fields
+ 		 */
+ 		if (address32) {
+ 			if (!address64->address) {
+ 
+ 				/* 64-bit address is zero, use 32-bit address */
+ 
+ 				acpi_tb_init_generic_address(address64,
+ 							     ACPI_ADR_SPACE_SYSTEM_IO,
+ 							     *ACPI_ADD_PTR(u8,
+ 									   &acpi_gbl_FADT,
+ 									   fadt_info_table
+ 									   [i].
+ 									   length),
+ 							     (u64)address32,
+ 							     name, flags);
+ 			} else if (address64->address != (u64)address32) {
+ 
+ 				/* Address mismatch */
+ 
+ 				ACPI_BIOS_WARNING((AE_INFO,
+ 						   "32/64X address mismatch in FADT/%s: "
+ 						   "0x%8.8X/0x%8.8X%8.8X, using %u-bit address",
+ 						   name, address32,
+ 						   ACPI_FORMAT_UINT64
+ 						   (address64->address),
+ 						   acpi_gbl_use32_bit_fadt_addresses
+ 						   ? 32 : 64));
+ 
+ 				if (acpi_gbl_use32_bit_fadt_addresses) {
+ 
+ 					/* 32-bit address override */
+ 
+ 					acpi_tb_init_generic_address(address64,
+ 								     ACPI_ADR_SPACE_SYSTEM_IO,
+ 								     *ACPI_ADD_PTR
+ 								     (u8,
+ 								      &acpi_gbl_FADT,
+ 								      fadt_info_table
+ 								      [i].
+ 								      length),
+ 								     (u64)
+ 								     address32,
+ 								     name,
+ 								     flags);
+ 				}
+ 			}
+ 		}
  
  		/*
++>>>>>>> 21126b296e6f (ACPICA: Remove extraneous error message for large number of GPEs.)
  		 * For each extended field, check for length mismatch between the
  		 * legacy length field and the corresponding 64-bit X length field.
  		 * Note: If the legacy length field is > 0xFF bits, ignore this
@@@ -572,9 -618,9 +665,9 @@@
  					   address64->bit_width));
  		}
  
- 		if (fadt_info_table[i].type & ACPI_FADT_REQUIRED) {
+ 		if (fadt_info_table[i].flags & ACPI_FADT_REQUIRED) {
  			/*
 -			 * Field is required (Pm1a_event, Pm1a_control).
 +			 * Field is required (Pm1a_event, Pm1a_control, pm_timer).
  			 * Both the address and length must be non-zero.
  			 */
  			if (!address64->address || !length) {
* Unmerged path drivers/acpi/acpica/tbfadt.c
