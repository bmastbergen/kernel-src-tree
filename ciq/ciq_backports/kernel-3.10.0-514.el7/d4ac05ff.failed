vxlan: introduce vxlan_hdr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit d4ac05ff3697e036dcb0e2e284c5f7eb77cc0966
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d4ac05ff.failed

Currently, pointer to the vxlan header is kept in a local variable. It has
to be reloaded whenever the pskb pull operations are performed which usually
happens somewhere deep in called functions.

Create a vxlan_hdr function and use it to reference the vxlan header
instead.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4ac05ff3697e036dcb0e2e284c5f7eb77cc0966)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index a2751f4f523c,524e3b139122..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1157,10 -1161,105 +1157,9 @@@ static struct vxlanhdr *vxlan_remcsum(s
  /* Callback from net/ipv4/udp.c to receive packets */
  static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)
  {
 -	struct metadata_dst *tun_dst = NULL;
  	struct vxlan_sock *vs;
- 	struct vxlanhdr *vxh;
  	u32 flags, vni;
 -	struct vxlan_metadata _md;
 -	struct vxlan_metadata *md = &_md;
 +	struct vxlan_metadata md = {0};
  
  	/* Need Vxlan and inner Ethernet header to be present */
  	if (!pskb_may_pull(skb, VXLAN_HLEN))
@@@ -1201,14 -1309,17 +1197,22 @@@
  	if ((flags & VXLAN_HF_GBP) && (vs->flags & VXLAN_F_GBP)) {
  		struct vxlanhdr_gbp *gbp;
  
++<<<<<<< HEAD
 +		gbp = (struct vxlanhdr_gbp *)vxh;
 +		md.gbp = ntohs(gbp->policy_id);
++=======
+ 		gbp = (struct vxlanhdr_gbp *)vxlan_hdr(skb);
+ 		md->gbp = ntohs(gbp->policy_id);
+ 
+ 		if (tun_dst)
+ 			tun_dst->u.tun_info.key.tun_flags |= TUNNEL_VXLAN_OPT;
++>>>>>>> d4ac05ff3697 (vxlan: introduce vxlan_hdr)
  
  		if (gbp->dont_learn)
 -			md->gbp |= VXLAN_GBP_DONT_LEARN;
 +			md.gbp |= VXLAN_GBP_DONT_LEARN;
  
  		if (gbp->policy_applied)
 -			md->gbp |= VXLAN_GBP_POLICY_APPLIED;
 +			md.gbp |= VXLAN_GBP_POLICY_APPLIED;
  
  		flags &= ~VXLAN_GBP_USED_BITS;
  	}
@@@ -1237,9 -1347,13 +1241,10 @@@ drop
  
  bad_flags:
  	netdev_dbg(skb->dev, "invalid vxlan flags=%#x vni=%#x\n",
- 		   ntohl(vxh->vx_flags), ntohl(vxh->vx_vni));
+ 		   ntohl(vxlan_hdr(skb)->vx_flags),
+ 		   ntohl(vxlan_hdr(skb)->vx_vni));
  
  error:
 -	if (tun_dst)
 -		dst_release((struct dst_entry *)tun_dst);
 -
  	/* Return non vxlan pkt */
  	return 1;
  }
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index b3828bd87f8a..d9f9ed0c6856 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -181,6 +181,11 @@ static inline netdev_features_t vxlan_features_check(struct sk_buff *skb,
 /* IPv6 header + UDP + VXLAN + Ethernet header */
 #define VXLAN6_HEADROOM (40 + 8 + 8 + 14)
 
+static inline struct vxlanhdr *vxlan_hdr(struct sk_buff *skb)
+{
+	return (struct vxlanhdr *)(udp_hdr(skb) + 1);
+}
+
 #if IS_ENABLED(CONFIG_VXLAN)
 void vxlan_get_rx_port(struct net_device *netdev);
 #else
