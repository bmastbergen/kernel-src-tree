ovl: modify ovl_permission() to do checks on two inodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vivek Goyal <vgoyal@redhat.com>
commit c0ca3d70e8d3cf81e2255a217f7ca402f5ed0862
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c0ca3d70.failed

Right now ovl_permission() calls __inode_permission(realinode), to do
permission checks on real inode and no checks are done on overlay inode.

Modify it to do checks both on overlay inode as well as underlying inode.
Checks on overlay inode will be done with the creds of calling task while
checks on underlying inode will be done with the creds of mounter.

	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit c0ca3d70e8d3cf81e2255a217f7ca402f5ed0862)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index cec7c3f64b1e,f84492ff505d..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -73,31 -109,13 +73,35 @@@ static int ovl_getattr(struct vfsmount 
  
  int ovl_permission(struct inode *inode, int mask)
  {
 -	struct ovl_entry *oe = inode->i_private;
 -	bool is_upper;
 -	struct dentry *realdentry = ovl_entry_real(oe, &is_upper);
 +	struct ovl_entry *oe;
 +	struct dentry *alias = NULL;
  	struct inode *realinode;
++<<<<<<< HEAD
 +	struct dentry *realdentry;
 +	bool is_upper;
++=======
+ 	const struct cred *old_cred;
++>>>>>>> c0ca3d70e8d3 (ovl: modify ovl_permission() to do checks on two inodes)
  	int err;
  
 +	if (S_ISDIR(inode->i_mode)) {
 +		oe = inode->i_private;
 +	} else if (mask & MAY_NOT_BLOCK) {
 +		return -ECHILD;
 +	} else {
 +		/*
 +		 * For non-directories find an alias and get the info
 +		 * from there.
 +		 */
 +		alias = d_find_any_alias(inode);
 +		if (WARN_ON(!alias))
 +			return -ENOENT;
 +
 +		oe = alias->d_fsdata;
 +	}
 +
 +	realdentry = ovl_entry_real(oe, &is_upper);
 +
  	if (ovl_is_default_permissions(inode)) {
  		struct kstat stat;
  		struct path realpath = { .dentry = realdentry };
@@@ -147,15 -162,23 +151,30 @@@
  		 * constructed return EROFS to prevent modification of
  		 * upper layer.
  		 */
 +		err = -EROFS;
  		if (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&
  		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
 -			return -EROFS;
 +			goto out_dput;
  	}
  
++<<<<<<< HEAD
 +	err = __inode_permission(realinode, mask);
 +out_dput:
 +	dput(alias);
++=======
+ 	/*
+ 	 * Check overlay inode with the creds of task and underlying inode
+ 	 * with creds of mounter
+ 	 */
+ 	err = generic_permission(inode, mask);
+ 	if (err)
+ 		return err;
+ 
+ 	old_cred = ovl_override_creds(inode->i_sb);
+ 	err = __inode_permission(realinode, mask);
+ 	revert_creds(old_cred);
+ 
++>>>>>>> c0ca3d70e8d3 (ovl: modify ovl_permission() to do checks on two inodes)
  	return err;
  }
  
@@@ -345,6 -323,19 +364,22 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ struct posix_acl *ovl_get_acl(struct inode *inode, int type)
+ {
+ 	struct inode *realinode = ovl_inode_real(inode);
+ 
+ 	if (!IS_POSIXACL(realinode))
+ 		return NULL;
+ 
+ 	if (!realinode->i_op->get_acl)
+ 		return NULL;
+ 
+ 	return realinode->i_op->get_acl(realinode, type);
+ }
+ 
++>>>>>>> c0ca3d70e8d3 (ovl: modify ovl_permission() to do checks on two inodes)
  static bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,
  				  struct dentry *realdentry)
  {
* Unmerged path fs/overlayfs/inode.c
