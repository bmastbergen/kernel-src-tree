RDMA/iw_cxgb4: stop_ep_timer() after MPA negotiation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hariprasad S <hariprasad@chelsio.com>
commit e4b76a2a2619e95deb1ae2b088c0aa4f24a0bbee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e4b76a2a.failed

->Stop the ep timer after MPA negotiation so that the arp failures
during send_mpa_reply/reject will be handled by process_timeout() after
the ep timer expires.
->Added case MPA_REP_SENT in process_timeout().
->For MPA reject, c4iw_ep_disconnect tries to start an already started
timer, which leads to warning message "timer already started".
-> In case of mpa reject stop the timer and call send_mpa_reject().
-> Added new ep flag STOP_MPA_TIMER to tell fw4_ack() to stop the timer
only for send_mpa_reply(), which is set in c4iw_accept_cr().

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e4b76a2a2619e95deb1ae2b088c0aa4f24a0bbee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
#	drivers/infiniband/hw/cxgb4/iw_cxgb4.h
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index 0a1096a0486d,410154c86061..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -1673,24 -1742,17 +1671,26 @@@ static int process_mpa_request(struct c
  	     ep->mpa_attr.xmit_marker_enabled, ep->mpa_attr.version,
  	     ep->mpa_attr.p2p_type);
  
- 	/*
- 	 * If the endpoint timer already expired, then we ignore
- 	 * the start request.  process_timeout() will abort
- 	 * the connection.
- 	 */
- 	if (!stop_ep_timer(ep)) {
- 		__state_set(&ep->com, MPA_REQ_RCVD);
+ 	__state_set(&ep->com, MPA_REQ_RCVD);
  
++<<<<<<< HEAD
 +		/* drive upcall */
 +		mutex_lock(&ep->parent_ep->com.mutex);
 +		if (ep->parent_ep->com.state != DEAD) {
 +			if (connect_request_upcall(ep))
 +				goto err_unlock_parent;
 +		} else {
++=======
+ 	/* drive upcall */
+ 	mutex_lock_nested(&ep->parent_ep->com.mutex, SINGLE_DEPTH_NESTING);
+ 	if (ep->parent_ep->com.state != DEAD) {
+ 		if (connect_request_upcall(ep))
++>>>>>>> e4b76a2a2619 (RDMA/iw_cxgb4: stop_ep_timer() after MPA negotiation)
  			goto err_unlock_parent;
- 		}
- 		mutex_unlock(&ep->parent_ep->com.mutex);
+ 	} else {
+ 		goto err_unlock_parent;
  	}
+ 	mutex_unlock(&ep->parent_ep->com.mutex);
  	return 0;
  
  err_unlock_parent:
diff --cc drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index 0bdf125ec100,d4e2b519a192..000000000000
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@@ -763,7 -755,7 +763,11 @@@ enum c4iw_ep_flags 
  	CLOSE_SENT		= 3,
  	TIMEOUT                 = 4,
  	QP_REFERENCED           = 5,
++<<<<<<< HEAD
 +	RELEASE_MAPINFO		= 6,
++=======
+ 	STOP_MPA_TIMER		= 7,
++>>>>>>> e4b76a2a2619 (RDMA/iw_cxgb4: stop_ep_timer() after MPA negotiation)
  };
  
  enum c4iw_ep_history {
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
* Unmerged path drivers/infiniband/hw/cxgb4/iw_cxgb4.h
