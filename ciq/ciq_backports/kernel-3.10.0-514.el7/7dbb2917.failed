net/mlx5e: make VXLAN support conditional

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: make VXLAN support conditional (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 94.87%
commit-author Arnd Bergmann <arnd@arndb.de>
commit 7dbb29172d415ccccad1166700d6be78dee9f2bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7dbb2917.failed

VXLAN can be disabled at compile-time or it can be a loadable
module while mlx5 is built-in, which leads to a link error:

drivers/net/built-in.o: In function `mlx5e_create_netdev':
ntb_netdev.c:(.text+0x106de4): undefined reference to `vxlan_get_rx_port'

This avoids the link error and makes the vxlan code optional,
like the other ethernet drivers do as well.

Link: https://patchwork.ozlabs.org/patch/589296/
Fixes: b3f63c3d5e2c ("net/mlx5e: Add netdev support for VXLAN tunneling")
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7dbb29172d415ccccad1166700d6be78dee9f2bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
#	drivers/net/ethernet/mellanox/mlx5/core/Kconfig
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,217ac530a514..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -29,34 -29,40 +29,55 @@@
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
 -#ifndef __MLX5_VXLAN_H__
 -#define __MLX5_VXLAN_H__
  
 -#include <linux/mlx5/driver.h>
 -#include "en.h"
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
 + */
  
 -struct mlx5e_vxlan {
 -	u16 udp_port;
 -};
 +#include "ipath_kernel.h"
  
 -struct mlx5e_vxlan_work {
 -	struct work_struct	work;
 -	struct mlx5e_priv	*priv;
 -	sa_family_t		sa_family;
 -	u16			port;
 -};
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
 +{
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +	return 0;
 +}
  
 -static inline bool mlx5e_vxlan_allowed(struct mlx5_core_dev *mdev)
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
 + */
 +int ipath_unordered_wc(void)
  {
 +	return 1;
 +}
++=======
+ 	return IS_ENABLED(CONFIG_MLX5_CORE_EN_VXLAN) &&
+ 		(MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) &&
+ 		mlx5_core_is_pf(mdev));
+ }
+ 
+ #ifdef CONFIG_MLX5_CORE_EN_VXLAN
+ void mlx5e_vxlan_init(struct mlx5e_priv *priv);
+ void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv);
+ #else
+ static inline void mlx5e_vxlan_init(struct mlx5e_priv *priv) {}
+ static inline void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv) {}
+ #endif
+ 
+ void mlx5e_vxlan_queue_work(struct mlx5e_priv *priv, sa_family_t sa_family,
+ 			    u16 port, int add);
+ struct mlx5e_vxlan *mlx5e_vxlan_lookup_port(struct mlx5e_priv *priv, u16 port);
+ 
+ #endif /* __MLX5_VXLAN_H__ */
++>>>>>>> 7dbb29172d41 (net/mlx5e: make VXLAN support conditional):drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Kconfig
index 158c88c69ef9,f5c3b9465d8d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Kconfig
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Kconfig
@@@ -18,3 -19,22 +18,25 @@@ config MLX5_CORE_E
  	  Ethernet support in Mellanox Technologies ConnectX-4 NIC.
  	  Ethernet and Infiniband support in ConnectX-4 are currently mutually
  	  exclusive.
++<<<<<<< HEAD
++=======
+ 
+ config MLX5_CORE_EN_DCB
+ 	bool "Data Center Bridging (DCB) Support"
+ 	default y
+ 	depends on MLX5_CORE_EN && DCB
+ 	---help---
+ 	  Say Y here if you want to use Data Center Bridging (DCB) in the
+ 	  driver.
+ 	  If set to N, will not be able to configure QoS and ratelimit attributes.
+ 	  This flag is depended on the kernel's DCB support.
+ 
+ 	  If unsure, set to Y
+ 
+ config MLX5_CORE_EN_VXLAN
+ 	bool "VXLAN offloads Support"
+ 	default y
+ 	depends on MLX5_CORE_EN && VXLAN && !(MLX5_CORE=y && VXLAN=m)
+ 	---help---
+ 	  Say Y here if you want to use VXLAN offloads in the driver.
++>>>>>>> 7dbb29172d41 (net/mlx5e: make VXLAN support conditional)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index fe11e967095f,bf65b71c7360..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -3,6 -3,10 +3,13 @@@ obj-$(CONFIG_MLX5_CORE)		+= mlx5_core.
  mlx5_core-y :=	main.o cmd.o debugfs.o fw.o eq.o uar.o pagealloc.o \
  		health.o mcg.o cq.o srq.o alloc.o qp.o port.o mr.o pd.o   \
  		mad.o transobj.o vport.o sriov.o fs_cmd.o fs_core.o
 -
  mlx5_core-$(CONFIG_MLX5_CORE_EN) += wq.o eswitch.o \
  		en_main.o en_fs.o en_ethtool.o en_tx.o en_rx.o \
++<<<<<<< HEAD
 +		en_txrx.o
++=======
+ 		en_txrx.o en_clock.o en_tc.o
+ 
+ mlx5_core-$(CONFIG_MLX5_CORE_EN_VXLAN) += vxlan.o
+ mlx5_core-$(CONFIG_MLX5_CORE_EN_DCB) +=  en_dcbnl.o
++>>>>>>> 7dbb29172d41 (net/mlx5e: make VXLAN support conditional)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index b2b207af1d60,24344aafbd36..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -501,9 -564,12 +501,15 @@@ struct mlx5e_priv 
  	struct mlx5e_flow_tables   fts;
  	struct mlx5e_eth_addr_db   eth_addr;
  	struct mlx5e_vlan_db       vlan;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_MLX5_CORE_EN_VXLAN
+ 	struct mlx5e_vxlan_db      vxlan;
+ #endif
++>>>>>>> 7dbb29172d41 (net/mlx5e: make VXLAN support conditional)
  
  	struct mlx5e_params        params;
 -	struct workqueue_struct    *wq;
 +	spinlock_t                 async_events_spinlock; /* sync hw events */
  	struct work_struct         update_carrier_work;
  	struct work_struct         set_rx_mode_work;
  	struct delayed_work        update_stats_work;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 23ff9e4eac90,94fef705890b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2016,17 -2149,120 +2016,126 @@@ static int mlx5e_get_vf_stats(struct ne
  					    vf_stats);
  }
  
++<<<<<<< HEAD
 +static struct net_device_ops mlx5e_netdev_ops = {
++=======
+ #if IS_ENABLED(CONFIG_MLX5_CORE_EN_VXLAN)
+ static void mlx5e_add_vxlan_port(struct net_device *netdev,
+ 				 sa_family_t sa_family, __be16 port)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	if (!mlx5e_vxlan_allowed(priv->mdev))
+ 		return;
+ 
+ 	mlx5e_vxlan_queue_work(priv, sa_family, be16_to_cpu(port), 1);
+ }
+ 
+ static void mlx5e_del_vxlan_port(struct net_device *netdev,
+ 				 sa_family_t sa_family, __be16 port)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	if (!mlx5e_vxlan_allowed(priv->mdev))
+ 		return;
+ 
+ 	mlx5e_vxlan_queue_work(priv, sa_family, be16_to_cpu(port), 0);
+ }
+ 
+ static netdev_features_t mlx5e_vxlan_features_check(struct mlx5e_priv *priv,
+ 						    struct sk_buff *skb,
+ 						    netdev_features_t features)
+ {
+ 	struct udphdr *udph;
+ 	u16 proto;
+ 	u16 port = 0;
+ 
+ 	switch (vlan_get_protocol(skb)) {
+ 	case htons(ETH_P_IP):
+ 		proto = ip_hdr(skb)->protocol;
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		proto = ipv6_hdr(skb)->nexthdr;
+ 		break;
+ 	default:
+ 		goto out;
+ 	}
+ 
+ 	if (proto == IPPROTO_UDP) {
+ 		udph = udp_hdr(skb);
+ 		port = be16_to_cpu(udph->dest);
+ 	}
+ 
+ 	/* Verify if UDP port is being offloaded by HW */
+ 	if (port && mlx5e_vxlan_lookup_port(priv, port))
+ 		return features;
+ 
+ out:
+ 	/* Disable CSUM and GSO if the udp dport is not offloaded by HW */
+ 	return features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
+ }
+ 
+ static netdev_features_t mlx5e_features_check(struct sk_buff *skb,
+ 					      struct net_device *netdev,
+ 					      netdev_features_t features)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	features = vlan_features_check(skb, features);
+ 	features = vxlan_features_check(skb, features);
+ 
+ 	/* Validate if the tunneled packet is being offloaded by HW */
+ 	if (skb->encapsulation &&
+ 	    (features & NETIF_F_CSUM_MASK || features & NETIF_F_GSO_MASK))
+ 		return mlx5e_vxlan_features_check(priv, skb, features);
+ 
+ 	return features;
+ }
+ #endif
+ 
+ static const struct net_device_ops mlx5e_netdev_ops_basic = {
++>>>>>>> 7dbb29172d41 (net/mlx5e: make VXLAN support conditional)
  	.ndo_open                = mlx5e_open,
  	.ndo_stop                = mlx5e_close,
  	.ndo_start_xmit          = mlx5e_xmit,
  	.ndo_get_stats64         = mlx5e_get_stats,
  	.ndo_set_rx_mode         = mlx5e_set_rx_mode,
  	.ndo_set_mac_address     = mlx5e_set_mac,
 -	.ndo_vlan_rx_add_vid     = mlx5e_vlan_rx_add_vid,
 -	.ndo_vlan_rx_kill_vid    = mlx5e_vlan_rx_kill_vid,
 +	.ndo_vlan_rx_add_vid	 = mlx5e_vlan_rx_add_vid,
 +	.ndo_vlan_rx_kill_vid	 = mlx5e_vlan_rx_kill_vid,
  	.ndo_set_features        = mlx5e_set_features,
++<<<<<<< HEAD
 +	.ndo_change_mtu		 = mlx5e_change_mtu
++=======
+ 	.ndo_change_mtu          = mlx5e_change_mtu,
+ 	.ndo_do_ioctl            = mlx5e_ioctl,
+ };
+ 
+ static const struct net_device_ops mlx5e_netdev_ops_sriov = {
+ 	.ndo_open                = mlx5e_open,
+ 	.ndo_stop                = mlx5e_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_setup_tc            = mlx5e_ndo_setup_tc,
+ 	.ndo_select_queue        = mlx5e_select_queue,
+ 	.ndo_get_stats64         = mlx5e_get_stats,
+ 	.ndo_set_rx_mode         = mlx5e_set_rx_mode,
+ 	.ndo_set_mac_address     = mlx5e_set_mac,
+ 	.ndo_vlan_rx_add_vid     = mlx5e_vlan_rx_add_vid,
+ 	.ndo_vlan_rx_kill_vid    = mlx5e_vlan_rx_kill_vid,
+ 	.ndo_set_features        = mlx5e_set_features,
+ 	.ndo_change_mtu          = mlx5e_change_mtu,
+ 	.ndo_do_ioctl            = mlx5e_ioctl,
+ #ifdef CONFIG_MLX5_CORE_EN_VXLAN
+ 	.ndo_add_vxlan_port      = mlx5e_add_vxlan_port,
+ 	.ndo_del_vxlan_port      = mlx5e_del_vxlan_port,
+ 	.ndo_features_check      = mlx5e_features_check,
+ #endif
+ 	.ndo_set_vf_mac          = mlx5e_set_vf_mac,
+ 	.ndo_set_vf_vlan         = mlx5e_set_vf_vlan,
+ 	.ndo_get_vf_config       = mlx5e_get_vf_config,
+ 	.ndo_set_vf_link_state   = mlx5e_set_vf_link_state,
+ 	.ndo_get_vf_stats        = mlx5e_get_vf_stats,
++>>>>>>> 7dbb29172d41 (net/mlx5e: make VXLAN support conditional)
  };
  
  static int mlx5e_check_required_hca_cap(struct mlx5_core_dev *mdev)
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Kconfig
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
