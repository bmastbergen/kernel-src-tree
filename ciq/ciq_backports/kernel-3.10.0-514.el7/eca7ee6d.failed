dm: distinquish old .request_fn (dm-old) vs dm-mq request-based DM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit eca7ee6dc01b21c669bce8c39d3d368509fb65e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/eca7ee6d.failed

Rename various methods to have either a "dm_old" or "dm_mq" prefix.
Improve code comments to assist with understanding the duality of code
that handles both "dm_old" and "dm_mq" cases.

It is no much easier to quickly look at the code and _know_ that a given
method is either 1) "dm_old" only 2) "dm_mq" only 3) common to both.

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit eca7ee6dc01b21c669bce8c39d3d368509fb65e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 511a3a6992f6,d4040e6d4d3d..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1114,15 -1140,10 +1114,19 @@@ static void free_rq_clone(struct reques
  		tio->ti->type->release_clone_rq(clone);
  	else if (!md->queue->mq_ops)
  		/* request_fn queue stacked on request_fn queue(s) */
++<<<<<<< HEAD
 +		free_clone_request(md, clone);
 +	/*
 +	 * NOTE: for the blk-mq queue stacked on request_fn queue(s) case:
 +	 * no need to call free_clone_request() because we leverage blk-mq by
 +	 * allocating the clone at the end of the blk-mq pdu (see: clone_rq)
 +	 */
++=======
+ 		free_old_clone_request(md, clone);
++>>>>>>> eca7ee6dc01b (dm: distinquish old .request_fn (dm-old) vs dm-mq request-based DM)
  
  	if (!md->queue->mq_ops)
- 		free_rq_tio(tio);
+ 		free_old_rq_tio(tio);
  }
  
  /*
@@@ -1990,28 -1857,22 +1994,38 @@@ static int setup_clone(struct request *
  	return 0;
  }
  
- static struct request *clone_rq(struct request *rq, struct mapped_device *md,
- 				struct dm_rq_target_io *tio, gfp_t gfp_mask)
+ static struct request *clone_old_rq(struct request *rq, struct mapped_device *md,
+ 				    struct dm_rq_target_io *tio, gfp_t gfp_mask)
  {
  	/*
 -	 * Create clone for use with .request_fn request_queue
 +	 * Do not allocate a clone if tio->clone was already set
 +	 * (see: dm_mq_queue_rq).
  	 */
 +	bool alloc_clone = !tio->clone;
  	struct request *clone;
  
++<<<<<<< HEAD
 +	if (alloc_clone) {
 +		clone = alloc_clone_request(md, gfp_mask);
 +		if (!clone)
 +			return NULL;
 +	} else
 +		clone = tio->clone;
++=======
+ 	clone = alloc_old_clone_request(md, gfp_mask);
+ 	if (!clone)
+ 		return NULL;
++>>>>>>> eca7ee6dc01b (dm: distinquish old .request_fn (dm-old) vs dm-mq request-based DM)
  
  	blk_rq_init(NULL, clone);
  	if (setup_clone(clone, rq, tio, gfp_mask)) {
  		/* -ENOMEM */
++<<<<<<< HEAD
 +		if (alloc_clone)
 +			free_clone_request(md, clone);
++=======
+ 		free_old_clone_request(md, clone);
++>>>>>>> eca7ee6dc01b (dm: distinquish old .request_fn (dm-old) vs dm-mq request-based DM)
  		return NULL;
  	}
  
@@@ -2979,9 -2784,14 +2997,9 @@@ int dm_setup_md_queue(struct mapped_dev
  		}
  		break;
  	case DM_TYPE_BIO_BASED:
- 		dm_init_old_md_queue(md);
+ 		dm_init_normal_md_queue(md);
  		blk_queue_make_request(md->queue, dm_make_request);
 -		/*
 -		 * DM handles splitting bios as needed.  Free the bio_split bioset
 -		 * since it won't be used (saves 1 process per bio-based DM device).
 -		 */
 -		bioset_free(md->queue->bio_split);
 -		md->queue->bio_split = NULL;
 +		blk_queue_merge_bvec(md->queue, dm_merge_bvec);
  		break;
  	}
  
diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 15016b4ea208..f1b1b5285131 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -426,7 +426,11 @@ static int __multipath_map(struct dm_target *ti, struct request *clone,
 		clone->rq_disk = bdev->bd_disk;
 		clone->cmd_flags |= REQ_FAILFAST_TRANSPORT;
 	} else {
-		/* blk-mq request-based interface */
+		/*
+		 * blk-mq request-based interface; used by both:
+		 * .request_fn stacked on blk-mq path(s) and
+		 * blk-mq stacked on blk-mq path(s).
+		 */
 		*__clone = blk_get_request(bdev_get_queue(bdev),
 					   rq_data_dir(rq), GFP_ATOMIC);
 		if (IS_ERR(*__clone)) {
* Unmerged path drivers/md/dm.c
