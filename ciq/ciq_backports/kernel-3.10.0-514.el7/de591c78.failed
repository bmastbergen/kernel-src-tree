e1000: switch to napi_gro_frags api

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Florian Westphal <fw@strlen.de>
commit de591c783ae739f6fb41e12f3371575edcb62af0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/de591c78.failed

napi_gro_frags allows skb re-use in case GRO can merge payload pages
into an skb on the GRO lists.

netperf TCP_STREAM, kvm-e1000 emulation, mtu 9k:
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec
old: 87380  16384  16384    30.00  8985.78
new: 87380  16384  16384    30.00  9907.05

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit de591c783ae739f6fb41e12f3371575edcb62af0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000/e1000_main.c
diff --cc drivers/net/ethernet/intel/e1000/e1000_main.c
index d3e0070ef2f4,5f6aded512f5..000000000000
--- a/drivers/net/ethernet/intel/e1000/e1000_main.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c
@@@ -4190,8 -4189,12 +4188,17 @@@ process_skb
  			/* this descriptor is only the beginning (or middle) */
  			if (!rxtop) {
  				/* this is the beginning of a chain */
++<<<<<<< HEAD
 +				rxtop = skb;
 +				skb_fill_page_desc(rxtop, 0, buffer_info->page,
++=======
+ 				rxtop = napi_get_frags(&adapter->napi);
+ 				if (!rxtop)
+ 					break;
+ 
+ 				skb_fill_page_desc(rxtop, 0,
+ 						   buffer_info->rxbuf.page,
++>>>>>>> de591c783ae7 (e1000: switch to napi_gro_frags api)
  						   0, length);
  			} else {
  				/* this is the middle of a chain */
@@@ -4220,20 -4217,43 +4227,54 @@@
  				/* no chain, got EOP, this buf is the packet
  				 * copybreak to save the put_page/alloc_page
  				 */
++<<<<<<< HEAD
 +				if (length <= copybreak &&
 +				    skb_tailroom(skb) >= length) {
 +					u8 *vaddr;
 +					vaddr = kmap_atomic(buffer_info->page);
++=======
+ 				p = buffer_info->rxbuf.page;
+ 				if (length <= copybreak) {
+ 					u8 *vaddr;
+ 
+ 					if (likely(!(netdev->features & NETIF_F_RXFCS)))
+ 						length -= 4;
+ 					skb = e1000_alloc_rx_skb(adapter,
+ 								 length);
+ 					if (!skb)
+ 						break;
+ 
+ 					vaddr = kmap_atomic(p);
++>>>>>>> de591c783ae7 (e1000: switch to napi_gro_frags api)
  					memcpy(skb_tail_pointer(skb), vaddr,
  					       length);
  					kunmap_atomic(vaddr);
  					/* re-use the page, so don't erase
 -					 * buffer_info->rxbuf.page
 +					 * buffer_info->page
  					 */
  					skb_put(skb, length);
+ 					e1000_rx_checksum(adapter,
+ 							  status | rx_desc->errors << 24,
+ 							  le16_to_cpu(rx_desc->csum), skb);
+ 
+ 					total_rx_bytes += skb->len;
+ 					total_rx_packets++;
+ 
+ 					e1000_receive_skb(adapter, status,
+ 							  rx_desc->special, skb);
+ 					goto next_desc;
  				} else {
++<<<<<<< HEAD
 +					skb_fill_page_desc(skb, 0,
 +							   buffer_info->page, 0,
++=======
+ 					skb = napi_get_frags(&adapter->napi);
+ 					if (!skb) {
+ 						adapter->alloc_rx_buff_failed++;
+ 						break;
+ 					}
+ 					skb_fill_page_desc(skb, 0, p, 0,
++>>>>>>> de591c783ae7 (e1000: switch to napi_gro_frags api)
  							   length);
  					e1000_consume_page(buffer_info, skb,
  							   length);
* Unmerged path drivers/net/ethernet/intel/e1000/e1000_main.c
