Btrfs: prevent list corruption during free space cache processing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chris Mason <clm@fb.com>
commit a3bdccc4e683f0ac69230707ed3fa20e7cf73a79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a3bdccc4.failed

__btrfs_write_out_cache is holding the ctl->tree_lock while it prepares
a list of bitmaps to record in the free space cache.  It was dropping
the lock while it worked on other components, which made a window for
free_bitmap() to free the bitmap struct without removing it from the
list.

This changes things to hold the lock the whole time, and also makes sure
we hold the lock during enospc cleanup.

	Reported-by: Filipe Manana <fdmanana@suse.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit a3bdccc4e683f0ac69230707ed3fa20e7cf73a79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/free-space-cache.c
diff --cc fs/btrfs/free-space-cache.c
index 39da6626f574,81fa75a8e1f3..000000000000
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@@ -1210,21 -1270,21 +1215,24 @@@ static int __btrfs_write_out_cache(stru
  	ret = write_cache_extent_entries(io_ctl, ctl,
  					 block_group, &entries, &bitmaps,
  					 &bitmap_list);
++<<<<<<< HEAD
 +	if (ret) {
 +		mutex_unlock(&ctl->cache_writeout_mutex);
 +		goto out_nospc;
 +	}
++=======
+ 	if (ret)
+ 		goto out_nospc_locked;
++>>>>>>> a3bdccc4e683 (Btrfs: prevent list corruption during free space cache processing)
  
  	/*
  	 * Some spaces that are freed in the current transaction are pinned,
  	 * they will be added into free space cache after the transaction is
  	 * committed, we shouldn't lose them.
 -	 *
 -	 * If this changes while we are working we'll get added back to
 -	 * the dirty list and redo it.  No locking needed
  	 */
  	ret = write_pinned_extent_entries(root, block_group, io_ctl, &entries);
- 	if (ret) {
- 		mutex_unlock(&ctl->cache_writeout_mutex);
- 		goto out_nospc;
- 	}
+ 	if (ret)
+ 		goto out_nospc_locked;
  
  	/*
  	 * At last, we write out all the bitmaps and keep cache_writeout_mutex
* Unmerged path fs/btrfs/free-space-cache.c
