sctp: hold transport before we access t->asoc in sctp proc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit fba4c330c5b9d1beeae08a42ed4430f5055e7f27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fba4c330.failed

Previously, before rhashtable, /proc assoc listing was done by
read-locking the entire hash entry and dumping all assocs at once, so we
were sure that the assoc wasn't freed because it wouldn't be possible to
remove it from the hash meanwhile.

Now we use rhashtable to list transports, and dump entries one by one.
That is, now we have to check if the assoc is still a good one, as the
transport we got may be being freed.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fba4c330c5b9d1beeae08a42ed4430f5055e7f27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/proc.c
diff --cc net/sctp/proc.c
index aaeecb033eeb,c74a810150aa..000000000000
--- a/net/sctp/proc.c
+++ b/net/sctp/proc.c
@@@ -323,53 -365,56 +323,93 @@@ static void * sctp_assocs_seq_next(stru
  /* Display sctp associations (/proc/net/sctp/assocs). */
  static int sctp_assocs_seq_show(struct seq_file *seq, void *v)
  {
 -	struct sctp_transport *transport;
 -	struct sctp_association *assoc;
 +	struct sctp_hashbucket *head;
  	struct sctp_ep_common *epb;
 +	struct sctp_association *assoc;
  	struct sock *sk;
 +	int    hash = *(loff_t *)v;
  
 -	if (v == SEQ_START_TOKEN) {
 -		seq_printf(seq, " ASSOC     SOCK   STY SST ST HBKT "
 -				"ASSOC-ID TX_QUEUE RX_QUEUE UID INODE LPORT "
 -				"RPORT LADDRS <-> RADDRS "
 -				"HBINT INS OUTS MAXRT T1X T2X RTXC "
 -				"wmema wmemq sndbuf rcvbuf\n");
 -		return 0;
 +	if (hash >= sctp_assoc_hashsize)
 +		return -ENOMEM;
 +
 +	head = &sctp_assoc_hashtable[hash];
 +	sctp_local_bh_disable();
 +	read_lock(&head->lock);
 +	sctp_for_each_hentry(epb, &head->chain) {
 +		assoc = sctp_assoc(epb);
 +		sk = epb->sk;
 +		if (!net_eq(sock_net(sk), seq_file_net(seq)))
 +			continue;
 +		seq_printf(seq,
 +			   "%8pK %8pK %-3d %-3d %-2d %-4d "
 +			   "%4d %8d %8d %7u %5lu %-5d %5d ",
 +			   assoc, sk, sctp_sk(sk)->type, sk->sk_state,
 +			   assoc->state, hash,
 +			   assoc->assoc_id,
 +			   assoc->sndbuf_used,
 +			   atomic_read(&assoc->rmem_alloc),
 +			   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sk)),
 +			   sock_i_ino(sk),
 +			   epb->bind_addr.port,
 +			   assoc->peer.port);
 +		seq_printf(seq, " ");
 +		sctp_seq_dump_local_addrs(seq, epb);
 +		seq_printf(seq, "<-> ");
 +		sctp_seq_dump_remote_addrs(seq, assoc);
 +		seq_printf(seq, "\t%8lu %5d %5d %4d %4d %4d %8d "
 +			   "%8d %8d %8d %8d",
 +			assoc->hbinterval, assoc->c.sinit_max_instreams,
 +			assoc->c.sinit_num_ostreams, assoc->max_retrans,
 +			assoc->init_retries, assoc->shutdown_retries,
 +			assoc->rtx_data_chunks,
 +			atomic_read(&sk->sk_wmem_alloc),
 +			sk->sk_wmem_queued,
 +			sk->sk_sndbuf,
 +			sk->sk_rcvbuf);
 +		seq_printf(seq, "\n");
  	}
++<<<<<<< HEAD
 +	read_unlock(&head->lock);
 +	sctp_local_bh_enable();
++=======
+ 
+ 	transport = (struct sctp_transport *)v;
+ 	if (!sctp_transport_hold(transport))
+ 		return 0;
+ 	assoc = transport->asoc;
+ 	epb = &assoc->base;
+ 	sk = epb->sk;
+ 
+ 	seq_printf(seq,
+ 		   "%8pK %8pK %-3d %-3d %-2d %-4d "
+ 		   "%4d %8d %8d %7u %5lu %-5d %5d ",
+ 		   assoc, sk, sctp_sk(sk)->type, sk->sk_state,
+ 		   assoc->state, 0,
+ 		   assoc->assoc_id,
+ 		   assoc->sndbuf_used,
+ 		   atomic_read(&assoc->rmem_alloc),
+ 		   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sk)),
+ 		   sock_i_ino(sk),
+ 		   epb->bind_addr.port,
+ 		   assoc->peer.port);
+ 	seq_printf(seq, " ");
+ 	sctp_seq_dump_local_addrs(seq, epb);
+ 	seq_printf(seq, "<-> ");
+ 	sctp_seq_dump_remote_addrs(seq, assoc);
+ 	seq_printf(seq, "\t%8lu %5d %5d %4d %4d %4d %8d "
+ 		   "%8d %8d %8d %8d",
+ 		assoc->hbinterval, assoc->c.sinit_max_instreams,
+ 		assoc->c.sinit_num_ostreams, assoc->max_retrans,
+ 		assoc->init_retries, assoc->shutdown_retries,
+ 		assoc->rtx_data_chunks,
+ 		atomic_read(&sk->sk_wmem_alloc),
+ 		sk->sk_wmem_queued,
+ 		sk->sk_sndbuf,
+ 		sk->sk_rcvbuf);
+ 	seq_printf(seq, "\n");
++>>>>>>> fba4c330c5b9 (sctp: hold transport before we access t->asoc in sctp proc)
+ 
+ 	sctp_transport_put(transport);
  
  	return 0;
  }
@@@ -443,85 -483,76 +483,100 @@@ static void sctp_remaddr_seq_stop(struc
  
  static int sctp_remaddr_seq_show(struct seq_file *seq, void *v)
  {
 +	struct sctp_hashbucket *head;
 +	struct sctp_ep_common *epb;
  	struct sctp_association *assoc;
  	struct sctp_transport *tsp;
 +	int    hash = *(loff_t *)v;
  
 -	if (v == SEQ_START_TOKEN) {
 -		seq_printf(seq, "ADDR ASSOC_ID HB_ACT RTO MAX_PATH_RTX "
 -				"REM_ADDR_RTX START STATE\n");
 -		return 0;
 -	}
 +	if (hash >= sctp_assoc_hashsize)
 +		return -ENOMEM;
  
++<<<<<<< HEAD
 +	head = &sctp_assoc_hashtable[hash];
 +	sctp_local_bh_disable();
 +	read_lock(&head->lock);
 +	rcu_read_lock();
 +	sctp_for_each_hentry(epb, &head->chain) {
 +		if (!net_eq(sock_net(epb->sk), seq_file_net(seq)))
++=======
+ 	tsp = (struct sctp_transport *)v;
+ 	if (!sctp_transport_hold(tsp))
+ 		return 0;
+ 	assoc = tsp->asoc;
+ 
+ 	list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
+ 				transports) {
+ 		if (tsp->dead)
++>>>>>>> fba4c330c5b9 (sctp: hold transport before we access t->asoc in sctp proc)
  			continue;
 -		/*
 -		 * The remote address (ADDR)
 -		 */
 -		tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
 -		seq_printf(seq, " ");
 -		/*
 -		 * The association ID (ASSOC_ID)
 -		 */
 -		seq_printf(seq, "%d ", tsp->asoc->assoc_id);
 -
 -		/*
 -		 * If the Heartbeat is active (HB_ACT)
 -		 * Note: 1 = Active, 0 = Inactive
 -		 */
 -		seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
 -
 -		/*
 -		 * Retransmit time out (RTO)
 -		 */
 -		seq_printf(seq, "%lu ", tsp->rto);
 -
 -		/*
 -		 * Maximum path retransmit count (PATH_MAX_RTX)
 -		 */
 -		seq_printf(seq, "%d ", tsp->pathmaxrxt);
 -
 -		/*
 -		 * remote address retransmit count (REM_ADDR_RTX)
 -		 * Note: We don't have a way to tally this at the moment
 -		 * so lets just leave it as zero for the moment
 -		 */
 -		seq_puts(seq, "0 ");
 -
 -		/*
 -		 * remote address start time (START).  This is also not
 -		 * currently implemented, but we can record it with a
 -		 * jiffies marker in a subsequent patch
 -		 */
 -		seq_puts(seq, "0 ");
 -
 -		/*
 -		 * The current state of this destination. I.e.
 -		 * SCTP_ACTIVE, SCTP_INACTIVE, ...
 -		 */
 -		seq_printf(seq, "%d", tsp->state);
 +		assoc = sctp_assoc(epb);
 +		list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
 +					transports) {
 +			if (tsp->dead)
 +				continue;
  
 -		seq_printf(seq, "\n");
 +			/*
 +			 * The remote address (ADDR)
 +			 */
 +			tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
 +			seq_printf(seq, " ");
 +
 +			/*
 +			 * The association ID (ASSOC_ID)
 +			 */
 +			seq_printf(seq, "%d ", tsp->asoc->assoc_id);
 +
 +			/*
 +			 * If the Heartbeat is active (HB_ACT)
 +			 * Note: 1 = Active, 0 = Inactive
 +			 */
 +			seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
 +
 +			/*
 +			 * Retransmit time out (RTO)
 +			 */
 +			seq_printf(seq, "%lu ", tsp->rto);
 +
 +			/*
 +			 * Maximum path retransmit count (PATH_MAX_RTX)
 +			 */
 +			seq_printf(seq, "%d ", tsp->pathmaxrxt);
 +
 +			/*
 +			 * remote address retransmit count (REM_ADDR_RTX)
 +			 * Note: We don't have a way to tally this at the moment
 +			 * so lets just leave it as zero for the moment
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * remote address start time (START).  This is also not
 +			 * currently implemented, but we can record it with a
 +			 * jiffies marker in a subsequent patch
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * The current state of this destination. I.e.
 +			 * SCTP_ACTIVE, SCTP_INACTIVE, ...
 +			 */
 +			seq_printf(seq, "%d", tsp->state);
 +
 +			seq_printf(seq, "\n");
 +		}
  	}
  
++<<<<<<< HEAD
 +	rcu_read_unlock();
 +	read_unlock(&head->lock);
 +	sctp_local_bh_enable();
++=======
+ 	sctp_transport_put(tsp);
++>>>>>>> fba4c330c5b9 (sctp: hold transport before we access t->asoc in sctp proc)
  
  	return 0;
 +
  }
  
  static const struct seq_operations sctp_remaddr_ops = {
* Unmerged path net/sctp/proc.c
