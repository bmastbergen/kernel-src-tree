perf hists: Introduce perf_hpp_list__for_each_sort_list macro

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit d29a497090845002ee449c8dc682dd59ad8bab42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d29a4970.failed

Introducing perf_hpp_list__for_each_sort_list macro to iterate
perf_hpp_list object's sort entries.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1453109064-1026-22-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit d29a497090845002ee449c8dc682dd59ad8bab42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/hist.c
#	tools/perf/util/hist.c
diff --cc tools/perf/ui/hist.c
index 2b9ea4c7e3a2,f09eabe18167..000000000000
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@@ -536,22 -553,12 +536,27 @@@ void perf_hpp__setup_output_field(void
  	struct perf_hpp_fmt *fmt;
  
  	/* append sort keys to output field */
++<<<<<<< HEAD
 +	perf_hpp__for_each_sort_list(fmt) {
 +		if (!list_empty(&fmt->list))
 +			continue;
++=======
+ 	perf_hpp_list__for_each_sort_list(&perf_hpp_list, fmt) {
+ 		struct perf_hpp_fmt *pos;
++>>>>>>> d29a49709084 (perf hists: Introduce perf_hpp_list__for_each_sort_list macro)
  
 -		perf_hpp_list__for_each_format(&perf_hpp_list, pos) {
 -			if (fmt_equal(fmt, pos))
 -				goto next;
 +		/*
 +		 * sort entry fields are dynamically created,
 +		 * so they can share a same sort key even though
 +		 * the list is empty.
 +		 */
 +		if (perf_hpp__is_sort_entry(fmt)) {
 +			struct perf_hpp_fmt *pos;
 +
 +			perf_hpp__for_each_format(pos) {
 +				if (perf_hpp__same_sort_entry(pos, fmt))
 +					goto next;
 +			}
  		}
  
  		perf_hpp__column_register(fmt);
@@@ -565,22 -572,12 +570,28 @@@ void perf_hpp__append_sort_keys(void
  	struct perf_hpp_fmt *fmt;
  
  	/* append output fields to sort keys */
 -	perf_hpp_list__for_each_format(&perf_hpp_list, fmt) {
 -		struct perf_hpp_fmt *pos;
 +	perf_hpp__for_each_format(fmt) {
 +		if (!list_empty(&fmt->sort_list))
 +			continue;
 +
++<<<<<<< HEAD
 +		/*
 +		 * sort entry fields are dynamically created,
 +		 * so they can share a same sort key even though
 +		 * the list is empty.
 +		 */
 +		if (perf_hpp__is_sort_entry(fmt)) {
 +			struct perf_hpp_fmt *pos;
  
 +			perf_hpp__for_each_sort_list(pos) {
 +				if (perf_hpp__same_sort_entry(pos, fmt))
 +					goto next;
 +			}
++=======
+ 		perf_hpp_list__for_each_sort_list(&perf_hpp_list, pos) {
+ 			if (fmt_equal(fmt, pos))
+ 				goto next;
++>>>>>>> d29a49709084 (perf hists: Introduce perf_hpp_list__for_each_sort_list macro)
  		}
  
  		perf_hpp__register_sort_field(fmt);
diff --cc tools/perf/util/hist.c
index d3cfa15c7e2e,dea475d1fab0..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -1116,8 -1120,8 +1116,13 @@@ static int hist_entry__sort(struct hist
  	struct perf_hpp_fmt *fmt;
  	int64_t cmp = 0;
  
++<<<<<<< HEAD
 +	perf_hpp__for_each_sort_list(fmt) {
 +		if (perf_hpp__should_skip(fmt))
++=======
+ 	perf_hpp_list__for_each_sort_list(&perf_hpp_list, fmt) {
+ 		if (perf_hpp__should_skip(fmt, a->hists))
++>>>>>>> d29a49709084 (perf hists: Introduce perf_hpp_list__for_each_sort_list macro)
  			continue;
  
  		cmp = fmt->sort(fmt, a, b);
* Unmerged path tools/perf/ui/hist.c
* Unmerged path tools/perf/util/hist.c
diff --git a/tools/perf/util/hist.h b/tools/perf/util/hist.h
index bd572df18d95..27f2f9ce6475 100644
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@ -246,8 +246,8 @@ static inline void perf_hpp__register_sort_field(struct perf_hpp_fmt *format)
 #define perf_hpp__for_each_format_safe(format, tmp)	\
 	list_for_each_entry_safe(format, tmp, &perf_hpp_list.fields, list)
 
-#define perf_hpp__for_each_sort_list(format) \
-	list_for_each_entry(format, &perf_hpp_list.sorts, sort_list)
+#define perf_hpp_list__for_each_sort_list(_list, format) \
+	list_for_each_entry(format, &(_list)->sorts, sort_list)
 
 #define perf_hpp__for_each_sort_list_safe(format, tmp)	\
 	list_for_each_entry_safe(format, tmp, &perf_hpp_list.sorts, sort_list)
