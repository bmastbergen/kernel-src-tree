IB/qib: Remove srq from qib

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 894c727b6af8cfd29fcb2b9db4520533d9e8d6a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/894c727b.failed

Remove srq from qib now that it has been moved into rdmavt.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Reviewed-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 894c727b6af8cfd29fcb2b9db4520533d9e8d6a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qib/qib_ruc.c
#	drivers/infiniband/hw/qib/qib_srq.c
#	drivers/infiniband/hw/qib/qib_verbs.h
diff --cc drivers/infiniband/hw/qib/qib_ruc.c
index e9132f7a68b0,682447e785e1..000000000000
--- a/drivers/infiniband/hw/qib/qib_ruc.c
+++ b/drivers/infiniband/hw/qib/qib_ruc.c
@@@ -136,13 -136,13 +136,20 @@@ bail
   *
   * Can be called from interrupt level.
   */
 -int qib_get_rwqe(struct rvt_qp *qp, int wr_id_only)
 +int qib_get_rwqe(struct qib_qp *qp, int wr_id_only)
  {
  	unsigned long flags;
++<<<<<<< HEAD
 +	struct qib_rq *rq;
 +	struct qib_rwq *wq;
 +	struct qib_srq *srq;
 +	struct qib_rwqe *wqe;
++=======
+ 	struct rvt_rq *rq;
+ 	struct rvt_rwq *wq;
+ 	struct rvt_srq *srq;
+ 	struct rvt_rwqe *wqe;
++>>>>>>> 894c727b6af8 (IB/qib: Remove srq from qib)
  	void (*handler)(struct ib_event *, void *);
  	u32 tail;
  	int ret;
diff --cc drivers/infiniband/hw/qib/qib_srq.c
index d6235931a1ba,e9dfa30433c6..000000000000
--- a/drivers/infiniband/hw/qib/qib_srq.c
+++ b/drivers/infiniband/hw/qib/qib_srq.c
@@@ -48,8 -48,8 +48,13 @@@
  int qib_post_srq_receive(struct ib_srq *ibsrq, struct ib_recv_wr *wr,
  			 struct ib_recv_wr **bad_wr)
  {
++<<<<<<< HEAD
 +	struct qib_srq *srq = to_isrq(ibsrq);
 +	struct qib_rwq *wq;
++=======
+ 	struct rvt_srq *srq = ibsrq_to_rvtsrq(ibsrq);
+ 	struct rvt_rwq *wq;
++>>>>>>> 894c727b6af8 (IB/qib: Remove srq from qib)
  	unsigned long flags;
  	int ret;
  
@@@ -212,8 -212,8 +217,13 @@@ int qib_modify_srq(struct ib_srq *ibsrq
  		   enum ib_srq_attr_mask attr_mask,
  		   struct ib_udata *udata)
  {
++<<<<<<< HEAD
 +	struct qib_srq *srq = to_isrq(ibsrq);
 +	struct qib_rwq *wq;
++=======
+ 	struct rvt_srq *srq = ibsrq_to_rvtsrq(ibsrq);
+ 	struct rvt_rwq *wq;
++>>>>>>> 894c727b6af8 (IB/qib: Remove srq from qib)
  	int ret = 0;
  
  	if (attr_mask & IB_SRQ_MAX_WR) {
diff --cc drivers/infiniband/hw/qib/qib_verbs.h
index ca366073af4f,00dd2ad0bfa2..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.h
+++ b/drivers/infiniband/hw/qib/qib_verbs.h
@@@ -275,141 -248,9 +275,144 @@@ struct qib_cq 
  	u8 notify;
  	u8 triggered;
  	struct qib_cq_wc *queue;
 -	struct rvt_mmap_info *ip;
 +	struct qib_mmap_info *ip;
 +};
 +
 +/*
 + * A segment is a linear region of low physical memory.
 + * XXX Maybe we should use phys addr here and kmap()/kunmap().
 + * Used by the verbs layer.
 + */
 +struct qib_seg {
 +	void *vaddr;
 +	size_t length;
 +};
 +
 +/* The number of qib_segs that fit in a page. */
 +#define QIB_SEGSZ     (PAGE_SIZE / sizeof(struct qib_seg))
 +
 +struct qib_segarray {
 +	struct qib_seg segs[QIB_SEGSZ];
 +};
 +
 +struct qib_mregion {
 +	struct ib_pd *pd;       /* shares refcnt of ibmr.pd */
 +	u64 user_base;          /* User's address for this region */
 +	u64 iova;               /* IB start address of this region */
 +	size_t length;
 +	u32 lkey;
 +	u32 offset;             /* offset (bytes) to start of region */
 +	int access_flags;
 +	u32 max_segs;           /* number of qib_segs in all the arrays */
 +	u32 mapsz;              /* size of the map array */
 +	u8  page_shift;         /* 0 - non unform/non powerof2 sizes */
 +	u8  lkey_published;     /* in global table */
 +	struct completion comp; /* complete when refcount goes to zero */
 +	struct rcu_head list;
 +	atomic_t refcount;
 +	struct qib_segarray *map[0];    /* the segments */
 +};
 +
 +/*
 + * These keep track of the copy progress within a memory region.
 + * Used by the verbs layer.
 + */
 +struct qib_sge {
 +	struct qib_mregion *mr;
 +	void *vaddr;            /* kernel virtual address of segment */
 +	u32 sge_length;         /* length of the SGE */
 +	u32 length;             /* remaining length of the segment */
 +	u16 m;                  /* current index: mr->map[m] */
 +	u16 n;                  /* current index: mr->map[m]->segs[n] */
 +};
 +
 +/* Memory region */
 +struct qib_mr {
 +	struct ib_mr ibmr;
 +	struct ib_umem *umem;
 +	struct qib_mregion mr;  /* must be last */
 +};
 +
 +/*
 + * Send work request queue entry.
 + * The size of the sg_list is determined when the QP is created and stored
 + * in qp->s_max_sge.
 + */
 +struct qib_swqe {
 +	struct ib_send_wr wr;   /* don't use wr.sg_list */
 +	u32 psn;                /* first packet sequence number */
 +	u32 lpsn;               /* last packet sequence number */
 +	u32 ssn;                /* send sequence number */
 +	u32 length;             /* total length of data in sg_list */
 +	struct qib_sge sg_list[0];
 +};
 +
 +/*
 + * Receive work request queue entry.
 + * The size of the sg_list is determined when the QP (or SRQ) is created
 + * and stored in qp->r_rq.max_sge (or srq->rq.max_sge).
 + */
 +struct qib_rwqe {
 +	u64 wr_id;
 +	u8 num_sge;
 +	struct ib_sge sg_list[0];
 +};
 +
 +/*
 + * This structure is used to contain the head pointer, tail pointer,
 + * and receive work queue entries as a single memory allocation so
 + * it can be mmap'ed into user space.
 + * Note that the wq array elements are variable size so you can't
 + * just index into the array to get the N'th element;
 + * use get_rwqe_ptr() instead.
 + */
 +struct qib_rwq {
 +	u32 head;               /* new work requests posted to the head */
 +	u32 tail;               /* receives pull requests from here. */
 +	struct qib_rwqe wq[0];
 +};
 +
 +struct qib_rq {
 +	struct qib_rwq *wq;
 +	u32 size;               /* size of RWQE array */
 +	u8 max_sge;
 +	spinlock_t lock /* protect changes in this struct */
 +		____cacheline_aligned_in_smp;
 +};
 +
++<<<<<<< HEAD
 +struct qib_srq {
 +	struct ib_srq ibsrq;
 +	struct qib_rq rq;
 +	struct qib_mmap_info *ip;
 +	/* send signal when number of RWQEs < limit */
 +	u32 limit;
 +};
 +
 +struct qib_sge_state {
 +	struct qib_sge *sg_list;      /* next SGE to be used if any */
 +	struct qib_sge sge;   /* progress state for the current SGE */
 +	u32 total_len;
 +	u8 num_sge;
 +};
 +
 +/*
 + * This structure holds the information that the send tasklet needs
 + * to send a RDMA read response or atomic operation.
 + */
 +struct qib_ack_entry {
 +	u8 opcode;
 +	u8 sent;
 +	u32 psn;
 +	u32 lpsn;
 +	union {
 +		struct qib_sge rdma_sge;
 +		u64 atomic_data;
 +	};
  };
  
++=======
++>>>>>>> 894c727b6af8 (IB/qib: Remove srq from qib)
  /*
   * qib specific data structure that will be hidden from rvt after the queue pair
   * is made common.
@@@ -836,14 -531,9 +839,18 @@@ static inline struct qib_cq *to_icq(str
  	return container_of(ibcq, struct qib_cq, ibcq);
  }
  
++<<<<<<< HEAD
 +static inline struct qib_srq *to_isrq(struct ib_srq *ibsrq)
 +{
 +	return container_of(ibsrq, struct qib_srq, ibsrq);
 +}
 +
 +static inline struct qib_qp *to_iqp(struct ib_qp *ibqp)
++=======
+ static inline struct rvt_qp *to_iqp(struct ib_qp *ibqp)
++>>>>>>> 894c727b6af8 (IB/qib: Remove srq from qib)
  {
 -	return container_of(ibqp, struct rvt_qp, ibqp);
 +	return container_of(ibqp, struct qib_qp, ibqp);
  }
  
  static inline struct qib_ibdev *to_idev(struct ib_device *ibdev)
diff --git a/drivers/infiniband/hw/qib/qib_qp.c b/drivers/infiniband/hw/qib/qib_qp.c
index cf1dd6e9d434..cb8caa433d49 100644
--- a/drivers/infiniband/hw/qib/qib_qp.c
+++ b/drivers/infiniband/hw/qib/qib_qp.c
@@ -1044,7 +1044,7 @@ struct ib_qp *qib_create_qp(struct ib_pd *ibpd,
 		sz = sizeof(*qp);
 		sg_list_sz = 0;
 		if (init_attr->srq) {
-			struct qib_srq *srq = to_isrq(init_attr->srq);
+			struct rvt_srq *srq = ibsrq_to_rvtsrq(init_attr->srq);
 
 			if (srq->rq.max_sge > 1)
 				sg_list_sz = sizeof(*qp->r_sg_list) *
* Unmerged path drivers/infiniband/hw/qib/qib_ruc.c
* Unmerged path drivers/infiniband/hw/qib/qib_srq.c
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.h
