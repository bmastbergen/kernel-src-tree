gpio: reflect base and ngpio into gpio_device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [gpio] reflect base and ngpio into gpio_device (Prarit Bhargava) [1358979]
Rebuild_FUZZ: 92.86%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit fdeb8e1547cb9dd39d5d7223b33f3565cf86c28e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fdeb8e15.failed

Some information about the GPIO chip need to stay around also
after the gpio_chip has been removed and only the gpio_device
persist. The base and ngpio are such things, for example we
don't want a new chip arriving to overlap the number space
of a dangling gpio_device, and the chardev may still query
the device for the number of lines etc.

Note that the code that assigns base and insert gpio_device
into the global list no longer check for a missing gpio_chip:
we respect the number space allocated by any other gpio_device.

As a consequence of the gdev being referenced directly from
the gpio_desc, we need to verify it differently from all
in-kernel API calls that fall through to direct queries to
the gpio_chip vtable: we first check that desc is !NULL, then
that desc->gdev is !NULL, then, if desc->gdev->chip is NULL,
we *BAIL OUT* without any error, so as to manage the case
where operations are requested on a device that is gone.

These checks were non-uniform and partly missing in the past:
so to simplify: create the macros VALIDATE_DESC() that will
return -EINVAL if the desc or desc->gdev is missing and just
0 if the chip is gone, and conversely VALIDATE_DESC_VOID()
for the case where the function does not return an error.
By using these macros, we get warning messages about missing
gdev with reference to the right function in the kernel log.

Despite the macro business this simplifies the code and make
it more readable than if we copy/paste the same descriptor
checking code into all code ABI call sites (IMHO).

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit fdeb8e1547cb9dd39d5d7223b33f3565cf86c28e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib-sysfs.c
#	drivers/gpio/gpiolib.c
#	drivers/gpio/gpiolib.h
diff --cc drivers/gpio/gpiolib.c
index 9b50ed619d38,0738f9a51633..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -154,23 -79,40 +154,54 @@@ static int gpio_chip_hwgpio(const struc
   */
  struct gpio_desc *gpio_to_desc(unsigned gpio)
  {
++<<<<<<< HEAD
 +	if (WARN(!gpio_is_valid(gpio), "invalid GPIO %d\n", gpio))
 +		return NULL;
 +	else
 +		return &gpio_desc[gpio];
++=======
+ 	struct gpio_device *gdev;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&gpio_lock, flags);
+ 
+ 	list_for_each_entry(gdev, &gpio_devices, list) {
+ 		if (gdev->base <= gpio &&
+ 		    gdev->base + gdev->ngpio > gpio) {
+ 			spin_unlock_irqrestore(&gpio_lock, flags);
+ 			return &gdev->descs[gpio - gdev->base];
+ 		}
+ 	}
+ 
+ 	spin_unlock_irqrestore(&gpio_lock, flags);
+ 
+ 	if (!gpio_is_valid(gpio))
+ 		WARN(1, "invalid GPIO %d\n", gpio);
+ 
+ 	return NULL;
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  }
  EXPORT_SYMBOL_GPL(gpio_to_desc);
  
  /**
 - * Get the GPIO descriptor corresponding to the given hw number for this chip.
 + * Convert an offset on a certain chip to a corresponding descriptor
   */
 -struct gpio_desc *gpiochip_get_desc(struct gpio_chip *chip,
 -				    u16 hwnum)
 +static struct gpio_desc *gpiochip_offset_to_desc(struct gpio_chip *chip,
 +						 unsigned int offset)
  {
++<<<<<<< HEAD
 +	if (offset >= chip->ngpio)
 +		return ERR_PTR(-EINVAL);
 +
 +	return &chip->desc[offset];
++=======
+ 	struct gpio_device *gdev = chip->gpiodev;
+ 
+ 	if (hwnum >= gdev->ngpio)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return &gdev->descs[hwnum];
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  }
  
  /**
@@@ -180,7 -122,7 +211,11 @@@
   */
  int desc_to_gpio(const struct gpio_desc *desc)
  {
++<<<<<<< HEAD
 +	return desc - &gpio_desc[0];
++=======
+ 	return desc->gdev->base + (desc - &desc->gdev->descs[0]);
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  }
  EXPORT_SYMBOL_GPL(desc_to_gpio);
  
@@@ -231,16 -142,16 +268,24 @@@ EXPORT_SYMBOL_GPL(gpiod_to_chip)
  /* dynamic allocation of GPIOs, e.g. on a hotplugged device */
  static int gpiochip_find_base(int ngpio)
  {
 -	struct gpio_device *gdev;
 +	struct gpio_chip *chip;
  	int base = ARCH_NR_GPIOS - ngpio;
  
 -	list_for_each_entry_reverse(gdev, &gpio_devices, list) {
 +	list_for_each_entry_reverse(chip, &gpio_chips, list) {
  		/* found a free space? */
++<<<<<<< HEAD
 +		if (chip->base + chip->ngpio <= base)
 +			break;
 +		else
 +			/* nope, check the space right before the chip */
 +			base = chip->base - ngpio;
++=======
+ 		if (gdev->base + gdev->ngpio <= base)
+ 			break;
+ 		else
+ 			/* nope, check the space right before the chip */
+ 			base = gdev->base - ngpio;
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  	}
  
  	if (gpio_is_valid(base)) {
@@@ -1125,40 -204,212 +1170,232 @@@ static inline void gpiochip_unexport(st
   * Return -EBUSY if the new chip overlaps with some other chip's integer
   * space.
   */
 -static int gpiodev_add_to_list(struct gpio_device *gdev)
 +static int gpiochip_add_to_list(struct gpio_chip *chip)
  {
 -	struct gpio_device *iterator;
 -	struct gpio_device *previous = NULL;
 -
 -	if (!gdev->chip)
 -		return -EINVAL;
 +	struct list_head *pos = &gpio_chips;
 +	struct gpio_chip *_chip;
 +	int err = 0;
  
 -	if (list_empty(&gpio_devices)) {
 -		list_add_tail(&gdev->list, &gpio_devices);
 -		return 0;
 +	/* find where to insert our chip */
 +	list_for_each(pos, &gpio_chips) {
 +		_chip = list_entry(pos, struct gpio_chip, list);
 +		/* shall we insert before _chip? */
 +		if (_chip->base >= chip->base + chip->ngpio)
 +			break;
  	}
  
++<<<<<<< HEAD
 +	/* are we stepping on the chip right before? */
 +	if (pos != &gpio_chips && pos->prev != &gpio_chips) {
 +		_chip = list_entry(pos->prev, struct gpio_chip, list);
 +		if (_chip->base + _chip->ngpio > chip->base) {
 +			dev_err(chip->dev,
 +			       "GPIO integer space overlap, cannot add chip\n");
 +			err = -EBUSY;
++=======
+ 	list_for_each_entry(iterator, &gpio_devices, list) {
+ 		if (iterator->base >= gdev->base + gdev->ngpio) {
+ 			/*
+ 			 * Iterator is the first GPIO chip so there is no
+ 			 * previous one
+ 			 */
+ 			if (!previous) {
+ 				goto found;
+ 			} else {
+ 				/*
+ 				 * We found a valid range(means
+ 				 * [base, base + ngpio - 1]) between previous
+ 				 * and iterator chip.
+ 				 */
+ 				if (previous->base + previous->ngpio
+ 				    <= gdev->base)
+ 					goto found;
+ 			}
+ 		}
+ 		previous = iterator;
+ 	}
+ 
+ 	/*
+ 	 * We are beyond the last chip in the list and iterator now
+ 	 * points to the head.
+ 	 * Let iterator point to the last chip in the list.
+ 	 */
+ 
+ 	iterator = list_last_entry(&gpio_devices, struct gpio_device, list);
+ 	if (iterator->base + iterator->ngpio <= gdev->base) {
+ 		list_add(&gdev->list, &iterator->list);
+ 		return 0;
+ 	}
+ 
+ 	dev_err(&gdev->dev,
+ 	       "GPIO integer space overlap, cannot add chip\n");
+ 	return -EBUSY;
+ 
+ found:
+ 	list_add_tail(&gdev->list, &iterator->list);
+ 	return 0;
+ }
+ 
+ /**
+  * Convert a GPIO name to its descriptor
+  */
+ static struct gpio_desc *gpio_name_to_desc(const char * const name)
+ {
+ 	struct gpio_device *gdev;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&gpio_lock, flags);
+ 
+ 	list_for_each_entry(gdev, &gpio_devices, list) {
+ 		int i;
+ 
+ 		for (i = 0; i != gdev->ngpio; ++i) {
+ 			struct gpio_desc *desc = &gdev->descs[i];
+ 
+ 			if (!desc->name || !name)
+ 				continue;
+ 
+ 			if (!strcmp(desc->name, name)) {
+ 				spin_unlock_irqrestore(&gpio_lock, flags);
+ 				return desc;
+ 			}
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  		}
  	}
  
 -	spin_unlock_irqrestore(&gpio_lock, flags);
 +	if (!err)
 +		list_add_tail(&chip->list, pos);
 +
++<<<<<<< HEAD
 +	return err;
 +}
  
 +/**
 + * gpiochip_add() - register a gpio_chip
++=======
+ 	return NULL;
+ }
+ 
+ /*
+  * Takes the names from gc->names and checks if they are all unique. If they
+  * are, they are assigned to their gpio descriptors.
+  *
+  * Warning if one of the names is already used for a different GPIO.
+  */
+ static int gpiochip_set_desc_names(struct gpio_chip *gc)
+ {
+ 	struct gpio_device *gdev = gc->gpiodev;
+ 	int i;
+ 
+ 	if (!gc->names)
+ 		return 0;
+ 
+ 	/* First check all names if they are unique */
+ 	for (i = 0; i != gc->ngpio; ++i) {
+ 		struct gpio_desc *gpio;
+ 
+ 		gpio = gpio_name_to_desc(gc->names[i]);
+ 		if (gpio)
+ 			dev_warn(&gdev->dev,
+ 				 "Detected name collision for GPIO name '%s'\n",
+ 				 gc->names[i]);
+ 	}
+ 
+ 	/* Then add all names to the GPIO descriptors */
+ 	for (i = 0; i != gc->ngpio; ++i)
+ 		gdev->descs[i].name = gc->names[i];
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * gpio_ioctl() - ioctl handler for the GPIO chardev
+  */
+ static long gpio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+ {
+ 	struct gpio_device *gdev = filp->private_data;
+ 	struct gpio_chip *chip = gdev->chip;
+ 	int __user *ip = (int __user *)arg;
+ 	struct gpiochip_info chipinfo;
+ 
+ 	/* We fail any subsequent ioctl():s when the chip is gone */
+ 	if (!chip)
+ 		return -ENODEV;
+ 
+ 	if (cmd == GPIO_GET_CHIPINFO_IOCTL) {
+ 		/* Fill in the struct and pass to userspace */
+ 		strncpy(chipinfo.name, dev_name(&gdev->dev),
+ 			sizeof(chipinfo.name));
+ 		chipinfo.name[sizeof(chipinfo.name)-1] = '\0';
+ 		chipinfo.lines = gdev->ngpio;
+ 		if (copy_to_user(ip, &chipinfo, sizeof(chipinfo)))
+ 			return -EFAULT;
+ 		return 0;
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ /**
+  * gpio_chrdev_open() - open the chardev for ioctl operations
+  * @inode: inode for this chardev
+  * @filp: file struct for storing private data
+  * Returns 0 on success
+  */
+ static int gpio_chrdev_open(struct inode *inode, struct file *filp)
+ {
+ 	struct gpio_device *gdev = container_of(inode->i_cdev,
+ 					      struct gpio_device, chrdev);
+ 
+ 	/* Fail on open if the backing gpiochip is gone */
+ 	if (!gdev || !gdev->chip)
+ 		return -ENODEV;
+ 	get_device(&gdev->dev);
+ 	filp->private_data = gdev;
+ 	return 0;
+ }
+ 
+ /**
+  * gpio_chrdev_release() - close chardev after ioctl operations
+  * @inode: inode for this chardev
+  * @filp: file struct for storing private data
+  * Returns 0 on success
+  */
+ static int gpio_chrdev_release(struct inode *inode, struct file *filp)
+ {
+ 	struct gpio_device *gdev = container_of(inode->i_cdev,
+ 					      struct gpio_device, chrdev);
+ 
+ 	if (!gdev)
+ 		return -ENODEV;
+ 	put_device(&gdev->dev);
+ 	return 0;
+ }
+ 
+ 
+ static const struct file_operations gpio_fileops = {
+ 	.release = gpio_chrdev_release,
+ 	.open = gpio_chrdev_open,
+ 	.owner = THIS_MODULE,
+ 	.llseek = noop_llseek,
+ 	.unlocked_ioctl = gpio_ioctl,
+ 	.compat_ioctl = gpio_ioctl,
+ };
+ 
+ static void gpiodevice_release(struct device *dev)
+ {
+ 	struct gpio_device *gdev = dev_get_drvdata(dev);
+ 
+ 	cdev_del(&gdev->chrdev);
+ 	list_del(&gdev->list);
+ 	ida_simple_remove(&gpio_ida, gdev->id);
+ 	kfree(gdev);
+ }
+ 
+ /**
+  * gpiochip_add_data() - register a gpio_chip
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
   * @chip: the chip to register, with chip->base initialized
 - * Context: potentially before irqs will work
 + * Context: potentially before irqs or kmalloc will work
   *
   * Returns a negative errno if the chip can't be registered, such as
   * because the chip->base is invalid or already associated with a
@@@ -1176,14 -427,61 +1413,65 @@@ int gpiochip_add(struct gpio_chip *chip
  {
  	unsigned long	flags;
  	int		status = 0;
 -	unsigned	i;
 +	unsigned	id;
  	int		base = chip->base;
 -	struct gpio_device *gdev;
  
++<<<<<<< HEAD
 +	if ((!gpio_is_valid(base) || !gpio_is_valid(base + chip->ngpio - 1))
 +			&& base >= 0) {
++=======
+ 	/*
+ 	 * First: allocate and populate the internal stat container, and
+ 	 * set up the struct device.
+ 	 */
+ 	gdev = kmalloc(sizeof(*gdev), GFP_KERNEL);
+ 	if (!gdev)
+ 		return -ENOMEM;
+ 	gdev->dev.bus = &gpio_bus_type;
+ 	gdev->chip = chip;
+ 	chip->gpiodev = gdev;
+ 	if (chip->parent) {
+ 		gdev->dev.parent = chip->parent;
+ 		gdev->dev.of_node = chip->parent->of_node;
+ 	} else {
+ #ifdef CONFIG_OF_GPIO
+ 	/* If the gpiochip has an assigned OF node this takes precedence */
+ 		if (chip->of_node)
+ 			gdev->dev.of_node = chip->of_node;
+ #endif
+ 	}
+ 	gdev->id = ida_simple_get(&gpio_ida, 0, 0, GFP_KERNEL);
+ 	if (gdev->id < 0) {
+ 		status = gdev->id;
+ 		goto err_free_gdev;
+ 	}
+ 	dev_set_name(&gdev->dev, "gpiochip%d", gdev->id);
+ 	device_initialize(&gdev->dev);
+ 	dev_set_drvdata(&gdev->dev, gdev);
+ 	if (chip->parent && chip->parent->driver)
+ 		gdev->owner = chip->parent->driver->owner;
+ 	else if (chip->owner)
+ 		/* TODO: remove chip->owner */
+ 		gdev->owner = chip->owner;
+ 	else
+ 		gdev->owner = THIS_MODULE;
+ 
+ 	gdev->descs = devm_kcalloc(&gdev->dev, chip->ngpio,
+ 				   sizeof(gdev->descs[0]), GFP_KERNEL);
+ 	if (!gdev->descs) {
+ 		status = -ENOMEM;
+ 		goto err_free_gdev;
+ 	}
+ 
+ 	if (chip->ngpio == 0) {
+ 		chip_err(chip, "tried to insert a GPIO chip with zero lines\n");
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  		status = -EINVAL;
 -		goto err_free_gdev;
 +		goto fail;
  	}
+ 	gdev->ngpio = chip->ngpio;
+ 	/* FIXME: move driver data into gpio_device dev_set_drvdata() */
+ 	chip->data = data;
  
  	spin_lock_irqsave(&gpio_lock, flags);
  
@@@ -1191,31 -496,37 +1486,42 @@@
  		base = gpiochip_find_base(chip->ngpio);
  		if (base < 0) {
  			status = base;
 -			spin_unlock_irqrestore(&gpio_lock, flags);
 -			goto err_free_gdev;
 +			goto unlock;
  		}
+ 		/*
+ 		 * TODO: it should not be necessary to reflect the assigned
+ 		 * base outside of the GPIO subsystem. Go over drivers and
+ 		 * see if anyone makes use of this, else drop this and assign
+ 		 * a poison instead.
+ 		 */
  		chip->base = base;
  	}
+ 	gdev->base = base;
  
 -	status = gpiodev_add_to_list(gdev);
 -	if (status) {
 -		spin_unlock_irqrestore(&gpio_lock, flags);
 -		goto err_free_gdev;
 -	}
 +	status = gpiochip_add_to_list(chip);
  
 -	for (i = 0; i < chip->ngpio; i++) {
 -		struct gpio_desc *desc = &gdev->descs[i];
 +	if (status == 0) {
 +		chip->desc = &gpio_desc[chip->base];
  
++<<<<<<< HEAD
 +		for (id = 0; id < chip->ngpio; id++) {
 +			struct gpio_desc *desc = &chip->desc[id];
 +			desc->chip = chip;
++=======
+ 		desc->gdev = gdev;
 -
 -		/* REVISIT: most hardware initializes GPIOs as inputs (often
 -		 * with pullups enabled) so power usage is minimized. Linux
 -		 * code should set the gpio direction first thing; but until
 -		 * it does, and in case chip->get_direction is not set, we may
 -		 * expose the wrong direction in sysfs.
 -		 */
 -		desc->flags = !chip->direction_input ? (1 << FLAG_IS_OUT) : 0;
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
 +
 +			/* REVISIT:  most hardware initializes GPIOs as
 +			 * inputs (often with pullups enabled) so power
 +			 * usage is minimized.  Linux code should set the
 +			 * gpio direction first thing; but until it does,
 +			 * and in case chip->get_direction is not set,
 +			 * we may expose the wrong direction in sysfs.
 +			 */
 +			desc->flags = !chip->direction_input
 +				? (1 << FLAG_IS_OUT)
 +				: 0;
 +		}
  	}
  
  	spin_unlock_irqrestore(&gpio_lock, flags);
@@@ -1224,31 -535,73 +1530,73 @@@
  	INIT_LIST_HEAD(&chip->pin_ranges);
  #endif
  
 -	status = gpiochip_set_desc_names(chip);
 +	of_gpiochip_add(chip);
 +
  	if (status)
 -		goto err_remove_from_list;
 +		goto fail;
  
 -	status = of_gpiochip_add(chip);
 +	status = gpiochip_export(chip);
  	if (status)
 -		goto err_remove_chip;
 +		goto fail;
  
++<<<<<<< HEAD
 +	pr_debug("%s: registered GPIOs %d to %d on device: %s\n", __func__,
 +		chip->base, chip->base + chip->ngpio - 1,
 +		chip->label ? : "generic");
++=======
+ 	acpi_gpiochip_add(chip);
+ 
+ 	/*
+ 	 * By first adding the chardev, and then adding the device,
+ 	 * we get a device node entry in sysfs under
+ 	 * /sys/bus/gpio/devices/gpiochipN/dev that can be used for
+ 	 * coldplug of device nodes and other udev business.
+ 	 */
+ 	cdev_init(&gdev->chrdev, &gpio_fileops);
+ 	gdev->chrdev.owner = THIS_MODULE;
+ 	gdev->chrdev.kobj.parent = &gdev->dev.kobj;
+ 	gdev->dev.devt = MKDEV(MAJOR(gpio_devt), gdev->id);
+ 	status = cdev_add(&gdev->chrdev, gdev->dev.devt, 1);
+ 	if (status < 0)
+ 		chip_warn(chip, "failed to add char device %d:%d\n",
+ 			  MAJOR(gpio_devt), gdev->id);
+ 	else
+ 		chip_dbg(chip, "added GPIO chardev (%d:%d)\n",
+ 			 MAJOR(gpio_devt), gdev->id);
+ 	status = device_add(&gdev->dev);
+ 	if (status)
+ 		goto err_remove_chardev;
+ 
+ 	status = gpiochip_sysfs_register(gdev);
+ 	if (status)
+ 		goto err_remove_device;
+ 
+ 	/* From this point, the .release() function cleans up gpio_device */
+ 	gdev->dev.release = gpiodevice_release;
+ 	get_device(&gdev->dev);
+ 	pr_debug("%s: registered GPIOs %d to %d on device: %s (%s)\n",
+ 		 __func__, gdev->base, gdev->base + gdev->ngpio - 1,
+ 		 dev_name(&gdev->dev), chip->label ? : "generic");
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  
  	return 0;
  
 -err_remove_device:
 -	device_del(&gdev->dev);
 -err_remove_chardev:
 -	cdev_del(&gdev->chrdev);
 -err_remove_chip:
 -	acpi_gpiochip_remove(chip);
 -	gpiochip_free_hogs(chip);
 -	of_gpiochip_remove(chip);
 -err_remove_from_list:
 -	spin_lock_irqsave(&gpio_lock, flags);
 -	list_del(&gdev->list);
 +unlock:
  	spin_unlock_irqrestore(&gpio_lock, flags);
++<<<<<<< HEAD
 +fail:
++=======
+ err_free_gdev:
+ 	ida_simple_remove(&gpio_ida, gdev->id);
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  	/* failures here can mean systems won't boot... */
  	pr_err("%s: GPIOs %d..%d (%s) failed to register\n", __func__,
- 		chip->base, chip->base + chip->ngpio - 1,
- 		chip->label ? : "generic");
+ 	       gdev->base, gdev->base + gdev->ngpio - 1,
+ 	       chip->label ? : "generic");
+ 	kfree(gdev);
  	return status;
  }
 -EXPORT_SYMBOL_GPL(gpiochip_add_data);
 +EXPORT_SYMBOL_GPL(gpiochip_add);
  
  /**
   * gpiochip_remove() - unregister a gpio_chip
@@@ -1256,36 -609,44 +1604,49 @@@
   *
   * A gpio_chip with any GPIOs still requested may not be removed.
   */
 -void gpiochip_remove(struct gpio_chip *chip)
 +int gpiochip_remove(struct gpio_chip *chip)
  {
 -	struct gpio_device *gdev = chip->gpiodev;
 -	struct gpio_desc *desc;
  	unsigned long	flags;
 -	unsigned	i;
 -	bool		requested = false;
 +	int		status = 0;
 +	unsigned	id;
  
 -	/* Numb the device, cancelling all outstanding operations */
 -	gdev->chip = NULL;
 +	spin_lock_irqsave(&gpio_lock, flags);
++<<<<<<< HEAD
  
 -	/* FIXME: should the legacy sysfs handling be moved to gpio_device? */
 -	gpiochip_sysfs_unregister(gdev);
 -	gpiochip_irqchip_remove(chip);
 -	acpi_gpiochip_remove(chip);
  	gpiochip_remove_pin_ranges(chip);
 -	gpiochip_free_hogs(chip);
  	of_gpiochip_remove(chip);
  
 -	spin_lock_irqsave(&gpio_lock, flags);
 +	for (id = 0; id < chip->ngpio; id++) {
 +		if (test_bit(FLAG_REQUESTED, &chip->desc[id].flags)) {
 +			status = -EBUSY;
 +			break;
 +		}
++=======
+ 	for (i = 0; i < gdev->ngpio; i++) {
+ 		desc = &gdev->descs[i];
+ 		if (test_bit(FLAG_REQUESTED, &desc->flags))
+ 			requested = true;
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
 +	}
 +	if (status == 0) {
 +		for (id = 0; id < chip->ngpio; id++)
 +			chip->desc[id].chip = NULL;
 +
 +		list_del(&chip->list);
  	}
 +
  	spin_unlock_irqrestore(&gpio_lock, flags);
  
++<<<<<<< HEAD
 +	if (status == 0)
 +		gpiochip_unexport(chip);
++=======
+ 	if (requested)
+ 		dev_crit(&gdev->dev,
+ 			 "REMOVING GPIOCHIP WITH GPIOS STILL REQUESTED\n");
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  
 -	/*
 -	 * The gpiochip side puts its use of the device to rest here:
 -	 * if there are no userspace clients, the chardev and device will
 -	 * be removed, else it will be dangling until the last user is
 -	 * gone.
 -	 */
 -	put_device(&gdev->dev);
 +	return status;
  }
  EXPORT_SYMBOL_GPL(gpiochip_remove);
  
@@@ -1333,6 -698,300 +1694,303 @@@ static struct gpio_chip *find_chip_by_n
  	return gpiochip_find((void *)name, gpiochip_match_name);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_GPIOLIB_IRQCHIP
+ 
+ /*
+  * The following is irqchip helper code for gpiochips.
+  */
+ 
+ /**
+  * gpiochip_set_chained_irqchip() - sets a chained irqchip to a gpiochip
+  * @gpiochip: the gpiochip to set the irqchip chain to
+  * @irqchip: the irqchip to chain to the gpiochip
+  * @parent_irq: the irq number corresponding to the parent IRQ for this
+  * chained irqchip
+  * @parent_handler: the parent interrupt handler for the accumulated IRQ
+  * coming out of the gpiochip. If the interrupt is nested rather than
+  * cascaded, pass NULL in this handler argument
+  */
+ void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
+ 				  struct irq_chip *irqchip,
+ 				  int parent_irq,
+ 				  irq_flow_handler_t parent_handler)
+ {
+ 	unsigned int offset;
+ 
+ 	if (!gpiochip->irqdomain) {
+ 		chip_err(gpiochip, "called %s before setting up irqchip\n",
+ 			 __func__);
+ 		return;
+ 	}
+ 
+ 	if (parent_handler) {
+ 		if (gpiochip->can_sleep) {
+ 			chip_err(gpiochip,
+ 				 "you cannot have chained interrupts on a "
+ 				 "chip that may sleep\n");
+ 			return;
+ 		}
+ 		/*
+ 		 * The parent irqchip is already using the chip_data for this
+ 		 * irqchip, so our callbacks simply use the handler_data.
+ 		 */
+ 		irq_set_chained_handler_and_data(parent_irq, parent_handler,
+ 						 gpiochip);
+ 
+ 		gpiochip->irq_parent = parent_irq;
+ 	}
+ 
+ 	/* Set the parent IRQ for all affected IRQs */
+ 	for (offset = 0; offset < gpiochip->ngpio; offset++)
+ 		irq_set_parent(irq_find_mapping(gpiochip->irqdomain, offset),
+ 			       parent_irq);
+ }
+ EXPORT_SYMBOL_GPL(gpiochip_set_chained_irqchip);
+ 
+ /**
+  * gpiochip_irq_map() - maps an IRQ into a GPIO irqchip
+  * @d: the irqdomain used by this irqchip
+  * @irq: the global irq number used by this GPIO irqchip irq
+  * @hwirq: the local IRQ/GPIO line offset on this gpiochip
+  *
+  * This function will set up the mapping for a certain IRQ line on a
+  * gpiochip by assigning the gpiochip as chip data, and using the irqchip
+  * stored inside the gpiochip.
+  */
+ static int gpiochip_irq_map(struct irq_domain *d, unsigned int irq,
+ 			    irq_hw_number_t hwirq)
+ {
+ 	struct gpio_chip *chip = d->host_data;
+ 
+ 	irq_set_chip_data(irq, chip);
+ 	/*
+ 	 * This lock class tells lockdep that GPIO irqs are in a different
+ 	 * category than their parents, so it won't report false recursion.
+ 	 */
+ 	irq_set_lockdep_class(irq, chip->lock_key);
+ 	irq_set_chip_and_handler(irq, chip->irqchip, chip->irq_handler);
+ 	/* Chips that can sleep need nested thread handlers */
+ 	if (chip->can_sleep && !chip->irq_not_threaded)
+ 		irq_set_nested_thread(irq, 1);
+ 	irq_set_noprobe(irq);
+ 
+ 	/*
+ 	 * No set-up of the hardware will happen if IRQ_TYPE_NONE
+ 	 * is passed as default type.
+ 	 */
+ 	if (chip->irq_default_type != IRQ_TYPE_NONE)
+ 		irq_set_irq_type(irq, chip->irq_default_type);
+ 
+ 	return 0;
+ }
+ 
+ static void gpiochip_irq_unmap(struct irq_domain *d, unsigned int irq)
+ {
+ 	struct gpio_chip *chip = d->host_data;
+ 
+ 	if (chip->can_sleep)
+ 		irq_set_nested_thread(irq, 0);
+ 	irq_set_chip_and_handler(irq, NULL, NULL);
+ 	irq_set_chip_data(irq, NULL);
+ }
+ 
+ static const struct irq_domain_ops gpiochip_domain_ops = {
+ 	.map	= gpiochip_irq_map,
+ 	.unmap	= gpiochip_irq_unmap,
+ 	/* Virtually all GPIO irqchips are twocell:ed */
+ 	.xlate	= irq_domain_xlate_twocell,
+ };
+ 
+ static int gpiochip_irq_reqres(struct irq_data *d)
+ {
+ 	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+ 
+ 	if (!try_module_get(chip->gpiodev->owner))
+ 		return -ENODEV;
+ 
+ 	if (gpiochip_lock_as_irq(chip, d->hwirq)) {
+ 		chip_err(chip,
+ 			"unable to lock HW IRQ %lu for IRQ\n",
+ 			d->hwirq);
+ 		module_put(chip->gpiodev->owner);
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
+ static void gpiochip_irq_relres(struct irq_data *d)
+ {
+ 	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+ 
+ 	gpiochip_unlock_as_irq(chip, d->hwirq);
+ 	module_put(chip->gpiodev->owner);
+ }
+ 
+ static int gpiochip_to_irq(struct gpio_chip *chip, unsigned offset)
+ {
+ 	return irq_find_mapping(chip->irqdomain, offset);
+ }
+ 
+ /**
+  * gpiochip_irqchip_remove() - removes an irqchip added to a gpiochip
+  * @gpiochip: the gpiochip to remove the irqchip from
+  *
+  * This is called only from gpiochip_remove()
+  */
+ static void gpiochip_irqchip_remove(struct gpio_chip *gpiochip)
+ {
+ 	unsigned int offset;
+ 
+ 	acpi_gpiochip_free_interrupts(gpiochip);
+ 
+ 	if (gpiochip->irq_parent) {
+ 		irq_set_chained_handler(gpiochip->irq_parent, NULL);
+ 		irq_set_handler_data(gpiochip->irq_parent, NULL);
+ 	}
+ 
+ 	/* Remove all IRQ mappings and delete the domain */
+ 	if (gpiochip->irqdomain) {
+ 		for (offset = 0; offset < gpiochip->ngpio; offset++)
+ 			irq_dispose_mapping(
+ 				irq_find_mapping(gpiochip->irqdomain, offset));
+ 		irq_domain_remove(gpiochip->irqdomain);
+ 	}
+ 
+ 	if (gpiochip->irqchip) {
+ 		gpiochip->irqchip->irq_request_resources = NULL;
+ 		gpiochip->irqchip->irq_release_resources = NULL;
+ 		gpiochip->irqchip = NULL;
+ 	}
+ }
+ 
+ /**
+  * gpiochip_irqchip_add() - adds an irqchip to a gpiochip
+  * @gpiochip: the gpiochip to add the irqchip to
+  * @irqchip: the irqchip to add to the gpiochip
+  * @first_irq: if not dynamically assigned, the base (first) IRQ to
+  * allocate gpiochip irqs from
+  * @handler: the irq handler to use (often a predefined irq core function)
+  * @type: the default type for IRQs on this irqchip, pass IRQ_TYPE_NONE
+  * to have the core avoid setting up any default type in the hardware.
+  * @lock_key: lockdep class
+  *
+  * This function closely associates a certain irqchip with a certain
+  * gpiochip, providing an irq domain to translate the local IRQs to
+  * global irqs in the gpiolib core, and making sure that the gpiochip
+  * is passed as chip data to all related functions. Driver callbacks
+  * need to use gpiochip_get_data() to get their local state containers back
+  * from the gpiochip passed as chip data. An irqdomain will be stored
+  * in the gpiochip that shall be used by the driver to handle IRQ number
+  * translation. The gpiochip will need to be initialized and registered
+  * before calling this function.
+  *
+  * This function will handle two cell:ed simple IRQs and assumes all
+  * the pins on the gpiochip can generate a unique IRQ. Everything else
+  * need to be open coded.
+  */
+ int _gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+ 			  struct irq_chip *irqchip,
+ 			  unsigned int first_irq,
+ 			  irq_flow_handler_t handler,
+ 			  unsigned int type,
+ 			  struct lock_class_key *lock_key)
+ {
+ 	struct device_node *of_node;
+ 	unsigned int offset;
+ 	unsigned irq_base = 0;
+ 
+ 	if (!gpiochip || !irqchip)
+ 		return -EINVAL;
+ 
+ 	if (!gpiochip->parent) {
+ 		pr_err("missing gpiochip .dev parent pointer\n");
+ 		return -EINVAL;
+ 	}
+ 	of_node = gpiochip->parent->of_node;
+ #ifdef CONFIG_OF_GPIO
+ 	/*
+ 	 * If the gpiochip has an assigned OF node this takes precedence
+ 	 * FIXME: get rid of this and use gpiochip->parent->of_node
+ 	 * everywhere
+ 	 */
+ 	if (gpiochip->of_node)
+ 		of_node = gpiochip->of_node;
+ #endif
+ 	gpiochip->irqchip = irqchip;
+ 	gpiochip->irq_handler = handler;
+ 	gpiochip->irq_default_type = type;
+ 	gpiochip->to_irq = gpiochip_to_irq;
+ 	gpiochip->lock_key = lock_key;
+ 	gpiochip->irqdomain = irq_domain_add_simple(of_node,
+ 					gpiochip->ngpio, first_irq,
+ 					&gpiochip_domain_ops, gpiochip);
+ 	if (!gpiochip->irqdomain) {
+ 		gpiochip->irqchip = NULL;
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * It is possible for a driver to override this, but only if the
+ 	 * alternative functions are both implemented.
+ 	 */
+ 	if (!irqchip->irq_request_resources &&
+ 	    !irqchip->irq_release_resources) {
+ 		irqchip->irq_request_resources = gpiochip_irq_reqres;
+ 		irqchip->irq_release_resources = gpiochip_irq_relres;
+ 	}
+ 
+ 	/*
+ 	 * Prepare the mapping since the irqchip shall be orthogonal to
+ 	 * any gpiochip calls. If the first_irq was zero, this is
+ 	 * necessary to allocate descriptors for all IRQs.
+ 	 */
+ 	for (offset = 0; offset < gpiochip->ngpio; offset++) {
+ 		irq_base = irq_create_mapping(gpiochip->irqdomain, offset);
+ 		if (offset == 0)
+ 			/*
+ 			 * Store the base into the gpiochip to be used when
+ 			 * unmapping the irqs.
+ 			 */
+ 			gpiochip->irq_base = irq_base;
+ 	}
+ 
+ 	acpi_gpiochip_request_interrupts(gpiochip);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(_gpiochip_irqchip_add);
+ 
+ #else /* CONFIG_GPIOLIB_IRQCHIP */
+ 
+ static void gpiochip_irqchip_remove(struct gpio_chip *gpiochip) {}
+ 
+ #endif /* CONFIG_GPIOLIB_IRQCHIP */
+ 
+ /**
+  * gpiochip_generic_request() - request the gpio function for a pin
+  * @chip: the gpiochip owning the GPIO
+  * @offset: the offset of the GPIO to request for GPIO function
+  */
+ int gpiochip_generic_request(struct gpio_chip *chip, unsigned offset)
+ {
+ 	return pinctrl_request_gpio(chip->gpiodev->base + offset);
+ }
+ EXPORT_SYMBOL_GPL(gpiochip_generic_request);
+ 
+ /**
+  * gpiochip_generic_free() - free the gpio function from a pin
+  * @chip: the gpiochip to request the gpio function for
+  * @offset: the offset of the GPIO to free from GPIO function
+  */
+ void gpiochip_generic_free(struct gpio_chip *chip, unsigned offset)
+ {
+ 	pinctrl_free_gpio(chip->gpiodev->base + offset);
+ }
+ EXPORT_SYMBOL_GPL(gpiochip_generic_free);
+ 
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  #ifdef CONFIG_PINCTRL
  
  /**
@@@ -1451,26 -1114,14 +2111,31 @@@ EXPORT_SYMBOL_GPL(gpiochip_remove_pin_r
   * on each other, and help provide better diagnostics in debugfs.
   * They're called even less than the "set direction" calls.
   */
 -static int __gpiod_request(struct gpio_desc *desc, const char *label)
 +static int gpiod_request(struct gpio_desc *desc, const char *label)
  {
++<<<<<<< HEAD
 +	struct gpio_chip	*chip;
 +	int			status = -EPROBE_DEFER;
++=======
+ 	struct gpio_chip	*chip = desc->gdev->chip;
+ 	int			status;
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  	unsigned long		flags;
  
 +	if (!desc) {
 +		pr_warn("%s: invalid GPIO\n", __func__);
 +		return -EINVAL;
 +	}
 +
  	spin_lock_irqsave(&gpio_lock, flags);
  
 +	chip = desc->chip;
 +	if (chip == NULL)
 +		goto done;
 +
 +	if (!try_module_get(chip->owner))
 +		goto done;
 +
  	/* NOTE:  gpio_request() can be called in early boot,
  	 * before IRQs are enabled, for non-sleeping (SOC) GPIOs.
  	 */
@@@ -1510,14 -1165,57 +2175,63 @@@ done
  	return status;
  }
  
++<<<<<<< HEAD
 +int gpio_request(unsigned gpio, const char *label)
 +{
 +	return gpiod_request(gpio_to_desc(gpio), label);
++=======
+ /*
+  * This descriptor validation needs to be inserted verbatim into each
+  * function taking a descriptor, so we need to use a preprocessor
+  * macro to avoid endless duplication.
+  */
+ #define VALIDATE_DESC(desc) do { \
+ 	if (!desc || !desc->gdev) { \
+ 		pr_warn("%s: invalid GPIO\n", __func__); \
+ 		return -EINVAL; \
+ 	} \
+ 	if ( !desc->gdev->chip ) { \
+ 		dev_warn(&desc->gdev->dev, \
+ 			 "%s: backing chip is gone\n", __func__); \
+ 		return 0; \
+ 	} } while (0)
+ 
+ #define VALIDATE_DESC_VOID(desc) do { \
+ 	if (!desc || !desc->gdev) { \
+ 		pr_warn("%s: invalid GPIO\n", __func__); \
+ 		return; \
+ 	} \
+ 	if (!desc->gdev->chip) { \
+ 		dev_warn(&desc->gdev->dev, \
+ 			 "%s: backing chip is gone\n", __func__); \
+ 		return; \
+ 	} } while (0)
+ 
+ 
+ int gpiod_request(struct gpio_desc *desc, const char *label)
+ {
+ 	int status = -EPROBE_DEFER;
+ 	struct gpio_device *gdev;
+ 
+ 	VALIDATE_DESC(desc);
+ 	gdev = desc->gdev;
+ 
+ 	if (try_module_get(gdev->owner)) {
+ 		status = __gpiod_request(desc, label);
+ 		if (status < 0)
+ 			module_put(gdev->owner);
+ 	}
+ 
+ 	if (status)
+ 		gpiod_dbg(desc, "%s: status %d\n", __func__, status);
+ 
+ 	return status;
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  }
 +EXPORT_SYMBOL_GPL(gpio_request);
  
 -static bool __gpiod_free(struct gpio_desc *desc)
 +static void gpiod_free(struct gpio_desc *desc)
  {
 -	bool			ret = false;
  	unsigned long		flags;
  	struct gpio_chip	*chip;
  
@@@ -1546,98 -1238,21 +2260,105 @@@
  		clear_bit(FLAG_REQUESTED, &desc->flags);
  		clear_bit(FLAG_OPEN_DRAIN, &desc->flags);
  		clear_bit(FLAG_OPEN_SOURCE, &desc->flags);
 -		clear_bit(FLAG_IS_HOGGED, &desc->flags);
 -		ret = true;
 -	}
 +	} else
 +		WARN_ON(extra_checks);
  
  	spin_unlock_irqrestore(&gpio_lock, flags);
 -	return ret;
  }
  
 -void gpiod_free(struct gpio_desc *desc)
 +void gpio_free(unsigned gpio)
  {
++<<<<<<< HEAD
 +	gpiod_free(gpio_to_desc(gpio));
++=======
+ 	if (desc && __gpiod_free(desc))
+ 		module_put(desc->gdev->owner);
+ 	else
+ 		WARN_ON(extra_checks);
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
 +}
 +EXPORT_SYMBOL_GPL(gpio_free);
 +
 +/**
 + * gpio_request_one - request a single GPIO with initial configuration
 + * @gpio:	the GPIO number
 + * @flags:	GPIO configuration as specified by GPIOF_*
 + * @label:	a literal description string of this GPIO
 + */
 +int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 +{
 +	struct gpio_desc *desc;
 +	int err;
 +
 +	desc = gpio_to_desc(gpio);
 +
 +	err = gpiod_request(desc, label);
 +	if (err)
 +		return err;
 +
 +	if (flags & GPIOF_OPEN_DRAIN)
 +		set_bit(FLAG_OPEN_DRAIN, &desc->flags);
 +
 +	if (flags & GPIOF_OPEN_SOURCE)
 +		set_bit(FLAG_OPEN_SOURCE, &desc->flags);
 +
 +	if (flags & GPIOF_DIR_IN)
 +		err = gpiod_direction_input(desc);
 +	else
 +		err = gpiod_direction_output(desc,
 +				(flags & GPIOF_INIT_HIGH) ? 1 : 0);
 +
 +	if (err)
 +		goto free_gpio;
 +
 +	if (flags & GPIOF_EXPORT) {
 +		err = gpiod_export(desc, flags & GPIOF_EXPORT_CHANGEABLE);
 +		if (err)
 +			goto free_gpio;
 +	}
 +
 +	return 0;
 +
 + free_gpio:
 +	gpiod_free(desc);
 +	return err;
 +}
 +EXPORT_SYMBOL_GPL(gpio_request_one);
 +
 +/**
 + * gpio_request_array - request multiple GPIOs in a single call
 + * @array:	array of the 'struct gpio'
 + * @num:	how many GPIOs in the array
 + */
 +int gpio_request_array(const struct gpio *array, size_t num)
 +{
 +	int i, err;
 +
 +	for (i = 0; i < num; i++, array++) {
 +		err = gpio_request_one(array->gpio, array->flags, array->label);
 +		if (err)
 +			goto err_free;
 +	}
 +	return 0;
 +
 +err_free:
 +	while (i--)
 +		gpio_free((--array)->gpio);
 +	return err;
  }
 +EXPORT_SYMBOL_GPL(gpio_request_array);
 +
 +/**
 + * gpio_free_array - release multiple GPIOs in a single call
 + * @array:	array of the 'struct gpio'
 + * @num:	how many GPIOs in the array
 + */
 +void gpio_free_array(const struct gpio *array, size_t num)
 +{
 +	while (num--)
 +		gpio_free((array++)->gpio);
 +}
 +EXPORT_SYMBOL_GPL(gpio_free_array);
  
  /**
   * gpiochip_is_requested - return string iff signal was requested
@@@ -1671,8 -1282,52 +2392,9 @@@ const char *gpiochip_is_requested(struc
  }
  EXPORT_SYMBOL_GPL(gpiochip_is_requested);
  
 -/**
 - * gpiochip_request_own_desc - Allow GPIO chip to request its own descriptor
 - * @desc: GPIO descriptor to request
 - * @label: label for the GPIO
 - *
 - * Function allows GPIO chip drivers to request and use their own GPIO
 - * descriptors via gpiolib API. Difference to gpiod_request() is that this
 - * function will not increase reference count of the GPIO chip module. This
 - * allows the GPIO chip module to be unloaded as needed (we assume that the
 - * GPIO chip driver handles freeing the GPIOs it has requested).
 - */
 -struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip, u16 hwnum,
 -					    const char *label)
 -{
 -	struct gpio_desc *desc = gpiochip_get_desc(chip, hwnum);
 -	int err;
 -
 -	if (IS_ERR(desc)) {
 -		chip_err(chip, "failed to get GPIO descriptor\n");
 -		return desc;
 -	}
 -
 -	err = __gpiod_request(desc, label);
 -	if (err < 0)
 -		return ERR_PTR(err);
 -
 -	return desc;
 -}
 -EXPORT_SYMBOL_GPL(gpiochip_request_own_desc);
 -
 -/**
 - * gpiochip_free_own_desc - Free GPIO requested by the chip driver
 - * @desc: GPIO descriptor to free
 - *
 - * Function frees the given GPIO requested previously with
 - * gpiochip_request_own_desc().
 - */
 -void gpiochip_free_own_desc(struct gpio_desc *desc)
 -{
 -	if (desc)
 -		__gpiod_free(desc);
 -}
 -EXPORT_SYMBOL_GPL(gpiochip_free_own_desc);
  
- /* Drivers MUST set GPIO direction before making get/set calls.  In
+ /*
+  * Drivers MUST set GPIO direction before making get/set calls.  In
   * some cases this is done in early boot, before IRQs are enabled.
   *
   * As a rule these aren't called more than once (except for drivers
@@@ -1692,17 -1347,12 +2414,14 @@@
   */
  int gpiod_direction_input(struct gpio_desc *desc)
  {
 +	unsigned long		flags;
  	struct gpio_chip	*chip;
  	int			status = -EINVAL;
 +	int			offset;
  
- 	if (!desc || !desc->chip) {
- 		pr_warn("%s: invalid GPIO\n", __func__);
- 		return -EINVAL;
- 	}
+ 	VALIDATE_DESC(desc);
+ 	chip = desc->gdev->chip;
  
- 	chip = desc->chip;
  	if (!chip->get || !chip->direction_input) {
  		gpiod_warn(desc,
  			"%s: missing get() or direction_input() operations\n",
@@@ -1826,13 -1404,45 +2545,54 @@@ int gpiod_direction_output(struct gpio_
  		set_bit(FLAG_IS_OUT, &desc->flags);
  	trace_gpio_value(desc_to_gpio(desc), 0, value);
  	trace_gpio_direction(desc_to_gpio(desc), 0, status);
 +lose:
  	return status;
 +fail:
 +	spin_unlock_irqrestore(&gpio_lock, flags);
 +	if (status)
 +		gpiod_dbg(desc, "%s: gpio status %d\n", __func__, status);
 +	return status;
++<<<<<<< HEAD
++=======
+ }
+ 
+ /**
+  * gpiod_direction_output_raw - set the GPIO direction to output
+  * @desc:	GPIO to set to output
+  * @value:	initial output value of the GPIO
+  *
+  * Set the direction of the passed GPIO to output, such as gpiod_set_value() can
+  * be called safely on it. The initial value of the output must be specified
+  * as raw value on the physical line without regard for the ACTIVE_LOW status.
+  *
+  * Return 0 in case of success, else an error code.
+  */
+ int gpiod_direction_output_raw(struct gpio_desc *desc, int value)
+ {
+ 	VALIDATE_DESC(desc);
+ 	return _gpiod_direction_output_raw(desc, value);
+ }
+ EXPORT_SYMBOL_GPL(gpiod_direction_output_raw);
+ 
+ /**
+  * gpiod_direction_output - set the GPIO direction to output
+  * @desc:	GPIO to set to output
+  * @value:	initial output value of the GPIO
+  *
+  * Set the direction of the passed GPIO to output, such as gpiod_set_value() can
+  * be called safely on it. The initial value of the output must be specified
+  * as the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
+  * account.
+  *
+  * Return 0 in case of success, else an error code.
+  */
+ int gpiod_direction_output(struct gpio_desc *desc, int value)
+ {
+ 	VALIDATE_DESC(desc);
+ 	if (test_bit(FLAG_ACTIVE_LOW, &desc->flags))
+ 		value = !value;
+ 	return _gpiod_direction_output_raw(desc, value);
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  }
  EXPORT_SYMBOL_GPL(gpiod_direction_output);
  
@@@ -1846,17 -1456,10 +2606,13 @@@
   */
  int gpiod_set_debounce(struct gpio_desc *desc, unsigned debounce)
  {
 +	unsigned long		flags;
  	struct gpio_chip	*chip;
 +	int			status = -EINVAL;
 +	int			offset;
  
- 	if (!desc || !desc->chip) {
- 		pr_warn("%s: invalid GPIO\n", __func__);
- 		return -EINVAL;
- 	}
- 
- 	chip = desc->chip;
+ 	VALIDATE_DESC(desc);
+ 	chip = desc->gdev->chip;
  	if (!chip->set || !chip->set_debounce) {
  		gpiod_dbg(desc,
  			  "%s: missing set() or set_debounce() operations\n",
@@@ -1925,12 -1509,13 +2682,12 @@@ EXPORT_SYMBOL_GPL(gpiod_is_active_low)
  static int _gpiod_get_raw_value(const struct gpio_desc *desc)
  {
  	struct gpio_chip	*chip;
 -	int offset;
  	int value;
 +	int offset;
  
- 	chip = desc->chip;
+ 	chip = desc->gdev->chip;
  	offset = gpio_chip_hwgpio(desc);
 -	value = chip->get ? chip->get(chip, offset) : -EIO;
 -	value = value < 0 ? value : !!value;
 +	value = chip->get ? chip->get(chip, offset) : 0;
  	trace_gpio_value(desc_to_gpio(desc), 1, value);
  	return value;
  }
@@@ -1968,12 -1552,15 +2724,12 @@@ EXPORT_SYMBOL_GPL(gpiod_get_raw_value)
  int gpiod_get_value(const struct gpio_desc *desc)
  {
  	int value;
- 	if (!desc)
- 		return 0;
+ 
+ 	VALIDATE_DESC(desc);
  	/* Should be using gpio_get_value_cansleep() */
- 	WARN_ON(desc->chip->can_sleep);
+ 	WARN_ON(desc->gdev->chip->can_sleep);
  
  	value = _gpiod_get_raw_value(desc);
 -	if (value < 0)
 -		return value;
 -
  	if (test_bit(FLAG_ACTIVE_LOW, &desc->flags))
  		value = !value;
  
@@@ -1984,12 -1571,12 +2740,12 @@@ EXPORT_SYMBOL_GPL(gpiod_get_value)
  /*
   *  _gpio_set_open_drain_value() - Set the open drain gpio's value.
   * @desc: gpio descriptor whose state need to be set.
 - * @value: Non-zero for setting it HIGH otherwise it will set to LOW.
 + * @value: Non-zero for setting it HIGH otherise it will set to LOW.
   */
 -static void _gpio_set_open_drain_value(struct gpio_desc *desc, bool value)
 +static void _gpio_set_open_drain_value(struct gpio_desc *desc, int value)
  {
  	int err = 0;
- 	struct gpio_chip *chip = desc->chip;
+ 	struct gpio_chip *chip = desc->gdev->chip;
  	int offset = gpio_chip_hwgpio(desc);
  
  	if (value) {
@@@ -2011,12 -1598,12 +2767,12 @@@
  /*
   *  _gpio_set_open_source_value() - Set the open source gpio's value.
   * @desc: gpio descriptor whose state need to be set.
 - * @value: Non-zero for setting it HIGH otherwise it will set to LOW.
 + * @value: Non-zero for setting it HIGH otherise it will set to LOW.
   */
 -static void _gpio_set_open_source_value(struct gpio_desc *desc, bool value)
 +static void _gpio_set_open_source_value(struct gpio_desc *desc, int value)
  {
  	int err = 0;
- 	struct gpio_chip *chip = desc->chip;
+ 	struct gpio_chip *chip = desc->gdev->chip;
  	int offset = gpio_chip_hwgpio(desc);
  
  	if (value) {
@@@ -2049,6 -1636,86 +2805,89 @@@ static void _gpiod_set_raw_value(struc
  		chip->set(chip, gpio_chip_hwgpio(desc), value);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * set multiple outputs on the same chip;
+  * use the chip's set_multiple function if available;
+  * otherwise set the outputs sequentially;
+  * @mask: bit mask array; one bit per output; BITS_PER_LONG bits per word
+  *        defines which outputs are to be changed
+  * @bits: bit value array; one bit per output; BITS_PER_LONG bits per word
+  *        defines the values the outputs specified by mask are to be set to
+  */
+ static void gpio_chip_set_multiple(struct gpio_chip *chip,
+ 				   unsigned long *mask, unsigned long *bits)
+ {
+ 	if (chip->set_multiple) {
+ 		chip->set_multiple(chip, mask, bits);
+ 	} else {
+ 		int i;
+ 		for (i = 0; i < chip->ngpio; i++) {
+ 			if (mask[BIT_WORD(i)] == 0) {
+ 				/* no more set bits in this mask word;
+ 				 * skip ahead to the next word */
+ 				i = (BIT_WORD(i) + 1) * BITS_PER_LONG - 1;
+ 				continue;
+ 			}
+ 			/* set outputs if the corresponding mask bit is set */
+ 			if (__test_and_clear_bit(i, mask))
+ 				chip->set(chip, i, test_bit(i, bits));
+ 		}
+ 	}
+ }
+ 
+ static void gpiod_set_array_value_priv(bool raw, bool can_sleep,
+ 				       unsigned int array_size,
+ 				       struct gpio_desc **desc_array,
+ 				       int *value_array)
+ {
+ 	int i = 0;
+ 
+ 	while (i < array_size) {
+ 		struct gpio_chip *chip = desc_array[i]->gdev->chip;
+ 		unsigned long mask[BITS_TO_LONGS(chip->ngpio)];
+ 		unsigned long bits[BITS_TO_LONGS(chip->ngpio)];
+ 		int count = 0;
+ 
+ 		if (!can_sleep)
+ 			WARN_ON(chip->can_sleep);
+ 
+ 		memset(mask, 0, sizeof(mask));
+ 		do {
+ 			struct gpio_desc *desc = desc_array[i];
+ 			int hwgpio = gpio_chip_hwgpio(desc);
+ 			int value = value_array[i];
+ 
+ 			if (!raw && test_bit(FLAG_ACTIVE_LOW, &desc->flags))
+ 				value = !value;
+ 			trace_gpio_value(desc_to_gpio(desc), 0, value);
+ 			/*
+ 			 * collect all normal outputs belonging to the same chip
+ 			 * open drain and open source outputs are set individually
+ 			 */
+ 			if (test_bit(FLAG_OPEN_DRAIN, &desc->flags)) {
+ 				_gpio_set_open_drain_value(desc, value);
+ 			} else if (test_bit(FLAG_OPEN_SOURCE, &desc->flags)) {
+ 				_gpio_set_open_source_value(desc, value);
+ 			} else {
+ 				__set_bit(hwgpio, mask);
+ 				if (value)
+ 					__set_bit(hwgpio, bits);
+ 				else
+ 					__clear_bit(hwgpio, bits);
+ 				count++;
+ 			}
+ 			i++;
+ 		} while ((i < array_size) &&
+ 			 (desc_array[i]->gdev->chip == chip));
+ 		/* push collected bits to outputs */
+ 		if (count != 0)
+ 			gpio_chip_set_multiple(chip, mask, bits);
+ 	}
+ }
+ 
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  /**
   * gpiod_set_raw_value() - assign a gpio's raw value
   * @desc: gpio whose value will be assigned
@@@ -2213,10 -1915,11 +3047,8 @@@ int gpiod_get_value_cansleep(const stru
  	int value;
  
  	might_sleep_if(extra_checks);
- 	if (!desc)
- 		return 0;
- 
+ 	VALIDATE_DESC(desc);
  	value = _gpiod_get_raw_value(desc);
 -	if (value < 0)
 -		return value;
 -
  	if (test_bit(FLAG_ACTIVE_LOW, &desc->flags))
  		value = !value;
  
@@@ -2479,19 -2644,60 +3308,34 @@@ void gpiod_put(struct gpio_desc *desc
  }
  EXPORT_SYMBOL_GPL(gpiod_put);
  
 -/**
 - * gpiod_put_array - dispose of multiple GPIO descriptors
 - * @descs:	struct gpio_descs containing an array of descriptors
 - */
 -void gpiod_put_array(struct gpio_descs *descs)
 -{
 -	unsigned int i;
 -
 -	for (i = 0; i < descs->ndescs; i++)
 -		gpiod_put(descs->desc[i]);
 -
 -	kfree(descs);
 -}
 -EXPORT_SYMBOL_GPL(gpiod_put_array);
 -
 -static int __init gpiolib_dev_init(void)
 -{
 -	int ret;
 -
 -	/* Register GPIO sysfs bus */
 -	ret  = bus_register(&gpio_bus_type);
 -	if (ret < 0) {
 -		pr_err("gpiolib: could not register GPIO bus type\n");
 -		return ret;
 -	}
 -
 -	ret = alloc_chrdev_region(&gpio_devt, 0, GPIO_DEV_MAX, "gpiochip");
 -	if (ret < 0) {
 -		pr_err("gpiolib: failed to allocate char dev region\n");
 -		bus_unregister(&gpio_bus_type);
 -	}
 -	return ret;
 -}
 -core_initcall(gpiolib_dev_init);
 -
  #ifdef CONFIG_DEBUG_FS
  
- static void gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+ static void gpiolib_dbg_show(struct seq_file *s, struct gpio_device *gdev)
  {
  	unsigned		i;
++<<<<<<< HEAD
 +	unsigned		gpio = chip->base;
 +	struct gpio_desc	*gdesc = &chip->desc[0];
 +	int			is_out;
 +	int			is_irq;
 +
 +	for (i = 0; i < chip->ngpio; i++, gpio++, gdesc++) {
 +		if (!test_bit(FLAG_REQUESTED, &gdesc->flags))
++=======
+ 	struct gpio_chip	*chip = gdev->chip;
+ 	unsigned		gpio = gdev->base;
+ 	struct gpio_desc	*gdesc = &gdev->descs[0];
+ 	int			is_out;
+ 	int			is_irq;
+ 
+ 	for (i = 0; i < gdev->ngpio; i++, gpio++, gdesc++) {
+ 		if (!test_bit(FLAG_REQUESTED, &gdesc->flags)) {
+ 			if (gdesc->name) {
+ 				seq_printf(s, " gpio-%-3d (%-20.20s)\n",
+ 					   gpio, gdesc->name);
+ 			}
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  			continue;
 -		}
  
  		gpiod_get_direction(gdesc);
  		is_out = test_bit(FLAG_IS_OUT, &gdesc->flags);
@@@ -2551,15 -2757,24 +3395,32 @@@ static void gpiolib_seq_stop(struct seq
  
  static int gpiolib_seq_show(struct seq_file *s, void *v)
  {
 -	struct gpio_device *gdev = v;
 -	struct gpio_chip *chip = gdev->chip;
 -	struct device *parent;
 -
 +	struct gpio_chip *chip = v;
 +	struct device *dev;
 +
++<<<<<<< HEAD
 +	seq_printf(s, "%sGPIOs %d-%d", (char *)s->private,
 +			chip->base, chip->base + chip->ngpio - 1);
 +	dev = chip->dev;
 +	if (dev)
 +		seq_printf(s, ", %s/%s", dev->bus ? dev->bus->name : "no-bus",
 +			dev_name(dev));
++=======
+ 	if (!chip) {
+ 		seq_printf(s, "%s%s: (dangling chip)", (char *)s->private,
+ 			   dev_name(&gdev->dev));
+ 		return 0;
+ 	}
+ 
+ 	seq_printf(s, "%s%s: GPIOs %d-%d", (char *)s->private,
+ 		   dev_name(&gdev->dev),
+ 		   gdev->base, gdev->base + gdev->ngpio - 1);
+ 	parent = chip->parent;
+ 	if (parent)
+ 		seq_printf(s, ", parent: %s/%s",
+ 			   parent->bus ? parent->bus->name : "no-bus",
+ 			   dev_name(parent));
++>>>>>>> fdeb8e1547cb (gpio: reflect base and ngpio into gpio_device)
  	if (chip->label)
  		seq_printf(s, ", %s", chip->label);
  	if (chip->can_sleep)
* Unmerged path drivers/gpio/gpiolib-sysfs.c
* Unmerged path drivers/gpio/gpiolib.h
* Unmerged path drivers/gpio/gpiolib-sysfs.c
* Unmerged path drivers/gpio/gpiolib.c
* Unmerged path drivers/gpio/gpiolib.h
