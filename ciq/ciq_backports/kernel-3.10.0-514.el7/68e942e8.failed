netfilter: nf_tables: support optional userdata for set elements

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 68e942e88add0ac8576fc8397e86495edf3dcea7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/68e942e8.failed

Add an userdata set extension and allow the user to attach arbitrary
data to set elements. This is intended to hold TLV encoded data like
comments or DNS annotations that have no meaning to the kernel.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 68e942e88add0ac8576fc8397e86495edf3dcea7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	include/uapi/linux/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
diff --cc include/net/netfilter/nf_tables.h
index 4ab50d820db0,63c44bdfdd3b..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -327,12 -348,18 +327,24 @@@ void nf_tables_unbind_set(const struct 
   *	@NFT_SET_EXT_KEY: element key
   *	@NFT_SET_EXT_DATA: mapping data
   *	@NFT_SET_EXT_FLAGS: element flags
++<<<<<<< HEAD
++=======
+  *	@NFT_SET_EXT_TIMEOUT: element timeout
+  *	@NFT_SET_EXT_EXPIRATION: element expiration time
+  *	@NFT_SET_EXT_USERDATA: user data associated with the element
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
   *	@NFT_SET_EXT_NUM: number of extension types
   */
  enum nft_set_extensions {
  	NFT_SET_EXT_KEY,
  	NFT_SET_EXT_DATA,
  	NFT_SET_EXT_FLAGS,
++<<<<<<< HEAD
++=======
+ 	NFT_SET_EXT_TIMEOUT,
+ 	NFT_SET_EXT_EXPIRATION,
+ 	NFT_SET_EXT_USERDATA,
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
  	NFT_SET_EXT_NUM
  };
  
@@@ -427,6 -456,40 +439,43 @@@ static inline u8 *nft_set_ext_flags(con
  	return nft_set_ext(ext, NFT_SET_EXT_FLAGS);
  }
  
++<<<<<<< HEAD
++=======
+ static inline u64 *nft_set_ext_timeout(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_TIMEOUT);
+ }
+ 
+ static inline unsigned long *nft_set_ext_expiration(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_EXPIRATION);
+ }
+ 
+ static inline struct nft_userdata *nft_set_ext_userdata(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_USERDATA);
+ }
+ 
+ static inline bool nft_set_elem_expired(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION) &&
+ 	       time_is_before_eq_jiffies(*nft_set_ext_expiration(ext));
+ }
+ 
+ static inline struct nft_set_ext *nft_set_elem_ext(const struct nft_set *set,
+ 						   void *elem)
+ {
+ 	return elem + set->ops->elemsize;
+ }
+ 
+ void *nft_set_elem_init(const struct nft_set *set,
+ 			const struct nft_set_ext_tmpl *tmpl,
+ 			const struct nft_data *key,
+ 			const struct nft_data *data,
+ 			u64 timeout, gfp_t gfp);
+ void nft_set_elem_destroy(const struct nft_set *set, void *elem);
+ 
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
  /**
   *	struct nft_set_gc_batch_head - nf_tables set garbage collection batch
   *
diff --cc include/uapi/linux/netfilter/nf_tables.h
index 971d245e7378,05ee1e0804a3..000000000000
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@@ -290,12 -290,18 +290,24 @@@ enum nft_set_elem_flags 
   * @NFTA_SET_ELEM_KEY: key value (NLA_NESTED: nft_data)
   * @NFTA_SET_ELEM_DATA: data value of mapping (NLA_NESTED: nft_data_attributes)
   * @NFTA_SET_ELEM_FLAGS: bitmask of nft_set_elem_flags (NLA_U32)
++<<<<<<< HEAD
++=======
+  * @NFTA_SET_ELEM_TIMEOUT: timeout value (NLA_U64)
+  * @NFTA_SET_ELEM_EXPIRATION: expiration time (NLA_U64)
+  * @NFTA_SET_ELEM_USERDATA: user data (NLA_BINARY)
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
   */
  enum nft_set_elem_attributes {
  	NFTA_SET_ELEM_UNSPEC,
  	NFTA_SET_ELEM_KEY,
  	NFTA_SET_ELEM_DATA,
  	NFTA_SET_ELEM_FLAGS,
++<<<<<<< HEAD
++=======
+ 	NFTA_SET_ELEM_TIMEOUT,
+ 	NFTA_SET_ELEM_EXPIRATION,
+ 	NFTA_SET_ELEM_USERDATA,
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
  	__NFTA_SET_ELEM_MAX
  };
  #define NFTA_SET_ELEM_MAX	(__NFTA_SET_ELEM_MAX - 1)
diff --cc net/netfilter/nf_tables_api.c
index 399ca83793bb,0b96fa0d64b2..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -2858,6 -2864,18 +2858,21 @@@ const struct nft_set_ext_type nft_set_e
  		.len	= sizeof(u8),
  		.align	= __alignof__(u8),
  	},
++<<<<<<< HEAD
++=======
+ 	[NFT_SET_EXT_TIMEOUT]		= {
+ 		.len	= sizeof(u64),
+ 		.align	= __alignof__(u64),
+ 	},
+ 	[NFT_SET_EXT_EXPIRATION]	= {
+ 		.len	= sizeof(unsigned long),
+ 		.align	= __alignof__(unsigned long),
+ 	},
+ 	[NFT_SET_EXT_USERDATA]		= {
+ 		.len	= sizeof(struct nft_userdata),
+ 		.align	= __alignof__(struct nft_userdata),
+ 	},
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
  };
  EXPORT_SYMBOL_GPL(nft_set_ext_types);
  
@@@ -2869,6 -2887,9 +2884,12 @@@ static const struct nla_policy nft_set_
  	[NFTA_SET_ELEM_KEY]		= { .type = NLA_NESTED },
  	[NFTA_SET_ELEM_DATA]		= { .type = NLA_NESTED },
  	[NFTA_SET_ELEM_FLAGS]		= { .type = NLA_U32 },
++<<<<<<< HEAD
++=======
+ 	[NFTA_SET_ELEM_TIMEOUT]		= { .type = NLA_U64 },
+ 	[NFTA_SET_ELEM_USERDATA]	= { .type = NLA_BINARY,
+ 					    .len = NFT_USERDATA_MAXLEN },
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
  };
  
  static const struct nla_policy nft_set_elem_list_policy[NFTA_SET_ELEM_LIST_MAX + 1] = {
@@@ -2925,10 -2946,39 +2946,19 @@@ static int nf_tables_fill_setelem(struc
  			  set->dlen) < 0)
  		goto nla_put_failure;
  
 -	if (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&
 -	    nla_put_be32(skb, NFTA_SET_ELEM_FLAGS,
 -		         htonl(*nft_set_ext_flags(ext))))
 -		goto nla_put_failure;
 -
 -	if (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT) &&
 -	    nla_put_be64(skb, NFTA_SET_ELEM_TIMEOUT,
 -			 cpu_to_be64(*nft_set_ext_timeout(ext))))
 -		goto nla_put_failure;
 -
 -	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {
 -		unsigned long expires, now = jiffies;
 -
 -		expires = *nft_set_ext_expiration(ext);
 -		if (time_before(now, expires))
 -			expires -= now;
 -		else
 -			expires = 0;
 -
 -		if (nla_put_be64(skb, NFTA_SET_ELEM_EXPIRATION,
 -				 cpu_to_be64(jiffies_to_msecs(expires))))
 +	if (elem->flags != 0)
 +		if (nla_put_be32(skb, NFTA_SET_ELEM_FLAGS, htonl(elem->flags)))
  			goto nla_put_failure;
 -	}
  
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {
+ 		struct nft_userdata *udata;
+ 
+ 		udata = nft_set_ext_userdata(ext);
+ 		if (nla_put(skb, NFTA_SET_ELEM_USERDATA,
+ 			    udata->len + 1, udata->data))
+ 			goto nla_put_failure;
+ 	}
+ 
  	nla_nest_end(skb, nest);
  	return 0;
  
@@@ -3152,15 -3243,19 +3182,25 @@@ static int nft_add_set_elem(struct nft_
  {
  	struct nlattr *nla[NFTA_SET_ELEM_MAX + 1];
  	struct nft_data_desc d1, d2;
 -	struct nft_set_ext_tmpl tmpl;
 -	struct nft_set_ext *ext;
  	struct nft_set_elem elem;
  	struct nft_set_binding *binding;
++<<<<<<< HEAD
 +	enum nft_registers dreg;
 +	struct nft_trans *trans;
++=======
+ 	struct nft_userdata *udata;
+ 	struct nft_data data;
+ 	enum nft_registers dreg;
+ 	struct nft_trans *trans;
+ 	u64 timeout;
+ 	u32 flags;
+ 	u8 ulen;
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
  	int err;
  
 +	if (set->size && set->nelems == set->size)
 +		return -ENFILE;
 +
  	err = nla_parse_nested(nla, NFTA_SET_ELEM_MAX, attr,
  			       nft_set_elem_policy);
  	if (err < 0)
@@@ -3227,15 -3338,45 +3267,45 @@@
  			if (err < 0)
  				goto err3;
  		}
 -
 -		nft_set_ext_add(&tmpl, NFT_SET_EXT_DATA);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* The full maximum length of userdata can exceed the maximum
+ 	 * offset value (U8_MAX) for following extensions, therefor it
+ 	 * must be the last extension added.
+ 	 */
+ 	ulen = 0;
+ 	if (nla[NFTA_SET_ELEM_USERDATA] != NULL) {
+ 		ulen = nla_len(nla[NFTA_SET_ELEM_USERDATA]);
+ 		if (ulen > 0)
+ 			nft_set_ext_add_length(&tmpl, NFT_SET_EXT_USERDATA,
+ 					       ulen);
+ 	}
+ 
+ 	err = -ENOMEM;
+ 	elem.priv = nft_set_elem_init(set, &tmpl, &elem.key, &data,
+ 				      timeout, GFP_KERNEL);
+ 	if (elem.priv == NULL)
+ 		goto err3;
+ 
+ 	ext = nft_set_elem_ext(set, elem.priv);
+ 	if (flags)
+ 		*nft_set_ext_flags(ext) = flags;
+ 	if (ulen > 0) {
+ 		udata = nft_set_ext_userdata(ext);
+ 		udata->len = ulen - 1;
+ 		nla_memcpy(&udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);
+ 	}
+ 
++>>>>>>> 68e942e88add (netfilter: nf_tables: support optional userdata for set elements)
  	trans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);
  	if (trans == NULL)
 -		goto err4;
 +		goto err3;
  
 -	ext->genmask = nft_genmask_cur(ctx->net) | NFT_SET_ELEM_BUSY_MASK;
  	err = set->ops->insert(set, &elem);
  	if (err < 0)
 -		goto err5;
 +		goto err4;
  
  	nft_trans_elem(trans) = elem;
  	list_add_tail(&trans->list, &ctx->net->nft.commit_list);
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
