s390/pci_dma: handle dma table failures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [s390] pci_dma: handle dma table failures (Hendrik Brueckner) [1330100]
Rebuild_FUZZ: 93.15%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 66728eeea6d80060e4b9df55c7845c838ff2799f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/66728eee.failed

We use lazy allocation for translation table entries but don't handle
allocation (and other) failures during translation table updates.

Handle these failures and undo translation table updates when it's
meaningful.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 66728eeea6d80060e4b9df55c7845c838ff2799f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci_dma.h
#	arch/s390/pci/pci_dma.c
#	drivers/iommu/s390-iommu.c
diff --cc arch/s390/include/asm/pci_dma.h
index 30b4c179c38c,1aac41e83ea1..000000000000
--- a/arch/s390/include/asm/pci_dma.h
+++ b/arch/s390/include/asm/pci_dma.h
@@@ -192,5 -192,10 +192,13 @@@ static inline unsigned long *get_st_pto
  /* Prototypes */
  int zpci_dma_init_device(struct zpci_dev *);
  void zpci_dma_exit_device(struct zpci_dev *);
++<<<<<<< HEAD
++=======
+ void dma_free_seg_table(unsigned long);
+ unsigned long *dma_alloc_cpu_table(void);
+ void dma_cleanup_tables(unsigned long *);
+ unsigned long *dma_walk_cpu_trans(unsigned long *rto, dma_addr_t dma_addr);
+ void dma_update_cpu_trans(unsigned long *entry, void *page_addr, int flags);
++>>>>>>> 66728eeea6d8 (s390/pci_dma: handle dma table failures)
  
  #endif
diff --cc arch/s390/pci/pci_dma.c
index 66b7fc6591c4,f137949c9abf..000000000000
--- a/arch/s390/pci/pci_dma.c
+++ b/arch/s390/pci/pci_dma.c
@@@ -114,17 -114,8 +114,22 @@@ unsigned long *dma_walk_cpu_trans(unsig
  	return &pto[px];
  }
  
++<<<<<<< HEAD
 +static void dma_update_cpu_trans(struct zpci_dev *zdev, void *page_addr,
 +				 dma_addr_t dma_addr, int flags)
 +{
 +	unsigned long *entry;
 +
 +	entry = dma_walk_cpu_trans(zdev->dma_table, dma_addr);
 +	if (!entry) {
 +		WARN_ON_ONCE(1);
 +		return;
 +	}
 +
++=======
+ void dma_update_cpu_trans(unsigned long *entry, void *page_addr, int flags)
+ {
++>>>>>>> 66728eeea6d8 (s390/pci_dma: handle dma table failures)
  	if (flags & ZPCI_PTE_INVALID) {
  		invalidate_pt_entry(entry);
  	} else {
@@@ -151,11 -143,18 +157,22 @@@ static int dma_update_trans(struct zpci
  		return -EINVAL;
  
  	spin_lock_irqsave(&zdev->dma_table_lock, irq_flags);
- 	if (!zdev->dma_table)
+ 	if (!zdev->dma_table) {
+ 		rc = -EINVAL;
  		goto no_refresh;
+ 	}
  
  	for (i = 0; i < nr_pages; i++) {
++<<<<<<< HEAD
 +		dma_update_cpu_trans(zdev, page_addr, dma_addr, flags);
++=======
+ 		entry = dma_walk_cpu_trans(zdev->dma_table, dma_addr);
+ 		if (!entry) {
+ 			rc = -ENOMEM;
+ 			goto undo_cpu_trans;
+ 		}
+ 		dma_update_cpu_trans(entry, page_addr, flags);
++>>>>>>> 66728eeea6d8 (s390/pci_dma: handle dma table failures)
  		page_addr += PAGE_SIZE;
  		dma_addr += PAGE_SIZE;
  	}
* Unmerged path drivers/iommu/s390-iommu.c
* Unmerged path arch/s390/include/asm/pci_dma.h
* Unmerged path arch/s390/pci/pci_dma.c
* Unmerged path drivers/iommu/s390-iommu.c
