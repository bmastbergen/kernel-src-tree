drivers:hv: Allow for MMIO claims that span ACPI _CRS records

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] Allow for MMIO claims that span ACPI _CRS records (Vitaly Kuznetsov) [1302147]
Rebuild_FUZZ: 89.09%
commit-author Jake Oshins <jakeo@microsoft.com>
commit 40f26f3168bf7a4da490db308dc0bd9f9923f41f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/40f26f31.failed

This patch makes 16GB GPUs work in Hyper-V VMs, since, for
compatibility reasons, the Hyper-V BIOS lists MMIO ranges in 2GB
chunks in its root bus's _CRS object.

	Signed-off-by: Jake Oshins <jakeo@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 40f26f3168bf7a4da490db308dc0bd9f9923f41f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index 7882a259dbd0,328e4c3808e0..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -1037,10 -1034,69 +1037,67 @@@ static acpi_status vmbus_walk_resources
  		break;
  
  	case ACPI_RESOURCE_TYPE_ADDRESS64:
 -		start = res->data.address64.address.minimum;
 -		end = res->data.address64.address.maximum;
 +		hyperv_mmio.start = res->data.address64.minimum;
 +		hyperv_mmio.end = res->data.address64.maximum;
  		break;
 -
 -	default:
 -		/* Unused resource type */
 -		return AE_OK;
 -
  	}
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Ignore ranges that are below 1MB, as they're not
+ 	 * necessary or useful here.
+ 	 */
+ 	if (end < 0x100000)
+ 		return AE_OK;
+ 
+ 	new_res = kzalloc(sizeof(*new_res), GFP_ATOMIC);
+ 	if (!new_res)
+ 		return AE_NO_MEMORY;
+ 
+ 	/* If this range overlaps the virtual TPM, truncate it. */
+ 	if (end > VTPM_BASE_ADDRESS && start < VTPM_BASE_ADDRESS)
+ 		end = VTPM_BASE_ADDRESS;
+ 
+ 	new_res->name = "hyperv mmio";
+ 	new_res->flags = IORESOURCE_MEM;
+ 	new_res->start = start;
+ 	new_res->end = end;
+ 
+ 	/*
+ 	 * Stick ranges from higher in address space at the front of the list.
+ 	 * If two ranges are adjacent, merge them.
+ 	 */
+ 	do {
+ 		if (!*old_res) {
+ 			*old_res = new_res;
+ 			break;
+ 		}
+ 
+ 		if (((*old_res)->end + 1) == new_res->start) {
+ 			(*old_res)->end = new_res->end;
+ 			kfree(new_res);
+ 			break;
+ 		}
+ 
+ 		if ((*old_res)->start == new_res->end + 1) {
+ 			(*old_res)->start = new_res->start;
+ 			kfree(new_res);
+ 			break;
+ 		}
+ 
+ 		if ((*old_res)->end < new_res->start) {
+ 			new_res->sibling = *old_res;
+ 			if (prev_res)
+ 				(*prev_res)->sibling = new_res;
+ 			*old_res = new_res;
+ 			break;
+ 		}
+ 
+ 		prev_res = old_res;
+ 		old_res = &(*old_res)->sibling;
+ 
+ 	} while (1);
++>>>>>>> 40f26f3168bf (drivers:hv: Allow for MMIO claims that span ACPI _CRS records)
  
  	return AE_OK;
  }
* Unmerged path drivers/hv/vmbus_drv.c
