mei: get rid of most of the pci dependencies in mei

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 2bf94cabb199f73402a5ddefa4a7bf1a82aaeda5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2bf94cab.failed

For purpose of adding testing HW we would like
to get rid of pci dependency in generic mei code
This patch provides only straight forward changes
FW status and prob quirks need to be handled separately

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2bf94cabb199f73402a5ddefa4a7bf1a82aaeda5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/hw-txe.c
#	drivers/misc/mei/main.c
#	drivers/misc/mei/nfc.c
#	drivers/misc/mei/pci-me.c
#	drivers/misc/mei/wd.c
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,5d47d1b36ccf..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -76,10 -76,9 +76,16 @@@ int mei_amthif_host_init(struct mei_dev
  
  	mei_cl_init(cl, dev);
  
++<<<<<<< HEAD
 +	i = mei_me_cl_by_uuid(dev, &mei_amthif_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev,
 +			"amthif: failed to find the client %d\n", i);
++=======
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_amthif_guid);
+ 	if (!me_cl) {
+ 		dev_info(dev->dev, "amthif: failed to find the client");
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		return -ENOTTY;
  	}
  
@@@ -87,9 -87,8 +93,14 @@@
  
  	/* Assign iamthif_mtu to the value received from ME  */
  
++<<<<<<< HEAD
 +	dev->iamthif_mtu = dev->me_clients[i].props.max_msg_length;
 +	dev_dbg(&dev->pdev->dev, "IAMTHIF_MTU = %d\n",
 +			dev->me_clients[i].props.max_msg_length);
++=======
+ 	dev->iamthif_mtu = me_cl->props.max_msg_length;
+ 	dev_dbg(dev->dev, "IAMTHIF_MTU = %d\n", dev->iamthif_mtu);
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  
  	kfree(dev->iamthif_msg_buf);
  	dev->iamthif_msg_buf = NULL;
@@@ -169,12 -168,7 +180,16 @@@ int mei_amthif_read(struct mei_device *
  		return -ETIME;
  	}
  
++<<<<<<< HEAD
 +	i = mei_me_cl_by_id(dev, dev->iamthif_cl.me_client_id);
 +	if (i < 0) {
 +		dev_dbg(&dev->pdev->dev, "amthif client not found.\n");
 +		return -ENOTTY;
 +	}
 +	dev_dbg(&dev->pdev->dev, "checking amthif data\n");
++=======
+ 	dev_dbg(dev->dev, "checking amthif data\n");
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  	cb = mei_amthif_find_read_list_entry(dev, file);
  
  	/* Check for if we can block or not*/
diff --cc drivers/misc/mei/hbm.c
index e04f10ba9aa2,209650bccf57..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -214,7 -248,7 +214,11 @@@ int mei_hbm_start_wait(struct mei_devic
  
  	if (ret == 0 && (dev->hbm_state <= MEI_HBM_STARTING)) {
  		dev->hbm_state = MEI_HBM_IDLE;
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev, "wating for mei start failed\n");
++=======
+ 		dev_err(dev->dev, "waiting for mei start failed\n");
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		return -ETIME;
  	}
  	return 0;
@@@ -427,25 -483,20 +431,40 @@@ static int mei_hbm_add_single_flow_cred
  				  struct hbm_flow_control *flow)
  {
  	struct mei_me_client *me_cl;
 +	int id;
  
++<<<<<<< HEAD
 +	id = mei_me_cl_by_id(dev, flow->me_addr);
 +	if (id < 0) {
 +		dev_err(&dev->pdev->dev, "no such me client %d\n",
++=======
+ 	me_cl = mei_me_cl_by_id(dev, flow->me_addr);
+ 	if (!me_cl) {
+ 		dev_err(dev->dev, "no such me client %d\n",
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  			flow->me_addr);
 -		return -ENOENT;
 +		return id;
  	}
  
++<<<<<<< HEAD
 +	me_cl = &dev->me_clients[id];
 +	if (me_cl->props.single_recv_buf) {
 +		me_cl->mei_flow_ctrl_creds++;
 +		dev_dbg(&dev->pdev->dev, "recv flow ctrl msg ME %d (single).\n",
 +		    flow->me_addr);
 +		dev_dbg(&dev->pdev->dev, "flow control credentials =%d.\n",
 +		    me_cl->mei_flow_ctrl_creds);
 +	} else {
 +		BUG();	/* error in flow control */
 +	}
++=======
+ 	if (WARN_ON(me_cl->props.single_recv_buf == 0))
+ 		return -EINVAL;
+ 
+ 	me_cl->mei_flow_ctrl_creds++;
+ 	dev_dbg(dev->dev, "recv flow ctrl msg ME %d (single) creds = %d.\n",
+ 	    flow->me_addr, me_cl->mei_flow_ctrl_creds);
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  
  	return 0;
  }
@@@ -806,6 -849,13 +825,16 @@@ int mei_hbm_dispatch(struct mei_device 
  		dev->pg_event = MEI_PG_EVENT_RECEIVED;
  		if (waitqueue_active(&dev->wait_pg))
  			wake_up(&dev->wait_pg);
++<<<<<<< HEAD
++=======
+ 		else
+ 			/*
+ 			* If the driver is not waiting on this then
+ 			* this is HW initiated exit from PG.
+ 			* Start runtime pm resume sequence to exit from PG.
+ 			*/
+ 			pm_request_resume(dev->dev);
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		break;
  
  	case HOST_CLIENT_PROPERTIES_RES_CMD:
@@@ -813,34 -863,24 +842,48 @@@
  
  		dev->init_clients_timer = 0;
  
 +		if (dev->me_clients == NULL) {
 +			dev_err(&dev->pdev->dev, "hbm: properties response: mei_clients not allocated\n");
 +			return -EPROTO;
 +		}
 +
 +		props_res = (struct hbm_props_response *)mei_msg;
 +		me_client = &dev->me_clients[dev->me_client_presentation_num];
 +
 +		if (props_res->status) {
 +			dev_err(&dev->pdev->dev, "hbm: properties response: wrong status = %d\n",
 +				props_res->status);
 +			return -EPROTO;
 +		}
 +
 +		if (me_client->client_id != props_res->me_addr) {
 +			dev_err(&dev->pdev->dev, "hbm: properties response: address mismatch %d ?= %d\n",
 +				me_client->client_id, props_res->me_addr);
 +			return -EPROTO;
 +		}
 +
  		if (dev->dev_state != MEI_DEV_INIT_CLIENTS ||
  		    dev->hbm_state != MEI_HBM_CLIENT_PROPERTIES) {
- 			dev_err(&dev->pdev->dev, "hbm: properties response: state mismatch, [%d, %d]\n",
+ 			dev_err(dev->dev, "hbm: properties response: state mismatch, [%d, %d]\n",
  				dev->dev_state, dev->hbm_state);
  			return -EPROTO;
  		}
  
++<<<<<<< HEAD
 +		me_client->props = props_res->client_properties;
++=======
+ 		props_res = (struct hbm_props_response *)mei_msg;
+ 
+ 		if (props_res->status) {
+ 			dev_err(dev->dev, "hbm: properties response: wrong status = %d %s\n",
+ 				props_res->status,
+ 				mei_hbm_status_str(props_res->status));
+ 			return -EPROTO;
+ 		}
+ 
+ 		mei_hbm_me_cl_add(dev, props_res);
+ 
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		dev->me_client_index++;
  		dev->me_client_presentation_num++;
  
diff --cc drivers/misc/mei/hw-txe.c
index f1cd166094f2,acc475eec150..000000000000
--- a/drivers/misc/mei/hw-txe.c
+++ b/drivers/misc/mei/hw-txe.c
@@@ -621,8 -636,9 +621,8 @@@ static int mei_txe_write(struct mei_dev
  
  	if (!mei_txe_is_input_ready(dev)) {
  		struct mei_fw_status fw_status;
 -
  		mei_fw_status(dev, &fw_status);
- 		dev_err(&dev->pdev->dev, "Input is not ready " FW_STS_FMT "\n",
+ 		dev_err(dev->dev, "Input is not ready " FW_STS_FMT "\n",
  			FW_STS_PRM(fw_status));
  		return -EAGAIN;
  	}
@@@ -719,14 -737,16 +719,26 @@@ static int mei_txe_read(struct mei_devi
  	if (WARN_ON(!buf || !len))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev,
 +		"buffer-length = %lu buf[0]0x%08X\n",
++=======
+ 	reg_buf = (u32 *)buf;
+ 	rem = len & 0x3;
+ 
+ 	dev_dbg(dev->dev, "buffer-length = %lu buf[0]0x%08X\n",
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		len, mei_txe_out_data_read(dev, 0));
  
  	for (i = 0; i < len / 4; i++) {
  		/* skip header: index starts from 1 */
++<<<<<<< HEAD
 +		u32 reg = mei_txe_out_data_read(dev, i + 1);
 +		dev_dbg(&dev->pdev->dev, "buf[%d] = 0x%08X\n", i, reg);
++=======
+ 		reg = mei_txe_out_data_read(dev, i + 1);
+ 		dev_dbg(dev->dev, "buf[%d] = 0x%08X\n", i, reg);
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		*reg_buf++ = reg;
  	}
  
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,4d738c881878..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -479,22 -446,23 +479,35 @@@ static int mei_ioctl_connect_client(str
  	}
  
  	/* find ME client we're trying to connect to */
++<<<<<<< HEAD
 +	i = mei_me_cl_by_uuid(dev, &data->in_client_uuid);
 +	if (i < 0 || dev->me_clients[i].props.fixed_address) {
 +		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
++=======
+ 	me_cl = mei_me_cl_by_uuid(dev, &data->in_client_uuid);
+ 	if (!me_cl || me_cl->props.fixed_address) {
+ 		dev_dbg(dev->dev, "Cannot connect to FW Client UUID = %pUl\n",
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  				&data->in_client_uuid);
  		rets = -ENOTTY;
  		goto end;
  	}
  
 -	cl->me_client_id = me_cl->client_id;
 -	cl->cl_uuid = me_cl->props.protocol_name;
 +	cl->me_client_id = dev->me_clients[i].client_id;
  
- 	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
+ 	dev_dbg(dev->dev, "Connect to FW Client ID = %d\n",
  			cl->me_client_id);
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
 +			dev->me_clients[i].props.protocol_version);
 +	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
 +			dev->me_clients[i].props.max_msg_length);
++=======
+ 	dev_dbg(dev->dev, "FW Client - Protocol Version = %d\n",
+ 			me_cl->props.protocol_version);
+ 	dev_dbg(dev->dev, "FW Client - Max Msg Len = %d\n",
+ 			me_cl->props.max_msg_length);
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  
  	/* if we're connecting to amthif client then we will use the
  	 * existing connection
@@@ -525,9 -491,9 +538,15 @@@
  
  	/* prepare the output buffer */
  	client = &data->out_client_properties;
++<<<<<<< HEAD
 +	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
 +	client->protocol_version = dev->me_clients[i].props.protocol_version;
 +	dev_dbg(&dev->pdev->dev, "Can connect?\n");
++=======
+ 	client->max_msg_length = me_cl->props.max_msg_length;
+ 	client->protocol_version = me_cl->props.protocol_version;
+ 	dev_dbg(dev->dev, "Can connect?\n");
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  
  
  	rets = mei_cl_connect(cl, file);
@@@ -683,28 -649,93 +702,62 @@@ static const struct file_operations mei
  	.llseek = no_llseek
  };
  
 -static struct class *mei_class;
 -static dev_t mei_devt;
 -#define MEI_MAX_DEVS  MINORMASK
 -static DEFINE_MUTEX(mei_minor_lock);
 -static DEFINE_IDR(mei_idr);
 -
 -/**
 - * mei_minor_get - obtain next free device minor number
 - *
 - * @dev:  device pointer
 - *
 - * returns allocated minor, or -ENOSPC if no free minor left
 +/*
 + * Misc Device Struct
   */
 -static int mei_minor_get(struct mei_device *dev)
 +static struct miscdevice  mei_misc_device = {
 +		.name = "mei",
 +		.fops = &mei_fops,
 +		.minor = MISC_DYNAMIC_MINOR,
 +};
 +
 +
 +int mei_register(struct mei_device *dev)
  {
  	int ret;
++<<<<<<< HEAD
 +	mei_misc_device.parent = &dev->pdev->dev;
 +	ret = misc_register(&mei_misc_device);
 +	if (ret)
++=======
+ 
+ 	mutex_lock(&mei_minor_lock);
+ 	ret = idr_alloc(&mei_idr, dev, 0, MEI_MAX_DEVS, GFP_KERNEL);
+ 	if (ret >= 0)
+ 		dev->minor = ret;
+ 	else if (ret == -ENOSPC)
+ 		dev_err(dev->dev, "too many mei devices\n");
+ 
+ 	mutex_unlock(&mei_minor_lock);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_minor_free - mark device minor number as free
+  *
+  * @dev:  device pointer
+  */
+ static void mei_minor_free(struct mei_device *dev)
+ {
+ 	mutex_lock(&mei_minor_lock);
+ 	idr_remove(&mei_idr, dev->minor);
+ 	mutex_unlock(&mei_minor_lock);
+ }
+ 
+ int mei_register(struct mei_device *dev, struct device *parent)
+ {
+ 	struct device *clsdev; /* class device */
+ 	int ret, devno;
+ 
+ 	ret = mei_minor_get(dev);
+ 	if (ret < 0)
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		return ret;
  
 -	/* Fill in the data structures */
 -	devno = MKDEV(MAJOR(mei_devt), dev->minor);
 -	cdev_init(&dev->cdev, &mei_fops);
 -	dev->cdev.owner = mei_fops.owner;
 -
 -	/* Add the device */
 -	ret = cdev_add(&dev->cdev, devno, 1);
 -	if (ret) {
 -		dev_err(parent, "unable to add device %d:%d\n",
 -			MAJOR(mei_devt), dev->minor);
 -		goto err_dev_add;
 -	}
 -
 -	clsdev = device_create(mei_class, parent, devno,
 -			 NULL, "mei%d", dev->minor);
 -
 -	if (IS_ERR(clsdev)) {
 -		dev_err(parent, "unable to create device %d:%d\n",
 -			MAJOR(mei_devt), dev->minor);
 -		ret = PTR_ERR(clsdev);
 -		goto err_dev_create;
 -	}
 -
 -	ret = mei_dbgfs_register(dev, dev_name(clsdev));
 -	if (ret) {
 -		dev_err(clsdev, "cannot register debugfs ret = %d\n", ret);
 -		goto err_dev_dbgfs;
 -	}
 +	if (mei_dbgfs_register(dev, mei_misc_device.name))
 +		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
  
  	return 0;
 -
 -err_dev_dbgfs:
 -	device_destroy(mei_class, devno);
 -err_dev_create:
 -	cdev_del(&dev->cdev);
 -err_dev_add:
 -	mei_minor_free(dev);
 -	return ret;
  }
  EXPORT_SYMBOL_GPL(mei_register);
  
diff --cc drivers/misc/mei/nfc.c
index 2b65e8021f0d,9f32fd6eaccf..000000000000
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@@ -498,9 -493,9 +493,15 @@@ int mei_nfc_host_init(struct mei_devic
  	}
  
  	/* check for valid client id */
++<<<<<<< HEAD
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_info_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
++=======
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_nfc_info_guid);
+ 	if (!me_cl) {
+ 		dev_info(dev->dev, "nfc: failed to find the client\n");
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		ret = -ENOTTY;
  		goto err;
  	}
@@@ -516,9 -511,9 +517,15 @@@
  	list_add_tail(&cl_info->device_link, &dev->device_list);
  
  	/* check for valid client id */
++<<<<<<< HEAD
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
++=======
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
+ 	if (!me_cl) {
+ 		dev_info(dev->dev, "nfc: failed to find the client\n");
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		ret = -ENOTTY;
  		goto err;
  	}
diff --cc drivers/misc/mei/pci-me.c
index 1eebd0f6a9f0,83e88920f738..000000000000
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@@ -346,8 -355,116 +346,120 @@@ static int mei_me_pci_resume(struct dev
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_PM_SLEEP */
+ 
+ #ifdef CONFIG_PM_RUNTIME
+ static int mei_me_pm_runtime_idle(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime_idle\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 	if (mei_write_is_idle(dev))
+ 		pm_runtime_autosuspend(device);
+ 
+ 	return -EBUSY;
+ }
+ 
+ static int mei_me_pm_runtime_suspend(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime suspend\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (mei_write_is_idle(dev))
+ 		ret = mei_me_pg_set_sync(dev);
+ 	else
+ 		ret = -EAGAIN;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime suspend ret=%d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ static int mei_me_pm_runtime_resume(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime resume\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	ret = mei_me_pg_unset_sync(dev);
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime resume ret = %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_set_pm_domain - fill and set pm domian stucture for device
+  *
+  * @dev: mei_device
+  */
+ static inline void mei_me_set_pm_domain(struct mei_device *dev)
+ {
+ 	struct pci_dev *pdev  = dev->pdev;
+ 
+ 	if (pdev->dev.bus && pdev->dev.bus->pm) {
+ 		dev->pg_domain.ops = *pdev->dev.bus->pm;
+ 
+ 		dev->pg_domain.ops.runtime_suspend = mei_me_pm_runtime_suspend;
+ 		dev->pg_domain.ops.runtime_resume = mei_me_pm_runtime_resume;
+ 		dev->pg_domain.ops.runtime_idle = mei_me_pm_runtime_idle;
+ 
+ 		pdev->dev.pm_domain = &dev->pg_domain;
+ 	}
+ }
+ 
+ /**
+  * mei_me_unset_pm_domain - clean pm domian stucture for device
+  *
+  * @dev: mei_device
+  */
+ static inline void mei_me_unset_pm_domain(struct mei_device *dev)
+ {
+ 	/* stop using pm callbacks if any */
+ 	dev->dev->pm_domain = NULL;
+ }
+ #endif /* CONFIG_PM_RUNTIME */
+ 
+ #ifdef CONFIG_PM
+ static const struct dev_pm_ops mei_me_pm_ops = {
+ 	SET_SYSTEM_SLEEP_PM_OPS(mei_me_pci_suspend,
+ 				mei_me_pci_resume)
+ 	SET_RUNTIME_PM_OPS(
+ 		mei_me_pm_runtime_suspend,
+ 		mei_me_pm_runtime_resume,
+ 		mei_me_pm_runtime_idle)
+ };
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  
 +static SIMPLE_DEV_PM_OPS(mei_me_pm_ops, mei_me_pci_suspend, mei_me_pci_resume);
  #define MEI_ME_PM_OPS	(&mei_me_pm_ops)
  #else
  #define MEI_ME_PM_OPS	NULL
diff --cc drivers/misc/mei/wd.c
index 1e4f4283f10e,d28511b78eaa..000000000000
--- a/drivers/misc/mei/wd.c
+++ b/drivers/misc/mei/wd.c
@@@ -75,9 -69,9 +75,15 @@@ int mei_wd_host_init(struct mei_device 
  
  
  	/* check for valid client id */
++<<<<<<< HEAD
 +	id = mei_me_cl_by_uuid(dev, &mei_wd_guid);
 +	if (id < 0) {
 +		dev_info(&dev->pdev->dev, "wd: failed to find the client\n");
++=======
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_wd_guid);
+ 	if (!me_cl) {
+ 		dev_info(dev->dev, "wd: failed to find the client\n");
++>>>>>>> 2bf94cabb199 (mei: get rid of most of the pci dependencies in mei)
  		return -ENOTTY;
  	}
  
* Unmerged path drivers/misc/mei/amthif.c
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index ca8736c3675b..fabaa8f0ba94 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -172,7 +172,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 	device->cl = cl;
 	device->ops = ops;
 
-	device->dev.parent = &dev->pdev->dev;
+	device->dev.parent = dev->dev;
 	device->dev.bus = &mei_cl_bus_type;
 	device->dev.type = &mei_cl_device_type;
 
@@ -180,7 +180,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 
 	status = device_register(&device->dev);
 	if (status) {
-		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
+		dev_err(dev->dev, "Failed to register MEI device\n");
 		kfree(device);
 		return NULL;
 	}
@@ -430,7 +430,7 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 	err = mei_cl_connect(cl, NULL);
 	if (err < 0) {
 		mutex_unlock(&dev->device_lock);
-		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
+		dev_err(dev->dev, "Could not connect to the ME client");
 
 		return err;
 	}
@@ -462,7 +462,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 
 	if (cl->state != MEI_FILE_CONNECTED) {
 		mutex_unlock(&dev->device_lock);
-		dev_err(&dev->pdev->dev, "Already disconnected");
+		dev_err(dev->dev, "Already disconnected");
 
 		return 0;
 	}
@@ -472,7 +472,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 	err = mei_cl_disconnect(cl);
 	if (err < 0) {
 		mutex_unlock(&dev->device_lock);
-		dev_err(&dev->pdev->dev,
+		dev_err(dev->dev,
 			"Could not disconnect from the ME client");
 
 		return err;
diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index 22a9268f24eb..c90df9e3acbd 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -331,13 +331,13 @@ int mei_cl_link(struct mei_cl *cl, int id)
 					MEI_CLIENTS_MAX);
 
 	if (id >= MEI_CLIENTS_MAX) {
-		dev_err(&dev->pdev->dev, "id exceeded %d", MEI_CLIENTS_MAX);
+		dev_err(dev->dev, "id exceeded %d", MEI_CLIENTS_MAX);
 		return -EMFILE;
 	}
 
 	open_handle_count = dev->open_handle_count + dev->iamthif_open_count;
 	if (open_handle_count >= MEI_MAX_OPEN_HANDLE_COUNT) {
-		dev_err(&dev->pdev->dev, "open_handle_count exceeded %d",
+		dev_err(dev->dev, "open_handle_count exceeded %d",
 			MEI_MAX_OPEN_HANDLE_COUNT);
 		return -EMFILE;
 	}
@@ -417,9 +417,9 @@ void mei_host_client_init(struct work_struct *work)
 
 	mutex_unlock(&dev->device_lock);
 
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
-	pm_runtime_autosuspend(&dev->pdev->dev);
+	pm_runtime_mark_last_busy(dev->dev);
+	dev_dbg(dev->dev, "rpm: autosuspend\n");
+	pm_runtime_autosuspend(dev->dev);
 }
 
 /**
@@ -432,12 +432,12 @@ bool mei_hbuf_acquire(struct mei_device *dev)
 {
 	if (mei_pg_state(dev) == MEI_PG_ON ||
 	    dev->pg_event == MEI_PG_EVENT_WAIT) {
-		dev_dbg(&dev->pdev->dev, "device is in pg\n");
+		dev_dbg(dev->dev, "device is in pg\n");
 		return false;
 	}
 
 	if (!dev->hbuf_is_ready) {
-		dev_dbg(&dev->pdev->dev, "hbuf is not ready\n");
+		dev_dbg(dev->dev, "hbuf is not ready\n");
 		return false;
 	}
 
@@ -471,9 +471,9 @@ int mei_cl_disconnect(struct mei_cl *cl)
 	if (cl->state != MEI_FILE_DISCONNECTING)
 		return 0;
 
-	rets = pm_runtime_get(&dev->pdev->dev);
+	rets = pm_runtime_get(dev->dev);
 	if (rets < 0 && rets != -EINPROGRESS) {
-		pm_runtime_put_noidle(&dev->pdev->dev);
+		pm_runtime_put_noidle(dev->dev);
 		cl_err(dev, cl, "rpm: get failed %d\n", rets);
 		return rets;
 	}
@@ -520,8 +520,8 @@ int mei_cl_disconnect(struct mei_cl *cl)
 	mei_io_list_flush(&dev->ctrl_wr_list, cl);
 free:
 	cl_dbg(dev, cl, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
+	pm_runtime_mark_last_busy(dev->dev);
+	pm_runtime_put_autosuspend(dev->dev);
 
 	mei_io_cb_free(cb);
 	return rets;
@@ -577,9 +577,9 @@ int mei_cl_connect(struct mei_cl *cl, struct file *file)
 
 	dev = cl->dev;
 
-	rets = pm_runtime_get(&dev->pdev->dev);
+	rets = pm_runtime_get(dev->dev);
 	if (rets < 0 && rets != -EINPROGRESS) {
-		pm_runtime_put_noidle(&dev->pdev->dev);
+		pm_runtime_put_noidle(dev->dev);
 		cl_err(dev, cl, "rpm: get failed %d\n", rets);
 		return rets;
 	}
@@ -627,8 +627,8 @@ int mei_cl_connect(struct mei_cl *cl, struct file *file)
 
 out:
 	cl_dbg(dev, cl, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
+	pm_runtime_mark_last_busy(dev->dev);
+	pm_runtime_put_autosuspend(dev->dev);
 
 	mei_io_cb_free(cb);
 	return rets;
@@ -747,9 +747,9 @@ int mei_cl_read_start(struct mei_cl *cl, size_t length)
 		return  -ENOTTY;
 	}
 
-	rets = pm_runtime_get(&dev->pdev->dev);
+	rets = pm_runtime_get(dev->dev);
 	if (rets < 0 && rets != -EINPROGRESS) {
-		pm_runtime_put_noidle(&dev->pdev->dev);
+		pm_runtime_put_noidle(dev->dev);
 		cl_err(dev, cl, "rpm: get failed %d\n", rets);
 		return rets;
 	}
@@ -782,8 +782,8 @@ int mei_cl_read_start(struct mei_cl *cl, size_t length)
 
 out:
 	cl_dbg(dev, cl, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
+	pm_runtime_mark_last_busy(dev->dev);
+	pm_runtime_put_autosuspend(dev->dev);
 
 	if (rets)
 		mei_io_cb_free(cb);
@@ -904,9 +904,9 @@ int mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb, bool blocking)
 
 	cl_dbg(dev, cl, "mei_cl_write %d\n", buf->size);
 
-	rets = pm_runtime_get(&dev->pdev->dev);
+	rets = pm_runtime_get(dev->dev);
 	if (rets < 0 && rets != -EINPROGRESS) {
-		pm_runtime_put_noidle(&dev->pdev->dev);
+		pm_runtime_put_noidle(dev->dev);
 		cl_err(dev, cl, "rpm: get failed %d\n", rets);
 		return rets;
 	}
@@ -981,8 +981,8 @@ out:
 	rets = buf->size;
 err:
 	cl_dbg(dev, cl, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
+	pm_runtime_mark_last_busy(dev->dev);
+	pm_runtime_put_autosuspend(dev->dev);
 
 	return rets;
 }
diff --git a/drivers/misc/mei/client.h b/drivers/misc/mei/client.h
index bf2b0b1b493d..ff187b882ed0 100644
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@ -103,9 +103,9 @@ void mei_cl_all_write_clear(struct mei_device *dev);
 #define MEI_CL_PRM(cl) (cl)->host_client_id, (cl)->me_client_id
 
 #define cl_dbg(dev, cl, format, arg...) \
-	dev_dbg(&(dev)->pdev->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
+	dev_dbg((dev)->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
 
 #define cl_err(dev, cl, format, arg...) \
-	dev_err(&(dev)->pdev->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
+	dev_err((dev)->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
 
 #endif /* _MEI_CLIENT_H_ */
diff --git a/drivers/misc/mei/debugfs.c b/drivers/misc/mei/debugfs.c
index 85d1d2217fb8..c8c93808df6e 100644
--- a/drivers/misc/mei/debugfs.c
+++ b/drivers/misc/mei/debugfs.c
@@ -178,19 +178,19 @@ int mei_dbgfs_register(struct mei_device *dev, const char *name)
 	f = debugfs_create_file("meclients", S_IRUSR, dir,
 				dev, &mei_dbgfs_fops_meclients);
 	if (!f) {
-		dev_err(&dev->pdev->dev, "meclients: registration failed\n");
+		dev_err(dev->dev, "meclients: registration failed\n");
 		goto err;
 	}
 	f = debugfs_create_file("active", S_IRUSR, dir,
 				dev, &mei_dbgfs_fops_active);
 	if (!f) {
-		dev_err(&dev->pdev->dev, "meclients: registration failed\n");
+		dev_err(dev->dev, "meclients: registration failed\n");
 		goto err;
 	}
 	f = debugfs_create_file("devstate", S_IRUSR, dir,
 				dev, &mei_dbgfs_fops_devstate);
 	if (!f) {
-		dev_err(&dev->pdev->dev, "devstate: registration failed\n");
+		dev_err(dev->dev, "devstate: registration failed\n");
 		goto err;
 	}
 	dev->dbgfs_dir = dir;
* Unmerged path drivers/misc/mei/hbm.c
diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c
index 241eae550b0c..4369dbd1dfef 100644
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@ -213,10 +213,10 @@ static int mei_me_hw_reset(struct mei_device *dev, bool intr_enable)
 	hcsr = mei_hcsr_read(hw);
 
 	if ((hcsr & H_RST) == 0)
-		dev_warn(&dev->pdev->dev, "H_RST is not set = 0x%08X", hcsr);
+		dev_warn(dev->dev, "H_RST is not set = 0x%08X", hcsr);
 
 	if ((hcsr & H_RDY) == H_RDY)
-		dev_warn(&dev->pdev->dev, "H_RDY is not cleared 0x%08X", hcsr);
+		dev_warn(dev->dev, "H_RDY is not cleared 0x%08X", hcsr);
 
 	if (intr_enable == false)
 		mei_me_hw_reset_release(dev);
@@ -272,7 +272,7 @@ static int mei_me_hw_ready_wait(struct mei_device *dev)
 			mei_secs_to_jiffies(MEI_HW_READY_TIMEOUT));
 	mutex_lock(&dev->device_lock);
 	if (!dev->recvd_hw_ready) {
-		dev_err(&dev->pdev->dev, "wait hw ready failed\n");
+		dev_err(dev->dev, "wait hw ready failed\n");
 		return -ETIME;
 	}
 
@@ -285,7 +285,7 @@ static int mei_me_hw_start(struct mei_device *dev)
 	int ret = mei_me_hw_ready_wait(dev);
 	if (ret)
 		return ret;
-	dev_dbg(&dev->pdev->dev, "hw is ready\n");
+	dev_dbg(dev->dev, "hw is ready\n");
 
 	mei_me_host_set_ready(dev);
 	return ret;
@@ -373,10 +373,10 @@ static int mei_me_write_message(struct mei_device *dev,
 	int i;
 	int empty_slots;
 
-	dev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(header));
+	dev_dbg(dev->dev, MEI_HDR_FMT, MEI_HDR_PRM(header));
 
 	empty_slots = mei_hbuf_empty_slots(dev);
-	dev_dbg(&dev->pdev->dev, "empty slots = %hu.\n", empty_slots);
+	dev_dbg(dev->dev, "empty slots = %hu.\n", empty_slots);
 
 	dw_cnt = mei_data2slots(length);
 	if (empty_slots < 0 || dw_cnt > empty_slots)
@@ -425,7 +425,7 @@ static int mei_me_count_full_read_slots(struct mei_device *dev)
 	if (filled_slots > buffer_depth)
 		return -EOVERFLOW;
 
-	dev_dbg(&dev->pdev->dev, "filled_slots =%08x\n", filled_slots);
+	dev_dbg(dev->dev, "filled_slots =%08x\n", filled_slots);
 	return (int)filled_slots;
 }
 
@@ -580,7 +580,7 @@ static bool mei_me_pg_is_enabled(struct mei_device *dev)
 	return true;
 
 notsupported:
-	dev_dbg(&dev->pdev->dev, "pg: not supported: HGP = %d hbm version %d.%d ?= %d.%d\n",
+	dev_dbg(dev->dev, "pg: not supported: HGP = %d hbm version %d.%d ?= %d.%d\n",
 		!!(reg & ME_PGIC_HRA),
 		dev->version.major_version,
 		dev->version.minor_version,
@@ -631,7 +631,7 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 	s32 slots;
 	int rets = 0;
 
-	dev_dbg(&dev->pdev->dev, "function called after ISR to handle the interrupt processing.\n");
+	dev_dbg(dev->dev, "function called after ISR to handle the interrupt processing.\n");
 	/* initialize our complete list */
 	mutex_lock(&dev->device_lock);
 	mei_io_list_init(&complete_list);
@@ -643,7 +643,7 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 
 	/* check if ME wants a reset */
 	if (!mei_hw_is_ready(dev) && dev->dev_state != MEI_DEV_RESETTING) {
-		dev_warn(&dev->pdev->dev, "FW not ready: resetting.\n");
+		dev_warn(dev->dev, "FW not ready: resetting.\n");
 		schedule_work(&dev->reset_work);
 		goto end;
 	}
@@ -652,19 +652,19 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 	if (!mei_host_is_ready(dev)) {
 		if (mei_hw_is_ready(dev)) {
 			mei_me_hw_reset_release(dev);
-			dev_dbg(&dev->pdev->dev, "we need to start the dev.\n");
+			dev_dbg(dev->dev, "we need to start the dev.\n");
 
 			dev->recvd_hw_ready = true;
 			wake_up(&dev->wait_hw_ready);
 		} else {
-			dev_dbg(&dev->pdev->dev, "Spurious Interrupt\n");
+			dev_dbg(dev->dev, "Spurious Interrupt\n");
 		}
 		goto end;
 	}
 	/* check slots available for reading */
 	slots = mei_count_full_read_slots(dev);
 	while (slots > 0) {
-		dev_dbg(&dev->pdev->dev, "slots to read = %08x\n", slots);
+		dev_dbg(dev->dev, "slots to read = %08x\n", slots);
 		rets = mei_irq_read_handler(dev, &complete_list, &slots);
 		/* There is a race between ME write and interrupt delivery:
 		 * Not all data is always available immediately after the
@@ -674,7 +674,7 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 			break;
 
 		if (rets && dev->dev_state != MEI_DEV_RESETTING) {
-			dev_err(&dev->pdev->dev, "mei_irq_read_handler ret = %d.\n",
+			dev_err(dev->dev, "mei_irq_read_handler ret = %d.\n",
 						rets);
 			schedule_work(&dev->reset_work);
 			goto end;
@@ -696,7 +696,7 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 	mei_irq_compl_handler(dev, &complete_list);
 
 end:
-	dev_dbg(&dev->pdev->dev, "interrupt thread end ret = %d\n", rets);
+	dev_dbg(dev->dev, "interrupt thread end ret = %d\n", rets);
 	mutex_unlock(&dev->device_lock);
 	return IRQ_HANDLED;
 }
* Unmerged path drivers/misc/mei/hw-txe.c
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index 08331e745faf..af9cce1e559a 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -89,7 +89,7 @@ int mei_reset(struct mei_device *dev)
 	    state != MEI_DEV_POWER_UP) {
 		struct mei_fw_status fw_status;
 		mei_fw_status(dev, &fw_status);
-		dev_warn(&dev->pdev->dev,
+		dev_warn(dev->dev,
 			"unexpected reset: dev_state = %s " FW_STS_FMT "\n",
 			mei_dev_state_str(state), FW_STS_PRM(fw_status));
 	}
@@ -107,7 +107,7 @@ int mei_reset(struct mei_device *dev)
 
 	dev->reset_count++;
 	if (dev->reset_count > MEI_MAX_CONSEC_RESET) {
-		dev_err(&dev->pdev->dev, "reset: reached maximal consecutive resets: disabling the device\n");
+		dev_err(dev->dev, "reset: reached maximal consecutive resets: disabling the device\n");
 		dev->dev_state = MEI_DEV_DISABLED;
 		return -ENODEV;
 	}
@@ -128,7 +128,7 @@ int mei_reset(struct mei_device *dev)
 		mei_cl_all_wakeup(dev);
 
 		/* remove entry if already in list */
-		dev_dbg(&dev->pdev->dev, "remove iamthif and wd from the file list.\n");
+		dev_dbg(dev->dev, "remove iamthif and wd from the file list.\n");
 		mei_cl_unlink(&dev->wd_cl);
 		mei_cl_unlink(&dev->iamthif_cl);
 		mei_amthif_reset_params(dev);
@@ -140,28 +140,28 @@ int mei_reset(struct mei_device *dev)
 	dev->wd_pending = false;
 
 	if (ret) {
-		dev_err(&dev->pdev->dev, "hw_reset failed ret = %d\n", ret);
+		dev_err(dev->dev, "hw_reset failed ret = %d\n", ret);
 		return ret;
 	}
 
 	if (state == MEI_DEV_POWER_DOWN) {
-		dev_dbg(&dev->pdev->dev, "powering down: end of reset\n");
+		dev_dbg(dev->dev, "powering down: end of reset\n");
 		dev->dev_state = MEI_DEV_DISABLED;
 		return 0;
 	}
 
 	ret = mei_hw_start(dev);
 	if (ret) {
-		dev_err(&dev->pdev->dev, "hw_start failed ret = %d\n", ret);
+		dev_err(dev->dev, "hw_start failed ret = %d\n", ret);
 		return ret;
 	}
 
-	dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
+	dev_dbg(dev->dev, "link is established start sending messages.\n");
 
 	dev->dev_state = MEI_DEV_INIT_CLIENTS;
 	ret = mei_hbm_start_req(dev);
 	if (ret) {
-		dev_err(&dev->pdev->dev, "hbm_start failed ret = %d\n", ret);
+		dev_err(dev->dev, "hbm_start failed ret = %d\n", ret);
 		dev->dev_state = MEI_DEV_RESETTING;
 		return ret;
 	}
@@ -187,7 +187,7 @@ int mei_start(struct mei_device *dev)
 
 	mei_hw_config(dev);
 
-	dev_dbg(&dev->pdev->dev, "reset in start the mei device.\n");
+	dev_dbg(dev->dev, "reset in start the mei device.\n");
 
 	dev->reset_count = 0;
 	do {
@@ -195,43 +195,43 @@ int mei_start(struct mei_device *dev)
 		ret = mei_reset(dev);
 
 		if (ret == -ENODEV || dev->dev_state == MEI_DEV_DISABLED) {
-			dev_err(&dev->pdev->dev, "reset failed ret = %d", ret);
+			dev_err(dev->dev, "reset failed ret = %d", ret);
 			goto err;
 		}
 	} while (ret);
 
 	/* we cannot start the device w/o hbm start message completed */
 	if (dev->dev_state == MEI_DEV_DISABLED) {
-		dev_err(&dev->pdev->dev, "reset failed");
+		dev_err(dev->dev, "reset failed");
 		goto err;
 	}
 
 	if (mei_hbm_start_wait(dev)) {
-		dev_err(&dev->pdev->dev, "HBM haven't started");
+		dev_err(dev->dev, "HBM haven't started");
 		goto err;
 	}
 
 	if (!mei_host_is_ready(dev)) {
-		dev_err(&dev->pdev->dev, "host is not ready.\n");
+		dev_err(dev->dev, "host is not ready.\n");
 		goto err;
 	}
 
 	if (!mei_hw_is_ready(dev)) {
-		dev_err(&dev->pdev->dev, "ME is not ready.\n");
+		dev_err(dev->dev, "ME is not ready.\n");
 		goto err;
 	}
 
 	if (!mei_hbm_version_is_supported(dev)) {
-		dev_dbg(&dev->pdev->dev, "MEI start failed.\n");
+		dev_dbg(dev->dev, "MEI start failed.\n");
 		goto err;
 	}
 
-	dev_dbg(&dev->pdev->dev, "link layer has been established.\n");
+	dev_dbg(dev->dev, "link layer has been established.\n");
 
 	mutex_unlock(&dev->device_lock);
 	return 0;
 err:
-	dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
+	dev_err(dev->dev, "link layer initialization failed.\n");
 	dev->dev_state = MEI_DEV_DISABLED;
 	mutex_unlock(&dev->device_lock);
 	return -ENODEV;
@@ -261,7 +261,7 @@ int mei_restart(struct mei_device *dev)
 	mutex_unlock(&dev->device_lock);
 
 	if (err == -ENODEV || dev->dev_state == MEI_DEV_DISABLED) {
-		dev_err(&dev->pdev->dev, "device disabled = %d\n", err);
+		dev_err(dev->dev, "device disabled = %d\n", err);
 		return -ENODEV;
 	}
 
@@ -287,7 +287,7 @@ static void mei_reset_work(struct work_struct *work)
 	mutex_unlock(&dev->device_lock);
 
 	if (dev->dev_state == MEI_DEV_DISABLED) {
-		dev_err(&dev->pdev->dev, "device disabled = %d\n", ret);
+		dev_err(dev->dev, "device disabled = %d\n", ret);
 		return;
 	}
 
@@ -298,7 +298,7 @@ static void mei_reset_work(struct work_struct *work)
 
 void mei_stop(struct mei_device *dev)
 {
-	dev_dbg(&dev->pdev->dev, "stopping the device.\n");
+	dev_dbg(dev->dev, "stopping the device.\n");
 
 	mei_cancel_work(dev);
 
@@ -332,7 +332,7 @@ bool mei_write_is_idle(struct mei_device *dev)
 		list_empty(&dev->ctrl_wr_list.list) &&
 		list_empty(&dev->write_list.list));
 
-	dev_dbg(&dev->pdev->dev, "write pg: is idle[%d] state=%s ctrl=%d write=%d\n",
+	dev_dbg(dev->dev, "write pg: is idle[%d] state=%s ctrl=%d write=%d\n",
 		idle,
 		mei_dev_state_str(dev->dev_state),
 		list_empty(&dev->ctrl_wr_list.list),
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index b8d9cfee3e87..8dac76901130 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -47,7 +47,7 @@ void mei_irq_compl_handler(struct mei_device *dev, struct mei_cl_cb *compl_list)
 		if (!cl)
 			continue;
 
-		dev_dbg(&dev->pdev->dev, "completing call back.\n");
+		dev_dbg(dev->dev, "completing call back.\n");
 		if (cl == &dev->iamthif_cl)
 			mei_amthif_complete(dev, cb);
 		else
@@ -148,10 +148,10 @@ static int mei_cl_irq_read_msg(struct mei_device *dev,
 		break;
 	}
 
-	dev_dbg(&dev->pdev->dev, "message read\n");
+	dev_dbg(dev->dev, "message read\n");
 	if (!buffer) {
 		mei_read_slots(dev, dev->rd_msg_buf, mei_hdr->length);
-		dev_dbg(&dev->pdev->dev, "discarding message " MEI_HDR_FMT "\n",
+		dev_dbg(dev->dev, "discarding message " MEI_HDR_FMT "\n",
 				MEI_HDR_PRM(mei_hdr));
 	}
 
@@ -333,20 +333,20 @@ int mei_irq_read_handler(struct mei_device *dev,
 	if (!dev->rd_msg_hdr) {
 		dev->rd_msg_hdr = mei_read_hdr(dev);
 		(*slots)--;
-		dev_dbg(&dev->pdev->dev, "slots =%08x.\n", *slots);
+		dev_dbg(dev->dev, "slots =%08x.\n", *slots);
 	}
 	mei_hdr = (struct mei_msg_hdr *) &dev->rd_msg_hdr;
-	dev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(mei_hdr));
+	dev_dbg(dev->dev, MEI_HDR_FMT, MEI_HDR_PRM(mei_hdr));
 
 	if (mei_hdr->reserved || !dev->rd_msg_hdr) {
-		dev_err(&dev->pdev->dev, "corrupted message header 0x%08X\n",
+		dev_err(dev->dev, "corrupted message header 0x%08X\n",
 				dev->rd_msg_hdr);
 		ret = -EBADMSG;
 		goto end;
 	}
 
 	if (mei_slots2data(*slots) < mei_hdr->length) {
-		dev_err(&dev->pdev->dev, "less data available than length=%08x.\n",
+		dev_err(dev->dev, "less data available than length=%08x.\n",
 				*slots);
 		/* we can't read the message */
 		ret = -ENODATA;
@@ -357,7 +357,7 @@ int mei_irq_read_handler(struct mei_device *dev,
 	if (mei_hdr->host_addr == 0 && mei_hdr->me_addr == 0) {
 		ret = mei_hbm_dispatch(dev, mei_hdr);
 		if (ret) {
-			dev_dbg(&dev->pdev->dev, "mei_hbm_dispatch failed ret = %d\n",
+			dev_dbg(dev->dev, "mei_hbm_dispatch failed ret = %d\n",
 					ret);
 			goto end;
 		}
@@ -374,7 +374,7 @@ int mei_irq_read_handler(struct mei_device *dev,
 
 	/* if no recipient cl was found we assume corrupted header */
 	if (&cl->link == &dev->file_list) {
-		dev_err(&dev->pdev->dev, "no destination client found 0x%08X\n",
+		dev_err(dev->dev, "no destination client found 0x%08X\n",
 				dev->rd_msg_hdr);
 		ret = -EBADMSG;
 		goto end;
@@ -386,14 +386,14 @@ int mei_irq_read_handler(struct mei_device *dev,
 
 		ret = mei_amthif_irq_read_msg(dev, mei_hdr, cmpl_list);
 		if (ret) {
-			dev_err(&dev->pdev->dev, "mei_amthif_irq_read_msg failed = %d\n",
+			dev_err(dev->dev, "mei_amthif_irq_read_msg failed = %d\n",
 					ret);
 			goto end;
 		}
 	} else {
 		ret = mei_cl_irq_read_msg(dev, mei_hdr, cmpl_list);
 		if (ret) {
-			dev_err(&dev->pdev->dev, "mei_cl_irq_read_msg failed = %d\n",
+			dev_err(dev->dev, "mei_cl_irq_read_msg failed = %d\n",
 					ret);
 			goto end;
 		}
@@ -406,7 +406,7 @@ reset_slots:
 
 	if (*slots == -EOVERFLOW) {
 		/* overflow - reset */
-		dev_err(&dev->pdev->dev, "resetting due to slots overflow.\n");
+		dev_err(dev->dev, "resetting due to slots overflow.\n");
 		/* set the event since message has been read */
 		ret = -ERANGE;
 		goto end;
@@ -444,7 +444,7 @@ int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 		return -EMSGSIZE;
 
 	/* complete all waiting for write CB */
-	dev_dbg(&dev->pdev->dev, "complete all waiting for write cb.\n");
+	dev_dbg(dev->dev, "complete all waiting for write cb.\n");
 
 	list = &dev->write_waiting_list;
 	list_for_each_entry_safe(cb, next, &list->list, list) {
@@ -486,7 +486,7 @@ int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 	}
 
 	/* complete control write list CB */
-	dev_dbg(&dev->pdev->dev, "complete control write list cb.\n");
+	dev_dbg(dev->dev, "complete control write list cb.\n");
 	list_for_each_entry_safe(cb, next, &dev->ctrl_wr_list.list, list) {
 		cl = cb->cl;
 		if (!cl) {
@@ -527,7 +527,7 @@ int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 
 	}
 	/* complete  write list CB */
-	dev_dbg(&dev->pdev->dev, "complete write list cb.\n");
+	dev_dbg(dev->dev, "complete write list cb.\n");
 	list_for_each_entry_safe(cb, next, &dev->write_list.list, list) {
 		cl = cb->cl;
 		if (cl == NULL)
@@ -568,7 +568,7 @@ void mei_timer(struct work_struct *work)
 
 		if (dev->init_clients_timer) {
 			if (--dev->init_clients_timer == 0) {
-				dev_err(&dev->pdev->dev, "timer: init clients timeout hbm_state = %d.\n",
+				dev_err(dev->dev, "timer: init clients timeout hbm_state = %d.\n",
 					dev->hbm_state);
 				mei_reset(dev);
 				goto out;
@@ -583,7 +583,7 @@ void mei_timer(struct work_struct *work)
 	list_for_each_entry(cl, &dev->file_list, link) {
 		if (cl->timer_count) {
 			if (--cl->timer_count == 0) {
-				dev_err(&dev->pdev->dev, "timer: connect/disconnect timeout.\n");
+				dev_err(dev->dev, "timer: connect/disconnect timeout.\n");
 				mei_reset(dev);
 				goto out;
 			}
@@ -595,7 +595,7 @@ void mei_timer(struct work_struct *work)
 
 	if (dev->iamthif_stall_timer) {
 		if (--dev->iamthif_stall_timer == 0) {
-			dev_err(&dev->pdev->dev, "timer: amthif  hanged.\n");
+			dev_err(dev->dev, "timer: amthif  hanged.\n");
 			mei_reset(dev);
 			dev->iamthif_msg_buf_size = 0;
 			dev->iamthif_msg_buf_index = 0;
@@ -617,17 +617,17 @@ void mei_timer(struct work_struct *work)
 		timeout = dev->iamthif_timer +
 			mei_secs_to_jiffies(MEI_IAMTHIF_READ_TIMER);
 
-		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",
+		dev_dbg(dev->dev, "dev->iamthif_timer = %ld\n",
 				dev->iamthif_timer);
-		dev_dbg(&dev->pdev->dev, "timeout = %ld\n", timeout);
-		dev_dbg(&dev->pdev->dev, "jiffies = %ld\n", jiffies);
+		dev_dbg(dev->dev, "timeout = %ld\n", timeout);
+		dev_dbg(dev->dev, "jiffies = %ld\n", jiffies);
 		if (time_after(jiffies, timeout)) {
 			/*
 			 * User didn't read the AMTHI data on time (15sec)
 			 * freeing AMTHI for other requests
 			 */
 
-			dev_dbg(&dev->pdev->dev, "freeing AMTHI for other requests\n");
+			dev_dbg(dev->dev, "freeing AMTHI for other requests\n");
 
 			mei_io_list_flush(&dev->amthif_rd_complete_list,
 				&dev->iamthif_cl);
* Unmerged path drivers/misc/mei/main.c
* Unmerged path drivers/misc/mei/nfc.c
* Unmerged path drivers/misc/mei/pci-me.c
diff --git a/drivers/misc/mei/pci-txe.c b/drivers/misc/mei/pci-txe.c
index 2343c6236df9..3cdae52cbf5b 100644
--- a/drivers/misc/mei/pci-txe.c
+++ b/drivers/misc/mei/pci-txe.c
@@ -398,7 +398,7 @@ static inline void mei_txe_set_pm_domain(struct mei_device *dev)
 static inline void mei_txe_unset_pm_domain(struct mei_device *dev)
 {
 	/* stop using pm callbacks if any */
-	dev->pdev->dev.pm_domain = NULL;
+	dev->dev->pm_domain = NULL;
 }
 #endif /* CONFIG_PM_RUNTIME */
 
* Unmerged path drivers/misc/mei/wd.c
