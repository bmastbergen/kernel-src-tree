PCI: Disable IO/MEM decoding for devices with non-compliant BARs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit b84106b4e2290c081cdab521fa832596cdfea246
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b84106b4.failed

The PCI config header (first 64 bytes of each device's config space) is
defined by the PCI spec so generic software can identify the device and
manage its usage of I/O, memory, and IRQ resources.

Some non-spec-compliant devices put registers other than BARs where the
BARs should be.  When the PCI core sizes these "BARs", the reads and writes
it does may have unwanted side effects, and the "BAR" may appear to
describe non-sensical address space.

Add a flag bit to mark non-compliant devices so we don't touch their BARs.
Turn off IO/MEM decoding to prevent the devices from consuming address
space, since we can't read the BARs to find out what that address space
would be.

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Tested-by: Andi Kleen <ak@linux.intel.com>
CC: stable@vger.kernel.org
(cherry picked from commit b84106b4e2290c081cdab521fa832596cdfea246)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/pci.h
diff --cc include/linux/pci.h
index 101751adcb61,5f80661d3519..000000000000
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@@ -359,8 -357,9 +359,14 @@@ struct pci_dev 
  	unsigned int	__aer_firmware_first:1;
  	unsigned int	broken_intx_masking:1;
  	unsigned int	io_window_1k:1;	/* Intel P2P bridge 1K I/O windows */
++<<<<<<< HEAD
 +	RH_KABI_FILL_HOLE(unsigned int no_64bit_msi:1) /* device may only use 32-bit MSIs */
 +	RH_KABI_FILL_HOLE(unsigned int irq_managed:1)
++=======
+ 	unsigned int	irq_managed:1;
+ 	unsigned int	has_secondary_link:1;
+ 	unsigned int	non_compliant_bars:1;	/* broken BARs; ignore them */
++>>>>>>> b84106b4e229 (PCI: Disable IO/MEM decoding for devices with non-compliant BARs)
  	pci_dev_flags_t dev_flags;
  	atomic_t	enable_cnt;	/* pci_enable_device has been called */
  
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a063f5af325f..91da44283f7b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -213,6 +213,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
 
+	if (dev->non_compliant_bars)
+		return 0;
+
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
 	/* No printks while decoding is disabled! */
@@ -1157,6 +1160,7 @@ static void pci_msi_setup_pci_dev(struct pci_dev *dev)
 int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
+	u16 cmd;
 	u8 hdr_type;
 	struct pci_slot *slot;
 	int pos = 0;
@@ -1204,6 +1208,16 @@ int pci_setup_device(struct pci_dev *dev)
 	/* device class may be changed after fixup */
 	class = dev->class >> 8;
 
+	if (dev->non_compliant_bars) {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		if (cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {
+			dev_info(&dev->dev, "device has non-compliant BARs; disabling IO/MEM decoding\n");
+			cmd &= ~PCI_COMMAND_IO;
+			cmd &= ~PCI_COMMAND_MEMORY;
+			pci_write_config_word(dev, PCI_COMMAND, cmd);
+		}
+	}
+
 	switch (dev->hdr_type) {		    /* header type */
 	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */
 		if (class == PCI_CLASS_BRIDGE_PCI)
* Unmerged path include/linux/pci.h
