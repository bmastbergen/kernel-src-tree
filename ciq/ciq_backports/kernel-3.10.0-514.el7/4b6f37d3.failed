mmc: sdhci: clean up sdhci_execute_tuning() decision

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: clean up sdhci_execute_tuning() decision (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 94.95%
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit 4b6f37d3a379b09840c482bc4dcb9c3b4f7246c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4b6f37d3.failed

Clean up the code in sdhci_execute_tuning() so the decision whether
to execute tuning is clearer - and despite this reflecting what the
original code was doing, it shows that it may not be what the author
actually intended.

	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Tested-by: Markus Pargmann <mpa@pengutronix.de>
	Tested-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 4b6f37d3a379b09840c482bc4dcb9c3b4f7246c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index e292d602646d,5c8b192c4c3e..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -1839,9 -1820,8 +1839,9 @@@ static int sdhci_card_busy(struct mmc_h
  
  static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
  {
- 	struct sdhci_host *host;
+ 	struct sdhci_host *host = mmc_priv(mmc);
  	u16 ctrl;
 +	u32 ier;
  	int tuning_loop_counter = MAX_TUNING_LOOP;
  	unsigned long timeout;
  	int err = 0;
@@@ -1862,15 -1837,18 +1857,30 @@@
  	 * If the Host Controller supports the HS200 mode then the
  	 * tuning function has to be executed.
  	 */
++<<<<<<< HEAD
 +	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR50) &&
 +	    (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
 +	     host->flags & SDHCI_SDR104_NEEDS_TUNING))
 +		requires_tuning_nonuhs = true;
 +
 +	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR104) ||
 +	    requires_tuning_nonuhs)
 +		ctrl |= SDHCI_CTRL_EXEC_TUNING;
 +	else {
++=======
+ 	switch (host->timing) {
+ 	case MMC_TIMING_MMC_HS200:
+ 	case MMC_TIMING_UHS_SDR104:
+ 		break;
+ 
+ 	case MMC_TIMING_UHS_SDR50:
+ 		if (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
+ 		    host->flags & SDHCI_SDR104_NEEDS_TUNING)
+ 			break;
+ 		/* FALLTHROUGH */
+ 
+ 	default:
++>>>>>>> 4b6f37d3a379 (mmc: sdhci: clean up sdhci_execute_tuning() decision)
  		spin_unlock_irqrestore(&host->lock, flags);
  		sdhci_runtime_pm_put(host);
  		return 0;
* Unmerged path drivers/mmc/host/sdhci.c
