nvme: simplify nvme_setup_prps calling convention

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 69d2b571746d1c3fa10b7a0aa00859b296a98d12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/69d2b571.failed

Pass back a true/false value instead of the length which needs a compare
with the bytes in the request and drop the pointless gfp_t argument.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 69d2b571746d1c3fa10b7a0aa00859b296a98d12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,75970fdeeecb..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -548,12 -704,13 +548,17 @@@ static void req_completion(struct nvme_
  	}
  	nvme_free_iod(nvmeq->dev, iod);
  
 -	if (likely(!requeue))
 -		blk_mq_complete_request(req, error);
 +	blk_mq_complete_request(req);
  }
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +/* length is in bytes.  gfp flags indicates whether we may sleep. */
 +int nvme_setup_prps(struct nvme_dev *dev, struct nvme_iod *iod, int total_len,
 +								gfp_t gfp)
++=======
+ static bool nvme_setup_prps(struct nvme_dev *dev, struct nvme_iod *iod,
+ 		int total_len)
++>>>>>>> 69d2b571746d (nvme: simplify nvme_setup_prps calling convention):drivers/nvme/host/pci.c
  {
  	struct dma_pool *pool;
  	int length = total_len;
@@@ -628,9 -785,24 +633,9 @@@
  		dma_len = sg_dma_len(sg);
  	}
  
- 	return total_len;
+ 	return true;
  }
  
 -static void nvme_submit_priv(struct nvme_queue *nvmeq, struct request *req,
 -		struct nvme_iod *iod)
 -{
 -	struct nvme_command cmnd;
 -
 -	memcpy(&cmnd, req->cmd, sizeof(cmnd));
 -	cmnd.rw.command_id = req->tag;
 -	if (req->nr_phys_segments) {
 -		cmnd.rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
 -		cmnd.rw.prp2 = cpu_to_le64(iod->first_dma);
 -	}
 -
 -	__nvme_submit_cmd(nvmeq, &cmnd);
 -}
 -
  /*
   * We reuse the small pool to allocate the 16-byte range here as it is not
   * worth having a special pool for these or additional cases to handle freeing
@@@ -770,10 -951,8 +775,15 @@@ static int nvme_queue_rq(struct blk_mq_
  		if (!dma_map_sg(nvmeq->q_dmadev, iod->sg, iod->nents, dma_dir))
  			goto retry_cmd;
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +		if (blk_rq_bytes(req) !=
 +                    nvme_setup_prps(nvmeq->dev, iod, blk_rq_bytes(req), GFP_ATOMIC)) {
 +			dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->sg,
 +					iod->nents, dma_dir);
++=======
+ 		if (!nvme_setup_prps(dev, iod, blk_rq_bytes(req))) {
+ 			dma_unmap_sg(dev->dev, iod->sg, iod->nents, dma_dir);
++>>>>>>> 69d2b571746d (nvme: simplify nvme_setup_prps calling convention):drivers/nvme/host/pci.c
  			goto retry_cmd;
  		}
  		if (blk_integrity_rq(req)) {
* Unmerged path drivers/block/nvme-core.c
