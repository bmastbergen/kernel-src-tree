perf cpu_map: Add cpu_map user level event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 6640b6c227fc85fd8bdcc4a31239a04450487f6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6640b6c2.failed

Adding the cpu_map event to pass/store cpu maps as data in
a pipe/perf.data.

We store maps in 2 formats:
  - list of cpus
  - mask of cpus

The format that takes less space is selected transparently in the
following patch.

The interface is made generic, so we could add the cpumap event data
into another event in the following patches.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1445784728-21732-8-git-send-email-jolsa@kernel.org
[ cpu_map_data_cpus -> cpu_map_entries, cpu_map_data_mask -> cpu_map_mask ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 6640b6c227fc85fd8bdcc4a31239a04450487f6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/event.c
#	tools/perf/util/event.h
#	tools/perf/util/session.c
#	tools/perf/util/tool.h
diff --cc tools/perf/util/event.c
index 763fbcde76fc,719c0781a82a..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -35,6 -37,8 +35,11 @@@ static const char *perf_event__names[] 
  	[PERF_RECORD_AUXTRACE_INFO]		= "AUXTRACE_INFO",
  	[PERF_RECORD_AUXTRACE]			= "AUXTRACE",
  	[PERF_RECORD_AUXTRACE_ERROR]		= "AUXTRACE_ERROR",
++<<<<<<< HEAD
++=======
+ 	[PERF_RECORD_THREAD_MAP]		= "THREAD_MAP",
+ 	[PERF_RECORD_CPU_MAP]			= "CPU_MAP",
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  };
  
  const char *perf_event__name(unsigned int id)
diff --cc tools/perf/util/event.h
index 9400ef1c1335,1c82a0ebda73..000000000000
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@@ -226,6 -226,8 +226,11 @@@ enum perf_user_event_type { /* above an
  	PERF_RECORD_AUXTRACE_INFO		= 70,
  	PERF_RECORD_AUXTRACE			= 71,
  	PERF_RECORD_AUXTRACE_ERROR		= 72,
++<<<<<<< HEAD
++=======
+ 	PERF_RECORD_THREAD_MAP			= 73,
+ 	PERF_RECORD_CPU_MAP			= 74,
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  	PERF_RECORD_HEADER_MAX
  };
  
@@@ -371,6 -416,9 +402,12 @@@ union perf_event 
  	struct auxtrace_error_event	auxtrace_error;
  	struct aux_event		aux;
  	struct itrace_start_event	itrace_start;
++<<<<<<< HEAD
++=======
+ 	struct context_switch_event	context_switch;
+ 	struct thread_map_event		thread_map;
+ 	struct cpu_map_event		cpu_map;
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  };
  
  void perf_event__print_totals(void);
diff --cc tools/perf/util/session.c
index 5c19125e63db,4350f5e85bf5..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -296,6 -296,25 +296,28 @@@ int process_event_auxtrace_error_stub(s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ static
+ int process_event_thread_map_stub(struct perf_tool *tool __maybe_unused,
+ 				  union perf_event *event __maybe_unused,
+ 				  struct perf_session *session __maybe_unused)
+ {
+ 	dump_printf(": unhandled!\n");
+ 	return 0;
+ }
+ 
+ static
+ int process_event_cpu_map_stub(struct perf_tool *tool __maybe_unused,
+ 			       union perf_event *event __maybe_unused,
+ 			       struct perf_session *session __maybe_unused)
+ {
+ 	dump_printf(": unhandled!\n");
+ 	return 0;
+ }
+ 
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  void perf_tool__fill_defaults(struct perf_tool *tool)
  {
  	if (tool->sample == NULL)
@@@ -344,6 -365,10 +366,13 @@@
  		tool->auxtrace = process_event_auxtrace_stub;
  	if (tool->auxtrace_error == NULL)
  		tool->auxtrace_error = process_event_auxtrace_error_stub;
++<<<<<<< HEAD
++=======
+ 	if (tool->thread_map == NULL)
+ 		tool->thread_map = process_event_thread_map_stub;
+ 	if (tool->cpu_map == NULL)
+ 		tool->cpu_map = process_event_cpu_map_stub;
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  }
  
  static void swap_sample_id_all(union perf_event *event, void *data)
@@@ -601,6 -639,53 +630,56 @@@ static void perf_event__auxtrace_error_
  	event->auxtrace_error.ip   = bswap_64(event->auxtrace_error.ip);
  }
  
++<<<<<<< HEAD
++=======
+ static void perf_event__thread_map_swap(union perf_event *event,
+ 					bool sample_id_all __maybe_unused)
+ {
+ 	unsigned i;
+ 
+ 	event->thread_map.nr = bswap_64(event->thread_map.nr);
+ 
+ 	for (i = 0; i < event->thread_map.nr; i++)
+ 		event->thread_map.entries[i].pid = bswap_64(event->thread_map.entries[i].pid);
+ }
+ 
+ static void perf_event__cpu_map_swap(union perf_event *event,
+ 				     bool sample_id_all __maybe_unused)
+ {
+ 	struct cpu_map_data *data = &event->cpu_map.data;
+ 	struct cpu_map_entries *cpus;
+ 	struct cpu_map_mask *mask;
+ 	unsigned i;
+ 
+ 	data->type = bswap_64(data->type);
+ 
+ 	switch (data->type) {
+ 	case PERF_CPU_MAP__CPUS:
+ 		cpus = (struct cpu_map_entries *)data->data;
+ 
+ 		cpus->nr = bswap_16(cpus->nr);
+ 
+ 		for (i = 0; i < cpus->nr; i++)
+ 			cpus->cpu[i] = bswap_16(cpus->cpu[i]);
+ 		break;
+ 	case PERF_CPU_MAP__MASK:
+ 		mask = (struct cpu_map_mask *) data->data;
+ 
+ 		mask->nr = bswap_16(mask->nr);
+ 		mask->long_size = bswap_16(mask->long_size);
+ 
+ 		switch (mask->long_size) {
+ 		case 4: mem_bswap_32(&mask->mask, mask->nr); break;
+ 		case 8: mem_bswap_64(&mask->mask, mask->nr); break;
+ 		default:
+ 			pr_err("cpu_map swap: unsupported long size\n");
+ 		}
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  typedef void (*perf_event__swap_op)(union perf_event *event,
  				    bool sample_id_all);
  
@@@ -626,6 -713,8 +705,11 @@@ static perf_event__swap_op perf_event__
  	[PERF_RECORD_AUXTRACE_INFO]	  = perf_event__auxtrace_info_swap,
  	[PERF_RECORD_AUXTRACE]		  = perf_event__auxtrace_swap,
  	[PERF_RECORD_AUXTRACE_ERROR]	  = perf_event__auxtrace_error_swap,
++<<<<<<< HEAD
++=======
+ 	[PERF_RECORD_THREAD_MAP]	  = perf_event__thread_map_swap,
+ 	[PERF_RECORD_CPU_MAP]		  = perf_event__cpu_map_swap,
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  	[PERF_RECORD_HEADER_MAX]	  = NULL,
  };
  
@@@ -1159,6 -1251,10 +1243,13 @@@ static s64 perf_session__process_user_e
  	case PERF_RECORD_AUXTRACE_ERROR:
  		perf_session__auxtrace_error_inc(session, event);
  		return tool->auxtrace_error(tool, event, session);
++<<<<<<< HEAD
++=======
+ 	case PERF_RECORD_THREAD_MAP:
+ 		return tool->thread_map(tool, event, session);
+ 	case PERF_RECORD_CPU_MAP:
+ 		return tool->cpu_map(tool, event, session);
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  	default:
  		return -EINVAL;
  	}
diff --cc tools/perf/util/tool.h
index c307dd438286,9e5925c78519..000000000000
--- a/tools/perf/util/tool.h
+++ b/tools/perf/util/tool.h
@@@ -54,7 -55,9 +54,13 @@@ struct perf_tool 
  	event_op2	build_id,
  			id_index,
  			auxtrace_info,
++<<<<<<< HEAD
 +			auxtrace_error;
++=======
+ 			auxtrace_error,
+ 			thread_map,
+ 			cpu_map;
++>>>>>>> 6640b6c227fc (perf cpu_map: Add cpu_map user level event)
  	event_op3	auxtrace;
  	bool		ordered_events;
  	bool		ordering_requires_timestamps;
* Unmerged path tools/perf/util/event.c
* Unmerged path tools/perf/util/event.h
* Unmerged path tools/perf/util/session.c
* Unmerged path tools/perf/util/tool.h
