IB/qib: Remove srq functionality

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jubin John <jubin.john@intel.com>
commit fd0bf5bedfbd898bddc9ea8e646b4cb3779ec9ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fd0bf5be.failed

srq functionality is now in rdmavt. Remove it from the qib driver.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit fd0bf5bedfbd898bddc9ea8e646b4cb3779ec9ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qib/Makefile
#	drivers/infiniband/hw/qib/qib_srq.c
#	drivers/infiniband/hw/qib/qib_verbs.c
#	drivers/infiniband/hw/qib/qib_verbs.h
diff --cc drivers/infiniband/hw/qib/Makefile
index 8a8f892de7df,79ebd79e8405..000000000000
--- a/drivers/infiniband/hw/qib/Makefile
+++ b/drivers/infiniband/hw/qib/Makefile
@@@ -1,11 -1,11 +1,18 @@@
  obj-$(CONFIG_INFINIBAND_QIB) += ib_qib.o
  
++<<<<<<< HEAD
 +ib_qib-y := qib_cq.o qib_diag.o qib_driver.o qib_eeprom.o \
 +	qib_file_ops.o qib_fs.o qib_init.o qib_intr.o qib_keys.o \
 +	qib_mad.o qib_mmap.o qib_mr.o qib_pcie.o qib_pio_copy.o \
 +	qib_qp.o qib_qsfp.o qib_rc.o qib_ruc.o qib_sdma.o qib_srq.o \
++=======
+ ib_qib-y := qib_diag.o qib_driver.o qib_eeprom.o \
+ 	qib_file_ops.o qib_fs.o qib_init.o qib_intr.o \
+ 	qib_mad.o qib_pcie.o qib_pio_copy.o \
+ 	qib_qp.o qib_qsfp.o qib_rc.o qib_ruc.o qib_sdma.o \
++>>>>>>> fd0bf5bedfbd (IB/qib: Remove srq functionality)
  	qib_sysfs.o qib_twsi.o qib_tx.o qib_uc.o qib_ud.o \
 -	qib_user_pages.o qib_user_sdma.o qib_iba7220.o \
 +	qib_user_pages.o qib_user_sdma.o qib_verbs_mcast.o qib_iba7220.o \
  	qib_sd7220.o qib_iba7322.o qib_verbs.o
  
  # 6120 has no fallback if no MSI interrupts, others can do INTx
diff --cc drivers/infiniband/hw/qib/qib_verbs.c
index c4417a1f33be,3785a526f2e9..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@@ -2109,13 -1655,7 +2109,16 @@@ int qib_register_ib_device(struct qib_d
  		init_ibport(ppd + i);
  
  	/* Only need to initialize non-zero fields. */
 +	spin_lock_init(&dev->qpt_lock);
 +	spin_lock_init(&dev->n_pds_lock);
 +	spin_lock_init(&dev->n_ahs_lock);
 +	spin_lock_init(&dev->n_cqs_lock);
  	spin_lock_init(&dev->n_qps_lock);
++<<<<<<< HEAD
 +	spin_lock_init(&dev->n_srqs_lock);
 +	spin_lock_init(&dev->n_mcast_grps_lock);
++=======
++>>>>>>> fd0bf5bedfbd (IB/qib: Remove srq functionality)
  	init_timer(&dev->mem_timer);
  	dev->mem_timer.function = mem_timer;
  	dev->mem_timer.data = (unsigned long) dev;
@@@ -2230,47 -1743,40 +2233,80 @@@
  	ibdev->modify_device = qib_modify_device;
  	ibdev->query_port = qib_query_port;
  	ibdev->modify_port = qib_modify_port;
 -	ibdev->query_pkey = NULL;
 +	ibdev->query_pkey = qib_query_pkey;
  	ibdev->query_gid = qib_query_gid;
++<<<<<<< HEAD
 +	ibdev->alloc_ucontext = qib_alloc_ucontext;
 +	ibdev->dealloc_ucontext = qib_dealloc_ucontext;
 +	ibdev->alloc_pd = qib_alloc_pd;
 +	ibdev->dealloc_pd = qib_dealloc_pd;
 +	ibdev->create_ah = qib_create_ah;
 +	ibdev->destroy_ah = qib_destroy_ah;
 +	ibdev->modify_ah = qib_modify_ah;
 +	ibdev->query_ah = qib_query_ah;
 +	ibdev->create_srq = qib_create_srq;
 +	ibdev->modify_srq = qib_modify_srq;
 +	ibdev->query_srq = qib_query_srq;
 +	ibdev->destroy_srq = qib_destroy_srq;
 +	ibdev->create_qp = qib_create_qp;
++=======
+ 	ibdev->alloc_ucontext = NULL;
+ 	ibdev->dealloc_ucontext = NULL;
+ 	ibdev->alloc_pd = NULL;
+ 	ibdev->dealloc_pd = NULL;
+ 	ibdev->create_ah = NULL;
+ 	ibdev->destroy_ah = NULL;
+ 	ibdev->modify_ah = NULL;
+ 	ibdev->query_ah = NULL;
+ 	ibdev->create_qp = NULL;
++>>>>>>> fd0bf5bedfbd (IB/qib: Remove srq functionality)
  	ibdev->modify_qp = qib_modify_qp;
 -	ibdev->query_qp = NULL;
 +	ibdev->query_qp = qib_query_qp;
  	ibdev->destroy_qp = qib_destroy_qp;
++<<<<<<< HEAD
 +	ibdev->post_send = qib_post_send;
 +	ibdev->post_recv = qib_post_receive;
 +	ibdev->post_srq_recv = qib_post_srq_receive;
 +	ibdev->create_cq = qib_create_cq;
 +	ibdev->destroy_cq = qib_destroy_cq;
 +	ibdev->resize_cq = qib_resize_cq;
 +	ibdev->poll_cq = qib_poll_cq;
 +	ibdev->req_notify_cq = qib_req_notify_cq;
 +	ibdev->get_dma_mr = qib_get_dma_mr;
 +	ibdev->reg_phys_mr = qib_reg_phys_mr;
 +	ibdev->reg_user_mr = qib_reg_user_mr;
 +	ibdev->dereg_mr = qib_dereg_mr;
 +	ibdev->alloc_mr = qib_alloc_mr;
 +	ibdev->alloc_fast_reg_page_list = qib_alloc_fast_reg_page_list;
 +	ibdev->free_fast_reg_page_list = qib_free_fast_reg_page_list;
 +	ibdev->alloc_fmr = qib_alloc_fmr;
 +	ibdev->map_phys_fmr = qib_map_phys_fmr;
 +	ibdev->unmap_fmr = qib_unmap_fmr;
 +	ibdev->dealloc_fmr = qib_dealloc_fmr;
 +	ibdev->attach_mcast = qib_multicast_attach;
 +	ibdev->detach_mcast = qib_multicast_detach;
++=======
+ 	ibdev->post_send = NULL;
+ 	ibdev->post_recv = NULL;
+ 	ibdev->create_cq = NULL;
+ 	ibdev->destroy_cq = NULL;
+ 	ibdev->resize_cq = NULL;
+ 	ibdev->poll_cq = NULL;
+ 	ibdev->req_notify_cq = NULL;
+ 	ibdev->get_dma_mr = NULL;
+ 	ibdev->reg_user_mr = NULL;
+ 	ibdev->dereg_mr = NULL;
+ 	ibdev->alloc_mr = NULL;
+ 	ibdev->map_mr_sg = NULL;
+ 	ibdev->alloc_fmr = NULL;
+ 	ibdev->map_phys_fmr = NULL;
+ 	ibdev->unmap_fmr = NULL;
+ 	ibdev->dealloc_fmr = NULL;
+ 	ibdev->attach_mcast = NULL;
+ 	ibdev->detach_mcast = NULL;
++>>>>>>> fd0bf5bedfbd (IB/qib: Remove srq functionality)
  	ibdev->process_mad = qib_process_mad;
 -	ibdev->mmap = NULL;
 +	ibdev->mmap = qib_mmap;
  	ibdev->dma_ops = NULL;
  	ibdev->get_port_immutable = qib_port_immutable;
  
diff --cc drivers/infiniband/hw/qib/qib_verbs.h
index ca366073af4f,a7e3c7111e14..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.h
+++ b/drivers/infiniband/hw/qib/qib_verbs.h
@@@ -782,18 -268,8 +782,21 @@@ struct qib_ibdev 
  	u32 n_piowait;
  	u32 n_txwait;
  
 +	u32 n_pds_allocated;    /* number of PDs allocated for device */
 +	spinlock_t n_pds_lock;
 +	u32 n_ahs_allocated;    /* number of AHs allocated for device */
 +	spinlock_t n_ahs_lock;
 +	u32 n_cqs_allocated;    /* number of CQs allocated for device */
 +	spinlock_t n_cqs_lock;
  	u32 n_qps_allocated;    /* number of QPs allocated for device */
  	spinlock_t n_qps_lock;
++<<<<<<< HEAD
 +	u32 n_srqs_allocated;   /* number of SRQs allocated for device */
 +	spinlock_t n_srqs_lock;
 +	u32 n_mcast_grps_allocated; /* number of mcast groups allocated */
 +	spinlock_t n_mcast_grps_lock;
++=======
++>>>>>>> fd0bf5bedfbd (IB/qib: Remove srq functionality)
  #ifdef CONFIG_DEBUG_FS
  	/* per HCA debugfs */
  	struct dentry *qib_ibdev_dbg;
@@@ -983,109 -417,21 +986,112 @@@ struct ib_ah *qib_create_qp0_ah(struct 
  
  void qib_rc_rnr_retry(unsigned long arg);
  
 -void qib_rc_send_complete(struct rvt_qp *qp, struct qib_ib_header *hdr);
 +void qib_rc_send_complete(struct qib_qp *qp, struct qib_ib_header *hdr);
  
 -void qib_rc_error(struct rvt_qp *qp, enum ib_wc_status err);
 +void qib_rc_error(struct qib_qp *qp, enum ib_wc_status err);
  
 -int qib_post_ud_send(struct rvt_qp *qp, struct ib_send_wr *wr);
 +int qib_post_ud_send(struct qib_qp *qp, struct ib_send_wr *wr);
  
  void qib_ud_rcv(struct qib_ibport *ibp, struct qib_ib_header *hdr,
 -		int has_grh, void *data, u32 tlen, struct rvt_qp *qp);
 +		int has_grh, void *data, u32 tlen, struct qib_qp *qp);
 +
 +int qib_alloc_lkey(struct qib_mregion *mr, int dma_region);
 +
 +void qib_free_lkey(struct qib_mregion *mr);
 +
 +int qib_lkey_ok(struct qib_lkey_table *rkt, struct qib_pd *pd,
 +		struct qib_sge *isge, struct ib_sge *sge, int acc);
 +
 +int qib_rkey_ok(struct qib_qp *qp, struct qib_sge *sge,
 +		u32 len, u64 vaddr, u32 rkey, int acc);
 +
++<<<<<<< HEAD
 +int qib_post_srq_receive(struct ib_srq *ibsrq, struct ib_recv_wr *wr,
 +			 struct ib_recv_wr **bad_wr);
 +
 +struct ib_srq *qib_create_srq(struct ib_pd *ibpd,
 +			      struct ib_srq_init_attr *srq_init_attr,
 +			      struct ib_udata *udata);
 +
 +int qib_modify_srq(struct ib_srq *ibsrq, struct ib_srq_attr *attr,
 +		   enum ib_srq_attr_mask attr_mask,
 +		   struct ib_udata *udata);
 +
 +int qib_query_srq(struct ib_srq *ibsrq, struct ib_srq_attr *attr);
 +
 +int qib_destroy_srq(struct ib_srq *ibsrq);
 +
 +int qib_cq_init(struct qib_devdata *dd);
 +
 +void qib_cq_exit(struct qib_devdata *dd);
 +
 +void qib_cq_enter(struct qib_cq *cq, struct ib_wc *entry, int sig);
 +
 +int qib_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *entry);
 +
 +struct ib_cq *qib_create_cq(struct ib_device *ibdev,
 +			    const struct ib_cq_init_attr *attr,
 +			    struct ib_ucontext *context,
 +			    struct ib_udata *udata);
 +
 +int qib_destroy_cq(struct ib_cq *ibcq);
 +
 +int qib_req_notify_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags notify_flags);
 +
 +int qib_resize_cq(struct ib_cq *ibcq, int cqe, struct ib_udata *udata);
 +
 +struct ib_mr *qib_get_dma_mr(struct ib_pd *pd, int acc);
 +
 +struct ib_mr *qib_reg_phys_mr(struct ib_pd *pd,
 +			      struct ib_phys_buf *buffer_list,
 +			      int num_phys_buf, int acc, u64 *iova_start);
 +
 +struct ib_mr *qib_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,
 +			      u64 virt_addr, int mr_access_flags,
 +			      struct ib_udata *udata);
  
 +int qib_dereg_mr(struct ib_mr *ibmr);
 +
 +struct ib_mr *qib_alloc_mr(struct ib_pd *pd,
 +			   enum ib_mr_type mr_type,
 +			   u32 max_entries);
 +
 +struct ib_fast_reg_page_list *qib_alloc_fast_reg_page_list(
 +				struct ib_device *ibdev, int page_list_len);
 +
 +void qib_free_fast_reg_page_list(struct ib_fast_reg_page_list *pl);
 +
 +int qib_fast_reg_mr(struct qib_qp *qp, struct ib_send_wr *wr);
 +
 +struct ib_fmr *qib_alloc_fmr(struct ib_pd *pd, int mr_access_flags,
 +			     struct ib_fmr_attr *fmr_attr);
 +
 +int qib_map_phys_fmr(struct ib_fmr *ibfmr, u64 *page_list,
 +		     int list_len, u64 iova);
 +
 +int qib_unmap_fmr(struct list_head *fmr_list);
 +
 +int qib_dealloc_fmr(struct ib_fmr *ibfmr);
 +
 +static inline void qib_get_mr(struct qib_mregion *mr)
 +{
 +	atomic_inc(&mr->refcount);
 +}
 +
++=======
++>>>>>>> fd0bf5bedfbd (IB/qib: Remove srq functionality)
  void mr_rcu_callback(struct rcu_head *list);
  
 -static inline void qib_put_ss(struct rvt_sge_state *ss)
 +static inline void qib_put_mr(struct qib_mregion *mr)
 +{
 +	if (unlikely(atomic_dec_and_test(&mr->refcount)))
 +		call_rcu(&mr->list, mr_rcu_callback);
 +}
 +
 +static inline void qib_put_ss(struct qib_sge_state *ss)
  {
  	while (ss->num_sge) {
 -		rvt_put_mr(ss->sge.mr);
 +		qib_put_mr(ss->sge.mr);
  		if (--ss->num_sge)
  			ss->sge = *ss->sg_list++;
  	}
* Unmerged path drivers/infiniband/hw/qib/qib_srq.c
* Unmerged path drivers/infiniband/hw/qib/Makefile
* Unmerged path drivers/infiniband/hw/qib/qib_srq.c
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.c
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.h
