mei: move fw_status back to hw ops handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 1bd30b6a42610466bae2c133e68a8feb1004929c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1bd30b6a.failed

fw status retrieval has pci specific implementation
so we push it back to the hw layer

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 1bd30b6a42610466bae2c133e68a8feb1004929c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/init.c
diff --cc drivers/misc/mei/init.c
index 08331e745faf,dd233fd43178..000000000000
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@@ -342,28 -344,16 +342,41 @@@ bool mei_write_is_idle(struct mei_devic
  }
  EXPORT_SYMBOL_GPL(mei_write_is_idle);
  
++<<<<<<< HEAD
 +int mei_fw_status(struct mei_device *dev, struct mei_fw_status *fw_status)
 +{
 +	int i;
 +	const struct mei_fw_status *fw_src = &dev->cfg->fw_status;
 +
 +	if (!fw_status)
 +		return -EINVAL;
 +
 +	fw_status->count = fw_src->count;
 +	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
 +		int ret;
 +		ret = pci_read_config_dword(dev->pdev,
 +			fw_src->status[i], &fw_status->status[i]);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(mei_fw_status);
 +
 +void mei_device_init(struct mei_device *dev, const struct mei_cfg *cfg)
++=======
+ /**
+  * mei_device_init  -- initialize mei_device structure
+  *
+  * @dev: the mei device
+  * @device: the device structure
+  * @hw_ops: hw operations
+  */
+ void mei_device_init(struct mei_device *dev,
+ 		     struct device *device,
+ 		     const struct mei_hw_ops *hw_ops)
++>>>>>>> 1bd30b6a4261 (mei: move fw_status back to hw ops handlers)
  {
  	/* setup our list array */
  	INIT_LIST_HEAD(&dev->file_list);
diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c
index 241eae550b0c..d0a025feede1 100644
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@ -101,6 +101,33 @@ static inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)
 	mei_me_reg_write(hw, H_CSR, hcsr);
 }
 
+/**
+ * mei_me_fw_status - read fw status register from pci config space
+ *
+ * @dev: mei device
+ * @fw_status: fw status register values
+ */
+static int mei_me_fw_status(struct mei_device *dev,
+			    struct mei_fw_status *fw_status)
+{
+	const struct mei_fw_status *fw_src = &dev->cfg->fw_status;
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+	int ret;
+	int i;
+
+	if (!fw_status)
+		return -EINVAL;
+
+	fw_status->count = fw_src->count;
+	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+		ret = pci_read_config_dword(pdev,
+			fw_src->status[i], &fw_status->status[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
 
 /**
  * mei_me_hw_config - configure hw dependent settings
@@ -703,6 +730,7 @@ end:
 
 static const struct mei_hw_ops mei_me_hw_ops = {
 
+	.fw_status = mei_me_fw_status,
 	.pg_state  = mei_me_pg_state,
 
 	.host_is_ready = mei_me_host_is_ready,
diff --git a/drivers/misc/mei/hw-txe.c b/drivers/misc/mei/hw-txe.c
index f1cd166094f2..69d7af08c9ed 100644
--- a/drivers/misc/mei/hw-txe.c
+++ b/drivers/misc/mei/hw-txe.c
@@ -559,6 +559,35 @@ static int mei_txe_readiness_wait(struct mei_device *dev)
 	return 0;
 }
 
+
+/**
+ * mei_txe_fw_status - read fw status register from pci config space
+ *
+ * @dev: mei device
+ * @fw_status: fw status register values
+ */
+static int mei_txe_fw_status(struct mei_device *dev,
+			     struct mei_fw_status *fw_status)
+{
+	const struct mei_fw_status *fw_src = &dev->cfg->fw_status;
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+	int ret;
+	int i;
+
+	if (!fw_status)
+		return -EINVAL;
+
+	fw_status->count = fw_src->count;
+	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+		ret = pci_read_config_dword(pdev,
+			fw_src->status[i], &fw_status->status[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 /**
  *  mei_txe_hw_config - configure hardware at the start of the devices
  *
@@ -1046,6 +1075,7 @@ static const struct mei_hw_ops mei_txe_hw_ops = {
 
 	.host_is_ready = mei_txe_host_is_ready,
 
+	.fw_status = mei_txe_fw_status,
 	.pg_state = mei_txe_pg_state,
 
 	.hw_is_ready = mei_txe_hw_is_ready,
* Unmerged path drivers/misc/mei/init.c
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 1b981b70f5aa..d47d88ef13e9 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -238,6 +238,7 @@ struct mei_cl {
  * @hw_start         - start hw after reset
  * @hw_config        - configure hw
 
+ * @fw_status        - get fw status registers
  * @pg_state         - power gating state of the device
  * @pg_is_enabled    - is power gating enabled
 
@@ -265,6 +266,8 @@ struct mei_hw_ops {
 	int (*hw_start)(struct mei_device *dev);
 	void (*hw_config)(struct mei_device *dev);
 
+
+	int (*fw_status)(struct mei_device *dev, struct mei_fw_status *fw_sts);
 	enum mei_pg_state (*pg_state)(struct mei_device *dev);
 	bool (*pg_is_enabled)(struct mei_device *dev);
 
@@ -723,7 +726,11 @@ static inline int mei_count_full_read_slots(struct mei_device *dev)
 	return dev->ops->rdbuf_full_slots(dev);
 }
 
-int mei_fw_status(struct mei_device *dev, struct mei_fw_status *fw_status);
+static inline int mei_fw_status(struct mei_device *dev,
+				struct mei_fw_status *fw_status)
+{
+	return dev->ops->fw_status(dev, fw_status);
+}
 
 #define FW_STS_FMT "%08X %08X"
 #define FW_STS_PRM(fw_status) \
