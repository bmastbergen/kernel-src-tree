sctp: remove the dead field of sctp_transport

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 47faa1e4c50ec26e6e75dcd1ce53f064bd45f729
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/47faa1e4.failed

After we use refcnt to check if transport is alive, the dead can be
removed from sctp_transport.

The traversal of transport_addr_list in procfs dump is using
list_for_each_entry_rcu, no need to check if it has been freed.

sctp_generate_t3_rtx_event and sctp_generate_heartbeat_event is
protected by sock lock, it's not necessary to check dead, either.
also, the timers are cancelled when sctp_transport_free() is
called, that it doesn't wait for refcnt to reach 0 to cancel them.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 47faa1e4c50ec26e6e75dcd1ce53f064bd45f729)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/proc.c
#	net/sctp/transport.c
diff --cc net/sctp/proc.c
index aaeecb033eeb,ded7d931a6a5..000000000000
--- a/net/sctp/proc.c
+++ b/net/sctp/proc.c
@@@ -443,85 -481,74 +441,104 @@@ static void sctp_remaddr_seq_stop(struc
  
  static int sctp_remaddr_seq_show(struct seq_file *seq, void *v)
  {
 +	struct sctp_hashbucket *head;
 +	struct sctp_ep_common *epb;
  	struct sctp_association *assoc;
  	struct sctp_transport *tsp;
 +	int    hash = *(loff_t *)v;
  
 -	if (v == SEQ_START_TOKEN) {
 -		seq_printf(seq, "ADDR ASSOC_ID HB_ACT RTO MAX_PATH_RTX "
 -				"REM_ADDR_RTX START STATE\n");
 -		return 0;
 -	}
 +	if (hash >= sctp_assoc_hashsize)
 +		return -ENOMEM;
  
++<<<<<<< HEAD
 +	head = &sctp_assoc_hashtable[hash];
 +	sctp_local_bh_disable();
 +	read_lock(&head->lock);
 +	rcu_read_lock();
 +	sctp_for_each_hentry(epb, &head->chain) {
 +		if (!net_eq(sock_net(epb->sk), seq_file_net(seq)))
 +			continue;
 +		assoc = sctp_assoc(epb);
 +		list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
 +					transports) {
 +			if (tsp->dead)
 +				continue;
++=======
+ 	tsp = (struct sctp_transport *)v;
+ 	if (!sctp_transport_hold(tsp))
+ 		return 0;
+ 	assoc = tsp->asoc;
+ 
+ 	list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
+ 				transports) {
+ 		/*
+ 		 * The remote address (ADDR)
+ 		 */
+ 		tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
+ 		seq_printf(seq, " ");
+ 		/*
+ 		 * The association ID (ASSOC_ID)
+ 		 */
+ 		seq_printf(seq, "%d ", tsp->asoc->assoc_id);
 -
 -		/*
 -		 * If the Heartbeat is active (HB_ACT)
 -		 * Note: 1 = Active, 0 = Inactive
 -		 */
 -		seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
 -
 -		/*
 -		 * Retransmit time out (RTO)
 -		 */
 -		seq_printf(seq, "%lu ", tsp->rto);
 -
 -		/*
 -		 * Maximum path retransmit count (PATH_MAX_RTX)
 -		 */
 -		seq_printf(seq, "%d ", tsp->pathmaxrxt);
 -
 -		/*
 -		 * remote address retransmit count (REM_ADDR_RTX)
 -		 * Note: We don't have a way to tally this at the moment
 -		 * so lets just leave it as zero for the moment
 -		 */
 -		seq_puts(seq, "0 ");
 -
 -		/*
 -		 * remote address start time (START).  This is also not
 -		 * currently implemented, but we can record it with a
 -		 * jiffies marker in a subsequent patch
 -		 */
 -		seq_puts(seq, "0 ");
 -
 -		/*
 -		 * The current state of this destination. I.e.
 -		 * SCTP_ACTIVE, SCTP_INACTIVE, ...
 -		 */
 -		seq_printf(seq, "%d", tsp->state);
 -
 -		seq_printf(seq, "\n");
++>>>>>>> 47faa1e4c50e (sctp: remove the dead field of sctp_transport)
 +
 +			/*
 +			 * The remote address (ADDR)
 +			 */
 +			tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
 +			seq_printf(seq, " ");
 +
 +			/*
 +			 * The association ID (ASSOC_ID)
 +			 */
 +			seq_printf(seq, "%d ", tsp->asoc->assoc_id);
 +
 +			/*
 +			 * If the Heartbeat is active (HB_ACT)
 +			 * Note: 1 = Active, 0 = Inactive
 +			 */
 +			seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
 +
 +			/*
 +			 * Retransmit time out (RTO)
 +			 */
 +			seq_printf(seq, "%lu ", tsp->rto);
 +
 +			/*
 +			 * Maximum path retransmit count (PATH_MAX_RTX)
 +			 */
 +			seq_printf(seq, "%d ", tsp->pathmaxrxt);
 +
 +			/*
 +			 * remote address retransmit count (REM_ADDR_RTX)
 +			 * Note: We don't have a way to tally this at the moment
 +			 * so lets just leave it as zero for the moment
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * remote address start time (START).  This is also not
 +			 * currently implemented, but we can record it with a
 +			 * jiffies marker in a subsequent patch
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * The current state of this destination. I.e.
 +			 * SCTP_ACTIVE, SCTP_INACTIVE, ...
 +			 */
 +			seq_printf(seq, "%d", tsp->state);
 +
 +			seq_printf(seq, "\n");
 +		}
  	}
  
 -	sctp_transport_put(tsp);
 +	rcu_read_unlock();
 +	read_unlock(&head->lock);
 +	sctp_local_bh_enable();
  
  	return 0;
 +
  }
  
  static const struct seq_operations sctp_remaddr_ops = {
diff --cc net/sctp/transport.c
index 098f1d5f769e,a431c14044a4..000000000000
--- a/net/sctp/transport.c
+++ b/net/sctp/transport.c
@@@ -176,9 -167,10 +174,16 @@@ static void sctp_transport_destroy_rcu(
   */
  static void sctp_transport_destroy(struct sctp_transport *transport)
  {
++<<<<<<< HEAD
 +	SCTP_ASSERT(transport->dead, "Transport is not dead", return);
 +
 +	call_rcu(&transport->rcu, sctp_transport_destroy_rcu);
++=======
+ 	if (unlikely(atomic_read(&transport->refcnt))) {
+ 		WARN(1, "Attempt to destroy undead transport %p!\n", transport);
+ 		return;
+ 	}
++>>>>>>> 47faa1e4c50e (sctp: remove the dead field of sctp_transport)
  
  	sctp_packet_free(&transport->packet);
  
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7a7c7cb8b173..7de3508fc8a9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -766,7 +766,6 @@ struct sctp_transport {
 
 	/* Reference counting. */
 	atomic_t refcnt;
-	__u32	 dead:1,
 		/* RTO-Pending : A flag used to track if one of the DATA
 		 *		chunks sent to this address is currently being
 		 *		used to compute a RTT. If this flag is 0,
@@ -776,7 +775,7 @@ struct sctp_transport {
 		 *		calculation completes (i.e. the DATA chunk
 		 *		is SACK'd) clear this flag.
 		 */
-		 rto_pending:1,
+	__u32	rto_pending:1,
 
 		/*
 		 * hb_sent : a flag that signals that we have a pending
* Unmerged path net/sctp/proc.c
diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c
index 57238eb66318..0a2d05460caf 100644
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@ -265,12 +265,6 @@ void sctp_generate_t3_rtx_event(unsigned long peer)
 		goto out_unlock;
 	}
 
-	/* Is this transport really dead and just waiting around for
-	 * the timer to let go of the reference?
-	 */
-	if (transport->dead)
-		goto out_unlock;
-
 	/* Run through the state machine.  */
 	error = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,
 			   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),
@@ -385,12 +379,6 @@ void sctp_generate_heartbeat_event(unsigned long data)
 		goto out_unlock;
 	}
 
-	/* Is this structure just waiting around for us to actually
-	 * get destroyed?
-	 */
-	if (transport->dead)
-		goto out_unlock;
-
 	error = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,
 			   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),
 			   asoc->state, asoc->ep, asoc,
* Unmerged path net/sctp/transport.c
