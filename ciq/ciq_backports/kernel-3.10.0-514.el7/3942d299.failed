mm/slab_common: allow NULL cache pointer in kmem_cache_destroy()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] slab_common: allow NULL cache pointer in kmem_cache_destroy() (Mike Snitzer) [1314893]
Rebuild_FUZZ: 97.60%
commit-author Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
commit 3942d29918522ba6a393c19388301ec04df429cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3942d299.failed

kmem_cache_destroy() does not tolerate a NULL kmem_cache pointer argument
and performs a NULL-pointer dereference.  This requires additional
attention and effort from developers/reviewers and forces all
kmem_cache_destroy() callers (200+ as of 4.1) to do a NULL check

    if (cache)
        kmem_cache_destroy(cache);

Or, otherwise, be invalid kmem_cache_destroy() users.

Tweak kmem_cache_destroy() and NULL-check the pointer there.

Proposed by Andrew Morton.

Link: https://lkml.org/lkml/2015/6/8/583
	Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Cc: Julia Lawall <julia.lawall@lip6.fr>
	Cc: Joe Perches <joe@perches.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3942d29918522ba6a393c19388301ec04df429cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slab_common.c
diff --cc mm/slab_common.c
index 2d414508e9ec,bde04a699ab6..000000000000
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@@ -250,34 -635,40 +250,46 @@@ EXPORT_SYMBOL(kmem_cache_create)
  
  void kmem_cache_destroy(struct kmem_cache *s)
  {
++<<<<<<< HEAD
 +	/* Destroy all the children caches if we aren't a memcg cache */
 +	kmem_cache_destroy_memcg_children(s);
++=======
+ 	struct kmem_cache *c, *c2;
+ 	LIST_HEAD(release);
+ 	bool need_rcu_barrier = false;
+ 	bool busy = false;
+ 
+ 	if (unlikely(!s))
+ 		return;
+ 
+ 	BUG_ON(!is_root_cache(s));
++>>>>>>> 3942d2991852 (mm/slab_common: allow NULL cache pointer in kmem_cache_destroy())
  
  	get_online_cpus();
 -	get_online_mems();
 -
  	mutex_lock(&slab_mutex);
 -
  	s->refcount--;
 -	if (s->refcount)
 -		goto out_unlock;
 -
 -	for_each_memcg_cache_safe(c, c2, s) {
 -		if (do_kmem_cache_shutdown(c, &release, &need_rcu_barrier))
 -			busy = true;
 +	if (!s->refcount) {
 +		list_del(&s->list);
 +
 +		if (!__kmem_cache_shutdown(s)) {
 +			mutex_unlock(&slab_mutex);
 +			if (s->flags & SLAB_DESTROY_BY_RCU)
 +				rcu_barrier();
 +
 +			memcg_release_cache(s);
 +			kfree(s->name);
 +			kmem_cache_free(kmem_cache, s);
 +		} else {
 +			list_add(&s->list, &slab_caches);
 +			mutex_unlock(&slab_mutex);
 +			printk(KERN_ERR "kmem_cache_destroy %s: Slab cache still has objects\n",
 +				s->name);
 +			dump_stack();
 +		}
 +	} else {
 +		mutex_unlock(&slab_mutex);
  	}
 -
 -	if (!busy)
 -		do_kmem_cache_shutdown(s, &release, &need_rcu_barrier);
 -
 -out_unlock:
 -	mutex_unlock(&slab_mutex);
 -
 -	put_online_mems();
  	put_online_cpus();
 -
 -	do_kmem_cache_release(&release, need_rcu_barrier);
  }
  EXPORT_SYMBOL(kmem_cache_destroy);
  
* Unmerged path mm/slab_common.c
