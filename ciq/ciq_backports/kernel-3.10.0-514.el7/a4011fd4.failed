cxgb4: Add debugfs support to dump tid info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit a4011fd470d334253a425942b29e65844642d0ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a4011fd4.failed

Add debugfs support to dump tid info like stid, sftid, tids, atid and
hwtids

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a4011fd470d334253a425942b29e65844642d0ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index 6e7613cab75a,ce075d11fb3f..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@@ -2167,12 -2257,73 +2167,82 @@@ static const struct file_operations mem
  	.llseek  = default_llseek,
  };
  
++<<<<<<< HEAD
 +static void set_debugfs_file_size(struct dentry *de, loff_t size)
 +{
 +	if (!IS_ERR(de) && de->d_inode)
 +		de->d_inode->i_size = size;
 +}
 +
++=======
+ static int tid_info_show(struct seq_file *seq, void *v)
+ {
+ 	struct adapter *adap = seq->private;
+ 	const struct tid_info *t = &adap->tids;
+ 	enum chip_type chip = CHELSIO_CHIP_VERSION(adap->params.chip);
+ 
+ 	if (t4_read_reg(adap, LE_DB_CONFIG_A) & HASHEN_F) {
+ 		unsigned int sb;
+ 
+ 		if (chip <= CHELSIO_T5)
+ 			sb = t4_read_reg(adap, LE_DB_SERVER_INDEX_A) / 4;
+ 		else
+ 			sb = t4_read_reg(adap, LE_DB_SRVR_START_INDEX_A);
+ 
+ 		if (sb) {
+ 			seq_printf(seq, "TID range: 0..%u/%u..%u", sb - 1,
+ 				   adap->tids.hash_base,
+ 				   t->ntids - 1);
+ 			seq_printf(seq, ", in use: %u/%u\n",
+ 				   atomic_read(&t->tids_in_use),
+ 				   atomic_read(&t->hash_tids_in_use));
+ 		} else if (adap->flags & FW_OFLD_CONN) {
+ 			seq_printf(seq, "TID range: %u..%u/%u..%u",
+ 				   t->aftid_base,
+ 				   t->aftid_end,
+ 				   adap->tids.hash_base,
+ 				   t->ntids - 1);
+ 			seq_printf(seq, ", in use: %u/%u\n",
+ 				   atomic_read(&t->tids_in_use),
+ 				   atomic_read(&t->hash_tids_in_use));
+ 		} else {
+ 			seq_printf(seq, "TID range: %u..%u",
+ 				   adap->tids.hash_base,
+ 				   t->ntids - 1);
+ 			seq_printf(seq, ", in use: %u\n",
+ 				   atomic_read(&t->hash_tids_in_use));
+ 		}
+ 	} else if (t->ntids) {
+ 		seq_printf(seq, "TID range: 0..%u", t->ntids - 1);
+ 		seq_printf(seq, ", in use: %u\n",
+ 			   atomic_read(&t->tids_in_use));
+ 	}
+ 
+ 	if (t->nstids)
+ 		seq_printf(seq, "STID range: %u..%u, in use: %u\n",
+ 			   (!t->stid_base &&
+ 			   (chip <= CHELSIO_T5)) ?
+ 			   t->stid_base + 1 : t->stid_base,
+ 			   t->stid_base + t->nstids - 1, t->stids_in_use);
+ 	if (t->natids)
+ 		seq_printf(seq, "ATID range: 0..%u, in use: %u\n",
+ 			   t->natids - 1, t->atids_in_use);
+ 	seq_printf(seq, "FTID range: %u..%u\n", t->ftid_base,
+ 		   t->ftid_base + t->nftids - 1);
+ 	if (t->nsftids)
+ 		seq_printf(seq, "SFTID range: %u..%u in use: %u\n",
+ 			   t->sftid_base, t->sftid_base + t->nsftids - 2,
+ 			   t->sftids_in_use);
+ 	if (t->ntids)
+ 		seq_printf(seq, "HW TID usage: %u IP users, %u IPv6 users\n",
+ 			   t4_read_reg(adap, LE_DB_ACT_CNT_IPV4_A),
+ 			   t4_read_reg(adap, LE_DB_ACT_CNT_IPV6_A));
+ 	return 0;
+ }
+ 
+ DEFINE_SIMPLE_DEBUGFS_FILE(tid_info);
+ 
++>>>>>>> a4011fd470d3 (cxgb4: Add debugfs support to dump tid info)
  static void add_debugfs_mem(struct adapter *adap, const char *name,
  			    unsigned int idx, unsigned int size_mb)
  {
@@@ -2305,7 -2737,9 +2375,8 @@@ int t4_setup_debugfs(struct adapter *ad
  #if IS_ENABLED(CONFIG_IPV6)
  		{ "clip_tbl", &clip_tbl_debugfs_fops, S_IRUSR, 0 },
  #endif
+ 		{ "tids", &tid_info_debugfs_fops, S_IRUSR, 0},
  		{ "blocked_fl", &blocked_fl_fops, S_IRUSR | S_IWUSR, 0 },
 -		{ "meminfo", &meminfo_fops, S_IRUSR, 0 },
  	};
  
  	/* Debug FS nodes common to all T5 and later adapters.
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
index 83c5d48c7f6b,4d2c9290c7dd..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
@@@ -2520,7 -2719,32 +2520,29 @@@
  #define REV_V(x) ((x) << REV_S)
  #define REV_G(x) (((x) >> REV_S) & REV_M)
  
++<<<<<<< HEAD
++=======
+ #define T6_UNKNOWNCMD_S    3
+ #define T6_UNKNOWNCMD_V(x) ((x) << T6_UNKNOWNCMD_S)
+ #define T6_UNKNOWNCMD_F    T6_UNKNOWNCMD_V(1U)
+ 
+ #define T6_LIP0_S    2
+ #define T6_LIP0_V(x) ((x) << T6_LIP0_S)
+ #define T6_LIP0_F    T6_LIP0_V(1U)
+ 
+ #define T6_LIPMISS_S    1
+ #define T6_LIPMISS_V(x) ((x) << T6_LIPMISS_S)
+ #define T6_LIPMISS_F    T6_LIPMISS_V(1U)
+ 
+ #define LE_DB_CONFIG_A 0x19c04
+ #define LE_DB_SERVER_INDEX_A 0x19c18
+ #define LE_DB_SRVR_START_INDEX_A 0x19c18
+ #define LE_DB_ACT_CNT_IPV4_A 0x19c20
+ #define LE_DB_ACT_CNT_IPV6_A 0x19c24
+ #define LE_DB_HASH_TID_BASE_A 0x19c30
+ #define LE_DB_HASH_TBL_BASE_ADDR_A 0x19c30
++>>>>>>> a4011fd470d3 (cxgb4: Add debugfs support to dump tid info)
  #define LE_DB_INT_CAUSE_A 0x19c3c
 -#define LE_DB_TID_HASHBASE_A 0x19df8
 -#define T6_LE_DB_HASH_TID_BASE_A 0x19df8
 -
 -#define HASHEN_S    20
 -#define HASHEN_V(x) ((x) << HASHEN_S)
 -#define HASHEN_F    HASHEN_V(1U)
  
  #define REQQPARERR_S    16
  #define REQQPARERR_V(x) ((x) << REQQPARERR_S)
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/sge.c b/drivers/net/ethernet/chelsio/cxgb4/sge.c
index 106fc9f1da68..781c569c5499 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@ -1364,18 +1364,17 @@ static void restart_ctrlq(unsigned long data)
 		struct fw_wr_hdr *wr;
 		unsigned int ndesc = skb->priority;     /* previously saved */
 
-		/*
-		 * Write descriptors and free skbs outside the lock to limit
+		written += ndesc;
+		/* Write descriptors and free skbs outside the lock to limit
 		 * wait times.  q->full is still set so new skbs will be queued.
 		 */
+		wr = (struct fw_wr_hdr *)&q->q.desc[q->q.pidx];
+		txq_advance(&q->q, ndesc);
 		spin_unlock(&q->sendq.lock);
 
-		wr = (struct fw_wr_hdr *)&q->q.desc[q->q.pidx];
 		inline_tx_skb(skb, &q->q, wr);
 		kfree_skb(skb);
 
-		written += ndesc;
-		txq_advance(&q->q, ndesc);
 		if (unlikely(txq_avail(&q->q) < TXQ_STOP_THRES)) {
 			unsigned long old = q->q.stops;
 
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
