staging/rdma/hfi1: Remove unnecessary duplicated variable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Remove unnecessary duplicated variable (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 92.45%
commit-author Mitko Haralanov <mitko.haralanov@intel.com>
commit 2780739262e32b9c283b6b04f7899f9803993ebc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/27807392.failed

struct hfi1_devdata contained 2 variables which represented the numa
node the device is attached to.  Remove the duplicated one.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Mitko Haralanov <mitko.haralanov@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2780739262e32b9c283b6b04f7899f9803993ebc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/verbs.c
diff --cc drivers/staging/hfi1/verbs.c
index d228eb7fc4f0,d617324e3c48..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -2000,13 -1520,71 +2000,79 @@@ int hfi1_register_ib_device(struct hfi1
  	strncpy(ibdev->node_desc, init_utsname()->nodename,
  		sizeof(ibdev->node_desc));
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ret = ib_register_device(ibdev, hfi1_create_port_files);
++=======
+ 	/*
+ 	 * Fill in rvt info object.
+ 	 */
+ 	dd->verbs_dev.rdi.driver_f.port_callback = hfi1_create_port_files;
+ 	dd->verbs_dev.rdi.driver_f.get_card_name = get_card_name;
+ 	dd->verbs_dev.rdi.driver_f.get_pci_dev = get_pci_dev;
+ 	dd->verbs_dev.rdi.driver_f.check_ah = hfi1_check_ah;
+ 	dd->verbs_dev.rdi.driver_f.notify_new_ah = hfi1_notify_new_ah;
+ 	/*
+ 	 * Fill in rvt info device attributes.
+ 	 */
+ 	hfi1_fill_device_attr(dd);
+ 
+ 	/* queue pair */
+ 	dd->verbs_dev.rdi.dparms.qp_table_size = hfi1_qp_table_size;
+ 	dd->verbs_dev.rdi.dparms.qpn_start = 0;
+ 	dd->verbs_dev.rdi.dparms.qpn_inc = 1;
+ 	dd->verbs_dev.rdi.dparms.qos_shift = dd->qos_shift;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_start = kdeth_qp << 16;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_end =
+ 	dd->verbs_dev.rdi.dparms.qpn_res_start + 65535;
+ 	dd->verbs_dev.rdi.dparms.max_rdma_atomic = HFI1_MAX_RDMA_ATOMIC;
+ 	dd->verbs_dev.rdi.dparms.psn_mask = PSN_MASK;
+ 	dd->verbs_dev.rdi.dparms.psn_shift = PSN_SHIFT;
+ 	dd->verbs_dev.rdi.dparms.psn_modify_mask = PSN_MODIFY_MASK;
+ 	dd->verbs_dev.rdi.driver_f.qp_priv_alloc = qp_priv_alloc;
+ 	dd->verbs_dev.rdi.driver_f.qp_priv_free = qp_priv_free;
+ 	dd->verbs_dev.rdi.driver_f.free_all_qps = free_all_qps;
+ 	dd->verbs_dev.rdi.driver_f.notify_qp_reset = notify_qp_reset;
+ 	dd->verbs_dev.rdi.driver_f.do_send = hfi1_do_send;
+ 	dd->verbs_dev.rdi.driver_f.schedule_send = hfi1_schedule_send;
+ 	dd->verbs_dev.rdi.driver_f.get_pmtu_from_attr = get_pmtu_from_attr;
+ 	dd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;
+ 	dd->verbs_dev.rdi.driver_f.flush_qp_waiters = flush_qp_waiters;
+ 	dd->verbs_dev.rdi.driver_f.stop_send_queue = stop_send_queue;
+ 	dd->verbs_dev.rdi.driver_f.quiesce_qp = quiesce_qp;
+ 	dd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;
+ 	dd->verbs_dev.rdi.driver_f.mtu_from_qp = mtu_from_qp;
+ 	dd->verbs_dev.rdi.driver_f.mtu_to_path_mtu = mtu_to_path_mtu;
+ 	dd->verbs_dev.rdi.driver_f.check_modify_qp = hfi1_check_modify_qp;
+ 	dd->verbs_dev.rdi.driver_f.modify_qp = hfi1_modify_qp;
+ 	dd->verbs_dev.rdi.driver_f.check_send_wr = hfi1_check_send_wr;
+ 
+ 	/* completeion queue */
+ 	snprintf(dd->verbs_dev.rdi.dparms.cq_name,
+ 		 sizeof(dd->verbs_dev.rdi.dparms.cq_name),
+ 		 "hfi1_cq%d", dd->unit);
+ 	dd->verbs_dev.rdi.dparms.node = dd->node;
+ 
+ 	/* misc settings */
+ 	dd->verbs_dev.rdi.flags = 0; /* Let rdmavt handle it all */
+ 	dd->verbs_dev.rdi.dparms.lkey_table_size = hfi1_lkey_table_size;
+ 	dd->verbs_dev.rdi.dparms.nports = dd->num_pports;
+ 	dd->verbs_dev.rdi.dparms.npkeys = hfi1_get_npkeys(dd);
+ 
+ 	ppd = dd->pport;
+ 	for (i = 0; i < dd->num_pports; i++, ppd++)
+ 		rvt_init_port(&dd->verbs_dev.rdi,
+ 			      &ppd->ibport_data.rvp,
+ 			      i,
+ 			      ppd->pkeys);
+ 
+ 	ret = rvt_register_device(&dd->verbs_dev.rdi);
++>>>>>>> 2780739262e3 (staging/rdma/hfi1: Remove unnecessary duplicated variable):drivers/staging/rdma/hfi1/verbs.c
  	if (ret)
 -		goto err_verbs_txreq;
 +		goto err_reg;
 +
 +	ret = hfi1_create_agents(dev);
 +	if (ret)
 +		goto err_agents;
  
  	ret = hfi1_verbs_register_sysfs(dd);
  	if (ret)
diff --git a/drivers/staging/hfi1/hfi.h b/drivers/staging/hfi1/hfi.h
index 8c6839cc9104..d0dab62f4f86 100644
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@ -1121,7 +1121,6 @@ struct hfi1_devdata {
 	struct timer_list rcverr_timer;
 	u32 rcv_ovfl_cnt;
 
-	int assigned_node_id;
 	wait_queue_head_t event_queue;
 
 	/* Save the enabled LCB error bits */
diff --git a/drivers/staging/hfi1/init.c b/drivers/staging/hfi1/init.c
index a3dd5b341034..628a21ad2197 100644
--- a/drivers/staging/hfi1/init.c
+++ b/drivers/staging/hfi1/init.c
@@ -128,15 +128,10 @@ int hfi1_create_ctxts(struct hfi1_devdata *dd)
 {
 	unsigned i;
 	int ret;
-	int local_node_id = pcibus_to_node(dd->pcidev->bus);
 
 	/* Control context has to be always 0 */
 	BUILD_BUG_ON(HFI1_CTRL_CTXT != 0);
 
-	if (local_node_id < 0)
-		local_node_id = numa_node_id();
-	dd->assigned_node_id = local_node_id;
-
 	dd->rcd = kcalloc(dd->num_rcv_contexts, sizeof(*dd->rcd), GFP_KERNEL);
 	if (!dd->rcd)
 		goto nomem;
diff --git a/drivers/staging/hfi1/qp.h b/drivers/staging/hfi1/qp.h
index 1144470a6bc0..0a40508bc4e4 100644
--- a/drivers/staging/hfi1/qp.h
+++ b/drivers/staging/hfi1/qp.h
@@ -268,7 +268,7 @@ static inline void _hfi1_schedule_send(struct hfi1_qp *qp)
 	iowait_schedule(&priv->s_iowait, ppd->hfi1_wq,
 			priv->s_sde ?
 			priv->s_sde->cpu :
-			cpumask_first(cpumask_of_node(dd->assigned_node_id)));
+			cpumask_first(cpumask_of_node(dd->node)));
 }
 
 /**
* Unmerged path drivers/staging/hfi1/verbs.c
