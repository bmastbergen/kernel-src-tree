firmware: Introduce request_firmware_direct()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [firmware] Introduce request_firmware_direct() (Prarit Bhargava) [1340431]
Rebuild_FUZZ: 87.50%
commit-author Takashi Iwai <tiwai@suse.de>
commit bba3a87e982ad5992e776ca1fc409326915d6b44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bba3a87e.failed

When CONFIG_FW_LOADER_USER_HELPER is set, request_firmware() falls
back to the usermode helper for loading via udev when the direct
loading fails.  But the recent udev takes way too long timeout (60
seconds) for non-existing firmware.  This is unacceptable for the
drivers like microcode loader where they load firmwares optionally,
i.e. it's no error even if no requested file exists.

This patch provides a new helper function, request_firmware_direct().
It behaves as same as request_firmware() except for that it doesn't
fall back to usermode helper but returns an error immediately if the
f/w can't be loaded directly in kernel.

Without CONFIG_FW_LOADER_USER_HELPER=y, request_firmware_direct() is
just an alias of request_firmware(), due to obvious reason.

	Tested-by: Prarit Bhargava <prarit@redhat.com>
	Acked-by: Ming Lei <ming.lei@canonical.com>
	Acked-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bba3a87e982ad5992e776ca1fc409326915d6b44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/firmware_class.c
diff --cc drivers/base/firmware_class.c
index 01e21037d8fe,1af03648daf8..000000000000
--- a/drivers/base/firmware_class.c
+++ b/drivers/base/firmware_class.c
@@@ -1044,11 -1093,21 +1044,27 @@@ _request_firmware(const struct firmwar
  		}
  	}
  
++<<<<<<< HEAD
 +	if (!fw_get_filesystem_firmware(device, fw->priv))
 +		ret = fw_load_from_user_helper(fw, name, device,
 +					       uevent, nowait, timeout);
++=======
+ 	ret = fw_get_filesystem_firmware(device, fw->priv);
+ 	if (ret) {
+ 		if (fallback) {
+ 			dev_warn(device,
+ 				 "Direct firmware load failed with error %d\n",
+ 				 ret);
+ 			dev_warn(device, "Falling back to user helper\n");
+ 			ret = fw_load_from_user_helper(fw, name, device,
+ 					       uevent, nowait, timeout);
+ 		}
+ 	}
+ 
+ 	/* don't cache firmware handled without uevent */
++>>>>>>> bba3a87e982a (firmware: Introduce request_firmware_direct())
  	if (!ret)
 -		ret = assign_firmware_buf(fw, device, !uevent);
 +		ret = assign_firmware_buf(fw, device);
  
  	usermodehelper_read_unlock();
  
@@@ -1086,8 -1145,39 +1102,42 @@@ in
  request_firmware(const struct firmware **firmware_p, const char *name,
                   struct device *device)
  {
++<<<<<<< HEAD
 +	return _request_firmware(firmware_p, name, device, true, false);
++=======
+ 	int ret;
+ 
+ 	/* Need to pin this module until return */
+ 	__module_get(THIS_MODULE);
+ 	ret = _request_firmware(firmware_p, name, device, true, false, true);
+ 	module_put(THIS_MODULE);
+ 	return ret;
++>>>>>>> bba3a87e982a (firmware: Introduce request_firmware_direct())
+ }
 -EXPORT_SYMBOL(request_firmware);
+ 
+ #ifdef CONFIG_FW_LOADER_USER_HELPER
+ /**
+  * request_firmware: - load firmware directly without usermode helper
+  * @firmware_p: pointer to firmware image
+  * @name: name of firmware file
+  * @device: device for which firmware is being loaded
+  *
+  * This function works pretty much like request_firmware(), but this doesn't
+  * fall back to usermode helper even if the firmware couldn't be loaded
+  * directly from fs.  Hence it's useful for loading optional firmwares, which
+  * aren't always present, without extra long timeouts of udev.
+  **/
+ int request_firmware_direct(const struct firmware **firmware_p,
+ 			    const char *name, struct device *device)
+ {
+ 	int ret;
+ 	__module_get(THIS_MODULE);
+ 	ret = _request_firmware(firmware_p, name, device, true, false, false);
+ 	module_put(THIS_MODULE);
+ 	return ret;
  }
+ EXPORT_SYMBOL_GPL(request_firmware_direct);
+ #endif
  
  /**
   * release_firmware: - release the resource associated with a firmware image
* Unmerged path drivers/base/firmware_class.c
diff --git a/include/linux/firmware.h b/include/linux/firmware.h
index e4279fedb93a..186c6ffe4318 100644
--- a/include/linux/firmware.h
+++ b/include/linux/firmware.h
@@ -79,4 +79,11 @@ static inline int uncache_firmware(const char *name)
 }
 #endif
 
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+int request_firmware_direct(const struct firmware **fw, const char *name,
+			    struct device *device);
+#else
+#define request_firmware_direct	request_firmware
+#endif
+
 #endif
