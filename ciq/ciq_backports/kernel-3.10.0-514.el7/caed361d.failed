drm/i915: Fix watermarks for VLV/CHV

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915: Fix watermarks for VLV/CHV (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 94.12%
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit caed361d83b204b7766924b80463bf7502ee7986
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/caed361d.failed

commit 92826fcdfc14 ("drm/i915: Calculate watermark related members in the crtc_state, v4.")
broke thigns by removing the pre vs. post wm update distinction. We also
lost the pre plane wm update entirely for VLV/CHV from the crtc enable
path.

This caused underruns on modeset and plane enable/disable on CHV,
and often those can lead to a dead pipe.

So let's bring back the pre vs. post thing, and let's toss in an
explicit wm update to valleyview_crtc_enable() to avoid having to
put it into the common code.

This is more or less a partial revert of the offending commit.

	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Cc: drm-intel-fixes@lists.freedesktop.org
Fixes: 92826fcdfc14 ("drm/i915: Calculate watermark related members in the crtc_state, v4.")
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1457543247-13987-4-git-send-email-ville.syrjala@linux.intel.com
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
(cherry picked from commit caed361d83b204b7766924b80463bf7502ee7986)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_atomic.c
#	drivers/gpu/drm/i915/intel_display.c
#	drivers/gpu/drm/i915/intel_drv.h
diff --cc drivers/gpu/drm/i915/intel_atomic.c
index 3903b90fb64e,79448f1c8b8d..000000000000
--- a/drivers/gpu/drm/i915/intel_atomic.c
+++ b/drivers/gpu/drm/i915/intel_atomic.c
@@@ -213,17 -85,21 +213,29 @@@ intel_connector_atomic_get_property(str
  struct drm_crtc_state *
  intel_crtc_duplicate_state(struct drm_crtc *crtc)
  {
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
  	struct intel_crtc_state *crtc_state;
  
 -	crtc_state = kmemdup(crtc->state, sizeof(*crtc_state), GFP_KERNEL);
 -	if (!crtc_state)
 -		return NULL;
 +	if (WARN_ON(!intel_crtc->config))
 +		crtc_state = kzalloc(sizeof(*crtc_state), GFP_KERNEL);
 +	else
 +		crtc_state = kmemdup(intel_crtc->config,
 +				     sizeof(*intel_crtc->config), GFP_KERNEL);
  
++<<<<<<< HEAD
 +	if (crtc_state)
 +		crtc_state->base.crtc = crtc;
++=======
+ 	__drm_atomic_helper_crtc_duplicate_state(crtc, &crtc_state->base);
+ 
+ 	crtc_state->update_pipe = false;
+ 	crtc_state->disable_lp_wm = false;
+ 	crtc_state->disable_cxsr = false;
+ 	crtc_state->update_wm_pre = false;
+ 	crtc_state->update_wm_post = false;
+ 	crtc_state->fb_changed = false;
+ 	crtc_state->wm.need_postvbl_update = false;
++>>>>>>> caed361d83b2 (drm/i915: Fix watermarks for VLV/CHV)
  
  	return &crtc_state->base;
  }
diff --cc drivers/gpu/drm/i915/intel_display.c
index e2e955a9df5d,860c53063c9b..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -4486,17 -4633,147 +4486,128 @@@ static void intel_crtc_disable_planes(s
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
  	int pipe = intel_crtc->pipe;
  
 -	/*
 -	 * Gen2 reports pipe underruns whenever all planes are disabled.
 -	 * So diasble underrun reporting before all the planes get disabled.
 -	 * FIXME: Need to fix the logic to work when we turn off all planes
 -	 * but leave the pipe running.
 -	 */
 -	if (IS_GEN2(dev))
 -		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);
 +	intel_crtc_wait_for_pending_flips(crtc);
  
 -	/*
 -	 * Vblank time updates from the shadow to live plane control register
 -	 * are blocked if the memory self-refresh mode is active at that
 -	 * moment. So to make sure the plane gets truly disabled, disable
 -	 * first the self-refresh mode. The self-refresh enable bit in turn
 -	 * will be checked/applied by the HW only at the next frame start
 -	 * event which is after the vblank start event, so we need to have a
 -	 * wait-for-vblank between disabling the plane and the pipe.
 -	 */
 -	if (HAS_GMCH_DISPLAY(dev)) {
 -		intel_set_memory_cxsr(dev_priv, false);
 -		dev_priv->wm.vlv.cxsr = false;
 -		intel_wait_for_vblank(dev, pipe);
 -	}
 +	if (dev_priv->fbc.crtc == intel_crtc)
 +		intel_fbc_disable(dev);
  
 -	/*
 -	 * FIXME IPS should be fine as long as one plane is
 -	 * enabled, but in practice it seems to have problems
 -	 * when going from primary only to sprite only and vice
 -	 * versa.
 -	 */
  	hsw_disable_ips(intel_crtc);
 -}
  
++<<<<<<< HEAD
 +	intel_crtc_dpms_overlay(intel_crtc, false);
 +	intel_crtc_update_cursor(crtc, false);
 +	intel_disable_sprite_planes(crtc);
 +	intel_disable_primary_hw_plane(crtc->primary, crtc);
++=======
+ static void intel_post_plane_update(struct intel_crtc *crtc)
+ {
+ 	struct intel_crtc_atomic_commit *atomic = &crtc->atomic;
+ 	struct intel_crtc_state *pipe_config =
+ 		to_intel_crtc_state(crtc->base.state);
+ 	struct drm_device *dev = crtc->base.dev;
+ 
+ 	intel_frontbuffer_flip(dev, atomic->fb_bits);
+ 
+ 	crtc->wm.cxsr_allowed = true;
+ 
+ 	if (pipe_config->update_wm_post && pipe_config->base.active)
+ 		intel_update_watermarks(&crtc->base);
+ 
+ 	if (atomic->update_fbc)
+ 		intel_fbc_post_update(crtc);
+ 
+ 	if (atomic->post_enable_primary)
+ 		intel_post_enable_primary(&crtc->base);
+ 
+ 	memset(atomic, 0, sizeof(*atomic));
+ }
+ 
+ static void intel_pre_plane_update(struct intel_crtc_state *old_crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(old_crtc_state->base.crtc);
+ 	struct drm_device *dev = crtc->base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_crtc_atomic_commit *atomic = &crtc->atomic;
+ 	struct intel_crtc_state *pipe_config =
+ 		to_intel_crtc_state(crtc->base.state);
+ 	struct drm_atomic_state *old_state = old_crtc_state->base.state;
+ 	struct drm_plane *primary = crtc->base.primary;
+ 	struct drm_plane_state *old_pri_state =
+ 		drm_atomic_get_existing_plane_state(old_state, primary);
+ 	bool modeset = needs_modeset(&pipe_config->base);
+ 
+ 	if (atomic->update_fbc)
+ 		intel_fbc_pre_update(crtc);
+ 
+ 	if (old_pri_state) {
+ 		struct intel_plane_state *primary_state =
+ 			to_intel_plane_state(primary->state);
+ 		struct intel_plane_state *old_primary_state =
+ 			to_intel_plane_state(old_pri_state);
+ 
+ 		if (old_primary_state->visible &&
+ 		    (modeset || !primary_state->visible))
+ 			intel_pre_disable_primary(&crtc->base);
+ 	}
+ 
+ 	if (pipe_config->disable_cxsr) {
+ 		crtc->wm.cxsr_allowed = false;
+ 
+ 		if (old_crtc_state->base.active)
+ 			intel_set_memory_cxsr(dev_priv, false);
+ 	}
+ 
+ 	/*
+ 	 * IVB workaround: must disable low power watermarks for at least
+ 	 * one frame before enabling scaling.  LP watermarks can be re-enabled
+ 	 * when scaling is disabled.
+ 	 *
+ 	 * WaCxSRDisabledForSpriteScaling:ivb
+ 	 */
+ 	if (pipe_config->disable_lp_wm) {
+ 		ilk_disable_lp_wm(dev);
+ 		intel_wait_for_vblank(dev, crtc->pipe);
+ 	}
+ 
+ 	/*
+ 	 * If we're doing a modeset, we're done.  No need to do any pre-vblank
+ 	 * watermark programming here.
+ 	 */
+ 	if (needs_modeset(&pipe_config->base))
+ 		return;
+ 
+ 	/*
+ 	 * For platforms that support atomic watermarks, program the
+ 	 * 'intermediate' watermarks immediately.  On pre-gen9 platforms, these
+ 	 * will be the intermediate values that are safe for both pre- and
+ 	 * post- vblank; when vblank happens, the 'active' values will be set
+ 	 * to the final 'target' values and we'll do this again to get the
+ 	 * optimal watermarks.  For gen9+ platforms, the values we program here
+ 	 * will be the final target values which will get automatically latched
+ 	 * at vblank time; no further programming will be necessary.
+ 	 *
+ 	 * If a platform hasn't been transitioned to atomic watermarks yet,
+ 	 * we'll continue to update watermarks the old way, if flags tell
+ 	 * us to.
+ 	 */
+ 	if (dev_priv->display.initial_watermarks != NULL)
+ 		dev_priv->display.initial_watermarks(pipe_config);
+ 	else if (pipe_config->update_wm_pre)
+ 		intel_update_watermarks(&crtc->base);
+ }
+ 
+ static void intel_crtc_disable_planes(struct drm_crtc *crtc, unsigned plane_mask)
+ {
+ 	struct drm_device *dev = crtc->dev;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+ 	struct drm_plane *p;
+ 	int pipe = intel_crtc->pipe;
+ 
+ 	intel_crtc_dpms_overlay_disable(intel_crtc);
+ 
+ 	drm_for_each_plane_mask(p, dev, plane_mask)
+ 		to_intel_plane(p)->disable_plane(p, crtc);
++>>>>>>> caed361d83b2 (drm/i915: Fix watermarks for VLV/CHV)
  
  	/*
  	 * FIXME: Once we grow proper nuclear flip support out of this we need
@@@ -10371,7 -11675,280 +10482,284 @@@ out_hang
  	return ret;
  }
  
++<<<<<<< HEAD
 +static struct drm_crtc_helper_funcs intel_helper_funcs = {
++=======
+ 
+ /**
+  * intel_wm_need_update - Check whether watermarks need updating
+  * @plane: drm plane
+  * @state: new plane state
+  *
+  * Check current plane state versus the new one to determine whether
+  * watermarks need to be recalculated.
+  *
+  * Returns true or false.
+  */
+ static bool intel_wm_need_update(struct drm_plane *plane,
+ 				 struct drm_plane_state *state)
+ {
+ 	struct intel_plane_state *new = to_intel_plane_state(state);
+ 	struct intel_plane_state *cur = to_intel_plane_state(plane->state);
+ 
+ 	/* Update watermarks on tiling or size changes. */
+ 	if (new->visible != cur->visible)
+ 		return true;
+ 
+ 	if (!cur->base.fb || !new->base.fb)
+ 		return false;
+ 
+ 	if (cur->base.fb->modifier[0] != new->base.fb->modifier[0] ||
+ 	    cur->base.rotation != new->base.rotation ||
+ 	    drm_rect_width(&new->src) != drm_rect_width(&cur->src) ||
+ 	    drm_rect_height(&new->src) != drm_rect_height(&cur->src) ||
+ 	    drm_rect_width(&new->dst) != drm_rect_width(&cur->dst) ||
+ 	    drm_rect_height(&new->dst) != drm_rect_height(&cur->dst))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool needs_scaling(struct intel_plane_state *state)
+ {
+ 	int src_w = drm_rect_width(&state->src) >> 16;
+ 	int src_h = drm_rect_height(&state->src) >> 16;
+ 	int dst_w = drm_rect_width(&state->dst);
+ 	int dst_h = drm_rect_height(&state->dst);
+ 
+ 	return (src_w != dst_w || src_h != dst_h);
+ }
+ 
+ int intel_plane_atomic_calc_changes(struct drm_crtc_state *crtc_state,
+ 				    struct drm_plane_state *plane_state)
+ {
+ 	struct intel_crtc_state *pipe_config = to_intel_crtc_state(crtc_state);
+ 	struct drm_crtc *crtc = crtc_state->crtc;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+ 	struct drm_plane *plane = plane_state->plane;
+ 	struct drm_device *dev = crtc->dev;
+ 	struct drm_i915_private *dev_priv = to_i915(dev);
+ 	struct intel_plane_state *old_plane_state =
+ 		to_intel_plane_state(plane->state);
+ 	int idx = intel_crtc->base.base.id, ret;
+ 	bool mode_changed = needs_modeset(crtc_state);
+ 	bool was_crtc_enabled = crtc->state->active;
+ 	bool is_crtc_enabled = crtc_state->active;
+ 	bool turn_off, turn_on, visible, was_visible;
+ 	struct drm_framebuffer *fb = plane_state->fb;
+ 
+ 	if (crtc_state && INTEL_INFO(dev)->gen >= 9 &&
+ 	    plane->type != DRM_PLANE_TYPE_CURSOR) {
+ 		ret = skl_update_scaler_plane(
+ 			to_intel_crtc_state(crtc_state),
+ 			to_intel_plane_state(plane_state));
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	was_visible = old_plane_state->visible;
+ 	visible = to_intel_plane_state(plane_state)->visible;
+ 
+ 	if (!was_crtc_enabled && WARN_ON(was_visible))
+ 		was_visible = false;
+ 
+ 	/*
+ 	 * Visibility is calculated as if the crtc was on, but
+ 	 * after scaler setup everything depends on it being off
+ 	 * when the crtc isn't active.
+ 	 */
+ 	if (!is_crtc_enabled)
+ 		to_intel_plane_state(plane_state)->visible = visible = false;
+ 
+ 	if (!was_visible && !visible)
+ 		return 0;
+ 
+ 	if (fb != old_plane_state->base.fb)
+ 		pipe_config->fb_changed = true;
+ 
+ 	turn_off = was_visible && (!visible || mode_changed);
+ 	turn_on = visible && (!was_visible || mode_changed);
+ 
+ 	DRM_DEBUG_ATOMIC("[CRTC:%i] has [PLANE:%i] with fb %i\n", idx,
+ 			 plane->base.id, fb ? fb->base.id : -1);
+ 
+ 	DRM_DEBUG_ATOMIC("[PLANE:%i] visible %i -> %i, off %i, on %i, ms %i\n",
+ 			 plane->base.id, was_visible, visible,
+ 			 turn_off, turn_on, mode_changed);
+ 
+ 	if (turn_on) {
+ 		pipe_config->update_wm_pre = true;
+ 
+ 		/* must disable cxsr around plane enable/disable */
+ 		if (plane->type != DRM_PLANE_TYPE_CURSOR)
+ 			pipe_config->disable_cxsr = true;
+ 	} else if (turn_off) {
+ 		pipe_config->update_wm_post = true;
+ 
+ 		/* must disable cxsr around plane enable/disable */
+ 		if (plane->type != DRM_PLANE_TYPE_CURSOR)
+ 			pipe_config->disable_cxsr = true;
+ 	} else if (intel_wm_need_update(plane, plane_state)) {
+ 		/* FIXME bollocks */
+ 		pipe_config->update_wm_pre = true;
+ 		pipe_config->update_wm_post = true;
+ 	}
+ 
+ 	/* Pre-gen9 platforms need two-step watermark updates */
+ 	if ((pipe_config->update_wm_pre || pipe_config->update_wm_post) &&
+ 	    INTEL_INFO(dev)->gen < 9 && dev_priv->display.optimize_watermarks)
+ 		to_intel_crtc_state(crtc_state)->wm.need_postvbl_update = true;
+ 
+ 	if (visible || was_visible)
+ 		intel_crtc->atomic.fb_bits |=
+ 			to_intel_plane(plane)->frontbuffer_bit;
+ 
+ 	switch (plane->type) {
+ 	case DRM_PLANE_TYPE_PRIMARY:
+ 		intel_crtc->atomic.post_enable_primary = turn_on;
+ 		intel_crtc->atomic.update_fbc = true;
+ 
+ 		break;
+ 	case DRM_PLANE_TYPE_CURSOR:
+ 		break;
+ 	case DRM_PLANE_TYPE_OVERLAY:
+ 		/*
+ 		 * WaCxSRDisabledForSpriteScaling:ivb
+ 		 *
+ 		 * cstate->update_wm was already set above, so this flag will
+ 		 * take effect when we commit and program watermarks.
+ 		 */
+ 		if (IS_IVYBRIDGE(dev) &&
+ 		    needs_scaling(to_intel_plane_state(plane_state)) &&
+ 		    !needs_scaling(old_plane_state))
+ 			pipe_config->disable_lp_wm = true;
+ 
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static bool encoders_cloneable(const struct intel_encoder *a,
+ 			       const struct intel_encoder *b)
+ {
+ 	/* masks could be asymmetric, so check both ways */
+ 	return a == b || (a->cloneable & (1 << b->type) &&
+ 			  b->cloneable & (1 << a->type));
+ }
+ 
+ static bool check_single_encoder_cloning(struct drm_atomic_state *state,
+ 					 struct intel_crtc *crtc,
+ 					 struct intel_encoder *encoder)
+ {
+ 	struct intel_encoder *source_encoder;
+ 	struct drm_connector *connector;
+ 	struct drm_connector_state *connector_state;
+ 	int i;
+ 
+ 	for_each_connector_in_state(state, connector, connector_state, i) {
+ 		if (connector_state->crtc != &crtc->base)
+ 			continue;
+ 
+ 		source_encoder =
+ 			to_intel_encoder(connector_state->best_encoder);
+ 		if (!encoders_cloneable(encoder, source_encoder))
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static bool check_encoder_cloning(struct drm_atomic_state *state,
+ 				  struct intel_crtc *crtc)
+ {
+ 	struct intel_encoder *encoder;
+ 	struct drm_connector *connector;
+ 	struct drm_connector_state *connector_state;
+ 	int i;
+ 
+ 	for_each_connector_in_state(state, connector, connector_state, i) {
+ 		if (connector_state->crtc != &crtc->base)
+ 			continue;
+ 
+ 		encoder = to_intel_encoder(connector_state->best_encoder);
+ 		if (!check_single_encoder_cloning(state, crtc, encoder))
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static int intel_crtc_atomic_check(struct drm_crtc *crtc,
+ 				   struct drm_crtc_state *crtc_state)
+ {
+ 	struct drm_device *dev = crtc->dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+ 	struct intel_crtc_state *pipe_config =
+ 		to_intel_crtc_state(crtc_state);
+ 	struct drm_atomic_state *state = crtc_state->state;
+ 	int ret;
+ 	bool mode_changed = needs_modeset(crtc_state);
+ 
+ 	if (mode_changed && !check_encoder_cloning(state, intel_crtc)) {
+ 		DRM_DEBUG_KMS("rejecting invalid cloning configuration\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mode_changed && !crtc_state->active)
+ 		pipe_config->update_wm_post = true;
+ 
+ 	if (mode_changed && crtc_state->enable &&
+ 	    dev_priv->display.crtc_compute_clock &&
+ 	    !WARN_ON(pipe_config->shared_dpll)) {
+ 		ret = dev_priv->display.crtc_compute_clock(intel_crtc,
+ 							   pipe_config);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ret = 0;
+ 	if (dev_priv->display.compute_pipe_wm) {
+ 		ret = dev_priv->display.compute_pipe_wm(pipe_config);
+ 		if (ret) {
+ 			DRM_DEBUG_KMS("Target pipe watermarks are invalid\n");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (dev_priv->display.compute_intermediate_wm &&
+ 	    !to_intel_atomic_state(state)->skip_intermediate_wm) {
+ 		if (WARN_ON(!dev_priv->display.compute_pipe_wm))
+ 			return 0;
+ 
+ 		/*
+ 		 * Calculate 'intermediate' watermarks that satisfy both the
+ 		 * old state and the new state.  We can program these
+ 		 * immediately.
+ 		 */
+ 		ret = dev_priv->display.compute_intermediate_wm(crtc->dev,
+ 								intel_crtc,
+ 								pipe_config);
+ 		if (ret) {
+ 			DRM_DEBUG_KMS("No valid intermediate pipe watermarks are possible\n");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (INTEL_INFO(dev)->gen >= 9) {
+ 		if (mode_changed)
+ 			ret = skl_update_scaler_crtc(pipe_config);
+ 
+ 		if (!ret)
+ 			ret = intel_atomic_setup_scalers(dev, intel_crtc,
+ 							 pipe_config);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static const struct drm_crtc_helper_funcs intel_helper_funcs = {
++>>>>>>> caed361d83b2 (drm/i915: Fix watermarks for VLV/CHV)
  	.mode_set_base_atomic = intel_pipe_set_base_atomic,
  	.load_lut = intel_crtc_load_lut,
  	.atomic_begin = intel_begin_crtc_commit,
@@@ -11632,45 -13184,369 +12020,371 @@@ static int __intel_set_mode(struct drm_
  	 * mode set on this crtc.  For other crtcs we need to use the
  	 * adjusted_mode bits in the crtc directly.
  	 */
 -	if (dev_priv->display.modeset_calc_cdclk) {
 -		ret = dev_priv->display.modeset_calc_cdclk(state);
 -
 -		if (!ret && intel_state->dev_cdclk != dev_priv->cdclk_freq)
 -			ret = intel_modeset_all_pipes(state);
 +	if (IS_VALLEYVIEW(dev)) {
 +		valleyview_modeset_global_pipes(dev, &prepare_pipes);
  
 -		if (ret < 0)
 -			return ret;
 -
 -		DRM_DEBUG_KMS("New cdclk calculated to be atomic %u, actual %u\n",
 -			      intel_state->cdclk, intel_state->dev_cdclk);
 -	} else
 -		to_intel_atomic_state(state)->cdclk = dev_priv->atomic_cdclk_freq;
 -
 -	intel_modeset_clear_plls(state);
 +		/* may have added more to prepare_pipes than we should */
 +		prepare_pipes &= ~disable_pipes;
 +	}
  
 -	if (IS_HASWELL(dev_priv))
 -		return haswell_mode_set_planes_workaround(state);
 +	ret = __intel_set_mode_setup_plls(dev, modeset_pipes, disable_pipes);
 +	if (ret)
 +		goto done;
  
 -	return 0;
 -}
 +	for_each_intel_crtc_masked(dev, disable_pipes, intel_crtc)
 +		intel_crtc_disable(&intel_crtc->base);
  
 -/*
 - * Handle calculation of various watermark data at the end of the atomic check
 - * phase.  The code here should be run after the per-crtc and per-plane 'check'
 - * handlers to ensure that all derived state has been updated.
 - */
 -static void calc_watermark_data(struct drm_atomic_state *state)
 -{
 -	struct drm_device *dev = state->dev;
 -	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
 -	struct drm_crtc *crtc;
 -	struct drm_crtc_state *cstate;
 -	struct drm_plane *plane;
 -	struct drm_plane_state *pstate;
 +	for_each_intel_crtc_masked(dev, prepare_pipes, intel_crtc) {
 +		if (intel_crtc->base.state->enable)
 +			dev_priv->display.crtc_disable(&intel_crtc->base);
 +	}
  
 -	/*
 -	 * Calculate watermark configuration details now that derived
 -	 * plane/crtc state is all properly updated.
 +	/* crtc->mode is already used by the ->mode_set callbacks, hence we need
 +	 * to set it here already despite that we pass it down the callchain.
 +	 *
 +	 * Note we'll need to fix this up when we start tracking multiple
 +	 * pipes; here we assume a single modeset_pipe and only track the
 +	 * single crtc and mode.
  	 */
++<<<<<<< HEAD
 +	if (modeset_pipes) {
 +		crtc->mode = *mode;
 +		/* mode_set/enable/disable functions rely on a correct pipe
 +		 * config. */
 +		intel_crtc_set_state(to_intel_crtc(crtc), pipe_config);
 +
 +		/*
 +		 * Calculate and store various constants which
 +		 * are later needed by vblank and swap-completion
 +		 * timestamping. They are derived from true hwmode.
 +		 */
 +		drm_calc_timestamping_constants(crtc,
 +						&pipe_config->base.adjusted_mode);
++=======
+ 	drm_for_each_crtc(crtc, dev) {
+ 		cstate = drm_atomic_get_existing_crtc_state(state, crtc) ?:
+ 			crtc->state;
+ 
+ 		if (cstate->active)
+ 			intel_state->wm_config.num_pipes_active++;
+ 	}
+ 	drm_for_each_legacy_plane(plane, dev) {
+ 		pstate = drm_atomic_get_existing_plane_state(state, plane) ?:
+ 			plane->state;
+ 
+ 		if (!to_intel_plane_state(pstate)->visible)
+ 			continue;
+ 
+ 		intel_state->wm_config.sprites_enabled = true;
+ 		if (pstate->crtc_w != pstate->src_w >> 16 ||
+ 		    pstate->crtc_h != pstate->src_h >> 16)
+ 			intel_state->wm_config.sprites_scaled = true;
+ 	}
+ }
+ 
+ /**
+  * intel_atomic_check - validate state object
+  * @dev: drm device
+  * @state: state to validate
+  */
+ static int intel_atomic_check(struct drm_device *dev,
+ 			      struct drm_atomic_state *state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(dev);
+ 	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
+ 	struct drm_crtc *crtc;
+ 	struct drm_crtc_state *crtc_state;
+ 	int ret, i;
+ 	bool any_ms = false;
+ 
+ 	ret = drm_atomic_helper_check_modeset(dev, state);
+ 	if (ret)
+ 		return ret;
+ 
+ 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+ 		struct intel_crtc_state *pipe_config =
+ 			to_intel_crtc_state(crtc_state);
+ 
+ 		memset(&to_intel_crtc(crtc)->atomic, 0,
+ 		       sizeof(struct intel_crtc_atomic_commit));
+ 
+ 		/* Catch I915_MODE_FLAG_INHERITED */
+ 		if (crtc_state->mode.private_flags != crtc->state->mode.private_flags)
+ 			crtc_state->mode_changed = true;
+ 
+ 		if (!crtc_state->enable) {
+ 			if (needs_modeset(crtc_state))
+ 				any_ms = true;
+ 			continue;
+ 		}
+ 
+ 		if (!needs_modeset(crtc_state))
+ 			continue;
+ 
+ 		/* FIXME: For only active_changed we shouldn't need to do any
+ 		 * state recomputation at all. */
+ 
+ 		ret = drm_atomic_add_affected_connectors(state, crtc);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = intel_modeset_pipe_config(crtc, pipe_config);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if (i915.fastboot &&
+ 		    intel_pipe_config_compare(dev,
+ 					to_intel_crtc_state(crtc->state),
+ 					pipe_config, true)) {
+ 			crtc_state->mode_changed = false;
+ 			to_intel_crtc_state(crtc_state)->update_pipe = true;
+ 		}
+ 
+ 		if (needs_modeset(crtc_state)) {
+ 			any_ms = true;
+ 
+ 			ret = drm_atomic_add_affected_planes(state, crtc);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		intel_dump_pipe_config(to_intel_crtc(crtc), pipe_config,
+ 				       needs_modeset(crtc_state) ?
+ 				       "[modeset]" : "[fastset]");
+ 	}
+ 
+ 	if (any_ms) {
+ 		ret = intel_modeset_checks(state);
+ 
+ 		if (ret)
+ 			return ret;
+ 	} else
+ 		intel_state->cdclk = dev_priv->cdclk_freq;
+ 
+ 	ret = drm_atomic_helper_check_planes(dev, state);
+ 	if (ret)
+ 		return ret;
+ 
+ 	intel_fbc_choose_crtc(dev_priv, state);
+ 	calc_watermark_data(state);
+ 
+ 	return 0;
+ }
+ 
+ static int intel_atomic_prepare_commit(struct drm_device *dev,
+ 				       struct drm_atomic_state *state,
+ 				       bool async)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct drm_plane_state *plane_state;
+ 	struct drm_crtc_state *crtc_state;
+ 	struct drm_plane *plane;
+ 	struct drm_crtc *crtc;
+ 	int i, ret;
+ 
+ 	if (async) {
+ 		DRM_DEBUG_KMS("i915 does not yet support async commit\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+ 		ret = intel_crtc_wait_for_pending_flips(crtc);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if (atomic_read(&to_intel_crtc(crtc)->unpin_work_count) >= 2)
+ 			flush_workqueue(dev_priv->wq);
+ 	}
+ 
+ 	ret = mutex_lock_interruptible(&dev->struct_mutex);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = drm_atomic_helper_prepare_planes(dev, state);
+ 	if (!ret && !async && !i915_reset_in_progress(&dev_priv->gpu_error)) {
+ 		u32 reset_counter;
+ 
+ 		reset_counter = atomic_read(&dev_priv->gpu_error.reset_counter);
+ 		mutex_unlock(&dev->struct_mutex);
+ 
+ 		for_each_plane_in_state(state, plane, plane_state, i) {
+ 			struct intel_plane_state *intel_plane_state =
+ 				to_intel_plane_state(plane_state);
+ 
+ 			if (!intel_plane_state->wait_req)
+ 				continue;
+ 
+ 			ret = __i915_wait_request(intel_plane_state->wait_req,
+ 						  reset_counter, true,
+ 						  NULL, NULL);
+ 
+ 			/* Swallow -EIO errors to allow updates during hw lockup. */
+ 			if (ret == -EIO)
+ 				ret = 0;
+ 
+ 			if (ret)
+ 				break;
+ 		}
+ 
+ 		if (!ret)
+ 			return 0;
+ 
+ 		mutex_lock(&dev->struct_mutex);
+ 		drm_atomic_helper_cleanup_planes(dev, state);
+ 	}
+ 
+ 	mutex_unlock(&dev->struct_mutex);
+ 	return ret;
+ }
+ 
+ static void intel_atomic_wait_for_vblanks(struct drm_device *dev,
+ 					  struct drm_i915_private *dev_priv,
+ 					  unsigned crtc_mask)
+ {
+ 	unsigned last_vblank_count[I915_MAX_PIPES];
+ 	enum pipe pipe;
+ 	int ret;
+ 
+ 	if (!crtc_mask)
+ 		return;
+ 
+ 	for_each_pipe(dev_priv, pipe) {
+ 		struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
+ 
+ 		if (!((1 << pipe) & crtc_mask))
+ 			continue;
+ 
+ 		ret = drm_crtc_vblank_get(crtc);
+ 		if (WARN_ON(ret != 0)) {
+ 			crtc_mask &= ~(1 << pipe);
+ 			continue;
+ 		}
+ 
+ 		last_vblank_count[pipe] = drm_crtc_vblank_count(crtc);
+ 	}
+ 
+ 	for_each_pipe(dev_priv, pipe) {
+ 		struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
+ 		long lret;
+ 
+ 		if (!((1 << pipe) & crtc_mask))
+ 			continue;
+ 
+ 		lret = wait_event_timeout(dev->vblank[pipe].queue,
+ 				last_vblank_count[pipe] !=
+ 					drm_crtc_vblank_count(crtc),
+ 				msecs_to_jiffies(50));
+ 
+ 		WARN_ON(!lret);
+ 
+ 		drm_crtc_vblank_put(crtc);
+ 	}
+ }
+ 
+ static bool needs_vblank_wait(struct intel_crtc_state *crtc_state)
+ {
+ 	/* fb updated, need to unpin old fb */
+ 	if (crtc_state->fb_changed)
+ 		return true;
+ 
+ 	/* wm changes, need vblank before final wm's */
+ 	if (crtc_state->update_wm_post)
+ 		return true;
+ 
+ 	/*
+ 	 * cxsr is re-enabled after vblank.
+ 	 * This is already handled by crtc_state->update_wm_post,
+ 	 * but added for clarity.
+ 	 */
+ 	if (crtc_state->disable_cxsr)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /**
+  * intel_atomic_commit - commit validated state object
+  * @dev: DRM device
+  * @state: the top-level driver state object
+  * @async: asynchronous commit
+  *
+  * This function commits a top-level state object that has been validated
+  * with drm_atomic_helper_check().
+  *
+  * FIXME:  Atomic modeset support for i915 is not yet complete.  At the moment
+  * we can only handle plane-related operations and do not yet support
+  * asynchronous commit.
+  *
+  * RETURNS
+  * Zero for success or -errno.
+  */
+ static int intel_atomic_commit(struct drm_device *dev,
+ 			       struct drm_atomic_state *state,
+ 			       bool async)
+ {
+ 	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct drm_crtc_state *crtc_state;
+ 	struct drm_crtc *crtc;
+ 	struct intel_crtc_state *intel_cstate;
+ 	int ret = 0, i;
+ 	bool hw_check = intel_state->modeset;
+ 	unsigned long put_domains[I915_MAX_PIPES] = {};
+ 	unsigned crtc_vblank_mask = 0;
+ 
+ 	ret = intel_atomic_prepare_commit(dev, state, async);
+ 	if (ret) {
+ 		DRM_DEBUG_ATOMIC("Preparing state failed with %i\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	drm_atomic_helper_swap_state(dev, state);
+ 	dev_priv->wm.config = to_intel_atomic_state(state)->wm_config;
+ 
+ 	if (intel_state->modeset) {
+ 		memcpy(dev_priv->min_pixclk, intel_state->min_pixclk,
+ 		       sizeof(intel_state->min_pixclk));
+ 		dev_priv->active_crtcs = intel_state->active_crtcs;
+ 		dev_priv->atomic_cdclk_freq = intel_state->cdclk;
+ 
+ 		intel_display_power_get(dev_priv, POWER_DOMAIN_MODESET);
+ 	}
+ 
+ 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+ 		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+ 
+ 		if (needs_modeset(crtc->state) ||
+ 		    to_intel_crtc_state(crtc->state)->update_pipe) {
+ 			hw_check = true;
+ 
+ 			put_domains[to_intel_crtc(crtc)->pipe] =
+ 				modeset_get_crtc_power_domains(crtc,
+ 					to_intel_crtc_state(crtc->state));
+ 		}
+ 
+ 		if (!needs_modeset(crtc->state))
+ 			continue;
+ 
+ 		intel_pre_plane_update(to_intel_crtc_state(crtc_state));
+ 
+ 		if (crtc_state->active) {
+ 			intel_crtc_disable_planes(crtc, crtc_state->plane_mask);
+ 			dev_priv->display.crtc_disable(crtc);
+ 			intel_crtc->active = false;
+ 			intel_fbc_disable(intel_crtc);
+ 			intel_disable_shared_dpll(intel_crtc);
+ 
+ 			/*
+ 			 * Underruns don't always raise
+ 			 * interrupts, so check manually.
+ 			 */
+ 			intel_check_cpu_fifo_underruns(dev_priv);
+ 			intel_check_pch_fifo_underruns(dev_priv);
+ 
+ 			if (!crtc->state->active)
+ 				intel_update_watermarks(crtc);
+ 		}
++>>>>>>> caed361d83b2 (drm/i915: Fix watermarks for VLV/CHV)
  	}
  
  	/* Only after disabling all output pipelines that will be changed can we
diff --cc drivers/gpu/drm/i915/intel_drv.h
index 640e923ced09,02b3d22862a1..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -274,9 -416,13 +274,17 @@@ struct intel_crtc_state 
  	 * accordingly.
  	 */
  #define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS	(1<<0) /* unreliable sync mode.flags */
 +#define PIPE_CONFIG_QUIRK_INHERITED_MODE	(1<<1) /* mode inherited from firmware */
  	unsigned long quirks;
  
++<<<<<<< HEAD
++=======
+ 	bool update_pipe; /* can a fast modeset be performed? */
+ 	bool disable_cxsr;
+ 	bool update_wm_pre, update_wm_post; /* watermarks are updated */
+ 	bool fb_changed; /* fb on any of the planes is changed */
+ 
++>>>>>>> caed361d83b2 (drm/i915: Fix watermarks for VLV/CHV)
  	/* Pipe source size (ie. panel fitter input size)
  	 * All planes will be positioned inside this space,
  	 * and get clipped at the edges. */
* Unmerged path drivers/gpu/drm/i915/intel_atomic.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
