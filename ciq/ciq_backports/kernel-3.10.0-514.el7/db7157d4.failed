qla2xxx: Fix shost use-after-free on device removal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Joe Lawrence <joe.lawrence@stratus.com>
commit db7157d4cfce6edf052452fb1d327d4d11b67f4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/db7157d4.failed

Once calling scsi_host_put, be careful to not access qla_hw_data through
the Scsi_Host private data (ie, scsi_qla_host base_vha).

Fixes: fe1b806f4f71 ("qla2xxx: Refactor shutdown code so some functionality can be reused")
	Cc: stable@vger.kernel.org # 3.14, 3.15, 3.16
	Signed-off-by: Joe Lawrence <joe.lawrence@stratus.com>
	Acked-by: Chad Dupuis <chad.dupuis@qlogic.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit db7157d4cfce6edf052452fb1d327d4d11b67f4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index d474e1847a2b,8252c0e6682c..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -3182,8 -3116,85 +3182,90 @@@ qla2x00_remove_one(struct pci_dev *pdev
  		if ((IS_QLA83XX(ha) || IS_QLA27XX(ha)) && ha->msixbase)
  			iounmap(ha->msixbase);
  	}
++<<<<<<< HEAD
 +
 +	scsi_host_put(base_vha->host);
++=======
+ }
+ 
+ static void
+ qla2x00_clear_drv_active(struct qla_hw_data *ha)
+ {
+ 	if (IS_QLA8044(ha)) {
+ 		qla8044_idc_lock(ha);
+ 		qla8044_clear_drv_active(ha);
+ 		qla8044_idc_unlock(ha);
+ 	} else if (IS_QLA82XX(ha)) {
+ 		qla82xx_idc_lock(ha);
+ 		qla82xx_clear_drv_active(ha);
+ 		qla82xx_idc_unlock(ha);
+ 	}
+ }
+ 
+ static void
+ qla2x00_remove_one(struct pci_dev *pdev)
+ {
+ 	scsi_qla_host_t *base_vha;
+ 	struct qla_hw_data  *ha;
+ 
+ 	/*
+ 	 * If the PCI device is disabled that means that probe failed and any
+ 	 * resources should be have cleaned up on probe exit.
+ 	 */
+ 	if (!atomic_read(&pdev->enable_cnt))
+ 		return;
+ 
+ 	base_vha = pci_get_drvdata(pdev);
+ 	ha = base_vha->hw;
+ 
+ 	qla2x00_wait_for_hba_ready(base_vha);
+ 
+ 	set_bit(UNLOADING, &base_vha->dpc_flags);
+ 
+ 	if (IS_QLAFX00(ha))
+ 		qlafx00_driver_shutdown(base_vha, 20);
+ 
+ 	qla2x00_delete_all_vps(ha, base_vha);
+ 
+ 	if (IS_QLA8031(ha)) {
+ 		ql_dbg(ql_dbg_p3p, base_vha, 0xb07e,
+ 		    "Clearing fcoe driver presence.\n");
+ 		if (qla83xx_clear_drv_presence(base_vha) != QLA_SUCCESS)
+ 			ql_dbg(ql_dbg_p3p, base_vha, 0xb079,
+ 			    "Error while clearing DRV-Presence.\n");
+ 	}
+ 
+ 	qla2x00_abort_all_cmds(base_vha, DID_NO_CONNECT << 16);
+ 
+ 	qla2x00_dfs_remove(base_vha);
+ 
+ 	qla84xx_put_chip(base_vha);
+ 
+ 	/* Disable timer */
+ 	if (base_vha->timer_active)
+ 		qla2x00_stop_timer(base_vha);
+ 
+ 	base_vha->flags.online = 0;
+ 
+ 	qla2x00_destroy_deferred_work(ha);
+ 
+ 	qlt_remove_target(ha, base_vha);
+ 
+ 	qla2x00_free_sysfs_attr(base_vha, true);
+ 
+ 	fc_remove_host(base_vha->host);
+ 
+ 	scsi_remove_host(base_vha->host);
+ 
+ 	qla2x00_free_device(base_vha);
+ 
+ 	scsi_host_put(base_vha->host);
+ 
+ 	qla2x00_clear_drv_active(ha);
+ 
+ 	qla2x00_unmap_iobases(ha);
+ 
++>>>>>>> db7157d4cfce (qla2xxx: Fix shost use-after-free on device removal)
  	pci_release_selected_regions(ha->pdev, ha->bars);
  	kfree(ha);
  	ha = NULL;
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
