PM / Domains: add setter for dev.pm_domain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [misc] pm/domains: add setter for dev.pm_domain (Jeremy McNicoll) [1309527]
Rebuild_FUZZ: 97.56%
commit-author Tomeu Vizoso <tomeu.vizoso@collabora.com>
commit 989561de9b5112999475b406557d9c7e9e59c041
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/989561de.failed

Adds a function that sets the pointer to dev_pm_domain in struct device
and that warns if the device has already finished probing. The reason
why we want to enforce that is because in the general case that can
cause problems and also that we can simplify code quite a bit if we can
always assume that.

This patch also changes all current code that directly sets the
dev.pm_domain pointer.

	Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 989561de9b5112999475b406557d9c7e9e59c041)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-omap2/omap_device.c
#	drivers/acpi/acpi_lpss.c
#	drivers/acpi/device_pm.c
#	drivers/base/power/clock_ops.c
#	drivers/base/power/common.c
#	drivers/base/power/domain.c
#	drivers/gpu/vga/vga_switcheroo.c
#	drivers/misc/mei/pci-me.c
#	drivers/misc/mei/pci-txe.c
#	include/linux/pm_domain.h
diff --cc arch/arm/mach-omap2/omap_device.c
index e6d230700b2b,220822bcfe3f..000000000000
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@@ -170,14 -169,20 +171,25 @@@ static int omap_device_build_from_dt(st
  			r->name = dev_name(&pdev->dev);
  	}
  
++<<<<<<< HEAD
 +	if (of_get_property(node, "ti,no_idle_on_suspend", NULL))
 +		omap_device_disable_idle_on_suspend(pdev);
++=======
+ 	dev_pm_domain_set(&pdev->dev, &omap_device_pm_domain);
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  
 -	if (device_active) {
 -		omap_device_enable(pdev);
 -		pm_runtime_set_active(&pdev->dev);
 -	}
 +	pdev->dev.pm_domain = &omap_device_pm_domain;
  
  odbfd_exit1:
  	kfree(hwmods);
  odbfd_exit:
++<<<<<<< HEAD
++=======
+ 	/* if data/we are at fault.. load up a fail handler */
+ 	if (ret)
+ 		dev_pm_domain_set(&pdev->dev, &omap_device_fail_pm_domain);
+ 
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  	return ret;
  }
  
diff --cc drivers/acpi/acpi_lpss.c
index 3c4f836c31c0,c570b1d9f094..000000000000
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@@ -16,8 -15,10 +16,9 @@@
  #include <linux/clk-provider.h>
  #include <linux/err.h>
  #include <linux/io.h>
 -#include <linux/mutex.h>
  #include <linux/platform_device.h>
  #include <linux/platform_data/clk-lpss.h>
+ #include <linux/pm_domain.h>
  #include <linux/pm_runtime.h>
  #include <linux/delay.h>
  
@@@ -630,8 -875,15 +631,20 @@@ static int acpi_lpss_platform_notify(st
  	}
  
  	switch (action) {
++<<<<<<< HEAD
 +	case BUS_NOTIFY_ADD_DEVICE:
 +		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
++=======
+ 	case BUS_NOTIFY_BIND_DRIVER:
+ 		dev_pm_domain_set(&pdev->dev, &acpi_lpss_pm_domain);
+ 		break;
+ 	case BUS_NOTIFY_DRIVER_NOT_BOUND:
+ 	case BUS_NOTIFY_UNBOUND_DRIVER:
+ 		pdev->dev.pm_domain = NULL;
+ 		break;
+ 	case BUS_NOTIFY_ADD_DEVICE:
+ 		dev_pm_domain_set(&pdev->dev, &acpi_lpss_pm_domain);
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  		if (pdata->dev_desc->flags & LPSS_LTR)
  			return sysfs_create_group(&pdev->dev.kobj,
  						  &lpss_attr_group);
@@@ -639,7 -891,7 +652,11 @@@
  	case BUS_NOTIFY_DEL_DEVICE:
  		if (pdata->dev_desc->flags & LPSS_LTR)
  			sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
++<<<<<<< HEAD
 +		pdev->dev.pm_domain = NULL;
++=======
+ 		dev_pm_domain_set(&pdev->dev, NULL);
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  		break;
  	default:
  		break;
diff --cc drivers/acpi/device_pm.c
index bce55ef59dce,cd2c3d6d40e0..000000000000
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@@ -974,6 -1044,40 +975,43 @@@ static struct dev_pm_domain acpi_genera
  };
  
  /**
++<<<<<<< HEAD
++=======
+  * acpi_dev_pm_detach - Remove ACPI power management from the device.
+  * @dev: Device to take care of.
+  * @power_off: Whether or not to try to remove power from the device.
+  *
+  * Remove the device from the general ACPI PM domain and remove its wakeup
+  * notifier.  If @power_off is set, additionally remove power from the device if
+  * possible.
+  *
+  * Callers must ensure proper synchronization of this function with power
+  * management callbacks.
+  */
+ static void acpi_dev_pm_detach(struct device *dev, bool power_off)
+ {
+ 	struct acpi_device *adev = ACPI_COMPANION(dev);
+ 
+ 	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
+ 		dev_pm_domain_set(dev, NULL);
+ 		acpi_remove_pm_notifier(adev);
+ 		if (power_off) {
+ 			/*
+ 			 * If the device's PM QoS resume latency limit or flags
+ 			 * have been exposed to user space, they have to be
+ 			 * hidden at this point, so that they don't affect the
+ 			 * choice of the low-power state to put the device into.
+ 			 */
+ 			dev_pm_qos_hide_latency_limit(dev);
+ 			dev_pm_qos_hide_flags(dev);
+ 			acpi_device_wakeup(adev, ACPI_STATE_S0, false);
+ 			acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
+ 		}
+ 	}
+ }
+ 
+ /**
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
   * acpi_dev_pm_attach - Prepare device for ACPI power management.
   * @dev: Device to prepare.
   * @power_on: Whether or not to power on the device.
@@@ -999,12 -1103,22 +1037,25 @@@ int acpi_dev_pm_attach(struct device *d
  	if (dev->pm_domain)
  		return -EEXIST;
  
++<<<<<<< HEAD
 +	acpi_add_pm_notifier(adev, acpi_wakeup_device, dev);
 +	dev->pm_domain = &acpi_general_pm_domain;
++=======
+ 	/*
+ 	 * Only attach the power domain to the first device if the
+ 	 * companion is shared by multiple. This is to prevent doing power
+ 	 * management twice.
+ 	 */
+ 	if (!acpi_device_is_first_physical_node(adev, dev))
+ 		return -EBUSY;
+ 
+ 	acpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);
+ 	dev_pm_domain_set(dev, &acpi_general_pm_domain);
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  	if (power_on) {
  		acpi_dev_pm_full_power(adev);
 -		acpi_device_wakeup(adev, ACPI_STATE_S0, false);
 +		__acpi_device_run_wake(adev, false);
  	}
 -
 -	dev->pm_domain->detach = acpi_dev_pm_detach;
  	return 0;
  }
  EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);
diff --cc drivers/base/power/clock_ops.c
index 9d8fde709390,272a52ebafc0..000000000000
--- a/drivers/base/power/clock_ops.c
+++ b/drivers/base/power/clock_ops.c
@@@ -13,10 -12,13 +13,15 @@@
  #include <linux/pm.h>
  #include <linux/pm_clock.h>
  #include <linux/clk.h>
 -#include <linux/clkdev.h>
  #include <linux/slab.h>
  #include <linux/err.h>
++<<<<<<< HEAD
++=======
+ #include <linux/pm_domain.h>
+ #include <linux/pm_runtime.h>
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  
 -#ifdef CONFIG_PM_CLK
 +#ifdef CONFIG_PM
  
  enum pce_status {
  	PCE_STATUS_NONE = 0,
diff --cc drivers/base/power/common.c
index 5da914041305,02812bcabcac..000000000000
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@@ -82,4 -79,73 +82,48 @@@ int dev_pm_put_subsys_data(struct devic
  
  	return ret;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(dev_pm_put_subsys_data);
++=======
+ EXPORT_SYMBOL_GPL(dev_pm_domain_attach);
+ 
+ /**
+  * dev_pm_domain_detach - Detach a device from its PM domain.
+  * @dev: Device to detach.
+  * @power_off: Used to indicate whether we should power off the device.
+  *
+  * This functions will reverse the actions from dev_pm_domain_attach() and thus
+  * try to detach the @dev from its PM domain. Typically it should be invoked
+  * from subsystem level code during the remove phase.
+  *
+  * Callers must ensure proper synchronization of this function with power
+  * management callbacks.
+  */
+ void dev_pm_domain_detach(struct device *dev, bool power_off)
+ {
+ 	if (dev->pm_domain && dev->pm_domain->detach)
+ 		dev->pm_domain->detach(dev, power_off);
+ }
+ EXPORT_SYMBOL_GPL(dev_pm_domain_detach);
+ 
+ /**
+  * dev_pm_domain_set - Set PM domain of a device.
+  * @dev: Device whose PM domain is to be set.
+  * @pd: PM domain to be set, or NULL.
+  *
+  * Sets the PM domain the device belongs to. The PM domain of a device needs
+  * to be set before its probe finishes (it's bound to a driver).
+  *
+  * This function must be called with the device lock held.
+  */
+ void dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd)
+ {
+ 	if (dev->pm_domain == pd)
+ 		return;
+ 
+ 	WARN(device_is_bound(dev),
+ 	     "PM domains can only be changed for unbound devices\n");
+ 	dev->pm_domain = pd;
+ }
+ EXPORT_SYMBOL_GPL(dev_pm_domain_set);
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
diff --cc drivers/base/power/domain.c
index bfb8955c406c,abbac6fe8fd5..000000000000
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@@ -1376,25 -1144,67 +1376,53 @@@ EXPORT_SYMBOL_GPL(pm_genpd_syscore_swit
  
  #endif /* CONFIG_PM_SLEEP */
  
 -static struct generic_pm_domain_data *genpd_alloc_dev_data(struct device *dev,
 -					struct generic_pm_domain *genpd,
 -					struct gpd_timing_data *td)
 +static struct generic_pm_domain_data *__pm_genpd_alloc_dev_data(struct device *dev)
  {
  	struct generic_pm_domain_data *gpd_data;
 -	int ret;
 -
 -	ret = dev_pm_get_subsys_data(dev);
 -	if (ret)
 -		return ERR_PTR(ret);
  
  	gpd_data = kzalloc(sizeof(*gpd_data), GFP_KERNEL);
 -	if (!gpd_data) {
 -		ret = -ENOMEM;
 -		goto err_put;
 -	}
 -
 -	if (td)
 -		gpd_data->td = *td;
 +	if (!gpd_data)
 +		return NULL;
  
 -	gpd_data->base.dev = dev;
 -	gpd_data->td.constraint_changed = true;
 -	gpd_data->td.effective_constraint_ns = -1;
 +	mutex_init(&gpd_data->lock);
  	gpd_data->nb.notifier_call = genpd_dev_pm_qos_notifier;
++<<<<<<< HEAD
 +	dev_pm_qos_add_notifier(dev, &gpd_data->nb);
++=======
+ 
+ 	spin_lock_irq(&dev->power.lock);
+ 
+ 	if (dev->power.subsys_data->domain_data) {
+ 		ret = -EINVAL;
+ 		goto err_free;
+ 	}
+ 
+ 	dev->power.subsys_data->domain_data = &gpd_data->base;
+ 
+ 	spin_unlock_irq(&dev->power.lock);
+ 
+ 	dev_pm_domain_set(dev, &genpd->domain);
+ 
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  	return gpd_data;
 -
 - err_free:
 -	spin_unlock_irq(&dev->power.lock);
 -	kfree(gpd_data);
 - err_put:
 -	dev_pm_put_subsys_data(dev);
 -	return ERR_PTR(ret);
  }
  
 -static void genpd_free_dev_data(struct device *dev,
 -				struct generic_pm_domain_data *gpd_data)
 +static void __pm_genpd_free_dev_data(struct device *dev,
 +				     struct generic_pm_domain_data *gpd_data)
  {
++<<<<<<< HEAD
 +	dev_pm_qos_remove_notifier(dev, &gpd_data->nb);
++=======
+ 	dev_pm_domain_set(dev, NULL);
+ 
+ 	spin_lock_irq(&dev->power.lock);
+ 
+ 	dev->power.subsys_data->domain_data = NULL;
+ 
+ 	spin_unlock_irq(&dev->power.lock);
+ 
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  	kfree(gpd_data);
 -	dev_pm_put_subsys_data(dev);
  }
  
  /**
diff --cc drivers/gpu/vga/vga_switcheroo.c
index 5ad0bd346435,7b95ed2fb49b..000000000000
--- a/drivers/gpu/vga/vga_switcheroo.c
+++ b/drivers/gpu/vga/vga_switcheroo.c
@@@ -2,35 -2,102 +2,41 @@@
   * Copyright (c) 2010 Red Hat Inc.
   * Author : Dave Airlie <airlied@redhat.com>
   *
 - * Copyright (c) 2015 Lukas Wunner <lukas@wunner.de>
 - *
 - * Permission is hereby granted, free of charge, to any person obtaining a
 - * copy of this software and associated documentation files (the "Software"),
 - * to deal in the Software without restriction, including without limitation
 - * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 - * and/or sell copies of the Software, and to permit persons to whom the
 - * Software is furnished to do so, subject to the following conditions:
 - *
 - * The above copyright notice and this permission notice (including the next
 - * paragraph) shall be included in all copies or substantial portions of the
 - * Software.
   *
 - * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 - * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 - * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 - * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 - * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 - * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 - * DEALINGS
 - * IN THE SOFTWARE.
 + * Licensed under GPLv2
   *
 - */
 + * vga_switcheroo.c - Support for laptop with dual GPU using one set of outputs
  
 -#define pr_fmt(fmt) "vga_switcheroo: " fmt
 + Switcher interface - methods require for ATPX and DCM
 + - switchto - this throws the output MUX switch
 + - discrete_set_power - sets the power state for the discrete card
 +
 + GPU driver interface
 + - set_gpu_state - this should do the equiv of s/r for the card
 +		  - this should *not* set the discrete power state
 + - switch_check  - check if the device is in a position to switch now
 + */
  
 -#include <linux/console.h>
 -#include <linux/debugfs.h>
 -#include <linux/fb.h>
 -#include <linux/fs.h>
  #include <linux/module.h>
++<<<<<<< HEAD
++=======
+ #include <linux/pci.h>
+ #include <linux/pm_domain.h>
+ #include <linux/pm_runtime.h>
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  #include <linux/seq_file.h>
  #include <linux/uaccess.h>
 -#include <linux/vgaarb.h>
 +#include <linux/fs.h>
 +#include <linux/debugfs.h>
 +#include <linux/fb.h>
 +
 +#include <linux/pci.h>
 +#include <linux/console.h>
  #include <linux/vga_switcheroo.h>
 +#include <linux/pm_runtime.h>
  
 -/**
 - * DOC: Overview
 - *
 - * vga_switcheroo is the Linux subsystem for laptop hybrid graphics.
 - * These come in two flavors:
 - *
 - * * muxed: Dual GPUs with a multiplexer chip to switch outputs between GPUs.
 - * * muxless: Dual GPUs but only one of them is connected to outputs.
 - * 	The other one is merely used to offload rendering, its results
 - * 	are copied over PCIe into the framebuffer. On Linux this is
 - * 	supported with DRI PRIME.
 - *
 - * Hybrid graphics started to appear in the late Naughties and were initially
 - * all muxed. Newer laptops moved to a muxless architecture for cost reasons.
 - * A notable exception is the MacBook Pro which continues to use a mux.
 - * Muxes come with varying capabilities: Some switch only the panel, others
 - * can also switch external displays. Some switch all display pins at once
 - * while others can switch just the DDC lines. (To allow EDID probing
 - * for the inactive GPU.) Also, muxes are often used to cut power to the
 - * discrete GPU while it is not used.
 - *
 - * DRM drivers register GPUs with vga_switcheroo, these are heretoforth called
 - * clients. The mux is called the handler. Muxless machines also register a
 - * handler to control the power state of the discrete GPU, its ->switchto
 - * callback is a no-op for obvious reasons. The discrete GPU is often equipped
 - * with an HDA controller for the HDMI/DP audio signal, this will also
 - * register as a client so that vga_switcheroo can take care of the correct
 - * suspend/resume order when changing the discrete GPU's power state. In total
 - * there can thus be up to three clients: Two vga clients (GPUs) and one audio
 - * client (on the discrete GPU). The code is mostly prepared to support
 - * machines with more than two GPUs should they become available.
 - * The GPU to which the outputs are currently switched is called the
 - * active client in vga_switcheroo parlance. The GPU not in use is the
 - * inactive client.
 - */
 +#include <linux/vgaarb.h>
  
 -/**
 - * struct vga_switcheroo_client - registered client
 - * @pdev: client pci device
 - * @fb_info: framebuffer to which console is remapped on switching
 - * @pwr_state: current power state
 - * @ops: client callbacks
 - * @id: client identifier. Determining the id requires the handler,
 - * 	so gpus are initially assigned VGA_SWITCHEROO_UNKNOWN_ID
 - * 	and later given their true id in vga_switcheroo_enable()
 - * @active: whether the outputs are currently switched to this client
 - * @driver_power_control: whether power state is controlled by the driver's
 - * 	runtime pm. If true, writing ON and OFF to the vga_switcheroo debugfs
 - * 	interface is a no-op so as not to interfere with runtime pm
 - * @list: client list
 - *
 - * Registered client. A client can be either a GPU or an audio device on a GPU.
 - * For audio clients, the @fb_info, @active and @driver_power_control members
 - * are bogus.
 - */
  struct vga_switcheroo_client {
  	struct pci_dev *pdev;
  	struct fb_info *fb_info;
@@@ -699,12 -987,13 +705,12 @@@ int vga_switcheroo_init_domain_pm_optim
  	/* copy over all the bus versions */
  	if (dev->bus && dev->bus->pm) {
  		domain->ops = *dev->bus->pm;
 -		domain->ops.runtime_resume =
 -			vga_switcheroo_runtime_resume_hdmi_audio;
 +		domain->ops.runtime_resume = vga_switcheroo_runtime_resume_hdmi_audio;
  
- 		dev->pm_domain = domain;
+ 		dev_pm_domain_set(dev, domain);
  		return 0;
  	}
- 	dev->pm_domain = NULL;
+ 	dev_pm_domain_set(dev, NULL);
  	return -EINVAL;
  }
  EXPORT_SYMBOL(vga_switcheroo_init_domain_pm_optimus_hdmi_audio);
diff --cc drivers/misc/mei/pci-me.c
index 1eebd0f6a9f0,75fc9c688df8..000000000000
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@@ -32,7 -30,9 +32,13 @@@
  #include <linux/compat.h>
  #include <linux/jiffies.h>
  #include <linux/interrupt.h>
++<<<<<<< HEAD
 +#include <linux/miscdevice.h>
++=======
+ 
+ #include <linux/pm_domain.h>
+ #include <linux/pm_runtime.h>
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  
  #include <linux/mei.h>
  
@@@ -346,8 -353,114 +352,118 @@@ static int mei_me_pci_resume(struct dev
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_PM_SLEEP */
+ 
+ #ifdef CONFIG_PM
+ static int mei_me_pm_runtime_idle(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime_idle\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 	if (mei_write_is_idle(dev))
+ 		pm_runtime_autosuspend(device);
+ 
+ 	return -EBUSY;
+ }
+ 
+ static int mei_me_pm_runtime_suspend(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime suspend\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (mei_write_is_idle(dev))
+ 		ret = mei_me_pg_enter_sync(dev);
+ 	else
+ 		ret = -EAGAIN;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime suspend ret=%d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ static int mei_me_pm_runtime_resume(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime resume\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	ret = mei_me_pg_exit_sync(dev);
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime resume ret = %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_set_pm_domain - fill and set pm domain structure for device
+  *
+  * @dev: mei_device
+  */
+ static inline void mei_me_set_pm_domain(struct mei_device *dev)
+ {
+ 	struct pci_dev *pdev  = to_pci_dev(dev->dev);
+ 
+ 	if (pdev->dev.bus && pdev->dev.bus->pm) {
+ 		dev->pg_domain.ops = *pdev->dev.bus->pm;
+ 
+ 		dev->pg_domain.ops.runtime_suspend = mei_me_pm_runtime_suspend;
+ 		dev->pg_domain.ops.runtime_resume = mei_me_pm_runtime_resume;
+ 		dev->pg_domain.ops.runtime_idle = mei_me_pm_runtime_idle;
+ 
+ 		dev_pm_domain_set(&pdev->dev, &dev->pg_domain);
+ 	}
+ }
+ 
+ /**
+  * mei_me_unset_pm_domain - clean pm domain structure for device
+  *
+  * @dev: mei_device
+  */
+ static inline void mei_me_unset_pm_domain(struct mei_device *dev)
+ {
+ 	/* stop using pm callbacks if any */
+ 	dev_pm_domain_set(dev->dev, NULL);
+ }
+ 
+ static const struct dev_pm_ops mei_me_pm_ops = {
+ 	SET_SYSTEM_SLEEP_PM_OPS(mei_me_pci_suspend,
+ 				mei_me_pci_resume)
+ 	SET_RUNTIME_PM_OPS(
+ 		mei_me_pm_runtime_suspend,
+ 		mei_me_pm_runtime_resume,
+ 		mei_me_pm_runtime_idle)
+ };
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  
 +static SIMPLE_DEV_PM_OPS(mei_me_pm_ops, mei_me_pci_suspend, mei_me_pci_resume);
  #define MEI_ME_PM_OPS	(&mei_me_pm_ops)
  #else
  #define MEI_ME_PM_OPS	NULL
diff --cc drivers/misc/mei/pci-txe.c
index c0eb095268aa,71f8a7475717..000000000000
--- a/drivers/misc/mei/pci-txe.c
+++ b/drivers/misc/mei/pci-txe.c
@@@ -398,11 -401,9 +399,15 @@@ static inline void mei_txe_set_pm_domai
  static inline void mei_txe_unset_pm_domain(struct mei_device *dev)
  {
  	/* stop using pm callbacks if any */
++<<<<<<< HEAD
 +	dev->pdev->dev.pm_domain = NULL;
++=======
+ 	dev_pm_domain_set(dev->dev, NULL);
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  }
 +#endif /* CONFIG_PM_RUNTIME */
  
 +#ifdef CONFIG_PM
  static const struct dev_pm_ops mei_txe_pm_ops = {
  	SET_SYSTEM_SLEEP_PM_OPS(mei_txe_pci_suspend,
  				mei_txe_pci_resume)
diff --cc include/linux/pm_domain.h
index 7c1d252b20c0,db21d3995f7e..000000000000
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@@ -269,45 -169,86 +269,74 @@@ static inline int pm_genpd_add_device(s
  	return __pm_genpd_add_device(genpd, dev, NULL);
  }
  
 -#ifdef CONFIG_PM_GENERIC_DOMAINS_SLEEP
 -extern void pm_genpd_syscore_poweroff(struct device *dev);
 -extern void pm_genpd_syscore_poweron(struct device *dev);
 -#else
 -static inline void pm_genpd_syscore_poweroff(struct device *dev) {}
 -static inline void pm_genpd_syscore_poweron(struct device *dev) {}
 -#endif
 -
 -/* OF PM domain providers */
 -struct of_device_id;
 -
 -struct genpd_onecell_data {
 -	struct generic_pm_domain **domains;
 -	unsigned int num_domains;
 -};
 -
 -typedef struct generic_pm_domain *(*genpd_xlate_t)(struct of_phandle_args *args,
 -						void *data);
 -
 -#ifdef CONFIG_PM_GENERIC_DOMAINS_OF
 -int __of_genpd_add_provider(struct device_node *np, genpd_xlate_t xlate,
 -			void *data);
 -void of_genpd_del_provider(struct device_node *np);
 -struct generic_pm_domain *of_genpd_get_from_provider(
 -			struct of_phandle_args *genpdspec);
 -
 -struct generic_pm_domain *__of_genpd_xlate_simple(
 -					struct of_phandle_args *genpdspec,
 -					void *data);
 -struct generic_pm_domain *__of_genpd_xlate_onecell(
 -					struct of_phandle_args *genpdspec,
 -					void *data);
 +static inline int pm_genpd_of_add_device(struct device_node *genpd_node,
 +					 struct device *dev)
 +{
 +	return __pm_genpd_of_add_device(genpd_node, dev, NULL);
 +}
  
 -int genpd_dev_pm_attach(struct device *dev);
 -#else /* !CONFIG_PM_GENERIC_DOMAINS_OF */
 -static inline int __of_genpd_add_provider(struct device_node *np,
 -					genpd_xlate_t xlate, void *data)
 +static inline int pm_genpd_name_add_device(const char *domain_name,
 +					   struct device *dev)
  {
 -	return 0;
 +	return __pm_genpd_name_add_device(domain_name, dev, NULL);
  }
 -static inline void of_genpd_del_provider(struct device_node *np) {}
  
 -static inline struct generic_pm_domain *of_genpd_get_from_provider(
 -			struct of_phandle_args *genpdspec)
 +static inline int pm_genpd_remove_callbacks(struct device *dev)
  {
 -	return NULL;
 +	return __pm_genpd_remove_callbacks(dev, true);
  }
  
 -#define __of_genpd_xlate_simple		NULL
 -#define __of_genpd_xlate_onecell	NULL
 +#ifdef CONFIG_PM_GENERIC_DOMAINS_RUNTIME
 +extern void genpd_queue_power_off_work(struct generic_pm_domain *genpd);
 +extern void pm_genpd_poweroff_unused(void);
 +#else
 +static inline void genpd_queue_power_off_work(struct generic_pm_domain *gpd) {}
 +static inline void pm_genpd_poweroff_unused(void) {}
 +#endif
  
 -static inline int genpd_dev_pm_attach(struct device *dev)
 +#ifdef CONFIG_PM_GENERIC_DOMAINS_SLEEP
 +extern void pm_genpd_syscore_switch(struct device *dev, bool suspend);
 +#else
 +static inline void pm_genpd_syscore_switch(struct device *dev, bool suspend) {}
 +#endif
 +
 +static inline void pm_genpd_syscore_poweroff(struct device *dev)
  {
 -	return -ENODEV;
 +	pm_genpd_syscore_switch(dev, true);
 +}
 +
 +static inline void pm_genpd_syscore_poweron(struct device *dev)
 +{
 +	pm_genpd_syscore_switch(dev, false);
  }
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_PM_GENERIC_DOMAINS_OF */
+ 
+ static inline int of_genpd_add_provider_simple(struct device_node *np,
+ 					struct generic_pm_domain *genpd)
+ {
+ 	return __of_genpd_add_provider(np, __of_genpd_xlate_simple, genpd);
+ }
+ static inline int of_genpd_add_provider_onecell(struct device_node *np,
+ 					struct genpd_onecell_data *data)
+ {
+ 	return __of_genpd_add_provider(np, __of_genpd_xlate_onecell, data);
+ }
+ 
+ #ifdef CONFIG_PM
+ extern int dev_pm_domain_attach(struct device *dev, bool power_on);
+ extern void dev_pm_domain_detach(struct device *dev, bool power_off);
+ extern void dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd);
+ #else
+ static inline int dev_pm_domain_attach(struct device *dev, bool power_on)
+ {
+ 	return -ENODEV;
+ }
+ static inline void dev_pm_domain_detach(struct device *dev, bool power_off) {}
+ static inline void dev_pm_domain_set(struct device *dev,
+ 				     struct dev_pm_domain *pd) {}
+ #endif
++>>>>>>> 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
  
  #endif /* _LINUX_PM_DOMAIN_H */
* Unmerged path arch/arm/mach-omap2/omap_device.c
* Unmerged path drivers/acpi/acpi_lpss.c
* Unmerged path drivers/acpi/device_pm.c
* Unmerged path drivers/base/power/clock_ops.c
* Unmerged path drivers/base/power/common.c
* Unmerged path drivers/base/power/domain.c
* Unmerged path drivers/gpu/vga/vga_switcheroo.c
* Unmerged path drivers/misc/mei/pci-me.c
* Unmerged path drivers/misc/mei/pci-txe.c
* Unmerged path include/linux/pm_domain.h
