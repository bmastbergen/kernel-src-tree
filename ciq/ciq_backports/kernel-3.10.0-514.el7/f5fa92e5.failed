mmc: sdhci: Let a driver override timeout clock frequency

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: Let a driver override timeout clock frequency (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.41%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit f5fa92e58bce2cbcce99c2c5260c0b338a1ef201
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f5fa92e5.failed

Let a driver override the timeout clock frequency by
populating it before calling sdhci_add_host().  Note
the value will otherwise be zero because sdhci_host is
zeroed when allocated.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit f5fa92e58bce2cbcce99c2c5260c0b338a1ef201)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index 3b1d1056b545,ada1a3ea3a87..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -2799,7 -2805,9 +2800,13 @@@ int sdhci_add_host(struct sdhci_host *h
  	if (debug_quirks2)
  		host->quirks2 = debug_quirks2;
  
++<<<<<<< HEAD
 +	sdhci_reset(host, SDHCI_RESET_ALL);
++=======
+ 	override_timeout_clk = host->timeout_clk;
+ 
+ 	sdhci_do_reset(host, SDHCI_RESET_ALL);
++>>>>>>> f5fa92e58bce (mmc: sdhci: Let a driver override timeout clock frequency)
  
  	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
  	host->version = (host->version & SDHCI_SPEC_VER_MASK)
@@@ -2945,26 -2951,31 +2952,29 @@@
  	} else
  		mmc->f_min = host->max_clk / SDHCI_MAX_DIV_SPEC_200;
  
 -	if (!(host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)) {
 -		host->timeout_clk = (caps[0] & SDHCI_TIMEOUT_CLK_MASK) >>
 -					SDHCI_TIMEOUT_CLK_SHIFT;
 -		if (host->timeout_clk == 0) {
 -			if (host->ops->get_timeout_clock) {
 -				host->timeout_clk =
 -					host->ops->get_timeout_clock(host);
 -			} else {
 -				pr_err("%s: Hardware doesn't specify timeout clock frequency.\n",
 -					mmc_hostname(mmc));
 -				return -ENODEV;
 -			}
 +	host->timeout_clk =
 +		(caps[0] & SDHCI_TIMEOUT_CLK_MASK) >> SDHCI_TIMEOUT_CLK_SHIFT;
 +	if (host->timeout_clk == 0) {
 +		if (host->ops->get_timeout_clock) {
 +			host->timeout_clk = host->ops->get_timeout_clock(host);
 +		} else if (!(host->quirks &
 +				SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)) {
 +			pr_err("%s: Hardware doesn't specify timeout clock "
 +			       "frequency.\n", mmc_hostname(mmc));
 +			return -ENODEV;
  		}
 +	}
 +	if (caps[0] & SDHCI_TIMEOUT_CLK_UNIT)
 +		host->timeout_clk *= 1000;
  
 -		if (caps[0] & SDHCI_TIMEOUT_CLK_UNIT)
 -			host->timeout_clk *= 1000;
 +	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)
 +		host->timeout_clk = mmc->f_max / 1000;
  
 -		mmc->max_busy_timeout = host->ops->get_max_timeout_count ?
 -			host->ops->get_max_timeout_count(host) : 1 << 27;
 -		mmc->max_busy_timeout /= host->timeout_clk;
 -	}
 +	mmc->max_busy_timeout = (1 << 27) / host->timeout_clk;
  
+ 	if (override_timeout_clk)
+ 		host->timeout_clk = override_timeout_clk;
+ 
  	mmc->caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE | MMC_CAP_CMD23;
  	mmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;
  
* Unmerged path drivers/mmc/host/sdhci.c
