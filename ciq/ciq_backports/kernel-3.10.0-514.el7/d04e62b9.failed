hpsa: add in sas transport class

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kevin Barnett <kevin.barnett@pmcs.com>
commit d04e62b9d63a7498735761dc40eaed88b7fd9d80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d04e62b9.failed

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d04e62b9d63a7498735761dc40eaed88b7fd9d80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
#	drivers/scsi/hpsa.h
#	drivers/scsi/hpsa_cmd.h
diff --cc drivers/scsi/hpsa.c
index 68754355feaa,5f02a603eb4d..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -282,6 -286,10 +293,13 @@@ static int hpsa_scsi_ioaccel_queue_comm
  static void hpsa_command_resubmit_worker(struct work_struct *work);
  static u32 lockup_detected(struct ctlr_info *h);
  static int detect_controller_lockup(struct ctlr_info *h);
++<<<<<<< HEAD
++=======
+ static void hpsa_disable_rld_caching(struct ctlr_info *h);
+ static inline int hpsa_scsi_do_report_phys_luns(struct ctlr_info *h,
+ 	struct ReportExtendedLUNdata *buf, int bufsize);
+ static int hpsa_luns_changed(struct ctlr_info *h);
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  
  static inline struct ctlr_info *sdev_to_hba(struct scsi_device *sdev)
  {
@@@ -1594,7 -1698,50 +1612,54 @@@ static void hpsa_update_log_drive_phys_
  	}
  }
  
++<<<<<<< HEAD
 +static void adjust_hpsa_scsi_table(struct ctlr_info *h, int hostno,
++=======
+ static int hpsa_add_device(struct ctlr_info *h, struct hpsa_scsi_dev_t *device)
+ {
+ 	int rc = 0;
+ 
+ 	if (!h->scsi_host)
+ 		return 1;
+ 
+ 	if (is_logical_device(device)) /* RAID */
+ 		rc = scsi_add_device(h->scsi_host, device->bus,
+ 					device->target, device->lun);
+ 	else /* HBA */
+ 		rc = hpsa_add_sas_device(h->sas_host, device);
+ 
+ 	return rc;
+ }
+ 
+ static void hpsa_remove_device(struct ctlr_info *h,
+ 			struct hpsa_scsi_dev_t *device)
+ {
+ 	struct scsi_device *sdev = NULL;
+ 
+ 	if (!h->scsi_host)
+ 		return;
+ 
+ 	if (is_logical_device(device)) { /* RAID */
+ 		sdev = scsi_device_lookup(h->scsi_host, device->bus,
+ 						device->target, device->lun);
+ 		if (sdev) {
+ 			scsi_remove_device(sdev);
+ 			scsi_device_put(sdev);
+ 		} else {
+ 			/*
+ 			 * We don't expect to get here.  Future commands
+ 			 * to this device will get a selection timeout as
+ 			 * if the device were gone.
+ 			 */
+ 			hpsa_show_dev_msg(KERN_WARNING, h, device,
+ 					"didn't find device for removal.");
+ 		}
+ 	} else /* HBA */
+ 		hpsa_remove_sas_device(device);
+ }
+ 
+ static void adjust_hpsa_scsi_table(struct ctlr_info *h,
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  	struct hpsa_scsi_dev_t *sd[], int nsds)
  {
  	/* sd contains scsi3 addresses and devtypes, and inquiry
@@@ -1804,28 -1931,27 +1869,50 @@@ static int hpsa_slave_alloc(struct scsi
  
  	h = sdev_to_hba(sdev);
  	spin_lock_irqsave(&h->devlock, flags);
++<<<<<<< HEAD
 +	sd = lookup_hpsa_scsi_dev(h, sdev_channel(sdev),
 +		sdev_id(sdev), sdev->lun);
 +
 +	if (likely(sd)) {
 +		atomic_set(&sd->ioaccel_cmds_out, 0);
 +		sdev->hostdata = (sd->expose_state & HPSA_SCSI_ADD) ? sd : NULL;
 +		queue_depth = sd->queue_depth != 0 ?
 +			sd->queue_depth : sdev->host->can_queue;
 +	} else {
++=======
+ 	if (sdev_channel(sdev) == HPSA_PHYSICAL_DEVICE_BUS) {
+ 		struct scsi_target *starget;
+ 		struct sas_rphy *rphy;
+ 
+ 		starget = scsi_target(sdev);
+ 		rphy = target_to_rphy(starget);
+ 		sd = hpsa_find_device_by_sas_rphy(h, rphy);
+ 		if (sd) {
+ 			sd->target = sdev_id(sdev);
+ 			sd->lun = sdev->lun;
+ 		}
+ 	} else
+ 		sd = lookup_hpsa_scsi_dev(h, sdev_channel(sdev),
+ 					sdev_id(sdev), sdev->lun);
+ 
+ 	if (sd && sd->expose_device) {
+ 		atomic_set(&sd->ioaccel_cmds_out, 0);
+ 		sdev->hostdata = sd;
+ 	} else
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  		sdev->hostdata = NULL;
 +		queue_depth = sdev->host->can_queue;
 +	}
 +
 +	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), queue_depth);
 +
 +	if (!shost_use_blk_mq(sdev->host)) {
 +		sdev->tagged_supported = 1;
 +		scsi_set_tag_type(sdev, MSG_SIMPLE_TAG);
 +		scsi_activate_tcq(sdev, queue_depth);
 +	}
  	spin_unlock_irqrestore(&h->devlock, flags);
 +
  	return 0;
  }
  
@@@ -2992,6 -3098,66 +3079,69 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int hpsa_bmic_sense_subsystem_information(struct ctlr_info *h,
+ 		unsigned char scsi3addr[], u16 bmic_device_index,
+ 		struct bmic_sense_subsystem_info *buf, size_t bufsize)
+ {
+ 	int rc = IO_OK;
+ 	struct CommandList *c;
+ 	struct ErrorInfo *ei;
+ 
+ 	c = cmd_alloc(h);
+ 
+ 	rc = fill_cmd(c, BMIC_SENSE_SUBSYSTEM_INFORMATION, h, buf, bufsize,
+ 		0, RAID_CTLR_LUNID, TYPE_CMD);
+ 	if (rc)
+ 		goto out;
+ 
+ 	c->Request.CDB[2] = bmic_device_index & 0xff;
+ 	c->Request.CDB[9] = (bmic_device_index >> 8) & 0xff;
+ 
+ 	rc = hpsa_scsi_do_simple_cmd_with_retry(h, c,
+ 				PCI_DMA_FROMDEVICE, NO_TIMEOUT);
+ 	if (rc)
+ 		goto out;
+ 	ei = c->err_info;
+ 	if (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {
+ 		hpsa_scsi_interpret_error(h, c);
+ 		rc = -1;
+ 	}
+ out:
+ 	cmd_free(h, c);
+ 	return rc;
+ }
+ 
+ static int hpsa_bmic_id_controller(struct ctlr_info *h,
+ 	struct bmic_identify_controller *buf, size_t bufsize)
+ {
+ 	int rc = IO_OK;
+ 	struct CommandList *c;
+ 	struct ErrorInfo *ei;
+ 
+ 	c = cmd_alloc(h);
+ 
+ 	rc = fill_cmd(c, BMIC_IDENTIFY_CONTROLLER, h, buf, bufsize,
+ 		0, RAID_CTLR_LUNID, TYPE_CMD);
+ 	if (rc)
+ 		goto out;
+ 
+ 	rc = hpsa_scsi_do_simple_cmd_with_retry(h, c,
+ 		PCI_DMA_FROMDEVICE, NO_TIMEOUT);
+ 	if (rc)
+ 		goto out;
+ 	ei = c->err_info;
+ 	if (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {
+ 		hpsa_scsi_interpret_error(h, c);
+ 		rc = -1;
+ 	}
+ out:
+ 	cmd_free(h, c);
+ 	return rc;
+ }
+ 
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  static int hpsa_bmic_id_physical_device(struct ctlr_info *h,
  		unsigned char scsi3addr[], u16 bmic_device_index,
  		struct bmic_identify_physical_device *buf, size_t bufsize)
@@@ -3827,34 -4056,37 +4039,41 @@@ static void hpsa_update_scsi_devices(st
  		hpsa_update_device_supports_aborts(h, tmpdevice, lunaddrbytes);
  		this_device = currentsd[ncurrent];
  
 -		/* Turn on discovery_polling if there are ext target devices.
 -		 * Event-based change notification is unreliable for those.
 +		/*
 +		 * For external target devices, we have to insert a LUN 0 which
 +		 * doesn't show up in CCISS_REPORT_PHYSICAL data, but there
 +		 * is nonetheless an enclosure device there.  We have to
 +		 * present that otherwise linux won't find anything if
 +		 * there is no lun 0.
  		 */
 -		if (!h->discovery_polling) {
 -			if (tmpdevice->external) {
 -				h->discovery_polling = 1;
 -				dev_info(&h->pdev->dev,
 -					"External target, activate discovery polling.\n");
 -			}
 +		if (add_ext_target_dev(h, tmpdevice, this_device,
 +				lunaddrbytes, lunzerobits,
 +				&n_ext_target_devs)) {
 +			ncurrent++;
 +			this_device = currentsd[ncurrent];
  		}
  
 -
  		*this_device = *tmpdevice;
 -		this_device->physical_device = physical_device;
  
 -		/*
 -		 * Expose all devices except for physical devices that
 -		 * are masked.
 -		 */
 -		if (MASKED_DEVICE(lunaddrbytes) && this_device->physical_device)
 -			this_device->expose_device = 0;
 -		else
 -			this_device->expose_device = 1;
 +		/* do not expose masked devices */
 +		if (MASKED_DEVICE(lunaddrbytes) &&
 +			i < nphysicals + (raid_ctlr_position == 0)) {
 +			if (h->hba_mode_enabled)
 +				dev_warn(&h->pdev->dev,
 +					"Masked physical device detected\n");
 +			this_device->expose_state = HPSA_DO_NOT_EXPOSE;
 +		} else {
 +			this_device->expose_state =
 +					HPSA_SG_ATTACH | HPSA_ULD_ATTACH;
 +		}
  
+ 
+ 		/*
+ 		 * Get the SAS address for physical devices that are exposed.
+ 		 */
+ 		if (this_device->physical_device && this_device->expose_device)
+ 			hpsa_get_sas_address(h, lunaddrbytes, this_device);
+ 
  		switch (this_device->devtype) {
  		case TYPE_ROM:
  			/* We don't *really* support actual CD-ROM devices,
@@@ -3908,7 -4132,19 +4127,23 @@@
  		if (ncurrent >= HPSA_MAX_DEVICES)
  			break;
  	}
++<<<<<<< HEAD
 +	adjust_hpsa_scsi_table(h, hostno, currentsd, ncurrent);
++=======
+ 
+ 	if (h->sas_host == NULL) {
+ 		int rc = 0;
+ 
+ 		rc = hpsa_add_sas_host(h);
+ 		if (rc) {
+ 			dev_warn(&h->pdev->dev,
+ 				"Could not add sas host %d\n", rc);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	adjust_hpsa_scsi_table(h, currentsd, ncurrent);
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  out:
  	kfree(tmpdevice);
  	for (i = 0; i < ndev_allocated; i++)
@@@ -6384,6 -6624,32 +6620,35 @@@ static int fill_cmd(struct CommandList 
  			c->Request.CDB[7] = (size >> 16) & 0xFF;
  			c->Request.CDB[8] = (size >> 8) & 0XFF;
  			break;
++<<<<<<< HEAD
++=======
+ 		case BMIC_SENSE_SUBSYSTEM_INFORMATION:
+ 			c->Request.CDBLen = 10;
+ 			c->Request.type_attr_dir =
+ 				TYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);
+ 			c->Request.Timeout = 0;
+ 			c->Request.CDB[0] = BMIC_READ;
+ 			c->Request.CDB[6] = BMIC_SENSE_SUBSYSTEM_INFORMATION;
+ 			c->Request.CDB[7] = (size >> 16) & 0xFF;
+ 			c->Request.CDB[8] = (size >> 8) & 0XFF;
+ 			break;
+ 		case BMIC_IDENTIFY_CONTROLLER:
+ 			c->Request.CDBLen = 10;
+ 			c->Request.type_attr_dir =
+ 				TYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);
+ 			c->Request.Timeout = 0;
+ 			c->Request.CDB[0] = BMIC_READ;
+ 			c->Request.CDB[1] = 0;
+ 			c->Request.CDB[2] = 0;
+ 			c->Request.CDB[3] = 0;
+ 			c->Request.CDB[4] = 0;
+ 			c->Request.CDB[5] = 0;
+ 			c->Request.CDB[6] = BMIC_IDENTIFY_CONTROLLER;
+ 			c->Request.CDB[7] = (size >> 16) & 0xFF;
+ 			c->Request.CDB[8] = (size >> 8) & 0XFF;
+ 			c->Request.CDB[9] = 0;
+ 			break;
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  		default:
  			dev_warn(&h->pdev->dev, "unknown command 0x%c\n", cmd);
  			BUG();
diff --cc drivers/scsi/hpsa.h
index 3e07d020f3bd,ae5beda1bdb5..000000000000
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@@ -37,8 -60,11 +60,9 @@@ struct hpsa_scsi_dev_t 
  	unsigned int devtype;
  	int bus, target, lun;		/* as presented to the OS */
  	unsigned char scsi3addr[8];	/* as presented to the HW */
 -	u8 physical_device : 1;
 -	u8 expose_device;
  #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
  	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
+ 	u64 sas_address;
  	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
  	unsigned char model[16];        /* bytes 16-31 of inquiry data */
  	unsigned char raid_level;	/* from inquiry page 0xC1 */
@@@ -70,11 -101,8 +94,16 @@@
  	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
  	int nphysical_disks;
  	int supports_aborts;
++<<<<<<< HEAD
 +#define HPSA_DO_NOT_EXPOSE	0x0
 +#define HPSA_SG_ATTACH		0x1
 +#define HPSA_ULD_ATTACH		0x2
 +#define HPSA_SCSI_ADD		(HPSA_SG_ATTACH | HPSA_ULD_ATTACH)
 +	u8 expose_state;
++=======
+ 	struct hpsa_sas_port *sas_port;
+ 	int external;   /* 1-from external array 0-not <0-unknown */
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  };
  
  struct reply_queue_buffer {
diff --cc drivers/scsi/hpsa_cmd.h
index 47c756ba8dce,d92ef0d352b5..000000000000
--- a/drivers/scsi/hpsa_cmd.h
+++ b/drivers/scsi/hpsa_cmd.h
@@@ -288,6 -286,11 +288,14 @@@ struct SenseSubsystem_info 
  #define BMIC_FLASH_FIRMWARE 0xF7
  #define BMIC_SENSE_CONTROLLER_PARAMETERS 0x64
  #define BMIC_IDENTIFY_PHYSICAL_DEVICE 0x15
++<<<<<<< HEAD
++=======
+ #define BMIC_IDENTIFY_CONTROLLER 0x11
+ #define BMIC_SET_DIAG_OPTIONS 0xF4
+ #define BMIC_SENSE_DIAG_OPTIONS 0xF5
+ #define HPSA_DIAG_OPTS_DISABLE_RLD_CACHING 0x40000000
+ #define BMIC_SENSE_SUBSYSTEM_INFORMATION 0x66
++>>>>>>> d04e62b9d63a (hpsa: add in sas transport class)
  
  /* Command List Structure */
  union SCSI3Addr {
* Unmerged path drivers/scsi/hpsa.c
* Unmerged path drivers/scsi/hpsa.h
* Unmerged path drivers/scsi/hpsa_cmd.h
