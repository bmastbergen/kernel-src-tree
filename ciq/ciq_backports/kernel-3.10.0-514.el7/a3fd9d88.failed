i40e/i40evf: Handle IPv6 extension headers in checksum offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit a3fd9d8876a589f05725237aced606b995956860
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a3fd9d88.failed

This patch adds support for IPv6 extension headers in setting up the Tx
checksum.  Without this patch extension headers would cause IPv6 traffic to
fail as the transport protocol could not be identified.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a3fd9d8876a589f05725237aced606b995956860)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5a3abb58e191,e49fe8f580b1..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2420,15 -2392,45 +2420,57 @@@ static void i40e_tx_enable_csum(struct 
  				struct i40e_ring *tx_ring,
  				u32 *cd_tunneling)
  {
++<<<<<<< HEAD
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
 +	u32 l4_tunnel = 0;
 +
 +	if (skb->encapsulation) {
 +		switch (ip_hdr(skb)->protocol) {
++=======
+ 	union {
+ 		struct iphdr *v4;
+ 		struct ipv6hdr *v6;
+ 		unsigned char *hdr;
+ 	} ip;
+ 	union {
+ 		struct tcphdr *tcp;
+ 		struct udphdr *udp;
+ 		unsigned char *hdr;
+ 	} l4;
+ 	unsigned char *exthdr;
+ 	u32 l4_tunnel = 0;
+ 	__be16 frag_off;
+ 	u8 l4_proto = 0;
+ 
+ 	ip.hdr = skb_network_header(skb);
+ 	l4.hdr = skb_transport_header(skb);
+ 
+ 	if (skb->encapsulation) {
+ 		/* define outer network header type */
+ 		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
+ 			if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
+ 			else
+ 				*cd_tunneling |=
+ 					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
+ 			l4_proto = ip.v4->protocol;
+ 		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
+ 			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
+ 
+ 			exthdr = ip.hdr + sizeof(*ip.v6);
+ 			l4_proto = ip.v6->nexthdr;
+ 			if (l4.hdr != exthdr)
+ 				ipv6_skip_exthdr(skb, exthdr - skb->data,
+ 						 &l4_proto, &frag_off);
+ 		}
+ 
+ 		/* define outer transport */
+ 		switch (l4_proto) {
++>>>>>>> a3fd9d8876a5 (i40e/i40evf: Handle IPv6 extension headers in checksum offload)
  		case IPPROTO_UDP:
  			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_UDP_TUNNEL;
@@@ -2493,16 -2475,18 +2535,26 @@@
  		} else {
  			*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV4;
  		}
 +		/* Now set the td_offset for IP header length */
 +		*td_offset = (network_hdr_len >> 2) <<
 +			      I40E_TX_DESC_LENGTH_IPLEN_SHIFT;
  	} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
++<<<<<<< HEAD
 +		l4_hdr = this_ipv6_hdr->nexthdr;
 +		*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV6;
 +		/* Now set the td_offset for IP header length */
 +		*td_offset = (network_hdr_len >> 2) <<
 +			      I40E_TX_DESC_LENGTH_IPLEN_SHIFT;
++=======
+ 		*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV6;
+ 
+ 		exthdr = ip.hdr + sizeof(*ip.v6);
+ 		l4_proto = ip.v6->nexthdr;
+ 		if (l4.hdr != exthdr)
+ 			ipv6_skip_exthdr(skb, exthdr - skb->data,
+ 					 &l4_proto, &frag_off);
++>>>>>>> a3fd9d8876a5 (i40e/i40evf: Handle IPv6 extension headers in checksum offload)
  	}
 -
 -	/* Now set the td_offset for IP header length */
 -	*td_offset = ((l4.hdr - ip.hdr) / 4) << I40E_TX_DESC_LENGTH_IPLEN_SHIFT;
  	/* words in MACLEN + dwords in IPLEN + dwords in L4Len */
  	*td_offset |= (skb_network_offset(skb) >> 1) <<
  		       I40E_TX_DESC_LENGTH_MACLEN_SHIFT;
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index f6384b0c8220,48ec7631b3dd..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -1628,15 -1609,45 +1628,57 @@@ static void i40e_tx_enable_csum(struct 
  				struct i40e_ring *tx_ring,
  				u32 *cd_tunneling)
  {
++<<<<<<< HEAD
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
 +	u32 l4_tunnel = 0;
 +
 +	if (skb->encapsulation) {
 +		switch (ip_hdr(skb)->protocol) {
++=======
+ 	union {
+ 		struct iphdr *v4;
+ 		struct ipv6hdr *v6;
+ 		unsigned char *hdr;
+ 	} ip;
+ 	union {
+ 		struct tcphdr *tcp;
+ 		struct udphdr *udp;
+ 		unsigned char *hdr;
+ 	} l4;
+ 	unsigned char *exthdr;
+ 	u32 l4_tunnel = 0;
+ 	__be16 frag_off;
+ 	u8 l4_proto = 0;
+ 
+ 	ip.hdr = skb_network_header(skb);
+ 	l4.hdr = skb_transport_header(skb);
+ 
+ 	if (skb->encapsulation) {
+ 		/* define outer network header type */
+ 		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
+ 			if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
+ 			else
+ 				*cd_tunneling |=
+ 					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
+ 			l4_proto = ip.v4->protocol;
+ 		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
+ 			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
+ 
+ 			exthdr = ip.hdr + sizeof(*ip.v6);
+ 			l4_proto = ip.v6->nexthdr;
+ 			if (l4.hdr != exthdr)
+ 				ipv6_skip_exthdr(skb, exthdr - skb->data,
+ 						 &l4_proto, &frag_off);
+ 		}
+ 
+ 		/* define outer transport */
+ 		switch (l4_proto) {
++>>>>>>> a3fd9d8876a5 (i40e/i40evf: Handle IPv6 extension headers in checksum offload)
  		case IPPROTO_UDP:
  			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_VXLAN_TUNNEL;
@@@ -1700,16 -1692,18 +1742,26 @@@
  		} else {
  			*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV4;
  		}
 +		/* Now set the td_offset for IP header length */
 +		*td_offset = (network_hdr_len >> 2) <<
 +			      I40E_TX_DESC_LENGTH_IPLEN_SHIFT;
  	} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
++<<<<<<< HEAD
 +		l4_hdr = this_ipv6_hdr->nexthdr;
 +		*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV6;
 +		/* Now set the td_offset for IP header length */
 +		*td_offset = (network_hdr_len >> 2) <<
 +			      I40E_TX_DESC_LENGTH_IPLEN_SHIFT;
++=======
+ 		*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV6;
+ 
+ 		exthdr = ip.hdr + sizeof(*ip.v6);
+ 		l4_proto = ip.v6->nexthdr;
+ 		if (l4.hdr != exthdr)
+ 			ipv6_skip_exthdr(skb, exthdr - skb->data,
+ 					 &l4_proto, &frag_off);
++>>>>>>> a3fd9d8876a5 (i40e/i40evf: Handle IPv6 extension headers in checksum offload)
  	}
 -
 -	/* Now set the td_offset for IP header length */
 -	*td_offset = ((l4.hdr - ip.hdr) / 4) << I40E_TX_DESC_LENGTH_IPLEN_SHIFT;
  	/* words in MACLEN + dwords in IPLEN + dwords in L4Len */
  	*td_offset |= (skb_network_offset(skb) >> 1) <<
  		       I40E_TX_DESC_LENGTH_MACLEN_SHIFT;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
