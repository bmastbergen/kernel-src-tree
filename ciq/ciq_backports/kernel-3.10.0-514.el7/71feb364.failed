NVMe: Fix IO for extended metadata formats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Keith Busch <keith.busch@intel.com>
commit 71feb364e7faadc681e714f7fdc2bede208ba26c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/71feb364.failed

This fixes io submit ioctl handling when using extended metadata
formats. When these formats are used, the user provides a single virtually
contiguous buffer containing both the block and metadata interleaved,
so the metadata size needs to be added to the total length and not mapped
as a separate transfer.

The command is also driver generated, so this patch does not enforce
blk-integrity extensions provide the metadata buffer.

	Reported-by: Marcin Dziegielewski <marcin.dziegielewski@intel.com>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 71feb364e7faadc681e714f7fdc2bede208ba26c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index d8687b59f02c,a501d3e6ac92..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -727,8 -851,9 +727,14 @@@ static int nvme_queue_rq(struct blk_mq_
  	 * unless this namespace is formated such that the metadata can be
  	 * stripped/generated by the controller with PRACT=1.
  	 */
++<<<<<<< HEAD
 +	if (ns->ms && !blk_integrity_rq(req)) {
 +		if (!(ns->pi_type && ns->ms == 8)) {
++=======
+ 	if (ns && ns->ms && !blk_integrity_rq(req)) {
+ 		if (!(ns->pi_type && ns->ms == 8) &&
+ 					req->cmd_type != REQ_TYPE_DRV_PRIV) {
++>>>>>>> 71feb364e7fa (NVMe: Fix IO for extended metadata formats)
  			req->errors = -EFAULT;
  			blk_mq_complete_request(req);
  			return BLK_MQ_RQ_QUEUE_OK;
@@@ -1654,17 -1744,20 +1660,30 @@@ static int nvme_submit_io(struct nvme_n
  		return -EINVAL;
  	}
  
 -	length = (io.nblocks + 1) << ns->lba_shift;
 -	meta_len = (io.nblocks + 1) * ns->ms;
 -	write = io.opcode & 1;
 +	if (IS_ERR(iod))
 +		return PTR_ERR(iod);
  
++<<<<<<< HEAD
 +	prp_len = nvme_setup_prps(dev, iod, length, GFP_KERNEL);
 +	if (length != prp_len) {
 +		status = -ENOMEM;
 +		goto unmap;
 +	}
 +	if (meta_len) {
 +		meta = dma_alloc_coherent(&dev->pci_dev->dev, meta_len,
 +					  &meta_dma, GFP_KERNEL);
++=======
+ 	if (ns->ext) {
+ 		length += meta_len;
+ 		meta_len = 0;
+ 	}
+ 	if (meta_len) {
+ 		if (((io.metadata & 3) || !io.metadata) && !ns->ext)
+ 			return -EINVAL;
+ 
+ 		meta = dma_alloc_coherent(dev->dev, meta_len,
+ 						&meta_dma, GFP_KERNEL);
++>>>>>>> 71feb364e7fa (NVMe: Fix IO for extended metadata formats)
  		if (!meta) {
  			status = -ENOMEM;
  			goto unmap;
* Unmerged path drivers/block/nvme-core.c
