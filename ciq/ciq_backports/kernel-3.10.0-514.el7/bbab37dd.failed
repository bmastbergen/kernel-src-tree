block: Add support for DAX reads/writes to block devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew Wilcox <matthew.r.wilcox@intel.com>
commit bbab37ddc20bae4709bca8745c128c4f46fe63c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bbab37dd.failed

If a block device supports the ->direct_access methods, bypass the normal
DIO path and use DAX to go straight to memcpy() instead of allocating
a DIO and a BIO.

Includes support for the DIO_SKIP_DIO_COUNT flag in DAX, as is done in
do_blockdev_direct_IO().

	Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit bbab37ddc20bae4709bca8745c128c4f46fe63c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/block_dev.c
#	fs/dax.c
diff --cc fs/block_dev.c
index db9b5e257bad,5dde6dff4940..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -161,9 -151,12 +161,18 @@@ blkdev_direct_IO(int rw, struct kiocb *
  	struct file *file = iocb->ki_filp;
  	struct inode *inode = file->f_mapping->host;
  
++<<<<<<< HEAD
 +	return __blockdev_direct_IO(rw, iocb, inode, I_BDEV(inode), iov, offset,
 +				    nr_segs, blkdev_get_block, NULL, NULL,
 +				    DIO_IGNORE_TRUNCATE);
++=======
+ 	if (IS_DAX(inode))
+ 		return dax_do_io(iocb, inode, iter, offset, blkdev_get_block,
+ 				NULL, DIO_SKIP_DIO_COUNT);
+ 	return __blockdev_direct_IO(iocb, inode, I_BDEV(inode), iter, offset,
+ 				    blkdev_get_block, NULL, NULL,
+ 				    DIO_SKIP_DIO_COUNT);
++>>>>>>> bbab37ddc20b (block: Add support for DAX reads/writes to block devices)
  }
  
  int __sync_blockdev(struct block_device *bdev, int wait)
@@@ -1199,9 -1176,8 +1208,10 @@@ static int __blkdev_get(struct block_de
  		bdev->bd_disk = disk;
  		bdev->bd_queue = disk->queue;
  		bdev->bd_contains = bdev;
+ 		bdev->bd_inode->i_flags = disk->fops->direct_access ? S_DAX : 0;
  		if (!partno) {
 +			struct backing_dev_info *bdi;
 +
  			ret = -ENXIO;
  			bdev->bd_part = disk_get_part(disk, partno);
  			if (!bdev->bd_part)
* Unmerged path fs/dax.c
* Unmerged path fs/block_dev.c
* Unmerged path fs/dax.c
