mmc: core: Add support for HS400 re-tuning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Add support for HS400 re-tuning (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 93.67%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 6376f69d20a6905c1d83be451065f70200490b98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6376f69d.failed

HS400 re-tuning must be done in HS200 mode. Add
the ability to switch from HS400 mode to HS200
mode before re-tuning and switch back to HS400
after re-tuning.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 6376f69d20a6905c1d83be451065f70200490b98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.h
#	drivers/mmc/core/host.c
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/core.h
index f712f6e0bc34,e6f2de7074ad..000000000000
--- a/drivers/mmc/core/core.h
+++ b/drivers/mmc/core/core.h
@@@ -84,5 -86,10 +84,13 @@@ void mmc_add_card_debugfs(struct mmc_ca
  void mmc_remove_card_debugfs(struct mmc_card *card);
  
  void mmc_init_context_info(struct mmc_host *host);
++<<<<<<< HEAD
++=======
+ 
+ int mmc_execute_tuning(struct mmc_card *card);
+ int mmc_hs200_to_hs400(struct mmc_card *card);
+ int mmc_hs400_to_hs200(struct mmc_card *card);
+ 
++>>>>>>> 6376f69d20a6 (mmc: core: Add support for HS400 re-tuning)
  #endif
  
diff --cc drivers/mmc/core/host.c
index 1ef8c2a03585,86c495b7a335..000000000000
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@@ -300,6 -301,90 +300,93 @@@ static inline void mmc_host_clk_sysfs_i
  
  #endif
  
++<<<<<<< HEAD
++=======
+ void mmc_retune_enable(struct mmc_host *host)
+ {
+ 	host->can_retune = 1;
+ 	if (host->retune_period)
+ 		mod_timer(&host->retune_timer,
+ 			  jiffies + host->retune_period * HZ);
+ }
+ 
+ void mmc_retune_disable(struct mmc_host *host)
+ {
+ 	host->can_retune = 0;
+ 	del_timer_sync(&host->retune_timer);
+ 	host->retune_now = 0;
+ 	host->need_retune = 0;
+ }
+ 
+ void mmc_retune_timer_stop(struct mmc_host *host)
+ {
+ 	del_timer_sync(&host->retune_timer);
+ }
+ EXPORT_SYMBOL(mmc_retune_timer_stop);
+ 
+ void mmc_retune_hold(struct mmc_host *host)
+ {
+ 	if (!host->hold_retune)
+ 		host->retune_now = 1;
+ 	host->hold_retune += 1;
+ }
+ 
+ void mmc_retune_release(struct mmc_host *host)
+ {
+ 	if (host->hold_retune)
+ 		host->hold_retune -= 1;
+ 	else
+ 		WARN_ON(1);
+ }
+ 
+ int mmc_retune(struct mmc_host *host)
+ {
+ 	bool return_to_hs400 = false;
+ 	int err;
+ 
+ 	if (host->retune_now)
+ 		host->retune_now = 0;
+ 	else
+ 		return 0;
+ 
+ 	if (!host->need_retune || host->doing_retune || !host->card)
+ 		return 0;
+ 
+ 	host->need_retune = 0;
+ 
+ 	host->doing_retune = 1;
+ 
+ 	if (host->ios.timing == MMC_TIMING_MMC_HS400) {
+ 		err = mmc_hs400_to_hs200(host->card);
+ 		if (err)
+ 			goto out;
+ 
+ 		return_to_hs400 = true;
+ 
+ 		if (host->ops->prepare_hs400_tuning)
+ 			host->ops->prepare_hs400_tuning(host, &host->ios);
+ 	}
+ 
+ 	err = mmc_execute_tuning(host->card);
+ 	if (err)
+ 		goto out;
+ 
+ 	if (return_to_hs400)
+ 		err = mmc_hs200_to_hs400(host->card);
+ out:
+ 	host->doing_retune = 0;
+ 
+ 	return err;
+ }
+ 
+ static void mmc_retune_timer(unsigned long data)
+ {
+ 	struct mmc_host *host = (struct mmc_host *)data;
+ 
+ 	mmc_retune_needed(host);
+ }
+ 
++>>>>>>> 6376f69d20a6 (mmc: core: Add support for HS400 re-tuning)
  /**
   *	mmc_of_parse() - parse host's device-tree node
   *	@host: host whose node should be parsed.
diff --cc drivers/mmc/core/mmc.c
index 1c70e41c57b6,a8028633253a..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -897,23 -924,333 +897,303 @@@ static int mmc_select_hs200(struct mmc_
  		if (err)
  			continue;
  
 -		bus_width = bus_widths[idx];
 -		mmc_set_bus_width(host, bus_width);
 +		mmc_set_bus_width(card->host, bus_widths[idx]);
  
 -		/*
 -		 * If controller can't handle bus width test,
 -		 * compare ext_csd previously read in 1 bit mode
 -		 * against ext_csd at new bus width
 -		 */
  		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 -			err = mmc_compare_ext_csds(card, bus_width);
 +			err = mmc_compare_ext_csds(card, bus_widths[idx]);
  		else
++<<<<<<< HEAD
 +			err = mmc_bus_test(card, bus_widths[idx]);
++=======
+ 			err = mmc_bus_test(card, bus_width);
+ 
+ 		if (!err) {
+ 			err = bus_width;
+ 			break;
+ 		} else {
+ 			pr_warn("%s: switch to bus width %d failed\n",
+ 				mmc_hostname(host), ext_csd_bits[idx]);
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Switch to the high-speed mode
+  */
+ static int mmc_select_hs(struct mmc_card *card)
+ {
+ 	int err;
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (!err)
+ 		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Activate wide bus and DDR if supported.
+  */
+ static int mmc_select_hs_ddr(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	u32 bus_width, ext_csd_bits;
+ 	int err = 0;
+ 
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))
+ 		return 0;
+ 
+ 	bus_width = host->ios.bus_width;
+ 	if (bus_width == MMC_BUS_WIDTH_1)
+ 		return 0;
+ 
+ 	ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
+ 		EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			EXT_CSD_BUS_WIDTH,
+ 			ext_csd_bits,
+ 			card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width %d ddr failed\n",
+ 			mmc_hostname(host), 1 << bus_width);
+ 		return err;
+ 	}
+ 
+ 	/*
+ 	 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
+ 	 * signaling.
+ 	 *
+ 	 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
+ 	 *
+ 	 * 1.8V vccq at 3.3V core voltage (vcc) is not required
+ 	 * in the JEDEC spec for DDR.
+ 	 *
+ 	 * Even (e)MMC card can support 3.3v to 1.2v vccq, but not all
+ 	 * host controller can support this, like some of the SDHCI
+ 	 * controller which connect to an eMMC device. Some of these
+ 	 * host controller still needs to use 1.8v vccq for supporting
+ 	 * DDR mode.
+ 	 *
+ 	 * So the sequence will be:
+ 	 * if (host and device can both support 1.2v IO)
+ 	 *	use 1.2v IO;
+ 	 * else if (host and device can both support 1.8v IO)
+ 	 *	use 1.8v IO;
+ 	 * so if host and device can only support 3.3v IO, this is the
+ 	 * last choice.
+ 	 *
+ 	 * WARNING: eMMC rules are NOT the same as SD DDR
+ 	 */
+ 	err = -EINVAL;
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_8V))
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* make sure vccq is 3.3v after switching disaster */
+ 	if (err)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
+ 
+ 	if (!err)
+ 		mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	return err;
+ }
+ 
+ static int mmc_select_hs400(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * HS400 mode requires 8-bit bus width
+ 	 */
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	      host->ios.bus_width == MMC_BUS_WIDTH_8))
+ 		return 0;
+ 
+ 	/*
+ 	 * Before switching to dual data rate operation for HS400,
+ 	 * it is required to convert from HS200 mode to HS mode.
+ 	 */
+ 	mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 	mmc_set_bus_speed(card);
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_err("%s: switch to high-speed from hs200 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			 EXT_CSD_BUS_WIDTH,
+ 			 EXT_CSD_DDR_BUS_WIDTH_8,
+ 			 card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width for hs400 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS400,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_err("%s: switch to hs400 failed, err:%d\n",
+ 			 mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
+ 	mmc_set_bus_speed(card);
+ 
+ 	return 0;
+ }
+ 
+ int mmc_hs200_to_hs400(struct mmc_card *card)
+ {
+ 	return mmc_select_hs400(card);
+ }
+ 
+ /* Caller must hold re-tuning */
+ static int mmc_switch_status(struct mmc_card *card)
+ {
+ 	u32 status;
+ 	int err;
+ 
+ 	err = mmc_send_status(card, &status);
+ 	if (err)
+ 		return err;
+ 
+ 	return mmc_switch_status_error(card->host, status);
+ }
+ 
+ int mmc_hs400_to_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	bool send_status = true;
+ 	unsigned int max_dtr;
+ 	int err;
+ 
+ 	if (host->caps & MMC_CAP_WAIT_WHILE_BUSY)
+ 		send_status = false;
+ 
+ 	/* Reduce frequency to HS */
+ 	max_dtr = card->ext_csd.hs_max_dtr;
+ 	mmc_set_clock(host, max_dtr);
+ 
+ 	/* Switch HS400 to HS DDR */
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+ 			   EXT_CSD_TIMING_HS, card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	/* Switch HS DDR to HS */
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BUS_WIDTH,
+ 			   EXT_CSD_BUS_WIDTH_8, card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	/* Switch HS to HS200 */
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+ 			   EXT_CSD_TIMING_HS200,
+ 			   card->ext_csd.generic_cmd6_time, true, send_status,
+ 			   true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS200);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	mmc_set_bus_speed(card);
+ 
+ 	return 0;
+ 
+ out_err:
+ 	pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
+ 	       __func__, err);
+ 	return err;
+ }
+ 
+ /*
+  * For device supporting HS200 mode, the following sequence
+  * should be done before executing the tuning process.
+  * 1. set the desired bus width(4-bit or 8-bit, 1-bit is not supported)
+  * 2. switch to HS200 mode
+  * 3. set the clock to > 52Mhz and <=200MHz
+  */
+ static int mmc_select_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = -EINVAL;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* If fails try again during next card power cycle */
+ 	if (err)
+ 		goto err;
+ 
+ 	/*
+ 	 * Set the bus width(4 or 8) with host's support and
+ 	 * switch to HS200 mode if bus width is set successfully.
+ 	 */
+ 	err = mmc_select_bus_width(card);
+ 	if (!IS_ERR_VALUE(err)) {
+ 		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 				   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS200,
+ 				   card->ext_csd.generic_cmd6_time,
+ 				   true, true, true);
++>>>>>>> 6376f69d20a6 (mmc: core: Add support for HS400 re-tuning)
  		if (!err)
 -			mmc_set_timing(host, MMC_TIMING_MMC_HS200);
 -	}
 -err:
 -	return err;
 -}
 -
 -/*
 - * Activate High Speed or HS200 mode if supported.
 - */
 -static int mmc_select_timing(struct mmc_card *card)
 -{
 -	int err = 0;
 -
 -	if (!mmc_can_ext_csd(card))
 -		goto bus_speed;
 -
 -	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
 -		err = mmc_select_hs200(card);
 -	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
 -		err = mmc_select_hs(card);
 -
 -	if (err && err != -EBADMSG)
 -		return err;
 -
 -	if (err) {
 -		pr_warn("%s: switch to %s failed\n",
 -			mmc_card_hs(card) ? "high-speed" :
 -			(mmc_card_hs200(card) ? "hs200" : ""),
 -			mmc_hostname(card->host));
 -		err = 0;
 +			break;
  	}
  
 -bus_speed:
 -	/*
 -	 * Set the bus speed to the selected bus timing.
 -	 * If timing is not selected, backward compatible is the default.
 -	 */
 -	mmc_set_bus_speed(card);
 +	/* switch to HS200 mode if bus width set successfully */
 +	if (!err)
 +		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +				EXT_CSD_HS_TIMING, 2,
 +				card->ext_csd.generic_cmd6_time,
 +				true, true, true);
 +err:
  	return err;
  }
  
* Unmerged path drivers/mmc/core/core.h
* Unmerged path drivers/mmc/core/host.c
* Unmerged path drivers/mmc/core/mmc.c
