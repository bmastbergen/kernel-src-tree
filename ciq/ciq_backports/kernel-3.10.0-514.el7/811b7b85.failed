nfs42: respect clone_blksize

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 811b7b85d6641df580a6c43184cf13d6fcc7498d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/811b7b85.failed

draft-ietf-nfsv4-minorversion2-38.txt says:
   Both cl_src_offset and
   cl_dst_offset must be aligned to the clone block size Section 12.2.1.
   The number of bytes to be cloned must be a multiple of the clone
   block size, except in the case in which cl_src_offset plus the number
   of bytes to be cloned is equal to the source file size.

	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 811b7b85d6641df580a6c43184cf13d6fcc7498d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4file.c
diff --cc fs/nfs/nfs4file.c
index 75f15320a424,4f463dd8bae3..000000000000
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@@ -165,8 -193,115 +165,106 @@@ static long nfs42_fallocate(struct fil
  		return nfs42_proc_deallocate(filep, offset, len);
  	return nfs42_proc_allocate(filep, offset, len);
  }
++<<<<<<< HEAD
++=======
+ 
+ static noinline long
+ nfs42_ioctl_clone(struct file *dst_file, unsigned long srcfd,
+ 		  u64 src_off, u64 dst_off, u64 count)
+ {
+ 	struct inode *dst_inode = file_inode(dst_file);
+ 	struct nfs_server *server = NFS_SERVER(dst_inode);
+ 	struct fd src_file;
+ 	struct inode *src_inode;
+ 	unsigned int bs = server->clone_blksize;
+ 	int ret;
+ 
+ 	/* dst file must be opened for writing */
+ 	if (!(dst_file->f_mode & FMODE_WRITE))
+ 		return -EINVAL;
+ 
+ 	ret = mnt_want_write_file(dst_file);
+ 	if (ret)
+ 		return ret;
+ 
+ 	src_file = fdget(srcfd);
+ 	if (!src_file.file) {
+ 		ret = -EBADF;
+ 		goto out_drop_write;
+ 	}
+ 
+ 	src_inode = file_inode(src_file.file);
+ 
+ 	/* src and dst must be different files */
+ 	ret = -EINVAL;
+ 	if (src_inode == dst_inode)
+ 		goto out_fput;
+ 
+ 	/* src file must be opened for reading */
+ 	if (!(src_file.file->f_mode & FMODE_READ))
+ 		goto out_fput;
+ 
+ 	/* src and dst must be regular files */
+ 	ret = -EISDIR;
+ 	if (!S_ISREG(src_inode->i_mode) || !S_ISREG(dst_inode->i_mode))
+ 		goto out_fput;
+ 
+ 	ret = -EXDEV;
+ 	if (src_file.file->f_path.mnt != dst_file->f_path.mnt ||
+ 	    src_inode->i_sb != dst_inode->i_sb)
+ 		goto out_fput;
+ 
+ 	/* check alignment w.r.t. clone_blksize */
+ 	ret = -EINVAL;
+ 	if (bs) {
+ 		if (!IS_ALIGNED(src_off, bs) || !IS_ALIGNED(dst_off, bs))
+ 			goto out_fput;
+ 		if (!IS_ALIGNED(count, bs) && i_size_read(src_inode) != (src_off + count))
+ 			goto out_fput;
+ 	}
+ 
+ 	/* XXX: do we lock at all? what if server needs CB_RECALL_LAYOUT? */
+ 	if (dst_inode < src_inode) {
+ 		mutex_lock_nested(&dst_inode->i_mutex, I_MUTEX_PARENT);
+ 		mutex_lock_nested(&src_inode->i_mutex, I_MUTEX_CHILD);
+ 	} else {
+ 		mutex_lock_nested(&src_inode->i_mutex, I_MUTEX_PARENT);
+ 		mutex_lock_nested(&dst_inode->i_mutex, I_MUTEX_CHILD);
+ 	}
+ 
+ 	/* flush all pending writes on both src and dst so that server
+ 	 * has the latest data */
+ 	ret = nfs_sync_inode(src_inode);
+ 	if (ret)
+ 		goto out_unlock;
+ 	ret = nfs_sync_inode(dst_inode);
+ 	if (ret)
+ 		goto out_unlock;
+ 
+ 	ret = nfs42_proc_clone(src_file.file, dst_file, src_off, dst_off, count);
+ 
+ 	/* truncate inode page cache of the dst range so that future reads can fetch
+ 	 * new data from server */
+ 	if (!ret)
+ 		truncate_inode_pages_range(&dst_inode->i_data, dst_off, dst_off + count - 1);
+ 
+ out_unlock:
+ 	if (dst_inode < src_inode) {
+ 		mutex_unlock(&src_inode->i_mutex);
+ 		mutex_unlock(&dst_inode->i_mutex);
+ 	} else {
+ 		mutex_unlock(&dst_inode->i_mutex);
+ 		mutex_unlock(&src_inode->i_mutex);
+ 	}
+ out_fput:
+ 	fdput(src_file);
+ out_drop_write:
+ 	mnt_drop_write_file(dst_file);
+ 	return ret;
+ }
++>>>>>>> 811b7b85d664 (nfs42: respect clone_blksize)
  #endif /* CONFIG_NFS_V4_2 */
  
 -long nfs4_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 -{
 -	switch (cmd) {
 -#ifdef CONFIG_NFS_V4_2
 -	case NFS_IOC_CLONE:
 -		return nfs42_ioctl_clone(file, arg, 0, 0, 0);
 -#endif
 -	}
 -
 -	return -ENOTTY;
 -}
 -
  const struct file_operations nfs4_file_operations = {
  #ifdef CONFIG_NFS_V4_2
  	.llseek		= nfs4_file_llseek,
* Unmerged path fs/nfs/nfs4file.c
