perf/x86/intel/cqm: Add storage for 'closid' and clean up 'struct intel_pqr_state'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit bf926731e1585ccad029ca2fad1444fee082b78d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bf926731.failed

'closid' (CLass Of Service ID) is used for the Class based Cache
Allocation Technology (CAT). Add explicit storage to the per cpu cache
for it, so it can be used later with the CAT support (requires to move
the per cpu data).

While at it:

 - Rename the structure to intel_pqr_state which reflects the actual
   purpose of the struct: cache values which go into the PQR MSR

 - Rename 'cnt' to rmid_usecnt which reflects the actual purpose of
   the counter.

 - Document the structure and the struct members.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Matt Fleming <matt.fleming@intel.com>
	Cc: Kanaka Juvva <kanaka.d.juvva@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Cc: Will Auld <will.auld@intel.com>
Link: http://lkml.kernel.org/r/20150518235150.240899319@linutronix.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit bf926731e1585ccad029ca2fad1444fee082b78d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/perf_event_intel_cqm.c
diff --cc arch/x86/kernel/cpu/perf_event_intel_cqm.c
index 147473998d45,8233b29bdd35..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel_cqm.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_cqm.c
@@@ -1242,24 -1237,28 +1245,30 @@@ static struct pmu intel_cqm_pmu = 
  
  static inline void cqm_pick_event_reader(int cpu)
  {
 -	int phys_id = topology_physical_package_id(cpu);
 -	int i;
 +	int reader;
  
 -	for_each_cpu(i, &cqm_cpumask) {
 -		if (phys_id == topology_physical_package_id(i))
 -			return;	/* already got reader for this socket */
 -	}
 -
 -	cpumask_set_cpu(cpu, &cqm_cpumask);
 +	/* First online cpu in package becomes the reader */
 +	reader = cpumask_any_and(&cqm_cpumask, topology_core_cpumask(cpu));
 +	if (reader >= nr_cpu_ids)
 +		cpumask_set_cpu(cpu, &cqm_cpumask);
  }
  
 -static void intel_cqm_cpu_prepare(unsigned int cpu)
 +static void intel_cqm_cpu_starting(unsigned int cpu)
  {
++<<<<<<< HEAD
 +	struct intel_cqm_state *state = &per_cpu(cqm_state, cpu);
 +	struct rh_cpuinfo_x86 *rh_c = &rh_cpu_data(cpu);
++=======
+ 	struct intel_pqr_state *state = &per_cpu(pqr_state, cpu);
+ 	struct cpuinfo_x86 *c = &cpu_data(cpu);
++>>>>>>> bf926731e158 (perf/x86/intel/cqm: Add storage for 'closid' and clean up 'struct intel_pqr_state')
  
  	state->rmid = 0;
- 	state->cnt  = 0;
+ 	state->closid = 0;
+ 	state->rmid_usecnt = 0;
  
 -	WARN_ON(c->x86_cache_max_rmid != cqm_max_rmid);
 -	WARN_ON(c->x86_cache_occ_scale != cqm_l3_scale);
 +	WARN_ON(rh_c->x86_cache_max_rmid != cqm_max_rmid);
 +	WARN_ON(rh_c->x86_cache_occ_scale != cqm_l3_scale);
  }
  
  static void intel_cqm_cpu_exit(unsigned int cpu)
* Unmerged path arch/x86/kernel/cpu/perf_event_intel_cqm.c
