netfilter: bridge: forward IPv6 fragmented packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bernhard Thaler <bernhard.thaler@wvnet.at>
commit efb6de9b4ba0092b2c55f6a52d16294a8a698edd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/efb6de9b.failed

IPv6 fragmented packets are not forwarded on an ethernet bridge
with netfilter ip6_tables loaded. e.g. steps to reproduce

1) create a simple bridge like this

        modprobe br_netfilter
        brctl addbr br0
        brctl addif br0 eth0
        brctl addif br0 eth2
        ifconfig eth0 up
        ifconfig eth2 up
        ifconfig br0 up

2) place a host with an IPv6 address on each side of the bridge

        set IPv6 address on host A:
        ip -6 addr add fd01:2345:6789:1::1/64 dev eth0

        set IPv6 address on host B:
        ip -6 addr add fd01:2345:6789:1::2/64 dev eth0

3) run a simple ping command on host A with packets > MTU

        ping6 -s 4000 fd01:2345:6789:1::2

4) wait some time and run e.g. "ip6tables -t nat -nvL" on the bridge

IPv6 fragmented packets traverse the bridge cleanly until somebody runs.
"ip6tables -t nat -nvL". As soon as it is run (and netfilter modules are
loaded) IPv6 fragmented packets do not traverse the bridge any more (you
see no more responses in ping's output).

After applying this patch IPv6 fragmented packets traverse the bridge
cleanly in above scenario.

	Signed-off-by: Bernhard Thaler <bernhard.thaler@wvnet.at>
[pablo@netfilter.org: small changes to br_nf_dev_queue_xmit]
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit efb6de9b4ba0092b2c55f6a52d16294a8a698edd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter_ipv6.h
#	net/bridge/br_netfilter.c
#	net/bridge/br_private.h
#	net/ipv6/netfilter.c
diff --cc include/linux/netfilter_ipv6.h
index 868a47c719f5,8b7d28f3aada..000000000000
--- a/include/linux/netfilter_ipv6.h
+++ b/include/linux/netfilter_ipv6.h
@@@ -26,6 -18,18 +26,21 @@@ __sum16 nf_ip6_checksum(struct sk_buff 
  int ipv6_netfilter_init(void);
  void ipv6_netfilter_fini(void);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Hook functions for ipv6 to allow xt_* modules to be built-in even
+  * if IPv6 is a module.
+  */
+ struct nf_ipv6_ops {
+ 	int (*chk_addr)(struct net *net, const struct in6_addr *addr,
+ 			const struct net_device *dev, int strict);
+ 	void (*route_input)(struct sk_buff *skb);
+ 	int (*fragment)(struct sock *sk, struct sk_buff *skb,
+ 			int (*output)(struct sock *, struct sk_buff *));
+ };
+ 
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
  extern const struct nf_ipv6_ops __rcu *nf_ipv6_ops;
  static inline const struct nf_ipv6_ops *nf_get_ipv6_ops(void)
  {
diff --cc net/bridge/br_netfilter.c
index bfa28cea8c79,535f9dae743e..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -34,11 -34,9 +34,12 @@@
  
  #include <net/ip.h>
  #include <net/ipv6.h>
+ #include <net/addrconf.h>
  #include <net/route.h>
 -#include <net/netfilter/br_netfilter.h>
 +
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK)
 +#include <net/netfilter/nf_conntrack.h>
 +#endif
  
  #include <asm/uaccess.h>
  #include "br_private.h"
@@@ -297,35 -265,123 +298,102 @@@ drop
  	return -1;
  }
  
 -/* We only check the length. A bridge shouldn't do any hop-by-hop stuff
 - * anyway
 - */
 -static int check_hbh_len(struct sk_buff *skb)
 +/* PF_BRIDGE/PRE_ROUTING *********************************************/
 +/* Undo the changes made for ip6tables PREROUTING and continue the
 + * bridge PRE_ROUTING hook. */
 +static int br_nf_pre_routing_finish_ipv6(struct sock *sk, struct sk_buff *skb)
  {
 -	unsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);
 -	u32 pkt_len;
 -	const unsigned char *nh = skb_network_header(skb);
 -	int off = raw - nh;
 -	int len = (raw[1] + 1) << 3;
 -
 -	if ((raw + len) - skb->data > skb_headlen(skb))
 -		goto bad;
 -
 -	off += 2;
 -	len -= 2;
 -
 -	while (len > 0) {
 -		int optlen = nh[off + 1] + 2;
 -
 -		switch (nh[off]) {
 -		case IPV6_TLV_PAD1:
 -			optlen = 1;
 -			break;
 -
 -		case IPV6_TLV_PADN:
 -			break;
 +	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
 +	struct rtable *rt;
  
 -		case IPV6_TLV_JUMBO:
 -			if (nh[off + 1] != 4 || (off & 3) != 2)
 -				goto bad;
 -			pkt_len = ntohl(*(__be32 *)(nh + off + 2));
 -			if (pkt_len <= IPV6_MAXPLEN ||
 -			    ipv6_hdr(skb)->payload_len)
 -				goto bad;
 -			if (pkt_len > skb->len - sizeof(struct ipv6hdr))
 -				goto bad;
 -			if (pskb_trim_rcsum(skb,
 -					    pkt_len + sizeof(struct ipv6hdr)))
 -				goto bad;
 -			nh = skb_network_header(skb);
 -			break;
 -		default:
 -			if (optlen > len)
 -				goto bad;
 -			break;
 -		}
 -		off += optlen;
 -		len -= optlen;
 +	if (nf_bridge->mask & BRNF_PKT_TYPE) {
 +		skb->pkt_type = PACKET_OTHERHOST;
 +		nf_bridge->mask ^= BRNF_PKT_TYPE;
  	}
 -	if (len == 0)
 +	nf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;
 +
 +	rt = bridge_parent_rtable(nf_bridge->physindev);
 +	if (!rt) {
 +		kfree_skb(skb);
  		return 0;
++<<<<<<< HEAD
++=======
+ bad:
+ 	return -1;
+ }
+ 
+ /* Equivalent to br_validate_ipv4 for IPv6 */
+ static int br_validate_ipv6(struct sk_buff *skb)
+ {
+ 	const struct ipv6hdr *hdr;
+ 	struct net_device *dev = skb->dev;
+ 	struct inet6_dev *idev = in6_dev_get(skb->dev);
+ 	u32 pkt_len;
+ 	u8 ip6h_len = sizeof(struct ipv6hdr);
+ 
+ 	if (!pskb_may_pull(skb, ip6h_len))
+ 		goto inhdr_error;
+ 
+ 	if (skb->len < ip6h_len)
+ 		goto drop;
+ 
+ 	hdr = ipv6_hdr(skb);
+ 
+ 	if (hdr->version != 6)
+ 		goto inhdr_error;
+ 
+ 	pkt_len = ntohs(hdr->payload_len);
+ 
+ 	if (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {
+ 		if (pkt_len + ip6h_len > skb->len) {
+ 			IP6_INC_STATS_BH(dev_net(dev), idev,
+ 					 IPSTATS_MIB_INTRUNCATEDPKTS);
+ 			goto drop;
+ 		}
+ 		if (pskb_trim_rcsum(skb, pkt_len + ip6h_len)) {
+ 			IP6_INC_STATS_BH(dev_net(dev), idev,
+ 					 IPSTATS_MIB_INDISCARDS);
+ 			goto drop;
+ 		}
+ 	}
+ 	if (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))
+ 		goto drop;
+ 
+ 	memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
+ 	/* No IP options in IPv6 header; however it should be
+ 	 * checked if some next headers need special treatment
+ 	 */
+ 	return 0;
+ 
+ inhdr_error:
+ 	IP6_INC_STATS_BH(dev_net(dev), idev, IPSTATS_MIB_INHDRERRORS);
+ drop:
+ 	return -1;
+ }
+ 
+ static void nf_bridge_update_protocol(struct sk_buff *skb)
+ {
+ 	switch (skb->nf_bridge->orig_proto) {
+ 	case BRNF_PROTO_8021Q:
+ 		skb->protocol = htons(ETH_P_8021Q);
+ 		break;
+ 	case BRNF_PROTO_PPPOE:
+ 		skb->protocol = htons(ETH_P_PPP_SES);
+ 		break;
+ 	case BRNF_PROTO_UNCHANGED:
+ 		break;
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
  	}
 +	skb_dst_set_noref(skb, &rt->dst);
 +
 +	skb->dev = nf_bridge->physindev;
 +	nf_bridge_update_protocol(skb);
 +	nf_bridge_push_encap_header(skb);
 +	NF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, sk, skb,
 +		       skb->dev, NULL,
 +		       br_handle_frame_finish, 1);
 +
 +	return 0;
  }
  
  /* Obtain the correct destination MAC address, while preserving the original
@@@ -372,20 -429,77 +440,80 @@@ free_skb
  	return 0;
  }
  
 -static bool daddr_was_changed(const struct sk_buff *skb,
 -			      const struct nf_bridge_info *nf_bridge)
 +static bool dnat_took_place(const struct sk_buff *skb)
  {
 -	switch (skb->protocol) {
 -	case htons(ETH_P_IP):
 -		return ip_hdr(skb)->daddr != nf_bridge->ipv4_daddr;
 -	case htons(ETH_P_IPV6):
 -		return memcmp(&nf_bridge->ipv6_daddr, &ipv6_hdr(skb)->daddr,
 -			      sizeof(ipv6_hdr(skb)->daddr)) != 0;
 -	default:
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK)
 +	enum ip_conntrack_info ctinfo;
 +	struct nf_conn *ct;
 +
 +	ct = nf_ct_get(skb, &ctinfo);
 +	if (!ct || nf_ct_is_untracked(ct))
  		return false;
 -	}
 -}
  
++<<<<<<< HEAD
 +	return test_bit(IPS_DST_NAT_BIT, &ct->status);
 +#else
 +	return false;
 +#endif
++=======
+ /* PF_BRIDGE/PRE_ROUTING: Undo the changes made for ip6tables
+  * PREROUTING and continue the bridge PRE_ROUTING hook. See comment
+  * for br_nf_pre_routing_finish(), same logic is used here but
+  * equivalent IPv6 function ip6_route_input() called indirectly.
+  */
+ static int br_nf_pre_routing_finish_ipv6(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);
+ 	struct rtable *rt;
+ 	struct net_device *dev = skb->dev;
+ 	const struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();
+ 
+ 	nf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;
+ 
+ 	if (nf_bridge->pkt_otherhost) {
+ 		skb->pkt_type = PACKET_OTHERHOST;
+ 		nf_bridge->pkt_otherhost = false;
+ 	}
+ 	nf_bridge->mask &= ~BRNF_NF_BRIDGE_PREROUTING;
+ 	if (daddr_was_changed(skb, nf_bridge)) {
+ 		skb_dst_drop(skb);
+ 		v6ops->route_input(skb);
+ 
+ 		if (skb_dst(skb)->error) {
+ 			kfree_skb(skb);
+ 			return 0;
+ 		}
+ 
+ 		if (skb_dst(skb)->dev == dev) {
+ 			skb->dev = nf_bridge->physindev;
+ 			nf_bridge_update_protocol(skb);
+ 			nf_bridge_push_encap_header(skb);
+ 			NF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
+ 				       sk, skb, skb->dev, NULL,
+ 				       br_nf_pre_routing_finish_bridge,
+ 				       1);
+ 			return 0;
+ 		}
+ 		ether_addr_copy(eth_hdr(skb)->h_dest, dev->dev_addr);
+ 		skb->pkt_type = PACKET_HOST;
+ 	} else {
+ 		rt = bridge_parent_rtable(nf_bridge->physindev);
+ 		if (!rt) {
+ 			kfree_skb(skb);
+ 			return 0;
+ 		}
+ 		skb_dst_set_noref(skb, &rt->dst);
+ 	}
+ 
+ 	skb->dev = nf_bridge->physindev;
+ 	nf_bridge_update_protocol(skb);
+ 	nf_bridge_push_encap_header(skb);
+ 	NF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, sk, skb,
+ 		       skb->dev, NULL,
+ 		       br_handle_frame_finish, 1);
+ 
+ 	return 0;
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
  }
  
  /* This requires some explaining. If DNAT has taken place,
@@@ -539,92 -657,16 +667,78 @@@ static struct net_device *setup_pre_rou
  	return skb->dev;
  }
  
 +/* We only check the length. A bridge shouldn't do any hop-by-hop stuff anyway */
 +static int check_hbh_len(struct sk_buff *skb)
 +{
 +	unsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);
 +	u32 pkt_len;
 +	const unsigned char *nh = skb_network_header(skb);
 +	int off = raw - nh;
 +	int len = (raw[1] + 1) << 3;
 +
 +	if ((raw + len) - skb->data > skb_headlen(skb))
 +		goto bad;
 +
 +	off += 2;
 +	len -= 2;
 +
 +	while (len > 0) {
 +		int optlen = nh[off + 1] + 2;
 +
 +		switch (nh[off]) {
 +		case IPV6_TLV_PAD1:
 +			optlen = 1;
 +			break;
 +
 +		case IPV6_TLV_PADN:
 +			break;
 +
 +		case IPV6_TLV_JUMBO:
 +			if (nh[off + 1] != 4 || (off & 3) != 2)
 +				goto bad;
 +			pkt_len = ntohl(*(__be32 *) (nh + off + 2));
 +			if (pkt_len <= IPV6_MAXPLEN ||
 +			    ipv6_hdr(skb)->payload_len)
 +				goto bad;
 +			if (pkt_len > skb->len - sizeof(struct ipv6hdr))
 +				goto bad;
 +			if (pskb_trim_rcsum(skb,
 +					    pkt_len + sizeof(struct ipv6hdr)))
 +				goto bad;
 +			nh = skb_network_header(skb);
 +			break;
 +		default:
 +			if (optlen > len)
 +				goto bad;
 +			break;
 +		}
 +		off += optlen;
 +		len -= optlen;
 +	}
 +	if (len == 0)
 +		return 0;
 +bad:
 +	return -1;
 +
 +}
 +
  /* Replicate the checks that IPv6 does on packet reception and pass the packet
-  * to ip6tables, which doesn't support NAT, so things are fairly simple. */
+  * to ip6tables.
+  */
  static unsigned int br_nf_pre_routing_ipv6(const struct nf_hook_ops *ops,
  					   struct sk_buff *skb,
 +					   const struct net_device *in,
 +					   const struct net_device *out,
  					   const struct nf_hook_state *state)
  {
++<<<<<<< HEAD
 +	const struct ipv6hdr *hdr;
 +	u32 pkt_len;
++=======
+ 	struct nf_bridge_info *nf_bridge;
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
  
- 	if (skb->len < sizeof(struct ipv6hdr))
- 		return NF_DROP;
- 
- 	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
- 		return NF_DROP;
- 
- 	hdr = ipv6_hdr(skb);
- 
- 	if (hdr->version != 6)
- 		return NF_DROP;
- 
- 	pkt_len = ntohs(hdr->payload_len);
- 
- 	if (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {
- 		if (pkt_len + sizeof(struct ipv6hdr) > skb->len)
- 			return NF_DROP;
- 		if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))
- 			return NF_DROP;
- 	}
- 	if (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))
+ 	if (br_validate_ipv6(skb))
  		return NF_DROP;
  
  	nf_bridge_put(skb->nf_bridge);
@@@ -724,17 -769,17 +838,25 @@@ static int br_nf_forward_finish(struct 
  	struct net_device *in;
  
  	if (!IS_ARP(skb) && !IS_VLAN_ARP(skb)) {
 +		int frag_max_size;
  
++<<<<<<< HEAD
 +		if (skb->protocol == htons(ETH_P_IP)) {
 +			frag_max_size = IPCB(skb)->frag_max_size;
 +			BR_INPUT_SKB_CB(skb)->frag_max_size = frag_max_size;
 +		}
++=======
+ 		if (skb->protocol == htons(ETH_P_IP))
+ 			nf_bridge->frag_max_size = IPCB(skb)->frag_max_size;
+ 
+ 		if (skb->protocol == htons(ETH_P_IPV6))
+ 			nf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
  
  		in = nf_bridge->physindev;
 -		if (nf_bridge->pkt_otherhost) {
 +		if (nf_bridge->mask & BRNF_PKT_TYPE) {
  			skb->pkt_type = PACKET_OTHERHOST;
 -			nf_bridge->pkt_otherhost = false;
 +			nf_bridge->mask ^= BRNF_PKT_TYPE;
  		}
  		nf_bridge_update_protocol(skb);
  	} else {
@@@ -791,14 -837,17 +913,20 @@@ static unsigned int br_nf_forward_ip(co
  	}
  
  	if (pf == NFPROTO_IPV4) {
 -		if (br_validate_ipv4(skb))
 +		int frag_max = BR_INPUT_SKB_CB(skb)->frag_max_size;
 +
 +		if (br_parse_ip_options(skb))
  			return NF_DROP;
 -		IPCB(skb)->frag_max_size = nf_bridge->frag_max_size;
 +
 +		IPCB(skb)->frag_max_size = frag_max;
  	}
  
+ 	if (pf == NFPROTO_IPV6) {
+ 		if (br_validate_ipv6(skb))
+ 			return NF_DROP;
+ 		IP6CB(skb)->frag_max_size = nf_bridge->frag_max_size;
+ 	}
+ 
  	nf_bridge->physoutdev = skb->dev;
  	if (pf == NFPROTO_IPV4)
  		skb->protocol = htons(ETH_P_IP);
@@@ -848,30 -895,114 +976,138 @@@ static unsigned int br_nf_forward_arp(c
  	return NF_STOLEN;
  }
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
 +{
 +	int ret;
 +
 +	if (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&
 +	    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
 +	    !skb_is_gso(skb)) {
 +		if (br_parse_ip_options(skb))
 +			/* Drop invalid packet */
 +			return NF_DROP;
 +		ret = ip_fragment(sk, skb, br_dev_queue_push_xmit);
 +	} else
 +		ret = br_dev_queue_push_xmit(sk, skb);
 +
 +	return ret;
 +}
 +#else
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
 +{
 +        return br_dev_queue_push_xmit(sk, skb);
++=======
+ #if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4) || IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)
+ static int br_nf_push_frag_xmit(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct brnf_frag_data *data;
+ 	int err;
+ 
+ 	data = this_cpu_ptr(&brnf_frag_data_storage);
+ 	err = skb_cow_head(skb, data->size);
+ 
+ 	if (err) {
+ 		kfree_skb(skb);
+ 		return 0;
+ 	}
+ 
+ 	skb_copy_to_linear_data_offset(skb, -data->size, data->mac, data->size);
+ 	__skb_push(skb, data->encap_size);
+ 
+ 	nf_bridge_info_free(skb);
+ 	return br_dev_queue_push_xmit(sk, skb);
  }
  #endif
  
+ static int br_nf_ip_fragment(struct sock *sk, struct sk_buff *skb,
+ 			     int (*output)(struct sock *, struct sk_buff *))
+ {
+ 	unsigned int mtu = ip_skb_dst_mtu(skb);
+ 	struct iphdr *iph = ip_hdr(skb);
+ 	struct rtable *rt = skb_rtable(skb);
+ 	struct net_device *dev = rt->dst.dev;
+ 
+ 	if (unlikely(((iph->frag_off & htons(IP_DF)) && !skb->ignore_df) ||
+ 		     (IPCB(skb)->frag_max_size &&
+ 		      IPCB(skb)->frag_max_size > mtu))) {
+ 		IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
+ 		kfree_skb(skb);
+ 		return -EMSGSIZE;
+ 	}
+ 
+ 	return ip_do_fragment(sk, skb, output);
+ }
+ 
+ static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct nf_bridge_info *nf_bridge;
+ 	unsigned int mtu_reserved;
+ 
+ 	mtu_reserved = nf_bridge_mtu_reduction(skb);
+ 
+ 	if (skb_is_gso(skb) || skb->len + mtu_reserved <= skb->dev->mtu) {
+ 		nf_bridge_info_free(skb);
+ 		return br_dev_queue_push_xmit(sk, skb);
+ 	}
+ 
+ 	nf_bridge = nf_bridge_info_get(skb);
+ 
+ #if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
+ 	/* This is wrong! We should preserve the original fragment
+ 	 * boundaries by preserving frag_list rather than refragmenting.
+ 	 */
+ 	if (skb->protocol == htons(ETH_P_IP)) {
+ 		struct brnf_frag_data *data;
+ 
+ 		if (br_validate_ipv4(skb))
+ 			return NF_DROP;
+ 
+ 		IPCB(skb)->frag_max_size = nf_bridge->frag_max_size;
+ 
+ 		nf_bridge_update_protocol(skb);
+ 
+ 		data = this_cpu_ptr(&brnf_frag_data_storage);
+ 		data->encap_size = nf_bridge_encap_header_len(skb);
+ 		data->size = ETH_HLEN + data->encap_size;
+ 
+ 		skb_copy_from_linear_data_offset(skb, -data->size, data->mac,
+ 						 data->size);
+ 
+ 		return br_nf_ip_fragment(sk, skb, br_nf_push_frag_xmit);
+ 	}
+ #endif
+ #if IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)
+ 	if (skb->protocol == htons(ETH_P_IPV6)) {
+ 		const struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();
+ 		struct brnf_frag_data *data;
+ 
+ 		if (br_validate_ipv6(skb))
+ 			return NF_DROP;
+ 
+ 		IP6CB(skb)->frag_max_size = nf_bridge->frag_max_size;
+ 
+ 		nf_bridge_update_protocol(skb);
+ 
+ 		data = this_cpu_ptr(&brnf_frag_data_storage);
+ 		data->encap_size = nf_bridge_encap_header_len(skb);
+ 		data->size = ETH_HLEN + data->encap_size;
+ 
+ 		skb_copy_from_linear_data_offset(skb, -data->size, data->mac,
+ 						 data->size);
+ 
+ 		if (v6ops)
+ 			return v6ops->fragment(sk, skb, br_nf_push_frag_xmit);
+ 		else
+ 			return -EMSGSIZE;
+ 	}
+ #endif
+ 	nf_bridge_info_free(skb);
+ 	return br_dev_queue_push_xmit(sk, skb);
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
+ }
+ 
  /* PF_BRIDGE/POST_ROUTING ********************************************/
  static unsigned int br_nf_post_routing(const struct nf_hook_ops *ops,
  				       struct sk_buff *skb,
diff --cc net/bridge/br_private.h
index 42f63e0bc8cf,5dccced71269..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -201,11 -211,14 +202,19 @@@ struct net_bridg
  	struct list_head		port_list;
  	struct net_device		*dev;
  
 -	struct pcpu_sw_netstats		__percpu *stats;
 +	RH_KABI_REPLACE(struct br_cpu_netstats __percpu *stats, struct pcpu_sw_netstats		__percpu *stats)
  	spinlock_t			hash_lock;
  	struct hlist_head		hash[BR_HASH_SIZE];
++<<<<<<< HEAD
 +#ifdef CONFIG_BRIDGE_NETFILTER
 +	struct rtable 			fake_rtable;
++=======
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+ 	union {
+ 		struct rtable		fake_rtable;
+ 		struct rt6_info		fake_rt6_info;
+ 	};
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
  	bool				nf_call_iptables;
  	bool				nf_call_ip6tables;
  	bool				nf_call_arptables;
diff --cc net/ipv6/netfilter.c
index 2f3f82728364,b4de08a83e0b..000000000000
--- a/net/ipv6/netfilter.c
+++ b/net/ipv6/netfilter.c
@@@ -189,6 -191,8 +189,11 @@@ static __sum16 nf_ip6_checksum_partial(
  
  static const struct nf_ipv6_ops ipv6ops = {
  	.chk_addr	= ipv6_chk_addr,
++<<<<<<< HEAD
++=======
+ 	.route_input    = ip6_route_input,
+ 	.fragment	= ip6_fragment
++>>>>>>> efb6de9b4ba0 (netfilter: bridge: forward IPv6 fragmented packets)
  };
  
  static const struct nf_afinfo nf_ip6_afinfo = {
* Unmerged path include/linux/netfilter_ipv6.h
* Unmerged path net/bridge/br_netfilter.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/ipv6/netfilter.c
