IB/qib,staging/rdma/hfi1: use setup_timer api

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] ib/qib, rdma/hfi1: use setup_timer api (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 89.16%
commit-author Hari Prasath Gujulan Elango <hgujulan@visteon.com>
commit 045277cf1548ab04a114bf560a01e38cf33b91b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/045277cf.failed

Replace the timer API's to initialize a timer & then assign the callback
function by the setup_timer() API.

	Signed-off-by: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 045277cf1548ab04a114bf560a01e38cf33b91b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qib/qib_verbs.c
#	drivers/staging/hfi1/verbs.c
diff --cc drivers/infiniband/hw/qib/qib_verbs.c
index c4417a1f33be,2abe31d4e350..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@@ -2109,46 -1602,10 +2109,50 @@@ int qib_register_ib_device(struct qib_d
  		init_ibport(ppd + i);
  
  	/* Only need to initialize non-zero fields. */
++<<<<<<< HEAD
 +	spin_lock_init(&dev->qpt_lock);
 +	spin_lock_init(&dev->n_pds_lock);
 +	spin_lock_init(&dev->n_ahs_lock);
 +	spin_lock_init(&dev->n_cqs_lock);
 +	spin_lock_init(&dev->n_qps_lock);
 +	spin_lock_init(&dev->n_srqs_lock);
 +	spin_lock_init(&dev->n_mcast_grps_lock);
 +	init_timer(&dev->mem_timer);
 +	dev->mem_timer.function = mem_timer;
 +	dev->mem_timer.data = (unsigned long) dev;
++=======
+ 	setup_timer(&dev->mem_timer, mem_timer, (unsigned long)dev);
++>>>>>>> 045277cf1548 (IB/qib,staging/rdma/hfi1: use setup_timer api)
  
 -	qpt_mask = dd->qpn_mask;
 +	qib_init_qpn_table(dd, &dev->qpn_table);
  
 +	/*
 +	 * The top ib_qib_lkey_table_size bits are used to index the
 +	 * table.  The lower 8 bits can be owned by the user (copied from
 +	 * the LKEY).  The remaining bits act as a generation number or tag.
 +	 */
 +	spin_lock_init(&dev->lk_table.lock);
 +	/* insure generation is at least 4 bits see keys.c */
 +	if (ib_qib_lkey_table_size > MAX_LKEY_TABLE_BITS) {
 +		qib_dev_warn(dd, "lkey bits %u too large, reduced to %u\n",
 +			ib_qib_lkey_table_size, MAX_LKEY_TABLE_BITS);
 +		ib_qib_lkey_table_size = MAX_LKEY_TABLE_BITS;
 +	}
 +	dev->lk_table.max = 1 << ib_qib_lkey_table_size;
 +	lk_tab_size = dev->lk_table.max * sizeof(*dev->lk_table.table);
 +	dev->lk_table.table = (struct qib_mregion __rcu **)
 +		vmalloc(lk_tab_size);
 +	if (dev->lk_table.table == NULL) {
 +		ret = -ENOMEM;
 +		goto err_lk;
 +	}
 +	RCU_INIT_POINTER(dev->dma_mr, NULL);
 +	for (i = 0; i < dev->lk_table.max; i++)
 +		RCU_INIT_POINTER(dev->lk_table.table[i], NULL);
 +	INIT_LIST_HEAD(&dev->pending_mmaps);
 +	spin_lock_init(&dev->pending_lock);
 +	dev->mmap_offset = PAGE_SIZE;
 +	spin_lock_init(&dev->mmap_offset_lock);
  	INIT_LIST_HEAD(&dev->piowait);
  	INIT_LIST_HEAD(&dev->dmawait);
  	INIT_LIST_HEAD(&dev->txwait);
diff --cc drivers/staging/hfi1/verbs.c
index d228eb7fc4f0,35f6d92a6249..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -1849,43 -1455,9 +1849,47 @@@ int hfi1_register_ib_device(struct hfi1
  
  	/* Only need to initialize non-zero fields. */
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	spin_lock_init(&dev->n_ahs_lock);
 +	spin_lock_init(&dev->n_cqs_lock);
 +	spin_lock_init(&dev->n_qps_lock);
 +	spin_lock_init(&dev->n_srqs_lock);
 +	spin_lock_init(&dev->n_mcast_grps_lock);
 +	init_timer(&dev->mem_timer);
 +	dev->mem_timer.function = mem_timer;
 +	dev->mem_timer.data = (unsigned long) dev;
++=======
+ 	setup_timer(&dev->mem_timer, mem_timer, (unsigned long)dev);
++>>>>>>> 045277cf1548 (IB/qib,staging/rdma/hfi1: use setup_timer api):drivers/staging/rdma/hfi1/verbs.c
  
 +	/*
 +	 * The top hfi1_lkey_table_size bits are used to index the
 +	 * table.  The lower 8 bits can be owned by the user (copied from
 +	 * the LKEY).  The remaining bits act as a generation number or tag.
 +	 */
 +	spin_lock_init(&dev->lk_table.lock);
 +	dev->lk_table.max = 1 << hfi1_lkey_table_size;
 +	/* ensure generation is at least 4 bits (keys.c) */
 +	if (hfi1_lkey_table_size > RVT_MAX_LKEY_TABLE_BITS) {
 +		dd_dev_warn(dd, "lkey bits %u too large, reduced to %u\n",
 +			      hfi1_lkey_table_size, RVT_MAX_LKEY_TABLE_BITS);
 +		hfi1_lkey_table_size = RVT_MAX_LKEY_TABLE_BITS;
 +	}
 +	lk_tab_size = dev->lk_table.max * sizeof(*dev->lk_table.table);
 +	dev->lk_table.table = (struct rvt_mregion __rcu **)
 +		vmalloc(lk_tab_size);
 +	if (dev->lk_table.table == NULL) {
 +		ret = -ENOMEM;
 +		goto err_lk;
 +	}
 +	RCU_INIT_POINTER(dev->dma_mr, NULL);
 +	for (i = 0; i < dev->lk_table.max; i++)
 +		RCU_INIT_POINTER(dev->lk_table.table[i], NULL);
 +	INIT_LIST_HEAD(&dev->pending_mmaps);
 +	spin_lock_init(&dev->pending_lock);
  	seqlock_init(&dev->iowait_lock);
 +	dev->mmap_offset = PAGE_SIZE;
 +	spin_lock_init(&dev->mmap_offset_lock);
  	INIT_LIST_HEAD(&dev->txwait);
  	INIT_LIST_HEAD(&dev->memwait);
  
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.c
* Unmerged path drivers/staging/hfi1/verbs.c
