ipv4: Don't do expensive useless work during inetdev destroy.

jira LE-1907
cve CVE-2016-3156
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ipv4: Don't do expensive useless work during inetdev destroy (Paolo Abeni) [1318271] {CVE-2016-3156}
Rebuild_FUZZ: 99.17%
commit-author David S. Miller <davem@davemloft.net>
commit fbd40ea0180a2d328c5adc61414dc8bab9335ce2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fbd40ea0.failed

When an inetdev is destroyed, every address assigned to the interface
is removed.  And in this scenerio we do two pointless things which can
be very expensive if the number of assigned interfaces is large:

1) Address promotion.  We are deleting all addresses, so there is no
   point in doing this.

2) A full nf conntrack table purge for every address.  We only need to
   do this once, as is already caught by the existing
   masq_dev_notifier so masq_inet_event() can skip this.

	Reported-by: Solar Designer <solar@openwall.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
	Tested-by: Cyrill Gorcunov <gorcunov@openvz.org>
(cherry picked from commit fbd40ea0180a2d328c5adc61414dc8bab9335ce2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
diff --cc net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
index ab16e4731d7a,ea91058b5f6f..000000000000
--- a/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
@@@ -108,9 -108,19 +108,25 @@@ static int masq_inet_event(struct notif
  			   unsigned long event,
  			   void *ptr)
  {
++<<<<<<< HEAD
 +	struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;
 +
 +	return masq_device_event(this, event, dev);
++=======
+ 	struct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;
+ 	struct netdev_notifier_info info;
+ 
+ 	/* The masq_dev_notifier will catch the case of the device going
+ 	 * down.  So if the inetdev is dead and being destroyed we have
+ 	 * no work to do.  Otherwise this is an individual address removal
+ 	 * and we have to perform the flush.
+ 	 */
+ 	if (idev->dead)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_notifier_info_init(&info, idev->dev);
+ 	return masq_device_event(this, event, &info);
++>>>>>>> fbd40ea0180a (ipv4: Don't do expensive useless work during inetdev destroy.)
  }
  
  static struct notifier_block masq_dev_notifier = {
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index 25ce9bd1a367..8a69d4a71a6e 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -324,6 +324,9 @@ static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
 
 	ASSERT_RTNL();
 
+	if (in_dev->dead)
+		goto no_promotions;
+
 	/* 1. Deleting primary ifaddr forces deletion all secondaries
 	 * unless alias promotion is set
 	 **/
@@ -370,6 +373,7 @@ static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
 			fib_del_ifaddr(ifa, ifa1);
 	}
 
+no_promotions:
 	/* 2. Unlink it */
 
 	*ifap = ifa1->ifa_next;
diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index 59c306b4d24b..0f098926bedf 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -815,6 +815,9 @@ void fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)
 		subnet = 1;
 	}
 
+	if (in_dev->dead)
+		goto no_promotions;
+
 	/* Deletion is more complicated than add.
 	 * We should take care of not to delete too much :-)
 	 *
@@ -890,6 +893,7 @@ void fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)
 		}
 	}
 
+no_promotions:
 	if (!(ok & BRD_OK))
 		fib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);
 	if (subnet && ifa->ifa_prefixlen < 31) {
* Unmerged path net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
