ipv6: Create RTF_CACHE clone when FLOWI_FLAG_KNOWN_NH is set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 3da59bd94583d1239e4fbdee452265a160b9cd71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3da59bd9.failed

This patch always creates RTF_CACHE clone with DST_NOCACHE
when FLOWI_FLAG_KNOWN_NH is set so that the rt6i_dst is set to
the fl6->daddr.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Tested-by: Julian Anastasov <ja@ssi.bg>
	Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3da59bd94583d1239e4fbdee452265a160b9cd71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_fib.h
#	net/ipv6/route.c
diff --cc include/net/ip6_fib.h
index d152e230d58f,5556111022eb..000000000000
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@@ -165,13 -159,12 +165,20 @@@ static inline void rt6_update_expires(s
  	rt0->rt6i_flags |= RTF_EXPIRES;
  }
  
 -static inline u32 rt6_get_cookie(const struct rt6_info *rt)
 +static inline void rt6_set_from(struct rt6_info *rt, struct rt6_info *from)
  {
++<<<<<<< HEAD
 +	struct dst_entry *new = (struct dst_entry *) from;
 +
 +	rt->rt6i_flags &= ~RTF_EXPIRES;
 +	dst_hold(new);
 +	rt->dst.from = new;
++=======
+ 	if (unlikely(rt->dst.flags & DST_NOCACHE))
+ 		rt = (struct rt6_info *)(rt->dst.from);
+ 
+ 	return rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
++>>>>>>> 3da59bd94583 (ipv6: Create RTF_CACHE clone when FLOWI_FLAG_KNOWN_NH is set)
  }
  
  static inline void ip6_rt_put(struct rt6_info *rt)
diff --cc net/ipv6/route.c
index d52d1361c9f9,9e4c3c5d1591..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -953,42 -901,34 +953,69 @@@ redo_rt6_select
  		}
  	}
  
- 	dst_hold(&rt->dst);
+ 	dst_use(&rt->dst, jiffies);
  	read_unlock_bh(&table->tb6_lock);
  
++<<<<<<< HEAD
 +	if (rt->rt6i_flags & RTF_CACHE)
 +		goto out2;
 +
 +	if (!rt6_is_gw_or_nonexthop(rt) ||
 +	    !(rt->dst.flags & DST_HOST) || !(rt->rt6i_flags & RTF_LOCAL))
 +		nrt = ip6_rt_cache_alloc(rt, &fl6->daddr, &fl6->saddr);
 +	else
 +		goto out2;
 +
 +	ip6_rt_put(rt);
 +	rt = nrt ? : net->ipv6.ip6_null_entry;
 +
 +	dst_hold(&rt->dst);
 +	if (nrt) {
 +		err = ip6_ins_rt(nrt);
 +		if (!err)
 +			goto out2;
 +	}
 +
 +	if (--attempts <= 0)
 +		goto out2;
 +
 +	/*
 +	 * Race condition! In the gap, when table->tb6_lock was
 +	 * released someone could insert this route.  Relookup.
 +	 */
 +	ip6_rt_put(rt);
 +	goto redo_fib6_lookup_lock;
 +
 +out2:
 +	rt->dst.lastuse = jiffies;
 +	rt->dst.__use++;
++=======
+ 	if (rt == net->ipv6.ip6_null_entry || (rt->rt6i_flags & RTF_CACHE)) {
+ 		goto done;
+ 	} else if (unlikely((fl6->flowi6_flags & FLOWI_FLAG_KNOWN_NH) &&
+ 			    !(rt->rt6i_flags & RTF_GATEWAY))) {
+ 		/* Create a RTF_CACHE clone which will not be
+ 		 * owned by the fib6 tree.  It is for the special case where
+ 		 * the daddr in the skb during the neighbor look-up is different
+ 		 * from the fl6->daddr used to look-up route here.
+ 		 */
++>>>>>>> 3da59bd94583 (ipv6: Create RTF_CACHE clone when FLOWI_FLAG_KNOWN_NH is set)
+ 
+ 		struct rt6_info *uncached_rt;
+ 
+ 		uncached_rt = ip6_rt_cache_alloc(rt, &fl6->daddr, NULL);
+ 		dst_release(&rt->dst);
+ 
+ 		if (uncached_rt)
+ 			uncached_rt->dst.flags |= DST_NOCACHE;
+ 		else
+ 			uncached_rt = net->ipv6.ip6_null_entry;
+ 		dst_hold(&uncached_rt->dst);
+ 		return uncached_rt;
+ 	}
  
+ done:
+ 	rt6_dst_from_metrics_check(rt);
  	return rt;
  }
  
@@@ -1098,6 -1033,33 +1125,36 @@@ struct dst_entry *ip6_blackhole_route(s
   *	Destination cache support functions
   */
  
++<<<<<<< HEAD
++=======
+ static void rt6_dst_from_metrics_check(struct rt6_info *rt)
+ {
+ 	if (rt->dst.from &&
+ 	    dst_metrics_ptr(&rt->dst) != dst_metrics_ptr(rt->dst.from))
+ 		dst_init_metrics(&rt->dst, dst_metrics_ptr(rt->dst.from), true);
+ }
+ 
+ static struct dst_entry *rt6_check(struct rt6_info *rt, u32 cookie)
+ {
+ 	if (!rt->rt6i_node || (rt->rt6i_node->fn_sernum != cookie))
+ 		return NULL;
+ 
+ 	if (rt6_check_expired(rt))
+ 		return NULL;
+ 
+ 	return &rt->dst;
+ }
+ 
+ static struct dst_entry *rt6_dst_from_check(struct rt6_info *rt, u32 cookie)
+ {
+ 	if (rt->dst.obsolete == DST_OBSOLETE_FORCE_CHK &&
+ 	    rt6_check((struct rt6_info *)(rt->dst.from), cookie))
+ 		return &rt->dst;
+ 	else
+ 		return NULL;
+ }
+ 
++>>>>>>> 3da59bd94583 (ipv6: Create RTF_CACHE clone when FLOWI_FLAG_KNOWN_NH is set)
  static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
  {
  	struct rt6_info *rt;
@@@ -1108,13 -1070,13 +1165,17 @@@
  	 * DST_OBSOLETE_FORCE_CHK which forces validation calls down
  	 * into this function always.
  	 */
- 	if (!rt->rt6i_node || (rt->rt6i_node->fn_sernum != cookie))
- 		return NULL;
- 
- 	if (rt6_check_expired(rt))
- 		return NULL;
  
++<<<<<<< HEAD
 +	return dst;
++=======
+ 	rt6_dst_from_metrics_check(rt);
+ 
+ 	if (unlikely(dst->flags & DST_NOCACHE))
+ 		return rt6_dst_from_check(rt, cookie);
+ 	else
+ 		return rt6_check(rt, cookie);
++>>>>>>> 3da59bd94583 (ipv6: Create RTF_CACHE clone when FLOWI_FLAG_KNOWN_NH is set)
  }
  
  static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
* Unmerged path include/net/ip6_fib.h
* Unmerged path net/ipv6/route.c
