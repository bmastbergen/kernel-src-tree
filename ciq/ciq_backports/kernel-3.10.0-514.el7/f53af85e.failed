IB/hfi1: Extract and reinsert MMU RB node on lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mitko Haralanov <mitko.haralanov@intel.com>
commit f53af85e4735514a572996fb551968da78657639
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f53af85e.failed

The page pinning function, which also maintains the pin cache,
behaves one of two ways when an exact buffer match is not found:
  1. If no node is not found (a buffer with the same starting address
     is not found in the cache), a new node is created, the buffer
     pages are pinned, and the node is inserted into the RB tree, or
  2. If a node is found but the buffer in that node is a subset of
     the new user buffer, the node is extended with the new buffer
     pages.

Both modes of operation require (re-)insertion into the interval RB
tree.

When the node being inserted is a new node, the operations are pretty
simple. However, when the node is already existing and is being
extended, special care must be taken.

First, we want to guard against an asynchronous attempt to
delete the node by the MMU invalidation notifier. The simplest way to
do this is to remove the node from the RB tree, preventing the search
algorithm from finding it.

Second, the node needs to be re-inserted so it lands in the proper place
in the tree and the tree is correctly re-balanced. This also requires
the node to be removed from the RB tree.

This commit adds the hfi1_mmu_rb_extract() function, which will search
for a node in the interval RB tree matching an address and length and
remove it from the RB tree if found. This allows for both of the above
special cases be handled in a single step.

	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Mitko Haralanov <mitko.haralanov@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit f53af85e4735514a572996fb551968da78657639)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/debugfs.h
#	drivers/staging/hfi1/user_sdma.c
#	drivers/staging/rdma/hfi1/mmu_rb.c
diff --cc drivers/staging/hfi1/debugfs.h
index 92d6fe146714,7a57b9c49d27..000000000000
--- a/drivers/staging/hfi1/debugfs.h
+++ b/drivers/staging/hfi1/debugfs.h
@@@ -49,30 -44,33 +49,41 @@@
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   */
 -#ifndef _HFI1_MMU_RB_H
 -#define _HFI1_MMU_RB_H
  
 -#include "hfi.h"
 +struct hfi1_ibdev;
 +#ifdef CONFIG_DEBUG_FS
 +void hfi1_dbg_ibdev_init(struct hfi1_ibdev *ibd);
 +void hfi1_dbg_ibdev_exit(struct hfi1_ibdev *ibd);
 +void hfi1_dbg_init(void);
 +void hfi1_dbg_exit(void);
 +#else
 +static inline void hfi1_dbg_ibdev_init(struct hfi1_ibdev *ibd)
 +{
 +}
  
 -struct mmu_rb_node {
 -	unsigned long addr;
 -	unsigned long len;
 -	unsigned long __last;
 -	struct rb_node node;
 -};
 +void hfi1_dbg_ibdev_exit(struct hfi1_ibdev *ibd)
 +{
 +}
  
 -struct mmu_rb_ops {
 -	bool (*filter)(struct mmu_rb_node *, unsigned long, unsigned long);
 -	int (*insert)(struct rb_root *, struct mmu_rb_node *);
 -	void (*remove)(struct rb_root *, struct mmu_rb_node *,
 -		       struct mm_struct *);
 -	int (*invalidate)(struct rb_root *, struct mmu_rb_node *);
 -};
 +void hfi1_dbg_init(void)
 +{
 +}
  
++<<<<<<< HEAD:drivers/staging/hfi1/debugfs.h
 +void hfi1_dbg_exit(void)
 +{
 +}
++=======
+ int hfi1_mmu_rb_register(struct rb_root *root, struct mmu_rb_ops *ops);
+ void hfi1_mmu_rb_unregister(struct rb_root *);
+ int hfi1_mmu_rb_insert(struct rb_root *, struct mmu_rb_node *);
+ void hfi1_mmu_rb_remove(struct rb_root *, struct mmu_rb_node *);
+ struct mmu_rb_node *hfi1_mmu_rb_search(struct rb_root *, unsigned long,
+ 				       unsigned long);
+ struct mmu_rb_node *hfi1_mmu_rb_extract(struct rb_root *, unsigned long,
+ 					unsigned long);
++>>>>>>> f53af85e4735 (IB/hfi1: Extract and reinsert MMU RB node on lookup):drivers/staging/rdma/hfi1/mmu_rb.h
 +
 +#endif
  
 -#endif /* _HFI1_MMU_RB_H */
 +#endif                          /* _HFI1_DEBUGFS_H */
diff --cc drivers/staging/hfi1/user_sdma.c
index 6967deb7956a,f7e2fe7ed9db..000000000000
--- a/drivers/staging/hfi1/user_sdma.c
+++ b/drivers/staging/hfi1/user_sdma.c
@@@ -1036,40 -1030,129 +1036,85 @@@ static inline int num_user_pages(const 
  	return 1 + ((epage - spage) >> PAGE_SHIFT);
  }
  
 -/* Caller must hold pq->evict_lock */
 -static u32 sdma_cache_evict(struct hfi1_user_sdma_pkt_q *pq, u32 npages)
 -{
 -	u32 cleared = 0;
 -	struct sdma_mmu_node *node, *ptr;
 -
 -	list_for_each_entry_safe_reverse(node, ptr, &pq->evict, list) {
 -		/* Make sure that no one is still using the node. */
 -		if (!atomic_read(&node->refcount)) {
 -			/*
 -			 * Need to use the page count now as the remove callback
 -			 * will free the node.
 -			 */
 -			cleared += node->npages;
 -			spin_unlock(&pq->evict_lock);
 -			hfi1_mmu_rb_remove(&pq->sdma_rb_root, &node->rb);
 -			spin_lock(&pq->evict_lock);
 -			if (cleared >= npages)
 -				break;
 -		}
 -	}
 -	return cleared;
 -}
 -
  static int pin_vector_pages(struct user_sdma_request *req,
  			    struct user_sdma_iovec *iovec) {
++<<<<<<< HEAD:drivers/staging/hfi1/user_sdma.c
 +	int pinned, npages;
++=======
+ 	int ret = 0, pinned, npages, cleared;
+ 	struct page **pages;
+ 	struct hfi1_user_sdma_pkt_q *pq = req->pq;
+ 	struct sdma_mmu_node *node = NULL;
+ 	struct mmu_rb_node *rb_node;
+ 
+ 	rb_node = hfi1_mmu_rb_extract(&pq->sdma_rb_root,
+ 				      (unsigned long)iovec->iov.iov_base,
+ 				      iovec->iov.iov_len);
+ 	if (rb_node && !IS_ERR(rb_node))
+ 		node = container_of(rb_node, struct sdma_mmu_node, rb);
+ 	else
+ 		rb_node = NULL;
+ 
+ 	if (!node) {
+ 		node = kzalloc(sizeof(*node), GFP_KERNEL);
+ 		if (!node)
+ 			return -ENOMEM;
+ 
+ 		node->rb.addr = (unsigned long)iovec->iov.iov_base;
+ 		node->pq = pq;
+ 		atomic_set(&node->refcount, 0);
+ 		INIT_LIST_HEAD(&node->list);
+ 	}
++>>>>>>> f53af85e4735 (IB/hfi1: Extract and reinsert MMU RB node on lookup):drivers/staging/rdma/hfi1/user_sdma.c
  
  	npages = num_user_pages(&iovec->iov);
 -	if (node->npages < npages) {
 -		pages = kcalloc(npages, sizeof(*pages), GFP_KERNEL);
 -		if (!pages) {
 -			SDMA_DBG(req, "Failed page array alloc");
 -			ret = -ENOMEM;
 -			goto bail;
 -		}
 -		memcpy(pages, node->pages, node->npages * sizeof(*pages));
 -
 -		npages -= node->npages;
 -retry:
 -		if (!hfi1_can_pin_pages(pq->dd, pq->n_locked, npages)) {
 -			spin_lock(&pq->evict_lock);
 -			cleared = sdma_cache_evict(pq, npages);
 -			spin_unlock(&pq->evict_lock);
 -			if (cleared >= npages)
 -				goto retry;
 -		}
 -		pinned = hfi1_acquire_user_pages(
 -			((unsigned long)iovec->iov.iov_base +
 -			 (node->npages * PAGE_SIZE)), npages, 0,
 -			pages + node->npages);
 -		if (pinned < 0) {
 -			kfree(pages);
 -			ret = pinned;
 -			goto bail;
 -		}
 -		if (pinned != npages) {
 -			unpin_vector_pages(current->mm, pages, node->npages,
 -					   pinned);
 -			ret = -EFAULT;
 -			goto bail;
 -		}
 -		kfree(node->pages);
 -		node->rb.len = iovec->iov.iov_len;
 -		node->pages = pages;
 -		node->npages += pinned;
 -		npages = node->npages;
 -		spin_lock(&pq->evict_lock);
 -		if (!rb_node)
 -			list_add(&node->list, &pq->evict);
 -		else
 -			list_move(&node->list, &pq->evict);
 -		pq->n_locked += pinned;
 -		spin_unlock(&pq->evict_lock);
 +	iovec->pages = kcalloc(npages, sizeof(*iovec->pages), GFP_KERNEL);
 +	if (!iovec->pages) {
 +		SDMA_DBG(req, "Failed page array alloc");
 +		return -ENOMEM;
  	}
 -	iovec->pages = node->pages;
 -	iovec->npages = npages;
  
++<<<<<<< HEAD:drivers/staging/hfi1/user_sdma.c
 +	pinned = hfi1_acquire_user_pages((unsigned long)iovec->iov.iov_base,
 +					 npages, 0, iovec->pages);
 +
 +	if (pinned < 0)
 +		return pinned;
 +
 +	iovec->npages = pinned;
 +	if (pinned != npages) {
 +		SDMA_DBG(req, "Failed to pin pages (%d/%u)", pinned, npages);
 +		unpin_vector_pages(iovec);
 +		return -EFAULT;
 +	}
 +	return 0;
++=======
+ 	ret = hfi1_mmu_rb_insert(&req->pq->sdma_rb_root, &node->rb);
+ 	if (ret) {
+ 		spin_lock(&pq->evict_lock);
+ 		if (!list_empty(&node->list))
+ 			list_del(&node->list);
+ 		pq->n_locked -= node->npages;
+ 		spin_unlock(&pq->evict_lock);
+ 		goto bail;
+ 	}
+ 	return 0;
+ bail:
+ 	if (rb_node)
+ 		unpin_vector_pages(current->mm, node->pages, 0, node->npages);
+ 	kfree(node);
+ 	return ret;
++>>>>>>> f53af85e4735 (IB/hfi1: Extract and reinsert MMU RB node on lookup):drivers/staging/rdma/hfi1/user_sdma.c
  }
  
 -static void unpin_vector_pages(struct mm_struct *mm, struct page **pages,
 -			       unsigned start, unsigned npages)
 +static void unpin_vector_pages(struct user_sdma_iovec *iovec)
  {
 -	hfi1_release_user_pages(mm, pages + start, npages, 0);
 -	kfree(pages);
 +	hfi1_release_user_pages(iovec->pages, iovec->npages, 0);
 +
 +	kfree(iovec->pages);
 +	iovec->pages = NULL;
 +	iovec->npages = 0;
 +	iovec->offset = 0;
  }
  
  static int check_header_template(struct user_sdma_request *req,
* Unmerged path drivers/staging/rdma/hfi1/mmu_rb.c
* Unmerged path drivers/staging/hfi1/debugfs.h
* Unmerged path drivers/staging/hfi1/user_sdma.c
* Unmerged path drivers/staging/rdma/hfi1/mmu_rb.c
