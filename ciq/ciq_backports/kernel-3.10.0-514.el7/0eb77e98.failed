vmstat: make vmstat_updater deferrable again and shut down on idle

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Lameter <cl@linux.com>
commit 0eb77e9880321915322d42913c3b53241739c8aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0eb77e98.failed

Currently the vmstat updater is not deferrable as a result of commit
ba4877b9ca51 ("vmstat: do not use deferrable delayed work for
vmstat_update").  This in turn can cause multiple interruptions of the
applications because the vmstat updater may run at

Make vmstate_update deferrable again and provide a function that folds
the differentials when the processor is going to idle mode thus
addressing the issue of the above commit in a clean way.

Note that the shepherd thread will continue scanning the differentials
from another processor and will reenable the vmstat workers if it
detects any changes.

Fixes: ba4877b9ca51 ("vmstat: do not use deferrable delayed work for vmstat_update")
	Signed-off-by: Christoph Lameter <cl@linux.com>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0eb77e9880321915322d42913c3b53241739c8aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/idle.c
#	mm/vmstat.c
diff --cc mm/vmstat.c
index f08f371beef8,83a003bc3cae..000000000000
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@@ -474,33 -484,35 +474,41 @@@ static int refresh_cpu_vm_stats(bool do
  #endif
  			}
  		}
- 		cond_resched();
  #ifdef CONFIG_NUMA
- 		/*
- 		 * Deal with draining the remote pageset of this
- 		 * processor
- 		 *
- 		 * Check if there are pages remaining in this pageset
- 		 * if not then there is nothing to expire.
- 		 */
- 		if (!__this_cpu_read(p->expire) ||
+ 		if (do_pagesets) {
+ 			cond_resched();
+ 			/*
+ 			 * Deal with draining the remote pageset of this
+ 			 * processor
+ 			 *
+ 			 * Check if there are pages remaining in this pageset
+ 			 * if not then there is nothing to expire.
+ 			 */
+ 			if (!__this_cpu_read(p->expire) ||
  			       !__this_cpu_read(p->pcp.count))
- 			continue;
- 
- 		/*
- 		 * We never drain zones local to this processor.
- 		 */
- 		if (zone_to_nid(zone) == numa_node_id()) {
- 			__this_cpu_write(p->expire, 0);
- 			continue;
- 		}
+ 				continue;
+ 
+ 			/*
+ 			 * We never drain zones local to this processor.
+ 			 */
+ 			if (zone_to_nid(zone) == numa_node_id()) {
+ 				__this_cpu_write(p->expire, 0);
+ 				continue;
+ 			}
  
- 		if (__this_cpu_dec_return(p->expire))
- 			continue;
+ 			if (__this_cpu_dec_return(p->expire))
+ 				continue;
  
++<<<<<<< HEAD
 +		if (__this_cpu_read(p->pcp.count)) {
 +			drain_zone_pages(zone, __this_cpu_ptr(&p->pcp));
 +			changes++;
++=======
+ 			if (__this_cpu_read(p->pcp.count)) {
+ 				drain_zone_pages(zone, this_cpu_ptr(&p->pcp));
+ 				changes++;
+ 			}
++>>>>>>> 0eb77e988032 (vmstat: make vmstat_updater deferrable again and shut down on idle)
  		}
  #endif
  	}
@@@ -1231,7 -1388,7 +1239,11 @@@ static cpumask_var_t cpu_stat_off
  
  static void vmstat_update(struct work_struct *w)
  {
++<<<<<<< HEAD
 +	if (refresh_cpu_vm_stats())
++=======
+ 	if (refresh_cpu_vm_stats(true)) {
++>>>>>>> 0eb77e988032 (vmstat: make vmstat_updater deferrable again and shut down on idle)
  		/*
  		 * Counters were updated so we expect more updates
  		 * to occur in the future. Keep on running the
* Unmerged path kernel/sched/idle.c
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 789f8d45fef2..73a8c62a7d1b 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -193,6 +193,7 @@ extern void __inc_zone_state(struct zone *, enum zone_stat_item);
 extern void dec_zone_state(struct zone *, enum zone_stat_item);
 extern void __dec_zone_state(struct zone *, enum zone_stat_item);
 
+void quiet_vmstat(void);
 void cpu_vm_stats_fold(int cpu);
 void refresh_zone_stat_thresholds(void);
 
@@ -254,6 +255,7 @@ static inline void __dec_zone_page_state(struct page *page,
 static inline void refresh_cpu_vm_stats(int cpu) { }
 static inline void refresh_zone_stat_thresholds(void) { }
 static inline void cpu_vm_stats_fold(int cpu) { }
+static inline void quiet_vmstat(void) { }
 
 static inline void drain_zonestat(struct zone *zone,
 			struct per_cpu_pageset *pset) { }
* Unmerged path kernel/sched/idle.c
* Unmerged path mm/vmstat.c
