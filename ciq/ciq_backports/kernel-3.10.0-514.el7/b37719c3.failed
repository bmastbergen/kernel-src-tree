mei: bus: fix drivers and devices names confusion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit b37719c31f8448ba36abc218a96663b4a6c66eb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b37719c3.failed

In the mei bus layer there is use of different variables
of driver and device types with no clear naming convention.
There are generic struct device and struct driver,
then mei_cl_{device, driver}, and finally mei_device which
in this context serves as a bus device.

The patch sets following naming convention:

the variables of type struct device remains dev
the variables of type struct driver remains drv
the variables of type struct mei_cl_device are now cldev
the variables of type struct mei_cl_driver are now cldrv
the variables of type struct mei_device are now bus, in bus
layer context

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b37719c31f8448ba36abc218a96663b4a6c66eb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/mei_dev.h
#	drivers/misc/mei/nfc.c
diff --cc drivers/misc/mei/bus.c
index ca8736c3675b,18c37af22f07..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -33,21 -32,33 +33,28 @@@
  
  static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
  {
- 	struct mei_cl_device *device = to_mei_cl_device(dev);
- 	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
  	const struct mei_cl_device_id *id;
 -	const uuid_le *uuid;
 -	const char *name;
  
- 	if (!device)
+ 	if (!cldev)
  		return 0;
  
++<<<<<<< HEAD
 +	if (!driver || !driver->id_table)
++=======
+ 	uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	name = cldev->name;
+ 
+ 	if (!cldrv || !cldrv->id_table)
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		return 0;
  
- 	id = driver->id_table;
+ 	id = cldrv->id_table;
  
 -	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 -
 -		if (!uuid_le_cmp(*uuid, id->uuid)) {
 -			if (id->name[0]) {
 -				if (!strncmp(name, id->name, sizeof(id->name)))
 -					return 1;
 -			} else {
 -				return 1;
 -			}
 -		}
 +	while (id->name[0]) {
 +		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
 +			return 1;
  
  		id++;
  	}
@@@ -70,9 -81,9 +77,13 @@@ static int mei_cl_device_probe(struct d
  
  	dev_dbg(dev, "Device probe\n");
  
++<<<<<<< HEAD
 +	strlcpy(id.name, dev_name(dev), sizeof(id.name));
++=======
+ 	strlcpy(id.name, cldev->name, sizeof(id.name));
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
- 	return driver->probe(device, &id);
+ 	return cldrv->probe(cldev, &id);
  }
  
  static int mei_cl_device_remove(struct device *dev)
@@@ -95,15 -106,43 +106,52 @@@
  		return 0;
  	}
  
- 	return driver->remove(device);
+ 	return cldrv->remove(cldev);
  }
  
++<<<<<<< HEAD
 +static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 +			     char *buf)
 +{
 +	int len;
 +
 +	len = snprintf(buf, PAGE_SIZE, "mei:%s\n", dev_name(dev));
++=======
+ static ssize_t name_show(struct device *dev, struct device_attribute *a,
+ 			     char *buf)
+ {
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 	size_t len;
+ 
+ 	len = snprintf(buf, PAGE_SIZE, "%s", cldev->name);
+ 
+ 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+ }
+ static DEVICE_ATTR_RO(name);
+ 
+ static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
+ 			     char *buf)
+ {
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	size_t len;
+ 
+ 	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
+ 
+ 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+ }
+ static DEVICE_ATTR_RO(uuid);
+ 
+ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+ 			     char *buf)
+ {
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	size_t len;
+ 
+ 	len = snprintf(buf, PAGE_SIZE, "mei:%s:" MEI_CL_UUID_FMT ":",
+ 		cldev->name, MEI_CL_UUID_ARGS(uuid->b));
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
  }
@@@ -117,7 -158,17 +165,21 @@@ ATTRIBUTE_GROUPS(mei_cl_dev)
  
  static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
  {
++<<<<<<< HEAD
 +	if (add_uevent_var(env, "MODALIAS=mei:%s", dev_name(dev)))
++=======
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+ 
+ 	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
+ 		return -ENOMEM;
+ 
+ 	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
+ 		return -ENOMEM;
+ 
+ 	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
+ 		cldev->name, MEI_CL_UUID_ARGS(uuid->b)))
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		return -ENOMEM;
  
  	return 0;
@@@ -134,54 -185,65 +196,111 @@@ static struct bus_type mei_cl_bus_type 
  
  static void mei_cl_dev_release(struct device *dev)
  {
++<<<<<<< HEAD
 +	kfree(to_mei_cl_device(dev));
++=======
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 
+ 	if (!cldev)
+ 		return;
+ 
+ 	mei_me_cl_put(cldev->me_cl);
+ 	kfree(cldev);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  }
  
  static struct device_type mei_cl_device_type = {
  	.release	= mei_cl_dev_release,
  };
  
++<<<<<<< HEAD
 +static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 +						uuid_le uuid)
 +{
 +	struct mei_cl *cl;
 +
 +	list_for_each_entry(cl, &dev->device_list, device_link) {
 +		if (!uuid_le_cmp(uuid, cl->device_uuid))
++=======
+ struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
+ 					 uuid_le uuid)
+ {
+ 	struct mei_cl *cl;
+ 
+ 	list_for_each_entry(cl, &bus->device_list, device_link) {
+ 		if (cl->cldev && cl->cldev->me_cl &&
+ 		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->cldev->me_cl)))
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  			return cl;
  	}
  
  	return NULL;
  }
++<<<<<<< HEAD
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
 +{
 +	struct mei_cl_device *device;
 +	struct mei_cl *cl;
 +	int status;
 +
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
 +
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
 +
 +	device->cl = cl;
 +	device->ops = ops;
 +
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
 +
 +	dev_set_name(&device->dev, "%s", name);
++=======
+ 
+ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					char *name)
+ {
+ 	struct mei_cl_device *cldev;
+ 	int status;
+ 
+ 	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+ 	if (!cldev)
+ 		return NULL;
+ 
+ 	cldev->me_cl = mei_me_cl_get(me_cl);
+ 	if (!cldev->me_cl) {
+ 		kfree(cldev);
+ 		return NULL;
+ 	}
+ 
+ 	cldev->cl = cl;
+ 	cldev->dev.parent = bus->dev;
+ 	cldev->dev.bus = &mei_cl_bus_type;
+ 	cldev->dev.type = &mei_cl_device_type;
+ 
+ 	strlcpy(cldev->name, name, sizeof(cldev->name));
  
- 	status = device_register(&device->dev);
+ 	dev_set_name(&cldev->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
+ 
+ 	status = device_register(&cldev->dev);
  	if (status) {
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
++=======
+ 		dev_err(bus->dev, "Failed to register MEI device\n");
+ 		mei_me_cl_put(cldev->me_cl);
+ 		kfree(cldev);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		return NULL;
  	}
  
@@@ -225,126 -287,123 +344,158 @@@ void mei_cl_driver_unregister(struct me
  }
  EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
  
 -ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 +static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
  			bool blocking)
  {
++<<<<<<< HEAD
 +	struct mei_device *dev;
 +	struct mei_cl_cb *cb;
 +	int id;
 +	int rets;
++=======
+ 	struct mei_device *bus;
+ 	struct mei_cl_cb *cb = NULL;
+ 	ssize_t rets;
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  	if (WARN_ON(!cl || !cl->dev))
  		return -ENODEV;
  
- 	dev = cl->dev;
+ 	bus = cl->dev;
  
++<<<<<<< HEAD
 +	if (cl->state != MEI_FILE_CONNECTED)
 +		return -ENODEV;
++=======
+ 	mutex_lock(&bus->device_lock);
+ 	if (!mei_cl_is_connected(cl)) {
+ 		rets = -ENODEV;
+ 		goto out;
+ 	}
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  	/* Check if we have an ME client device */
 -	if (!mei_me_cl_is_active(cl->me_cl)) {
 -		rets = -ENOTTY;
 -		goto out;
 -	}
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0)
 +		return id;
  
 -	if (length > mei_cl_mtu(cl)) {
 -		rets = -EFBIG;
 -		goto out;
 -	}
 +	if (length > dev->me_clients[id].props.max_msg_length)
 +		return -EINVAL;
  
 -	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
 -	if (!cb) {
 -		rets = -ENOMEM;
 -		goto out;
 +	cb = mei_io_cb_init(cl, NULL);
 +	if (!cb)
 +		return -ENOMEM;
 +
 +	rets = mei_io_cb_alloc_req_buf(cb, length);
 +	if (rets < 0) {
 +		mei_io_cb_free(cb);
 +		return rets;
  	}
  
 -	memcpy(cb->buf.data, buf, length);
 +	memcpy(cb->request_buffer.data, buf, length);
 +
 +	mutex_lock(&dev->device_lock);
  
  	rets = mei_cl_write(cl, cb, blocking);
  
++<<<<<<< HEAD
 +	mutex_unlock(&dev->device_lock);
++=======
+ out:
+ 	mutex_unlock(&bus->device_lock);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  	if (rets < 0)
  		mei_io_cb_free(cb);
  
  	return rets;
  }
  
 -ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
  {
- 	struct mei_device *dev;
+ 	struct mei_device *bus;
  	struct mei_cl_cb *cb;
  	size_t r_length;
 -	ssize_t rets;
 +	int err;
  
  	if (WARN_ON(!cl || !cl->dev))
  		return -ENODEV;
  
- 	dev = cl->dev;
+ 	bus = cl->dev;
  
- 	mutex_lock(&dev->device_lock);
+ 	mutex_lock(&bus->device_lock);
  
 -	cb = mei_cl_read_cb(cl, NULL);
 -	if (cb)
 -		goto copy;
 -
 -	rets = mei_cl_read_start(cl, length, NULL);
 -	if (rets && rets != -EBUSY)
 -		goto out;
 +	if (!cl->read_cb) {
 +		err = mei_cl_read_start(cl, length);
 +		if (err < 0) {
 +			mutex_unlock(&dev->device_lock);
 +			return err;
 +		}
 +	}
  
 -	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
 +	if (cl->reading_state != MEI_READ_COMPLETE &&
 +	    !waitqueue_active(&cl->rx_wait)) {
  
- 		mutex_unlock(&dev->device_lock);
+ 		mutex_unlock(&bus->device_lock);
  
  		if (wait_event_interruptible(cl->rx_wait,
 -				(!list_empty(&cl->rd_completed)) ||
 -				(!mei_cl_is_connected(cl)))) {
 +				cl->reading_state == MEI_READ_COMPLETE  ||
 +				mei_cl_is_transitioning(cl))) {
  
  			if (signal_pending(current))
  				return -EINTR;
  			return -ERESTARTSYS;
  		}
  
++<<<<<<< HEAD
 +		mutex_lock(&dev->device_lock);
++=======
+ 		mutex_lock(&bus->device_lock);
+ 
+ 		if (!mei_cl_is_connected(cl)) {
+ 			rets = -EBUSY;
+ 			goto out;
+ 		}
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  	}
  
 -	cb = mei_cl_read_cb(cl, NULL);
 -	if (!cb) {
 -		rets = 0;
 -		goto out;
 -	}
 +	cb = cl->read_cb;
  
 -copy:
 -	if (cb->status) {
 -		rets = cb->status;
 -		goto free;
 +	if (cl->reading_state != MEI_READ_COMPLETE) {
 +		r_length = 0;
 +		goto out;
  	}
  
  	r_length = min_t(size_t, length, cb->buf_idx);
 -	memcpy(buf, cb->buf.data, r_length);
 -	rets = r_length;
  
 -free:
 +	memcpy(buf, cb->response_buffer.data, r_length);
 +
  	mei_io_cb_free(cb);
 +	cl->reading_state = MEI_IDLE;
 +	cl->read_cb = NULL;
 +
  out:
- 	mutex_unlock(&dev->device_lock);
+ 	mutex_unlock(&bus->device_lock);
  
 -	return rets;
 +	return r_length;
 +}
 +
++<<<<<<< HEAD
 +inline int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
 +{
 +	return ___mei_cl_send(cl, buf, length, 0);
 +}
 +
 +inline int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
 +{
 +	return ___mei_cl_send(cl, buf, length, 1);
  }
  
 +int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
++=======
+ ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  {
- 	struct mei_cl *cl = device->cl;
+ 	struct mei_cl *cl = cldev->cl;
  
  	if (cl == NULL)
  		return -ENODEV;
@@@ -356,9 -412,9 +507,15 @@@
  }
  EXPORT_SYMBOL_GPL(mei_cl_send);
  
++<<<<<<< HEAD
 +int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
 +{
 +	struct mei_cl *cl =  device->cl;
++=======
+ ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ {
+ 	struct mei_cl *cl = cldev->cl;
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  	if (cl == NULL)
  		return -ENODEV;
@@@ -372,31 -425,31 +529,39 @@@ EXPORT_SYMBOL_GPL(mei_cl_recv)
  
  static void mei_bus_event_work(struct work_struct *work)
  {
- 	struct mei_cl_device *device;
+ 	struct mei_cl_device *cldev;
  
- 	device = container_of(work, struct mei_cl_device, event_work);
+ 	cldev = container_of(work, struct mei_cl_device, event_work);
  
- 	if (device->event_cb)
- 		device->event_cb(device, device->events, device->event_context);
+ 	if (cldev->event_cb)
+ 		cldev->event_cb(cldev, cldev->events, cldev->event_context);
  
- 	device->events = 0;
+ 	cldev->events = 0;
  
  	/* Prepare for the next read */
++<<<<<<< HEAD
 +	mei_cl_read_start(device->cl, 0);
++=======
+ 	mei_cl_read_start(cldev->cl, 0, NULL);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  }
  
- int mei_cl_register_event_cb(struct mei_cl_device *device,
+ int mei_cl_register_event_cb(struct mei_cl_device *cldev,
  			  mei_cl_event_cb_t event_cb, void *context)
  {
- 	if (device->event_cb)
+ 	if (cldev->event_cb)
  		return -EALREADY;
  
- 	device->events = 0;
- 	device->event_cb = event_cb;
- 	device->event_context = context;
- 	INIT_WORK(&device->event_work, mei_bus_event_work);
+ 	cldev->events = 0;
+ 	cldev->event_cb = event_cb;
+ 	cldev->event_context = context;
+ 	INIT_WORK(&cldev->event_work, mei_bus_event_work);
  
++<<<<<<< HEAD
 +	mei_cl_read_start(device->cl, 0);
++=======
+ 	mei_cl_read_start(cldev->cl, 0, NULL);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  	return 0;
  }
@@@ -423,27 -476,30 +588,45 @@@ int mei_cl_enable_device(struct mei_cl_
  	if (cl == NULL)
  		return -ENODEV;
  
- 	dev = cl->dev;
+ 	bus = cl->dev;
  
- 	mutex_lock(&dev->device_lock);
+ 	mutex_lock(&bus->device_lock);
  
++<<<<<<< HEAD
 +	err = mei_cl_connect(cl, NULL);
 +	if (err < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
++=======
+ 	if (mei_cl_is_connected(cl)) {
+ 		mutex_unlock(&bus->device_lock);
+ 		dev_warn(bus->dev, "Already connected");
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = mei_cl_connect(cl, cldev->me_cl, NULL);
+ 	if (err < 0) {
+ 		mutex_unlock(&bus->device_lock);
+ 		dev_err(bus->dev, "Could not connect to the ME client");
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  		return err;
  	}
  
- 	mutex_unlock(&dev->device_lock);
+ 	mutex_unlock(&bus->device_lock);
  
++<<<<<<< HEAD
 +	if (device->event_cb && !cl->read_cb)
 +		mei_cl_read_start(device->cl, 0);
++=======
+ 	if (cldev->event_cb)
+ 		mei_cl_read_start(cldev->cl, 0, NULL);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
 -	return 0;
 +	if (!device->ops || !device->ops->enable)
 +		return 0;
 +
 +	return device->ops->enable(device);
  }
  EXPORT_SYMBOL_GPL(mei_cl_enable_device);
  
@@@ -456,87 -512,46 +639,109 @@@ int mei_cl_disable_device(struct mei_cl
  	if (cl == NULL)
  		return -ENODEV;
  
- 	dev = cl->dev;
+ 	bus = cl->dev;
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->device_lock);
 +
 +	if (cl->state != MEI_FILE_CONNECTED) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Already disconnected");
 +
 +		return 0;
++=======
+ 	cldev->event_cb = NULL;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 
+ 	if (!mei_cl_is_connected(cl)) {
+ 		dev_err(bus->dev, "Already disconnected");
+ 		err = 0;
+ 		goto out;
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  	}
  
 +	cl->state = MEI_FILE_DISCONNECTING;
 +
  	err = mei_cl_disconnect(cl);
  	if (err < 0) {
++<<<<<<< HEAD
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect from the ME client");
 +
 +		return err;
++=======
+ 		dev_err(bus->dev, "Could not disconnect from the ME client");
+ 		goto out;
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  	}
  
  	/* Flush queues and remove any pending read */
 -	mei_cl_flush_queues(cl, NULL);
 +	mei_cl_flush_queues(cl);
 +
 +	if (cl->read_cb) {
 +		struct mei_cl_cb *cb = NULL;
 +
 +		cb = mei_cl_find_read_cb(cl);
 +		/* Remove entry from read list */
 +		if (cb)
 +			list_del(&cb->list);
 +
 +		cb = cl->read_cb;
 +		cl->read_cb = NULL;
 +
 +		if (cb) {
 +			mei_io_cb_free(cb);
 +			cb = NULL;
 +		}
 +	}
  
 +	device->event_cb = NULL;
 +
++<<<<<<< HEAD
 +	mutex_unlock(&dev->device_lock);
++=======
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 	return err;
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
 +
 +	if (!device->ops || !device->ops->disable)
 +		return 0;
  
 +	return device->ops->disable(device);
  }
  EXPORT_SYMBOL_GPL(mei_cl_disable_device);
  
  void mei_cl_bus_rx_event(struct mei_cl *cl)
  {
- 	struct mei_cl_device *device = cl->device;
+ 	struct mei_cl_device *cldev = cl->cldev;
  
- 	if (!device || !device->event_cb)
+ 	if (!cldev || !cldev->event_cb)
  		return;
  
- 	set_bit(MEI_CL_EVENT_RX, &device->events);
+ 	set_bit(MEI_CL_EVENT_RX, &cldev->events);
  
- 	schedule_work(&device->event_work);
+ 	schedule_work(&cldev->event_work);
  }
  
 +void mei_cl_bus_remove_devices(struct mei_device *dev)
 +{
 +	struct mei_cl *cl, *next;
 +
 +	mutex_lock(&dev->device_lock);
 +	list_for_each_entry_safe(cl, next, &dev->device_list, device_link) {
 +		if (cl->device)
 +			mei_cl_remove_device(cl->device);
 +
 +		list_del(&cl->device_link);
 +		mei_cl_unlink(cl);
 +		kfree(cl);
 +	}
 +	mutex_unlock(&dev->device_lock);
 +}
 +
  int __init mei_cl_bus_init(void)
  {
  	return bus_register(&mei_cl_bus_type);
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,bc65fb42aea9..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -201,10 -215,34 +201,36 @@@ struct mei_cl_cb 
  	unsigned long buf_idx;
  	unsigned long read_time;
  	struct file *file_object;
 -	int status;
  	u32 internal:1;
 -	u32 completed:1;
  };
  
++<<<<<<< HEAD
 +/* MEI client instance carried as file->private_data*/
++=======
+ /**
+  * struct mei_cl - me client host representation
+  *    carried in file->private_data
+  *
+  * @link: link in the clients list
+  * @dev: mei parent device
+  * @state: file operation state
+  * @tx_wait: wait queue for tx completion
+  * @rx_wait: wait queue for rx completion
+  * @wait:  wait queue for management operation
+  * @status: connection status
+  * @me_cl: fw client connected
+  * @host_client_id: host id
+  * @mei_flow_ctrl_creds: transmit flow credentials
+  * @timer_count:  watchdog timer for operation completion
+  * @reserved: reserved for alignment
+  * @writing_state: state of the tx
+  * @rd_pending: pending read credits
+  * @rd_completed: completed read
+  *
+  * @cldev: device on the mei client bus
+  * @device_link:  link to bus clients
+  */
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  struct mei_cl {
  	struct list_head link;
  	struct mei_device *dev;
@@@ -213,20 -251,18 +239,20 @@@
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
  	int status;
 -	struct mei_me_client *me_cl;
 +	/* ID of client connected */
  	u8 host_client_id;
 +	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
  	u8 timer_count;
 -	u8 reserved;
 +	enum mei_file_transaction_states reading_state;
  	enum mei_file_transaction_states writing_state;
 -	struct list_head rd_pending;
 -	struct list_head rd_completed;
 +	int sm_state;
 +	struct mei_cl_cb *read_cb;
  
  	/* MEI CL bus data */
- 	struct mei_cl_device *device;
+ 	struct mei_cl_device *cldev;
  	struct list_head device_link;
 +	uuid_le device_uuid;
  };
  
  /** struct mei_hw_ops
@@@ -289,74 -330,22 +315,86 @@@ struct mei_hw_ops 
  
  /* MEI bus API*/
  
++<<<<<<< HEAD
 +/**
 + * struct mei_cl_ops - MEI CL device ops
 + * This structure allows ME host clients to implement technology
 + * specific operations.
 + *
 + * @enable: Enable an MEI CL device. Some devices require specific
 + *	HECI commands to initialize completely.
 + * @disable: Disable an MEI CL device.
 + * @send: Tx hook for the device. This allows ME host clients to trap
 + *	the device driver buffers before actually physically
 + *	pushing it to the ME.
 + * @recv: Rx hook for the device. This allows ME host clients to trap the
 + *	ME buffers before forwarding them to the device driver.
 + */
 +struct mei_cl_ops {
 +	int (*enable)(struct mei_cl_device *device);
 +	int (*disable)(struct mei_cl_device *device);
 +	int (*send)(struct mei_cl_device *device, u8 *buf, size_t length);
 +	int (*recv)(struct mei_cl_device *device, u8 *buf, size_t length);
 +};
 +
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops);
 +void mei_cl_remove_device(struct mei_cl_device *device);
++=======
+ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					char *name);
+ void mei_cl_remove_device(struct mei_cl_device *cldev);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
 -ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 -			bool blocking);
 -ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
  void mei_cl_bus_rx_event(struct mei_cl *cl);
- void mei_cl_bus_remove_devices(struct mei_device *dev);
+ void mei_cl_bus_remove_devices(struct mei_device *bus);
  int mei_cl_bus_init(void);
  void mei_cl_bus_exit(void);
++<<<<<<< HEAD
 +
++=======
+ struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus, uuid_le uuid);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  /**
 + * struct mei_cl_device - MEI device handle
 + * An mei_cl_device pointer is returned from mei_add_device()
 + * and links MEI bus clients to their actual ME host client pointer.
 + * Drivers for MEI devices will get an mei_cl_device pointer
 + * when being probed and shall use it for doing ME bus I/O.
 + *
 + * @dev: linux driver model device pointer
 + * @uuid: me client uuid
 + * @cl: mei client
 + * @ops: ME transport ops
 + * @event_cb: Drivers register this callback to get asynchronous ME
 + *	events (e.g. Rx buffer pending) notifications.
 + * @events: Events bitmask sent to the driver.
 + * @priv_data: client private data
 + */
 +struct mei_cl_device {
 +	struct device dev;
 +
 +	struct mei_cl *cl;
 +
 +	const struct mei_cl_ops *ops;
 +
 +	struct work_struct event_work;
 +	mei_cl_event_cb_t event_cb;
 +	void *event_context;
 +	unsigned long events;
 +
 +	void *priv_data;
 +};
 +
 +
 + /**
   * enum mei_pg_event - power gating transition events
   *
   * @MEI_PG_EVENT_IDLE: the driver is not in power gating transition
diff --cc drivers/misc/mei/nfc.c
index 2b65e8021f0d,47aa1523d9e1..000000000000
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@@ -163,7 -167,7 +163,11 @@@ static int mei_nfc_build_bus_name(struc
  			return 0;
  
  		default:
++<<<<<<< HEAD
 +			dev_err(&dev->pdev->dev, "Unknown radio type 0x%x\n",
++=======
+ 			dev_err(bus->dev, "Unknown radio type 0x%x\n",
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  				ndev->radio_type);
  
  			return -EINVAL;
@@@ -175,14 -179,14 +179,22 @@@
  			ndev->bus_name = "pn544";
  			return 0;
  		default:
++<<<<<<< HEAD
 +			dev_err(&dev->pdev->dev, "Unknown radio type 0x%x\n",
++=======
+ 			dev_err(bus->dev, "Unknown radio type 0x%x\n",
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  				ndev->radio_type);
  
  			return -EINVAL;
  		}
  
  	default:
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev, "Unknown vendor ID 0x%x\n",
++=======
+ 		dev_err(bus->dev, "Unknown vendor ID 0x%x\n",
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  			ndev->vendor_id);
  
  		return -EINVAL;
@@@ -191,76 -195,9 +203,76 @@@
  	return 0;
  }
  
 +static int mei_nfc_connect(struct mei_nfc_dev *ndev)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl *cl;
 +	struct mei_nfc_cmd *cmd, *reply;
 +	struct mei_nfc_connect *connect;
 +	struct mei_nfc_connect_resp *connect_resp;
 +	size_t connect_length, connect_resp_length;
 +	int bytes_recv, ret;
 +
 +	cl = ndev->cl;
 +	dev = cl->dev;
 +
 +	connect_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect);
 +
 +	connect_resp_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect_resp);
 +
 +	cmd = kzalloc(connect_length, GFP_KERNEL);
 +	if (!cmd)
 +		return -ENOMEM;
 +	connect = (struct mei_nfc_connect *)cmd->data;
 +
 +	reply = kzalloc(connect_resp_length, GFP_KERNEL);
 +	if (!reply) {
 +		kfree(cmd);
 +		return -ENOMEM;
 +	}
 +
 +	connect_resp = (struct mei_nfc_connect_resp *)reply->data;
 +
 +	cmd->command = MEI_NFC_CMD_MAINTENANCE;
 +	cmd->data_size = 3;
 +	cmd->sub_command = MEI_NFC_SUBCMD_CONNECT;
 +	connect->fw_ivn = ndev->fw_ivn;
 +	connect->vendor_id = ndev->vendor_id;
 +
 +	ret = __mei_cl_send(cl, (u8 *)cmd, connect_length);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not send connect cmd\n");
 +		goto err;
 +	}
 +
 +	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, connect_resp_length);
 +	if (bytes_recv < 0) {
 +		dev_err(&dev->pdev->dev, "Could not read connect response\n");
 +		ret = bytes_recv;
 +		goto err;
 +	}
 +
 +	dev_info(&dev->pdev->dev, "IVN 0x%x Vendor ID 0x%x\n",
 +		 connect_resp->fw_ivn, connect_resp->vendor_id);
 +
 +	dev_info(&dev->pdev->dev, "ME FW %d.%d.%d.%d\n",
 +		connect_resp->me_major, connect_resp->me_minor,
 +		connect_resp->me_hotfix, connect_resp->me_build);
 +
 +	ret = 0;
 +
 +err:
 +	kfree(reply);
 +	kfree(cmd);
 +
 +	return ret;
 +}
 +
  static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
  {
- 	struct mei_device *dev;
+ 	struct mei_device *bus;
  	struct mei_cl *cl;
  
  	struct mei_nfc_cmd cmd;
@@@ -277,9 -214,9 +289,13 @@@
  	cmd.data_size = 1;
  	cmd.sub_command = MEI_NFC_SUBCMD_IF_VERSION;
  
 -	ret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd), 1);
 +	ret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd));
  	if (ret < 0) {
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev, "Could not send IF version cmd\n");
++=======
+ 		dev_err(bus->dev, "Could not send IF version cmd\n");
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		return ret;
  	}
  
@@@ -293,7 -230,7 +309,11 @@@
  
  	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, if_version_length);
  	if (bytes_recv < 0 || bytes_recv < sizeof(struct mei_nfc_reply)) {
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev, "Could not read IF version\n");
++=======
+ 		dev_err(bus->dev, "Could not read IF version\n");
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		ret = -EIO;
  		goto err;
  	}
@@@ -309,103 -246,9 +329,103 @@@ err
  	return ret;
  }
  
 +static int mei_nfc_enable(struct mei_cl_device *cldev)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	int ret;
 +
 +	dev = ndev->cl->dev;
 +
 +	ret = mei_nfc_connect(ndev);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not connect to NFC");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int mei_nfc_disable(struct mei_cl_device *cldev)
 +{
 +	return 0;
 +}
 +
 +static int mei_nfc_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hdr;
 +	u8 *mei_buf;
 +	int err;
 +
 +	ndev = (struct mei_nfc_dev *) cldev->priv_data;
 +	dev = ndev->cl->dev;
 +
 +	mei_buf = kzalloc(length + MEI_NFC_HEADER_SIZE, GFP_KERNEL);
 +	if (!mei_buf)
 +		return -ENOMEM;
 +
 +	hdr = (struct mei_nfc_hci_hdr *) mei_buf;
 +	hdr->cmd = MEI_NFC_CMD_HCI_SEND;
 +	hdr->status = 0;
 +	hdr->req_id = ndev->req_id;
 +	hdr->reserved = 0;
 +	hdr->data_size = length;
 +
 +	memcpy(mei_buf + MEI_NFC_HEADER_SIZE, buf, length);
 +
 +	err = __mei_cl_send(ndev->cl, mei_buf, length + MEI_NFC_HEADER_SIZE);
 +	if (err < 0)
 +		return err;
 +
 +	kfree(mei_buf);
 +
 +	if (!wait_event_interruptible_timeout(ndev->send_wq,
 +				ndev->recv_req_id == ndev->req_id, HZ)) {
 +		dev_err(&dev->pdev->dev, "NFC MEI command timeout\n");
 +		err = -ETIME;
 +	} else {
 +		ndev->req_id++;
 +	}
 +
 +	return err;
 +}
 +
 +static int mei_nfc_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hci_hdr;
 +	int received_length;
 +
 +	ndev = (struct mei_nfc_dev *)cldev->priv_data;
 +
 +	received_length = __mei_cl_recv(ndev->cl, buf, length);
 +	if (received_length < 0)
 +		return received_length;
 +
 +	hci_hdr = (struct mei_nfc_hci_hdr *) buf;
 +
 +	if (hci_hdr->cmd == MEI_NFC_CMD_HCI_SEND) {
 +		ndev->recv_req_id = hci_hdr->req_id;
 +		wake_up(&ndev->send_wq);
 +
 +		return 0;
 +	}
 +
 +	return received_length;
 +}
 +
 +static struct mei_cl_ops nfc_ops = {
 +	.enable = mei_nfc_enable,
 +	.disable = mei_nfc_disable,
 +	.send = mei_nfc_send,
 +	.recv = mei_nfc_recv,
 +};
 +
  static void mei_nfc_init(struct work_struct *work)
  {
- 	struct mei_device *dev;
+ 	struct mei_device *bus;
  	struct mei_cl_device *cldev;
  	struct mei_nfc_dev *ndev;
  	struct mei_cl *cl_info;
@@@ -413,52 -257,57 +433,95 @@@
  	ndev = container_of(work, struct mei_nfc_dev, init_work);
  
  	cl_info = ndev->cl_info;
- 	dev = cl_info->dev;
+ 	bus = cl_info->dev;
  
- 	mutex_lock(&dev->device_lock);
+ 	mutex_lock(&bus->device_lock);
  
++<<<<<<< HEAD
 +	if (mei_cl_connect(cl_info, NULL) < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not connect to the NFC INFO ME client");
 +
 +		goto err;
 +	}
 +
 +	mutex_unlock(&dev->device_lock);
 +
 +	if (mei_nfc_if_version(ndev) < 0) {
 +		dev_err(&dev->pdev->dev, "Could not get the NFC interface version");
++=======
+ 	/* check for valid client id */
+ 	me_cl_info = mei_me_cl_by_uuid(bus, &mei_nfc_info_guid);
+ 	if (!me_cl_info) {
+ 		mutex_unlock(&bus->device_lock);
+ 		dev_info(bus->dev, "nfc: failed to find the info client\n");
+ 		goto err;
+ 	}
+ 
+ 	if (mei_cl_connect(cl_info, me_cl_info, NULL) < 0) {
+ 		mei_me_cl_put(me_cl_info);
+ 		mutex_unlock(&bus->device_lock);
+ 		dev_err(bus->dev, "Could not connect to the NFC INFO ME client");
  
  		goto err;
  	}
+ 	mei_me_cl_put(me_cl_info);
+ 	mutex_unlock(&bus->device_lock);
  
+ 	if (mei_nfc_if_version(ndev) < 0) {
+ 		dev_err(bus->dev, "Could not get the NFC interface version");
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
+ 
+ 		goto err;
+ 	}
+ 
++<<<<<<< HEAD
 +	dev_info(&dev->pdev->dev,
 +		"NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",
++=======
+ 	dev_info(bus->dev, "NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		ndev->fw_ivn, ndev->vendor_id, ndev->radio_type);
  
- 	mutex_lock(&dev->device_lock);
+ 	mutex_lock(&bus->device_lock);
  
  	if (mei_cl_disconnect(cl_info) < 0) {
++<<<<<<< HEAD
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect the NFC INFO ME client");
++=======
+ 		mutex_unlock(&bus->device_lock);
+ 		dev_err(bus->dev, "Could not disconnect the NFC INFO ME client");
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  		goto err;
  	}
  
- 	mutex_unlock(&dev->device_lock);
+ 	mutex_unlock(&bus->device_lock);
  
  	if (mei_nfc_build_bus_name(ndev) < 0) {
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev,
 +			"Could not build the bus ID name\n");
 +		return;
 +	}
 +
 +	cldev = mei_cl_add_device(dev, mei_nfc_guid, ndev->bus_name, &nfc_ops);
 +	if (!cldev) {
 +		dev_err(&dev->pdev->dev,
 +			"Could not add the NFC device to the MEI bus\n");
++=======
+ 		dev_err(bus->dev, "Could not build the bus ID name\n");
+ 		return;
+ 	}
+ 
+ 	cldev = mei_cl_add_device(bus, ndev->me_cl, ndev->cl,
+ 				  ndev->bus_name);
+ 	if (!cldev) {
+ 		dev_err(bus->dev, "Could not add the NFC device to the MEI bus\n");
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
  		goto err;
  	}
@@@ -476,23 -325,22 +539,36 @@@ err
  }
  
  
++<<<<<<< HEAD
 +int mei_nfc_host_init(struct mei_device *dev)
++=======
+ int mei_nfc_host_init(struct mei_device *bus, struct mei_me_client *me_cl)
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  {
 -	struct mei_nfc_dev *ndev;
 -	struct mei_cl *cl_info, *cl;
 -	int ret;
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	struct mei_cl *cl_info, *cl = NULL;
 +	int i, ret;
  
++<<<<<<< HEAD
 +	/* already initialized */
 +	if (ndev->cl_info)
++=======
+ 
+ 	/* in case of internal reset bail out
+ 	 * as the device is already setup
+ 	 */
+ 	cl = mei_cl_bus_find_cl_by_uuid(bus, mei_nfc_guid);
+ 	if (cl)
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		return 0;
  
 -	ndev = kzalloc(sizeof(struct mei_nfc_dev), GFP_KERNEL);
 -	if (!ndev) {
 +	ndev->cl_info = mei_cl_allocate(dev);
 +	ndev->cl = mei_cl_allocate(dev);
 +
 +	cl = ndev->cl;
 +	cl_info = ndev->cl_info;
 +
 +	if (!cl || !cl_info) {
  		ret = -ENOMEM;
  		goto err;
  	}
@@@ -505,39 -351,27 +581,57 @@@
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	cl_info->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl_info, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
++=======
+ 	cl_info = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+ 	if (IS_ERR(cl_info)) {
+ 		ret = PTR_ERR(cl_info);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  		goto err;
 -	}
 +
 +	cl_info->device_uuid = mei_nfc_info_guid;
  
- 	list_add_tail(&cl_info->device_link, &dev->device_list);
+ 	list_add_tail(&cl_info->device_link, &bus->device_list);
  
++<<<<<<< HEAD
 +	/* check for valid client id */
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
 +		ret = -ENOTTY;
 +		goto err;
 +	}
 +
 +	cl->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
 +
 +	cl->device_uuid = mei_nfc_guid;
 +
 +
 +	list_add_tail(&cl->device_link, &dev->device_list);
++=======
+ 	ndev->cl_info = cl_info;
+ 
+ 	cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+ 	if (IS_ERR(cl)) {
+ 		ret = PTR_ERR(cl);
+ 		goto err;
+ 	}
+ 
+ 	list_add_tail(&cl->device_link, &bus->device_list);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  
 -	ndev->cl = cl;
 +	ndev->req_id = 1;
  
  	INIT_WORK(&ndev->init_work, mei_nfc_init);
 +	init_waitqueue_head(&ndev->send_wq);
  	schedule_work(&ndev->init_work);
  
  	return 0;
@@@ -548,10 -382,34 +642,39 @@@ err
  	return ret;
  }
  
- void mei_nfc_host_exit(struct mei_device *dev)
+ void mei_nfc_host_exit(struct mei_device *bus)
  {
++<<<<<<< HEAD
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	cancel_work_sync(&ndev->init_work);
++=======
+ 	struct mei_nfc_dev *ndev;
+ 	struct mei_cl *cl;
+ 	struct mei_cl_device *cldev;
+ 
+ 	cl = mei_cl_bus_find_cl_by_uuid(bus, mei_nfc_guid);
+ 	if (!cl)
+ 		return;
+ 
+ 	cldev = cl->cldev;
+ 	if (!cldev)
+ 		return;
+ 
+ 	ndev = (struct mei_nfc_dev *)cldev->priv_data;
+ 	if (ndev)
+ 		cancel_work_sync(&ndev->init_work);
+ 
+ 	cldev->priv_data = NULL;
+ 
+ 	/* Need to remove the device here
+ 	 * since mei_nfc_free will unlink the clients
+ 	 */
+ 	mei_cl_remove_device(cldev);
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	mei_nfc_free(ndev);
+ 	mutex_unlock(&bus->device_lock);
++>>>>>>> b37719c31f84 (mei: bus: fix drivers and devices names confusion)
  }
  
  
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/mei_dev.h
* Unmerged path drivers/misc/mei/nfc.c
