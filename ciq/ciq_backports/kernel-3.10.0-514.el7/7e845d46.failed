HID: introduce helper to access hid_output_raw_report()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hid] introduce helper to access hid_output_raw_report() (Benjamin Tissoires) [1311883]
Rebuild_FUZZ: 95.24%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 7e845d46b13e7730a3720e978c28117ce422edf9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7e845d46.failed

Add a helper to access hdev->hid_output_raw_report().

To convert the drivers, use the following snippets:

for i in drivers/hid/*.c
do
  sed -i.bak "s/[^ \t]*->hid_output_raw_report(/hid_output_raw_report(/g" $i
done

Then manually fix for checkpatch.pl

	Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 7e845d46b13e7730a3720e978c28117ce422edf9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-sony.c
diff --cc drivers/hid/hid-sony.c
index 312098e4af4f,075089b37236..000000000000
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@@ -189,9 -720,325 +189,328 @@@ static int sixaxis_set_operational_usb(
  static int sixaxis_set_operational_bt(struct hid_device *hdev)
  {
  	unsigned char buf[] = { 0xf4,  0x42, 0x03, 0x00, 0x00 };
- 	return hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
+ 	return hid_output_raw_report(hdev, buf, sizeof(buf),
+ 				     HID_FEATURE_REPORT);
  }
  
++<<<<<<< HEAD
++=======
+ static void buzz_set_leds(struct hid_device *hdev, const __u8 *leds)
+ {
+ 	struct list_head *report_list =
+ 		&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 	struct hid_report *report = list_entry(report_list->next,
+ 		struct hid_report, list);
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	value[0] = 0x00;
+ 	value[1] = leds[0] ? 0xff : 0x00;
+ 	value[2] = leds[1] ? 0xff : 0x00;
+ 	value[3] = leds[2] ? 0xff : 0x00;
+ 	value[4] = leds[3] ? 0xff : 0x00;
+ 	value[5] = 0x00;
+ 	value[6] = 0x00;
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ static void sony_set_leds(struct hid_device *hdev, const __u8 *leds, int count)
+ {
+ 	struct sony_sc *drv_data = hid_get_drvdata(hdev);
+ 	int n;
+ 
+ 	BUG_ON(count > MAX_LEDS);
+ 
+ 	if (drv_data->quirks & BUZZ_CONTROLLER && count == 4) {
+ 		buzz_set_leds(hdev, leds);
+ 	} else if ((drv_data->quirks & SIXAXIS_CONTROLLER_USB) ||
+ 		   (drv_data->quirks & DUALSHOCK4_CONTROLLER_USB)) {
+ 		for (n = 0; n < count; n++)
+ 			drv_data->led_state[n] = leds[n];
+ 		schedule_work(&drv_data->state_worker);
+ 	}
+ }
+ 
+ static void sony_led_set_brightness(struct led_classdev *led,
+ 				    enum led_brightness value)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n]) {
+ 			if (value != drv_data->led_state[n]) {
+ 				drv_data->led_state[n] = value;
+ 				sony_set_leds(hdev, drv_data->led_state, drv_data->led_count);
+ 			}
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static enum led_brightness sony_led_get_brightness(struct led_classdev *led)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 	int on = 0;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return LED_OFF;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n]) {
+ 			on = !!(drv_data->led_state[n]);
+ 			break;
+ 		}
+ 	}
+ 
+ 	return on ? LED_FULL : LED_OFF;
+ }
+ 
+ static void sony_leds_remove(struct hid_device *hdev)
+ {
+ 	struct sony_sc *drv_data;
+ 	struct led_classdev *led;
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	BUG_ON(!(drv_data->quirks & SONY_LED_SUPPORT));
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		led = drv_data->leds[n];
+ 		drv_data->leds[n] = NULL;
+ 		if (!led)
+ 			continue;
+ 		led_classdev_unregister(led);
+ 		kfree(led);
+ 	}
+ 
+ 	drv_data->led_count = 0;
+ }
+ 
+ static int sony_leds_init(struct hid_device *hdev)
+ {
+ 	struct sony_sc *drv_data;
+ 	int n, ret = 0;
+ 	int max_brightness;
+ 	int use_colors;
+ 	struct led_classdev *led;
+ 	size_t name_sz;
+ 	char *name;
+ 	size_t name_len;
+ 	const char *name_fmt;
+ 	static const char * const color_str[] = { "red", "green", "blue" };
+ 	static const __u8 initial_values[MAX_LEDS] = { 0x00, 0x00, 0x00, 0x00 };
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	BUG_ON(!(drv_data->quirks & SONY_LED_SUPPORT));
+ 
+ 	if (drv_data->quirks & BUZZ_CONTROLLER) {
+ 		drv_data->led_count = 4;
+ 		max_brightness = 1;
+ 		use_colors = 0;
+ 		name_len = strlen("::buzz#");
+ 		name_fmt = "%s::buzz%d";
+ 		/* Validate expected report characteristics. */
+ 		if (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))
+ 			return -ENODEV;
+ 	} else if (drv_data->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		drv_data->led_count = 3;
+ 		max_brightness = 255;
+ 		use_colors = 1;
+ 		name_len = 0;
+ 		name_fmt = "%s:%s";
+ 	} else {
+ 		drv_data->led_count = 4;
+ 		max_brightness = 1;
+ 		use_colors = 0;
+ 		name_len = strlen("::sony#");
+ 		name_fmt = "%s::sony%d";
+ 	}
+ 
+ 	/* Clear LEDs as we have no way of reading their initial state. This is
+ 	 * only relevant if the driver is loaded after somebody actively set the
+ 	 * LEDs to on */
+ 	sony_set_leds(hdev, initial_values, drv_data->led_count);
+ 
+ 	name_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 
+ 		if (use_colors)
+ 			name_sz = strlen(dev_name(&hdev->dev)) + strlen(color_str[n]) + 2;
+ 
+ 		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
+ 		if (!led) {
+ 			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
+ 			ret = -ENOMEM;
+ 			goto error_leds;
+ 		}
+ 
+ 		name = (void *)(&led[1]);
+ 		if (use_colors)
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), color_str[n]);
+ 		else
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);
+ 		led->name = name;
+ 		led->brightness = 0;
+ 		led->max_brightness = max_brightness;
+ 		led->brightness_get = sony_led_get_brightness;
+ 		led->brightness_set = sony_led_set_brightness;
+ 
+ 		ret = led_classdev_register(&hdev->dev, led);
+ 		if (ret) {
+ 			hid_err(hdev, "Failed to register LED %d\n", n);
+ 			kfree(led);
+ 			goto error_leds;
+ 		}
+ 
+ 		drv_data->leds[n] = led;
+ 	}
+ 
+ 	return ret;
+ 
+ error_leds:
+ 	sony_leds_remove(hdev);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	unsigned char buf[] = {
+ 		0x01,
+ 		0x00, 0xff, 0x00, 0xff, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x00,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0x00, 0x00, 0x00, 0x00, 0x00
+ 	};
+ 
+ #ifdef CONFIG_SONY_FF
+ 	buf[3] = sc->right ? 1 : 0;
+ 	buf[5] = sc->left;
+ #endif
+ 
+ 	buf[10] |= sc->led_state[0] << 1;
+ 	buf[10] |= sc->led_state[1] << 2;
+ 	buf[10] |= sc->led_state[2] << 3;
+ 	buf[10] |= sc->led_state[3] << 4;
+ 
+ 	hid_output_raw_report(sc->hdev, buf, sizeof(buf), HID_OUTPUT_REPORT);
+ }
+ 
+ static void dualshock4_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct hid_device *hdev = sc->hdev;
+ 	struct hid_report *report = sc->output_report;
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	value[0] = 0x03;
+ 
+ #ifdef CONFIG_SONY_FF
+ 	value[3] = sc->right;
+ 	value[4] = sc->left;
+ #endif
+ 
+ 	value[5] = sc->led_state[0];
+ 	value[6] = sc->led_state[1];
+ 	value[7] = sc->led_state[2];
+ 
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ #ifdef CONFIG_SONY_FF
+ static int sony_play_effect(struct input_dev *dev, void *data,
+ 			    struct ff_effect *effect)
+ {
+ 	struct hid_device *hid = input_get_drvdata(dev);
+ 	struct sony_sc *sc = hid_get_drvdata(hid);
+ 
+ 	if (effect->type != FF_RUMBLE)
+ 		return 0;
+ 
+ 	sc->left = effect->u.rumble.strong_magnitude / 256;
+ 	sc->right = effect->u.rumble.weak_magnitude / 256;
+ 
+ 	schedule_work(&sc->state_worker);
+ 	return 0;
+ }
+ 
+ static int sony_init_ff(struct hid_device *hdev)
+ {
+ 	struct hid_input *hidinput = list_entry(hdev->inputs.next,
+ 						struct hid_input, list);
+ 	struct input_dev *input_dev = hidinput->input;
+ 
+ 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+ 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
+ }
+ 
+ static void sony_destroy_ff(struct hid_device *hdev)
+ {
+ 	struct sony_sc *sc = hid_get_drvdata(hdev);
+ 
+ 	cancel_work_sync(&sc->state_worker);
+ }
+ 
+ #else
+ static int sony_init_ff(struct hid_device *hdev)
+ {
+ 	return 0;
+ }
+ 
+ static void sony_destroy_ff(struct hid_device *hdev)
+ {
+ }
+ #endif
+ 
+ static int sony_set_output_report(struct sony_sc *sc, int req_id, int req_size)
+ {
+ 	struct list_head *head, *list;
+ 	struct hid_report *report;
+ 	struct hid_device *hdev = sc->hdev;
+ 
+ 	list = &hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 
+ 	list_for_each(head, list) {
+ 		report = list_entry(head, struct hid_report, list);
+ 
+ 		if (report->id == req_id) {
+ 			if (report->size < req_size) {
+ 				hid_err(hdev, "Output report 0x%02x (%i bits) is smaller than requested size (%i bits)\n",
+ 					req_id, report->size, req_size);
+ 				return -EINVAL;
+ 			}
+ 			sc->output_report = report;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	hid_err(hdev, "Unable to locate output report 0x%02x\n", req_id);
+ 
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 7e845d46b13e (HID: introduce helper to access hid_output_raw_report())
  static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
  {
  	int ret;
diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 802311fb961a..0a0c9cb31407 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1184,7 +1184,7 @@ static void hidinput_led_worker(struct work_struct *work)
 
 	hid_output_report(report, buf);
 	/* synchronous output report */
-	hid->hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT);
+	hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT);
 	kfree(buf);
 }
 
diff --git a/drivers/hid/hid-lg.c b/drivers/hid/hid-lg.c
index 12fc48c968e6..6726e4696b0d 100644
--- a/drivers/hid/hid-lg.c
+++ b/drivers/hid/hid-lg.c
@@ -692,7 +692,8 @@ static int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	if (hdev->product == USB_DEVICE_ID_LOGITECH_WII_WHEEL) {
 		unsigned char buf[] = { 0x00, 0xAF,  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 
-		ret = hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
+		ret = hid_output_raw_report(hdev, buf, sizeof(buf),
+					    HID_FEATURE_REPORT);
 
 		if (ret >= 0) {
 			/* insert a little delay of 10 jiffies ~ 40ms */
@@ -704,7 +705,8 @@ static int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)
 			buf[1] = 0xB2;
 			get_random_bytes(&buf[2], 2);
 
-			ret = hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
+			ret = hid_output_raw_report(hdev, buf, sizeof(buf),
+						    HID_FEATURE_REPORT);
 		}
 	}
 
diff --git a/drivers/hid/hid-magicmouse.c b/drivers/hid/hid-magicmouse.c
index c24f3dfd9367..20dc62557084 100644
--- a/drivers/hid/hid-magicmouse.c
+++ b/drivers/hid/hid-magicmouse.c
@@ -548,7 +548,7 @@ static int magicmouse_probe(struct hid_device *hdev,
 	 * but there seems to be no other way of switching the mode.
 	 * Thus the super-ugly hacky success check below.
 	 */
-	ret = hdev->hid_output_raw_report(hdev, feature, sizeof(feature),
+	ret = hid_output_raw_report(hdev, feature, sizeof(feature),
 			HID_FEATURE_REPORT);
 	if (ret != -EIO && ret != sizeof(feature)) {
 		hid_err(hdev, "unable to request touch data (%d)\n", ret);
* Unmerged path drivers/hid/hid-sony.c
diff --git a/drivers/hid/hid-thingm.c b/drivers/hid/hid-thingm.c
index 99342cfa0ea2..7dd3197f3b3e 100644
--- a/drivers/hid/hid-thingm.c
+++ b/drivers/hid/hid-thingm.c
@@ -48,8 +48,8 @@ static int blink1_send_command(struct blink1_data *data,
 			buf[0], buf[1], buf[2], buf[3], buf[4],
 			buf[5], buf[6], buf[7], buf[8]);
 
-	ret = data->hdev->hid_output_raw_report(data->hdev, buf,
-			BLINK1_CMD_SIZE, HID_FEATURE_REPORT);
+	ret = hid_output_raw_report(data->hdev, buf, BLINK1_CMD_SIZE,
+				    HID_FEATURE_REPORT);
 
 	return ret < 0 ? ret : 0;
 }
diff --git a/drivers/hid/hid-wacom.c b/drivers/hid/hid-wacom.c
index a4a8bb0da688..eb3f5d1086fa 100644
--- a/drivers/hid/hid-wacom.c
+++ b/drivers/hid/hid-wacom.c
@@ -126,8 +126,7 @@ static void wacom_set_image(struct hid_device *hdev, const char *image,
 
 	rep_data[0] = WAC_CMD_ICON_START_STOP;
 	rep_data[1] = 0;
-	ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
-				HID_FEATURE_REPORT);
+	ret = hid_output_raw_report(hdev, rep_data, 2, HID_FEATURE_REPORT);
 	if (ret < 0)
 		goto err;
 
@@ -141,15 +140,14 @@ static void wacom_set_image(struct hid_device *hdev, const char *image,
 			rep_data[j + 3] = p[(i << 6) + j];
 
 		rep_data[2] = i;
-		ret = hdev->hid_output_raw_report(hdev, rep_data, 67,
+		ret = hid_output_raw_report(hdev, rep_data, 67,
 					HID_FEATURE_REPORT);
 	}
 
 	rep_data[0] = WAC_CMD_ICON_START_STOP;
 	rep_data[1] = 0;
 
-	ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
-				HID_FEATURE_REPORT);
+	ret = hid_output_raw_report(hdev, rep_data, 2, HID_FEATURE_REPORT);
 
 err:
 	return;
@@ -181,7 +179,7 @@ static void wacom_leds_set_brightness(struct led_classdev *led_dev,
 		buf[3] = value;
 		/* use fixed brightness for OLEDs */
 		buf[4] = 0x08;
-		hdev->hid_output_raw_report(hdev, buf, 9, HID_FEATURE_REPORT);
+		hid_output_raw_report(hdev, buf, 9, HID_FEATURE_REPORT);
 		kfree(buf);
 	}
 
@@ -328,7 +326,7 @@ static void wacom_set_features(struct hid_device *hdev, u8 speed)
 		rep_data[0] = 0x03 ; rep_data[1] = 0x00;
 		limit = 3;
 		do {
-			ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
+			ret = hid_output_raw_report(hdev, rep_data, 2,
 					HID_FEATURE_REPORT);
 		} while (ret < 0 && limit-- > 0);
 
@@ -341,7 +339,7 @@ static void wacom_set_features(struct hid_device *hdev, u8 speed)
 			rep_data[1] = 0x00;
 			limit = 3;
 			do {
-				ret = hdev->hid_output_raw_report(hdev,
+				ret = hid_output_raw_report(hdev,
 					rep_data, 2, HID_FEATURE_REPORT);
 			} while (ret < 0 && limit-- > 0);
 
@@ -367,7 +365,7 @@ static void wacom_set_features(struct hid_device *hdev, u8 speed)
 		rep_data[0] = 0x03;
 		rep_data[1] = wdata->features;
 
-		ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
+		ret = hid_output_raw_report(hdev, rep_data, 2,
 					HID_FEATURE_REPORT);
 		if (ret >= 0)
 			wdata->high_speed = speed;
diff --git a/drivers/hid/hid-wiimote-core.c b/drivers/hid/hid-wiimote-core.c
index e5ee1f20bbd9..b626492ab65c 100644
--- a/drivers/hid/hid-wiimote-core.c
+++ b/drivers/hid/hid-wiimote-core.c
@@ -69,7 +69,7 @@ static ssize_t wiimote_hid_send(struct hid_device *hdev, __u8 *buffer,
 	if (!buf)
 		return -ENOMEM;
 
-	ret = hdev->hid_output_raw_report(hdev, buf, count, HID_OUTPUT_REPORT);
+	ret = hid_output_raw_report(hdev, buf, count, HID_OUTPUT_REPORT);
 
 	kfree(buf);
 	return ret;
diff --git a/drivers/hid/hidraw.c b/drivers/hid/hidraw.c
index 9cc86097e507..7929549475a9 100644
--- a/drivers/hid/hidraw.c
+++ b/drivers/hid/hidraw.c
@@ -153,7 +153,7 @@ static ssize_t hidraw_send_report(struct file *file, const char __user *buffer,
 		goto out_free;
 	}
 
-	ret = dev->hid_output_raw_report(dev, buf, count, report_type);
+	ret = hid_output_raw_report(dev, buf, count, report_type);
 out_free:
 	kfree(buf);
 out:
diff --git a/include/linux/hid.h b/include/linux/hid.h
index 5270972f80a9..67eb1c885e02 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -1020,6 +1020,22 @@ static inline int hid_hw_output_report(struct hid_device *hdev, __u8 *buf,
 	return -ENOSYS;
 }
 
+/**
+ * hid_output_raw_report - send an output or a feature report to the device
+ *
+ * @hdev: hid device
+ * @buf: raw data to transfer
+ * @len: length of buf
+ * @report_type: HID_FEATURE_REPORT or HID_OUTPUT_REPORT
+ *
+ * @return: count of data transfered, negative if error
+ */
+static inline int hid_output_raw_report(struct hid_device *hdev, __u8 *buf,
+					size_t len, unsigned char report_type)
+{
+	return hdev->hid_output_raw_report(hdev, buf, len, report_type);
+}
+
 /**
  * hid_hw_idle - send idle request to device
  *
