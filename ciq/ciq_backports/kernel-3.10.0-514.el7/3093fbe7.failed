route: Per route IP tunnel metadata via lightweight tunnel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit 3093fbe7ff4bc7d1571fc217dade1cf80330a714
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3093fbe7.failed

This introduces a new IP tunnel lightweight tunnel type which allows
to specify IP tunnel instructions per route. Only IPv4 is supported
at this point.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3093fbe7ff4bc7d1571fc217dade1cf80330a714)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/dst_metadata.h
#	include/net/ip_tunnels.h
#	include/uapi/linux/lwtunnel.h
#	net/ipv4/route.c
diff --cc drivers/net/vxlan.c
index e2461103c0f3,9486d7ec128c..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1876,6 -1935,7 +1876,10 @@@ static void vxlan_encap_bypass(struct s
  static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
  			   struct vxlan_rdst *rdst, bool did_rsc)
  {
++<<<<<<< HEAD
++=======
+ 	struct ip_tunnel_info *info;
++>>>>>>> 3093fbe7ff4b (route: Per route IP tunnel metadata via lightweight tunnel)
  	struct vxlan_dev *vxlan = netdev_priv(dev);
  	struct sock *sk = vxlan->vn_sock->sock->sk;
  	struct rtable *rt = NULL;
@@@ -1888,10 -1950,28 +1892,33 @@@
  	__be16 df = 0;
  	__u8 tos, ttl;
  	int err;
 -	u32 flags = vxlan->flags;
  
++<<<<<<< HEAD
 +	dst_port = rdst->remote_port ? rdst->remote_port : vxlan->dst_port;
 +	vni = rdst->remote_vni;
 +	dst = &rdst->remote_ip;
++=======
+ 	/* FIXME: Support IPv6 */
+ 	info = skb_tunnel_info(skb, AF_INET);
+ 
+ 	if (rdst) {
+ 		dst_port = rdst->remote_port ? rdst->remote_port : vxlan->dst_port;
+ 		vni = rdst->remote_vni;
+ 		dst = &rdst->remote_ip;
+ 	} else {
+ 		if (!info) {
+ 			WARN_ONCE(1, "%s: Missing encapsulation instructions\n",
+ 				  dev->name);
+ 			goto drop;
+ 		}
+ 
+ 		dst_port = info->key.tp_dst ? : vxlan->dst_port;
+ 		vni = be64_to_cpu(info->key.tun_id);
+ 		remote_ip.sin.sin_family = AF_INET;
+ 		remote_ip.sin.sin_addr.s_addr = info->key.ipv4_dst;
+ 		dst = &remote_ip;
+ 	}
++>>>>>>> 3093fbe7ff4b (route: Per route IP tunnel metadata via lightweight tunnel)
  
  	if (vxlan_addr_any(dst)) {
  		if (did_rsc) {
@@@ -2049,6 -2144,7 +2076,10 @@@ tx_free
  static netdev_tx_t vxlan_xmit(struct sk_buff *skb, struct net_device *dev)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
++<<<<<<< HEAD
++=======
+ 	const struct ip_tunnel_info *info;
++>>>>>>> 3093fbe7ff4b (route: Per route IP tunnel metadata via lightweight tunnel)
  	struct ethhdr *eth;
  	bool did_rsc = false;
  	struct vxlan_rdst *rdst, *fdst = NULL;
diff --cc include/net/ip_tunnels.h
index 1466fdbddeda,0b7e18cfa0b4..000000000000
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@@ -296,6 -293,16 +296,19 @@@ static inline void iptunnel_xmit_stats(
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline void *ip_tunnel_info_opts(struct ip_tunnel_info *info, size_t n)
+ {
+ 	return info + 1;
+ }
+ 
+ static inline struct ip_tunnel_info *lwt_tun_info(struct lwtunnel_state *lwtstate)
+ {
+ 	return (struct ip_tunnel_info *)lwtstate->data;
+ }
+ 
++>>>>>>> 3093fbe7ff4b (route: Per route IP tunnel metadata via lightweight tunnel)
  #endif /* CONFIG_INET */
  
  #endif /* __NET_IP_TUNNELS_H */
diff --cc net/ipv4/route.c
index bb601e82773a,519ec232818d..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1657,6 -1693,13 +1657,16 @@@ static int ip_route_input_slow(struct s
  	   by fib_lookup.
  	 */
  
++<<<<<<< HEAD
++=======
+ 	tun_info = skb_tunnel_info(skb, AF_INET);
+ 	if (tun_info && tun_info->mode == IP_TUNNEL_INFO_RX)
+ 		fl4.flowi4_tun_key.tun_id = tun_info->key.tun_id;
+ 	else
+ 		fl4.flowi4_tun_key.tun_id = 0;
+ 	skb_dst_drop(skb);
+ 
++>>>>>>> 3093fbe7ff4b (route: Per route IP tunnel metadata via lightweight tunnel)
  	if (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr))
  		goto martian_source;
  
* Unmerged path include/net/dst_metadata.h
* Unmerged path include/uapi/linux/lwtunnel.h
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/dst_metadata.h
* Unmerged path include/net/ip_tunnels.h
* Unmerged path include/uapi/linux/lwtunnel.h
diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h
index a94764ea9e9c..db730bbd8018 100644
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@ -285,6 +285,21 @@ enum rt_class_t {
 
 /* Routing message attributes */
 
+enum ip_tunnel_t {
+	IP_TUN_UNSPEC,
+	IP_TUN_ID,
+	IP_TUN_DST,
+	IP_TUN_SRC,
+	IP_TUN_TTL,
+	IP_TUN_TOS,
+	IP_TUN_SPORT,
+	IP_TUN_DPORT,
+	IP_TUN_FLAGS,
+	__IP_TUN_MAX,
+};
+
+#define IP_TUN_MAX (__IP_TUN_MAX - 1)
+
 enum rtattr_type_t {
 	RTA_UNSPEC,
 	RTA_DST,
diff --git a/net/ipv4/ip_tunnel_core.c b/net/ipv4/ip_tunnel_core.c
index 010b54caceed..1ac801ce9e60 100644
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@ -188,3 +188,117 @@ struct rtnl_link_stats64 *ip_tunnel_get_stats64(struct net_device *dev,
 	return tot;
 }
 EXPORT_SYMBOL_GPL(ip_tunnel_get_stats64);
+
+static const struct nla_policy ip_tun_policy[IP_TUN_MAX + 1] = {
+	[IP_TUN_ID]		= { .type = NLA_U64 },
+	[IP_TUN_DST]		= { .type = NLA_U32 },
+	[IP_TUN_SRC]		= { .type = NLA_U32 },
+	[IP_TUN_TTL]		= { .type = NLA_U8 },
+	[IP_TUN_TOS]		= { .type = NLA_U8 },
+	[IP_TUN_SPORT]		= { .type = NLA_U16 },
+	[IP_TUN_DPORT]		= { .type = NLA_U16 },
+	[IP_TUN_FLAGS]		= { .type = NLA_U16 },
+};
+
+static int ip_tun_build_state(struct net_device *dev, struct nlattr *attr,
+			      struct lwtunnel_state **ts)
+{
+	struct ip_tunnel_info *tun_info;
+	struct lwtunnel_state *new_state;
+	struct nlattr *tb[IP_TUN_MAX + 1];
+	int err;
+
+	err = nla_parse_nested(tb, IP_TUN_MAX, attr, ip_tun_policy);
+	if (err < 0)
+		return err;
+
+	new_state = lwtunnel_state_alloc(sizeof(*tun_info));
+	if (!new_state)
+		return -ENOMEM;
+
+	new_state->type = LWTUNNEL_ENCAP_IP;
+
+	tun_info = lwt_tun_info(new_state);
+
+	if (tb[IP_TUN_ID])
+		tun_info->key.tun_id = nla_get_u64(tb[IP_TUN_ID]);
+
+	if (tb[IP_TUN_DST])
+		tun_info->key.ipv4_dst = nla_get_be32(tb[IP_TUN_DST]);
+
+	if (tb[IP_TUN_SRC])
+		tun_info->key.ipv4_src = nla_get_be32(tb[IP_TUN_SRC]);
+
+	if (tb[IP_TUN_TTL])
+		tun_info->key.ipv4_ttl = nla_get_u8(tb[IP_TUN_TTL]);
+
+	if (tb[IP_TUN_TOS])
+		tun_info->key.ipv4_tos = nla_get_u8(tb[IP_TUN_TOS]);
+
+	if (tb[IP_TUN_SPORT])
+		tun_info->key.tp_src = nla_get_be16(tb[IP_TUN_SPORT]);
+
+	if (tb[IP_TUN_DPORT])
+		tun_info->key.tp_dst = nla_get_be16(tb[IP_TUN_DPORT]);
+
+	if (tb[IP_TUN_FLAGS])
+		tun_info->key.tun_flags = nla_get_u16(tb[IP_TUN_FLAGS]);
+
+	tun_info->mode = IP_TUNNEL_INFO_TX;
+	tun_info->options = NULL;
+	tun_info->options_len = 0;
+
+	*ts = new_state;
+
+	return 0;
+}
+
+static int ip_tun_fill_encap_info(struct sk_buff *skb,
+				  struct lwtunnel_state *lwtstate)
+{
+	struct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);
+
+	if (nla_put_u64(skb, IP_TUN_ID, tun_info->key.tun_id) ||
+	    nla_put_be32(skb, IP_TUN_DST, tun_info->key.ipv4_dst) ||
+	    nla_put_be32(skb, IP_TUN_SRC, tun_info->key.ipv4_src) ||
+	    nla_put_u8(skb, IP_TUN_TOS, tun_info->key.ipv4_tos) ||
+	    nla_put_u8(skb, IP_TUN_TTL, tun_info->key.ipv4_ttl) ||
+	    nla_put_u16(skb, IP_TUN_SPORT, tun_info->key.tp_src) ||
+	    nla_put_u16(skb, IP_TUN_DPORT, tun_info->key.tp_dst) ||
+	    nla_put_u16(skb, IP_TUN_FLAGS, tun_info->key.tun_flags))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int ip_tun_encap_nlsize(struct lwtunnel_state *lwtstate)
+{
+	return nla_total_size(8)	/* IP_TUN_ID */
+		+ nla_total_size(4)	/* IP_TUN_DST */
+		+ nla_total_size(4)	/* IP_TUN_SRC */
+		+ nla_total_size(1)	/* IP_TUN_TOS */
+		+ nla_total_size(1)	/* IP_TUN_TTL */
+		+ nla_total_size(2)	/* IP_TUN_SPORT */
+		+ nla_total_size(2)	/* IP_TUN_DPORT */
+		+ nla_total_size(2);	/* IP_TUN_FLAGS */
+}
+
+static const struct lwtunnel_encap_ops ip_tun_lwt_ops = {
+	.build_state = ip_tun_build_state,
+	.fill_encap = ip_tun_fill_encap_info,
+	.get_encap_size = ip_tun_encap_nlsize,
+};
+
+static int __init ip_tunnel_core_init(void)
+{
+	lwtunnel_encap_add_ops(&ip_tun_lwt_ops, LWTUNNEL_ENCAP_IP);
+
+	return 0;
+}
+module_init(ip_tunnel_core_init);
+
+static void __exit ip_tunnel_core_exit(void)
+{
+	lwtunnel_encap_del_ops(&ip_tun_lwt_ops, LWTUNNEL_ENCAP_IP);
+}
+module_exit(ip_tunnel_core_exit);
* Unmerged path net/ipv4/route.c
diff --git a/net/openvswitch/vport.h b/net/openvswitch/vport.h
index 4750fb673a9f..75d68248ba69 100644
--- a/net/openvswitch/vport.h
+++ b/net/openvswitch/vport.h
@@ -27,6 +27,7 @@
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
 #include <linux/u64_stats_sync.h>
+#include <net/route.h>
 
 #include "datapath.h"
 
