KVM: Recover IRTE to remapped mode if the interrupt is not single-destination

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Feng Wu <feng.wu@intel.com>
commit 23a1c2579b575b228a6c685dfe93f296d3d5e0e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/23a1c257.failed

When the interrupt is not single destination any more, we need
to change back IRTE to remapped mode explicitly.

	Signed-off-by: Feng Wu <feng.wu@intel.com>
	Reviewed-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 23a1c2579b575b228a6c685dfe93f296d3d5e0e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index a7d76dce5145,a4b4aa4cdc54..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9849,6 -10600,214 +9849,217 @@@ static void vmx_enable_log_dirty_pt_mas
  	kvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * This routine does the following things for vCPU which is going
+  * to be blocked if VT-d PI is enabled.
+  * - Store the vCPU to the wakeup list, so when interrupts happen
+  *   we can find the right vCPU to wake up.
+  * - Change the Posted-interrupt descriptor as below:
+  *      'NDST' <-- vcpu->pre_pcpu
+  *      'NV' <-- POSTED_INTR_WAKEUP_VECTOR
+  * - If 'ON' is set during this process, which means at least one
+  *   interrupt is posted for this vCPU, we cannot block it, in
+  *   this case, return 1, otherwise, return 0.
+  *
+  */
+ static int vmx_pre_block(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long flags;
+ 	unsigned int dest;
+ 	struct pi_desc old, new;
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	vcpu->pre_pcpu = vcpu->cpu;
+ 	spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			  vcpu->pre_pcpu), flags);
+ 	list_add_tail(&vcpu->blocked_vcpu_list,
+ 		      &per_cpu(blocked_vcpu_on_cpu,
+ 		      vcpu->pre_pcpu));
+ 	spin_unlock_irqrestore(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			       vcpu->pre_pcpu), flags);
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		/*
+ 		 * We should not block the vCPU if
+ 		 * an interrupt is posted for it.
+ 		 */
+ 		if (pi_test_on(pi_desc) == 1) {
+ 			spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					  vcpu->pre_pcpu), flags);
+ 			list_del(&vcpu->blocked_vcpu_list);
+ 			spin_unlock_irqrestore(
+ 					&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					vcpu->pre_pcpu), flags);
+ 			vcpu->pre_pcpu = -1;
+ 
+ 			return 1;
+ 		}
+ 
+ 		WARN((pi_desc->sn == 1),
+ 		     "Warning: SN field of posted-interrupts "
+ 		     "is set before blocking\n");
+ 
+ 		/*
+ 		 * Since vCPU can be preempted during this process,
+ 		 * vcpu->cpu could be different with pre_pcpu, we
+ 		 * need to set pre_pcpu as the destination of wakeup
+ 		 * notification event, then we can find the right vCPU
+ 		 * to wakeup in wakeup handler if interrupts happen
+ 		 * when the vCPU is in blocked state.
+ 		 */
+ 		dest = cpu_physical_id(vcpu->pre_pcpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* set 'NV' to 'wakeup vector' */
+ 		new.nv = POSTED_INTR_WAKEUP_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	return 0;
+ }
+ 
+ static void vmx_post_block(struct kvm_vcpu *vcpu)
+ {
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 	struct pi_desc old, new;
+ 	unsigned int dest;
+ 	unsigned long flags;
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return;
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		dest = cpu_physical_id(vcpu->cpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* Allow posting non-urgent interrupts */
+ 		new.sn = 0;
+ 
+ 		/* set 'NV' to 'notification vector' */
+ 		new.nv = POSTED_INTR_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	if(vcpu->pre_pcpu != -1) {
+ 		spin_lock_irqsave(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		list_del(&vcpu->blocked_vcpu_list);
+ 		spin_unlock_irqrestore(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		vcpu->pre_pcpu = -1;
+ 	}
+ }
+ 
+ /*
+  * vmx_update_pi_irte - set IRTE for Posted-Interrupts
+  *
+  * @kvm: kvm
+  * @host_irq: host irq of the interrupt
+  * @guest_irq: gsi of the interrupt
+  * @set: set or unset PI
+  * returns 0 on success, < 0 on failure
+  */
+ static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,
+ 			      uint32_t guest_irq, bool set)
+ {
+ 	struct kvm_kernel_irq_routing_entry *e;
+ 	struct kvm_irq_routing_table *irq_rt;
+ 	struct kvm_lapic_irq irq;
+ 	struct kvm_vcpu *vcpu;
+ 	struct vcpu_data vcpu_info;
+ 	int idx, ret = -EINVAL;
+ 
+ 	if (!kvm_arch_has_assigned_device(kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	BUG_ON(guest_irq >= irq_rt->nr_rt_entries);
+ 
+ 	hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {
+ 		if (e->type != KVM_IRQ_ROUTING_MSI)
+ 			continue;
+ 		/*
+ 		 * VT-d PI cannot support posting multicast/broadcast
+ 		 * interrupts to a vCPU, we still use interrupt remapping
+ 		 * for these kind of interrupts.
+ 		 *
+ 		 * For lowest-priority interrupts, we only support
+ 		 * those with single CPU as the destination, e.g. user
+ 		 * configures the interrupts via /proc/irq or uses
+ 		 * irqbalance to make the interrupts single-CPU.
+ 		 *
+ 		 * We will support full lowest-priority interrupt later.
+ 		 */
+ 
+ 		kvm_set_msi_irq(e, &irq);
+ 		if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {
+ 			/*
+ 			 * Make sure the IRTE is in remapped mode if
+ 			 * we don't handle it in posted mode.
+ 			 */
+ 			ret = irq_set_vcpu_affinity(host_irq, NULL);
+ 			if (ret < 0) {
+ 				printk(KERN_INFO
+ 				   "failed to back to remapped mode, irq: %u\n",
+ 				   host_irq);
+ 				goto out;
+ 			}
+ 
+ 			continue;
+ 		}
+ 
+ 		vcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));
+ 		vcpu_info.vector = irq.vector;
+ 
+ 		trace_kvm_pi_irte_update(vcpu->vcpu_id, e->gsi,
+ 				vcpu_info.vector, vcpu_info.pi_desc_addr, set);
+ 
+ 		if (set)
+ 			ret = irq_set_vcpu_affinity(host_irq, &vcpu_info);
+ 		else {
+ 			/* suppress notification event before unposting */
+ 			pi_set_sn(vcpu_to_pi_desc(vcpu));
+ 			ret = irq_set_vcpu_affinity(host_irq, NULL);
+ 			pi_clear_sn(vcpu_to_pi_desc(vcpu));
+ 		}
+ 
+ 		if (ret < 0) {
+ 			printk(KERN_INFO "%s: failed to update PI IRTE\n",
+ 					__func__);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ out:
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ 	return ret;
+ }
+ 
++>>>>>>> 23a1c2579b57 (KVM: Recover IRTE to remapped mode if the interrupt is not single-destination)
  static struct kvm_x86_ops vmx_x86_ops = {
  	.cpu_has_kvm_support = cpu_has_kvm_support,
  	.disabled_by_bios = vmx_disabled_by_bios,
* Unmerged path arch/x86/kvm/vmx.c
