drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915: Introduce Kabypoint PCH for Kabylake H/DT (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 94.95%
commit-author Rodrigo Vivi <rodrigo.vivi@intel.com>
commit 22dea0be50b2eb0bafd3c82e1fb080113e0c889e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/22dea0be.failed

Some Kabylake SKUs are going to use Kabypoint PCH.
It is mainly for Halo and DT ones.

>From our specs it doesn't seem that KBP brings
any change on the display south engine. So let's consider
this as a continuation of SunrisePoint, i.e., SPT+.

Since it is easy to get confused by a letter change:
KBL = Kabylake - CPU/GPU codename.
KBP = Kabypoint - PCH codename.

	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Reviewed-by: Ander Conselvan de Oliveira <conselvan2@gmail.com>
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=96826
Link: http://patchwork.freedesktop.org/patch/msgid/1467418032-15167-1-git-send-email-rodrigo.vivi@intel.com
	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
(cherry picked from commit 22dea0be50b2eb0bafd3c82e1fb080113e0c889e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_drv.c
#	drivers/gpu/drm/i915/i915_drv.h
#	drivers/gpu/drm/i915/i915_irq.c
#	drivers/gpu/drm/i915/intel_panel.c
diff --cc drivers/gpu/drm/i915/i915_drv.c
index a19d2c71e205,b9a811750ca8..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@@ -490,57 -202,1205 +490,74 @@@ void intel_detect_pch(struct drm_devic
  			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
  				dev_priv->pch_type = PCH_SPT;
  				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
++<<<<<<< HEAD
 +				WARN_ON(!IS_SKYLAKE(dev));
++=======
+ 				WARN_ON(!IS_SKYLAKE(dev) &&
+ 					!IS_KABYLAKE(dev));
+ 			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
+ 				dev_priv->pch_type = PCH_KBP;
+ 				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
+ 				WARN_ON(!IS_KABYLAKE(dev));
 -			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 -				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 -				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
 -				    pch->subsystem_vendor ==
 -					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
 -				    pch->subsystem_device ==
 -					    PCI_SUBDEVICE_ID_QEMU)) {
 -				dev_priv->pch_type = intel_virt_detect_pch(dev);
 -			} else
 -				continue;
 -
 -			break;
 -		}
 -	}
 -	if (!pch)
 -		DRM_DEBUG_KMS("No PCH found.\n");
 -
 -	pci_dev_put(pch);
 -}
 -
 -bool i915_semaphore_is_enabled(struct drm_i915_private *dev_priv)
 -{
 -	if (INTEL_GEN(dev_priv) < 6)
 -		return false;
 -
 -	if (i915.semaphores >= 0)
 -		return i915.semaphores;
 -
 -	/* TODO: make semaphores and Execlists play nicely together */
 -	if (i915.enable_execlists)
 -		return false;
 -
 -#ifdef CONFIG_INTEL_IOMMU
 -	/* Enable semaphores on SNB when IO remapping is off */
 -	if (IS_GEN6(dev_priv) && intel_iommu_gfx_mapped)
 -		return false;
 -#endif
 -
 -	return true;
 -}
 -
 -static int i915_getparam(struct drm_device *dev, void *data,
 -			 struct drm_file *file_priv)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	drm_i915_getparam_t *param = data;
 -	int value;
 -
 -	switch (param->param) {
 -	case I915_PARAM_IRQ_ACTIVE:
 -	case I915_PARAM_ALLOW_BATCHBUFFER:
 -	case I915_PARAM_LAST_DISPATCH:
 -		/* Reject all old ums/dri params. */
 -		return -ENODEV;
 -	case I915_PARAM_CHIPSET_ID:
 -		value = dev->pdev->device;
 -		break;
 -	case I915_PARAM_REVISION:
 -		value = dev->pdev->revision;
 -		break;
 -	case I915_PARAM_HAS_GEM:
 -		value = 1;
 -		break;
 -	case I915_PARAM_NUM_FENCES_AVAIL:
 -		value = dev_priv->num_fence_regs;
 -		break;
 -	case I915_PARAM_HAS_OVERLAY:
 -		value = dev_priv->overlay ? 1 : 0;
 -		break;
 -	case I915_PARAM_HAS_PAGEFLIPPING:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_EXECBUF2:
 -		/* depends on GEM */
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_BSD:
 -		value = intel_engine_initialized(&dev_priv->engine[VCS]);
 -		break;
 -	case I915_PARAM_HAS_BLT:
 -		value = intel_engine_initialized(&dev_priv->engine[BCS]);
 -		break;
 -	case I915_PARAM_HAS_VEBOX:
 -		value = intel_engine_initialized(&dev_priv->engine[VECS]);
 -		break;
 -	case I915_PARAM_HAS_BSD2:
 -		value = intel_engine_initialized(&dev_priv->engine[VCS2]);
 -		break;
 -	case I915_PARAM_HAS_RELAXED_FENCING:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_COHERENT_RINGS:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_EXEC_CONSTANTS:
 -		value = INTEL_INFO(dev)->gen >= 4;
 -		break;
 -	case I915_PARAM_HAS_RELAXED_DELTA:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_GEN7_SOL_RESET:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_LLC:
 -		value = HAS_LLC(dev);
 -		break;
 -	case I915_PARAM_HAS_WT:
 -		value = HAS_WT(dev);
 -		break;
 -	case I915_PARAM_HAS_ALIASING_PPGTT:
 -		value = USES_PPGTT(dev);
 -		break;
 -	case I915_PARAM_HAS_WAIT_TIMEOUT:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_SEMAPHORES:
 -		value = i915_semaphore_is_enabled(dev_priv);
 -		break;
 -	case I915_PARAM_HAS_PRIME_VMAP_FLUSH:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_SECURE_BATCHES:
 -		value = capable(CAP_SYS_ADMIN);
 -		break;
 -	case I915_PARAM_HAS_PINNED_BATCHES:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_EXEC_NO_RELOC:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_EXEC_HANDLE_LUT:
 -		value = 1;
 -		break;
 -	case I915_PARAM_CMD_PARSER_VERSION:
 -		value = i915_cmd_parser_get_version(dev_priv);
 -		break;
 -	case I915_PARAM_HAS_COHERENT_PHYS_GTT:
 -		value = 1;
 -		break;
 -	case I915_PARAM_MMAP_VERSION:
 -		value = 1;
 -		break;
 -	case I915_PARAM_SUBSLICE_TOTAL:
 -		value = INTEL_INFO(dev)->subslice_total;
 -		if (!value)
 -			return -ENODEV;
 -		break;
 -	case I915_PARAM_EU_TOTAL:
 -		value = INTEL_INFO(dev)->eu_total;
 -		if (!value)
 -			return -ENODEV;
 -		break;
 -	case I915_PARAM_HAS_GPU_RESET:
 -		value = i915.enable_hangcheck && intel_has_gpu_reset(dev_priv);
 -		break;
 -	case I915_PARAM_HAS_RESOURCE_STREAMER:
 -		value = HAS_RESOURCE_STREAMER(dev);
 -		break;
 -	case I915_PARAM_HAS_EXEC_SOFTPIN:
 -		value = 1;
 -		break;
 -	case I915_PARAM_HAS_POOLED_EU:
 -		value = HAS_POOLED_EU(dev);
 -		break;
 -	case I915_PARAM_MIN_EU_IN_POOL:
 -		value = INTEL_INFO(dev)->min_eu_in_pool;
 -		break;
 -	default:
 -		DRM_DEBUG("Unknown parameter %d\n", param->param);
 -		return -EINVAL;
 -	}
 -
 -	if (put_user(value, param->value))
 -		return -EFAULT;
 -
 -	return 0;
 -}
 -
 -static int i915_get_bridge_dev(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -
 -	dev_priv->bridge_dev = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
 -	if (!dev_priv->bridge_dev) {
 -		DRM_ERROR("bridge device not found\n");
 -		return -1;
 -	}
 -	return 0;
 -}
 -
 -/* Allocate space for the MCH regs if needed, return nonzero on error */
 -static int
 -intel_alloc_mchbar_resource(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	int reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 -	u32 temp_lo, temp_hi = 0;
 -	u64 mchbar_addr;
 -	int ret;
 -
 -	if (INTEL_INFO(dev)->gen >= 4)
 -		pci_read_config_dword(dev_priv->bridge_dev, reg + 4, &temp_hi);
 -	pci_read_config_dword(dev_priv->bridge_dev, reg, &temp_lo);
 -	mchbar_addr = ((u64)temp_hi << 32) | temp_lo;
 -
 -	/* If ACPI doesn't have it, assume we need to allocate it ourselves */
 -#ifdef CONFIG_PNP
 -	if (mchbar_addr &&
 -	    pnp_range_reserved(mchbar_addr, mchbar_addr + MCHBAR_SIZE))
 -		return 0;
 -#endif
 -
 -	/* Get some space for it */
 -	dev_priv->mch_res.name = "i915 MCHBAR";
 -	dev_priv->mch_res.flags = IORESOURCE_MEM;
 -	ret = pci_bus_alloc_resource(dev_priv->bridge_dev->bus,
 -				     &dev_priv->mch_res,
 -				     MCHBAR_SIZE, MCHBAR_SIZE,
 -				     PCIBIOS_MIN_MEM,
 -				     0, pcibios_align_resource,
 -				     dev_priv->bridge_dev);
 -	if (ret) {
 -		DRM_DEBUG_DRIVER("failed bus alloc: %d\n", ret);
 -		dev_priv->mch_res.start = 0;
 -		return ret;
 -	}
 -
 -	if (INTEL_INFO(dev)->gen >= 4)
 -		pci_write_config_dword(dev_priv->bridge_dev, reg + 4,
 -				       upper_32_bits(dev_priv->mch_res.start));
 -
 -	pci_write_config_dword(dev_priv->bridge_dev, reg,
 -			       lower_32_bits(dev_priv->mch_res.start));
 -	return 0;
 -}
 -
 -/* Setup MCHBAR if possible, return true if we should disable it again */
 -static void
 -intel_setup_mchbar(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 -	u32 temp;
 -	bool enabled;
 -
 -	if (IS_VALLEYVIEW(dev) || IS_CHERRYVIEW(dev))
 -		return;
 -
 -	dev_priv->mchbar_need_disable = false;
 -
 -	if (IS_I915G(dev) || IS_I915GM(dev)) {
 -		pci_read_config_dword(dev_priv->bridge_dev, DEVEN, &temp);
 -		enabled = !!(temp & DEVEN_MCHBAR_EN);
 -	} else {
 -		pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg, &temp);
 -		enabled = temp & 1;
 -	}
 -
 -	/* If it's already enabled, don't have to do anything */
 -	if (enabled)
 -		return;
 -
 -	if (intel_alloc_mchbar_resource(dev))
 -		return;
 -
 -	dev_priv->mchbar_need_disable = true;
 -
 -	/* Space is allocated or reserved, so enable it. */
 -	if (IS_I915G(dev) || IS_I915GM(dev)) {
 -		pci_write_config_dword(dev_priv->bridge_dev, DEVEN,
 -				       temp | DEVEN_MCHBAR_EN);
 -	} else {
 -		pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg, &temp);
 -		pci_write_config_dword(dev_priv->bridge_dev, mchbar_reg, temp | 1);
 -	}
 -}
 -
 -static void
 -intel_teardown_mchbar(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 -
 -	if (dev_priv->mchbar_need_disable) {
 -		if (IS_I915G(dev) || IS_I915GM(dev)) {
 -			u32 deven_val;
 -
 -			pci_read_config_dword(dev_priv->bridge_dev, DEVEN,
 -					      &deven_val);
 -			deven_val &= ~DEVEN_MCHBAR_EN;
 -			pci_write_config_dword(dev_priv->bridge_dev, DEVEN,
 -					       deven_val);
 -		} else {
 -			u32 mchbar_val;
 -
 -			pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg,
 -					      &mchbar_val);
 -			mchbar_val &= ~1;
 -			pci_write_config_dword(dev_priv->bridge_dev, mchbar_reg,
 -					       mchbar_val);
 -		}
 -	}
 -
 -	if (dev_priv->mch_res.start)
 -		release_resource(&dev_priv->mch_res);
 -}
 -
 -/* true = enable decode, false = disable decoder */
 -static unsigned int i915_vga_set_decode(void *cookie, bool state)
 -{
 -	struct drm_device *dev = cookie;
 -
 -	intel_modeset_vga_set_state(dev, state);
 -	if (state)
 -		return VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |
 -		       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 -	else
 -		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 -}
 -
 -static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)
 -{
 -	struct drm_device *dev = pci_get_drvdata(pdev);
 -	pm_message_t pmm = { .event = PM_EVENT_SUSPEND };
 -
 -	if (state == VGA_SWITCHEROO_ON) {
 -		pr_info("switched on\n");
 -		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
 -		/* i915 resume handler doesn't set to D0 */
 -		pci_set_power_state(dev->pdev, PCI_D0);
 -		i915_resume_switcheroo(dev);
 -		dev->switch_power_state = DRM_SWITCH_POWER_ON;
 -	} else {
 -		pr_info("switched off\n");
 -		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
 -		i915_suspend_switcheroo(dev, pmm);
 -		dev->switch_power_state = DRM_SWITCH_POWER_OFF;
 -	}
 -}
 -
 -static bool i915_switcheroo_can_switch(struct pci_dev *pdev)
 -{
 -	struct drm_device *dev = pci_get_drvdata(pdev);
 -
 -	/*
 -	 * FIXME: open_count is protected by drm_global_mutex but that would lead to
 -	 * locking inversion with the driver load path. And the access here is
 -	 * completely racy anyway. So don't bother with locking for now.
 -	 */
 -	return dev->open_count == 0;
 -}
 -
 -static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 -	.set_gpu_state = i915_switcheroo_set_state,
 -	.reprobe = NULL,
 -	.can_switch = i915_switcheroo_can_switch,
 -};
 -
 -static void i915_gem_fini(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -
 -	/*
 -	 * Neither the BIOS, ourselves or any other kernel
 -	 * expects the system to be in execlists mode on startup,
 -	 * so we need to reset the GPU back to legacy mode. And the only
 -	 * known way to disable logical contexts is through a GPU reset.
 -	 *
 -	 * So in order to leave the system in a known default configuration,
 -	 * always reset the GPU upon unload. Afterwards we then clean up the
 -	 * GEM state tracking, flushing off the requests and leaving the
 -	 * system in a known idle state.
 -	 *
 -	 * Note that is of the upmost importance that the GPU is idle and
 -	 * all stray writes are flushed *before* we dismantle the backing
 -	 * storage for the pinned objects.
 -	 *
 -	 * However, since we are uncertain that reseting the GPU on older
 -	 * machines is a good idea, we don't - just in case it leaves the
 -	 * machine in an unusable condition.
 -	 */
 -	if (HAS_HW_CONTEXTS(dev)) {
 -		int reset = intel_gpu_reset(dev_priv, ALL_ENGINES);
 -		WARN_ON(reset && reset != -ENODEV);
 -	}
 -
 -	mutex_lock(&dev->struct_mutex);
 -	i915_gem_reset(dev);
 -	i915_gem_cleanup_engines(dev);
 -	i915_gem_context_fini(dev);
 -	mutex_unlock(&dev->struct_mutex);
 -
 -	WARN_ON(!list_empty(&to_i915(dev)->context_list));
 -}
 -
 -static int i915_load_modeset_init(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	int ret;
 -
 -	if (i915_inject_load_failure())
 -		return -ENODEV;
 -
 -	ret = intel_bios_init(dev_priv);
 -	if (ret)
 -		DRM_INFO("failed to find VBIOS tables\n");
 -
 -	/* If we have > 1 VGA cards, then we need to arbitrate access
 -	 * to the common VGA resources.
 -	 *
 -	 * If we are a secondary display controller (!PCI_DISPLAY_CLASS_VGA),
 -	 * then we do not take part in VGA arbitration and the
 -	 * vga_client_register() fails with -ENODEV.
 -	 */
 -	ret = vga_client_register(dev->pdev, dev, NULL, i915_vga_set_decode);
 -	if (ret && ret != -ENODEV)
 -		goto out;
 -
 -	intel_register_dsm_handler();
 -
 -	ret = vga_switcheroo_register_client(dev->pdev, &i915_switcheroo_ops, false);
 -	if (ret)
 -		goto cleanup_vga_client;
 -
 -	/* must happen before intel_power_domains_init_hw() on VLV/CHV */
 -	intel_update_rawclk(dev_priv);
 -
 -	intel_power_domains_init_hw(dev_priv, false);
 -
 -	intel_csr_ucode_init(dev_priv);
 -
 -	ret = intel_irq_install(dev_priv);
 -	if (ret)
 -		goto cleanup_csr;
 -
 -	intel_setup_gmbus(dev);
 -
 -	/* Important: The output setup functions called by modeset_init need
 -	 * working irqs for e.g. gmbus and dp aux transfers. */
 -	intel_modeset_init(dev);
 -
 -	intel_guc_init(dev);
 -
 -	ret = i915_gem_init(dev);
 -	if (ret)
 -		goto cleanup_irq;
 -
 -	intel_modeset_gem_init(dev);
 -
 -	if (INTEL_INFO(dev)->num_pipes == 0)
 -		return 0;
 -
 -	ret = intel_fbdev_init(dev);
 -	if (ret)
 -		goto cleanup_gem;
 -
 -	/* Only enable hotplug handling once the fbdev is fully set up. */
 -	intel_hpd_init(dev_priv);
 -
 -	drm_kms_helper_poll_init(dev);
 -
 -	return 0;
 -
 -cleanup_gem:
 -	i915_gem_fini(dev);
 -cleanup_irq:
 -	intel_guc_fini(dev);
 -	drm_irq_uninstall(dev);
 -	intel_teardown_gmbus(dev);
 -cleanup_csr:
 -	intel_csr_ucode_fini(dev_priv);
 -	intel_power_domains_fini(dev_priv);
 -	vga_switcheroo_unregister_client(dev->pdev);
 -cleanup_vga_client:
 -	vga_client_register(dev->pdev, NULL, NULL, NULL);
 -out:
 -	return ret;
 -}
 -
 -#if IS_ENABLED(CONFIG_FB)
 -static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 -{
 -	struct apertures_struct *ap;
 -	struct pci_dev *pdev = dev_priv->drm.pdev;
 -	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 -	bool primary;
 -	int ret;
 -
 -	ap = alloc_apertures(1);
 -	if (!ap)
 -		return -ENOMEM;
 -
 -	ap->ranges[0].base = ggtt->mappable_base;
 -	ap->ranges[0].size = ggtt->mappable_end;
 -
 -	primary =
 -		pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
 -
 -	ret = remove_conflicting_framebuffers(ap, "inteldrmfb", primary);
 -
 -	kfree(ap);
 -
 -	return ret;
 -}
 -#else
 -static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 -{
 -	return 0;
 -}
 -#endif
 -
 -#if !defined(CONFIG_VGA_CONSOLE)
 -static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
 -{
 -	return 0;
 -}
 -#elif !defined(CONFIG_DUMMY_CONSOLE)
 -static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
 -{
 -	return -ENODEV;
 -}
 -#else
 -static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
 -{
 -	int ret = 0;
 -
 -	DRM_INFO("Replacing VGA console driver\n");
 -
 -	console_lock();
 -	if (con_is_bound(&vga_con))
 -		ret = do_take_over_console(&dummy_con, 0, MAX_NR_CONSOLES - 1, 1);
 -	if (ret == 0) {
 -		ret = do_unregister_con_driver(&vga_con);
 -
 -		/* Ignore "already unregistered". */
 -		if (ret == -ENODEV)
 -			ret = 0;
 -	}
 -	console_unlock();
 -
 -	return ret;
 -}
 -#endif
 -
 -static void intel_init_dpio(struct drm_i915_private *dev_priv)
 -{
 -	/*
 -	 * IOSF_PORT_DPIO is used for VLV x2 PHY (DP/HDMI B and C),
 -	 * CHV x1 PHY (DP/HDMI D)
 -	 * IOSF_PORT_DPIO_2 is used for CHV x2 PHY (DP/HDMI B and C)
 -	 */
 -	if (IS_CHERRYVIEW(dev_priv)) {
 -		DPIO_PHY_IOSF_PORT(DPIO_PHY0) = IOSF_PORT_DPIO_2;
 -		DPIO_PHY_IOSF_PORT(DPIO_PHY1) = IOSF_PORT_DPIO;
 -	} else if (IS_VALLEYVIEW(dev_priv)) {
 -		DPIO_PHY_IOSF_PORT(DPIO_PHY0) = IOSF_PORT_DPIO;
 -	}
 -}
 -
 -static int i915_workqueues_init(struct drm_i915_private *dev_priv)
 -{
 -	/*
 -	 * The i915 workqueue is primarily used for batched retirement of
 -	 * requests (and thus managing bo) once the task has been completed
 -	 * by the GPU. i915_gem_retire_requests() is called directly when we
 -	 * need high-priority retirement, such as waiting for an explicit
 -	 * bo.
 -	 *
 -	 * It is also used for periodic low-priority events, such as
 -	 * idle-timers and recording error state.
 -	 *
 -	 * All tasks on the workqueue are expected to acquire the dev mutex
 -	 * so there is no point in running more than one instance of the
 -	 * workqueue at any time.  Use an ordered one.
 -	 */
 -	dev_priv->wq = alloc_ordered_workqueue("i915", 0);
 -	if (dev_priv->wq == NULL)
 -		goto out_err;
 -
 -	dev_priv->hotplug.dp_wq = alloc_ordered_workqueue("i915-dp", 0);
 -	if (dev_priv->hotplug.dp_wq == NULL)
 -		goto out_free_wq;
 -
 -	return 0;
 -
 -out_free_wq:
 -	destroy_workqueue(dev_priv->wq);
 -out_err:
 -	DRM_ERROR("Failed to allocate workqueues.\n");
 -
 -	return -ENOMEM;
 -}
 -
 -static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
 -{
 -	destroy_workqueue(dev_priv->hotplug.dp_wq);
 -	destroy_workqueue(dev_priv->wq);
 -}
 -
 -/**
 - * i915_driver_init_early - setup state not requiring device access
 - * @dev_priv: device private
 - *
 - * Initialize everything that is a "SW-only" state, that is state not
 - * requiring accessing the device or exposing the driver via kernel internal
 - * or userspace interfaces. Example steps belonging here: lock initialization,
 - * system memory allocation, setting up device specific attributes and
 - * function hooks not requiring accessing the device.
 - */
 -static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 -				  const struct pci_device_id *ent)
 -{
 -	const struct intel_device_info *match_info =
 -		(struct intel_device_info *)ent->driver_data;
 -	struct intel_device_info *device_info;
 -	int ret = 0;
 -
 -	if (i915_inject_load_failure())
 -		return -ENODEV;
 -
 -	/* Setup the write-once "constant" device info */
 -	device_info = mkwrite_device_info(dev_priv);
 -	memcpy(device_info, match_info, sizeof(*device_info));
 -	device_info->device_id = dev_priv->drm.pdev->device;
 -
 -	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
 -	device_info->gen_mask = BIT(device_info->gen - 1);
 -
 -	spin_lock_init(&dev_priv->irq_lock);
 -	spin_lock_init(&dev_priv->gpu_error.lock);
 -	mutex_init(&dev_priv->backlight_lock);
 -	spin_lock_init(&dev_priv->uncore.lock);
 -	spin_lock_init(&dev_priv->mm.object_stat_lock);
 -	spin_lock_init(&dev_priv->mmio_flip_lock);
 -	mutex_init(&dev_priv->sb_lock);
 -	mutex_init(&dev_priv->modeset_restore_lock);
 -	mutex_init(&dev_priv->av_mutex);
 -	mutex_init(&dev_priv->wm.wm_mutex);
 -	mutex_init(&dev_priv->pps_mutex);
 -
 -	ret = i915_workqueues_init(dev_priv);
 -	if (ret < 0)
 -		return ret;
 -
 -	ret = intel_gvt_init(dev_priv);
 -	if (ret < 0)
 -		goto err_workqueues;
 -
 -	/* This must be called before any calls to HAS_PCH_* */
 -	intel_detect_pch(&dev_priv->drm);
 -
 -	intel_pm_setup(&dev_priv->drm);
 -	intel_init_dpio(dev_priv);
 -	intel_power_domains_init(dev_priv);
 -	intel_irq_init(dev_priv);
 -	intel_init_display_hooks(dev_priv);
 -	intel_init_clock_gating_hooks(dev_priv);
 -	intel_init_audio_hooks(dev_priv);
 -	i915_gem_load_init(&dev_priv->drm);
 -
 -	intel_display_crc_init(&dev_priv->drm);
 -
 -	intel_device_info_dump(dev_priv);
 -
 -	/* Not all pre-production machines fall into this category, only the
 -	 * very first ones. Almost everything should work, except for maybe
 -	 * suspend/resume. And we don't implement workarounds that affect only
 -	 * pre-production machines. */
 -	if (IS_HSW_EARLY_SDV(dev_priv))
 -		DRM_INFO("This is an early pre-production Haswell machine. "
 -			 "It may not be fully functional.\n");
 -
 -	return 0;
 -
 -err_workqueues:
 -	i915_workqueues_cleanup(dev_priv);
 -	return ret;
 -}
 -
 -/**
 - * i915_driver_cleanup_early - cleanup the setup done in i915_driver_init_early()
 - * @dev_priv: device private
 - */
 -static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 -{
 -	i915_gem_load_cleanup(&dev_priv->drm);
 -	i915_workqueues_cleanup(dev_priv);
 -}
 -
 -static int i915_mmio_setup(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	int mmio_bar;
 -	int mmio_size;
 -
 -	mmio_bar = IS_GEN2(dev) ? 1 : 0;
 -	/*
 -	 * Before gen4, the registers and the GTT are behind different BARs.
 -	 * However, from gen4 onwards, the registers and the GTT are shared
 -	 * in the same BAR, so we want to restrict this ioremap from
 -	 * clobbering the GTT which we want ioremap_wc instead. Fortunately,
 -	 * the register BAR remains the same size for all the earlier
 -	 * generations up to Ironlake.
 -	 */
 -	if (INTEL_INFO(dev)->gen < 5)
 -		mmio_size = 512 * 1024;
 -	else
 -		mmio_size = 2 * 1024 * 1024;
 -	dev_priv->regs = pci_iomap(dev->pdev, mmio_bar, mmio_size);
 -	if (dev_priv->regs == NULL) {
 -		DRM_ERROR("failed to map registers\n");
 -
 -		return -EIO;
 -	}
 -
 -	/* Try to make sure MCHBAR is enabled before poking at it */
 -	intel_setup_mchbar(dev);
 -
 -	return 0;
 -}
 -
 -static void i915_mmio_cleanup(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -
 -	intel_teardown_mchbar(dev);
 -	pci_iounmap(dev->pdev, dev_priv->regs);
 -}
 -
 -/**
 - * i915_driver_init_mmio - setup device MMIO
 - * @dev_priv: device private
 - *
 - * Setup minimal device state necessary for MMIO accesses later in the
 - * initialization sequence. The setup here should avoid any other device-wide
 - * side effects or exposing the driver via kernel internal or user space
 - * interfaces.
 - */
 -static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = &dev_priv->drm;
 -	int ret;
 -
 -	if (i915_inject_load_failure())
 -		return -ENODEV;
 -
 -	if (i915_get_bridge_dev(dev))
 -		return -EIO;
 -
 -	ret = i915_mmio_setup(dev);
 -	if (ret < 0)
 -		goto put_bridge;
 -
 -	intel_uncore_init(dev_priv);
 -
 -	return 0;
 -
 -put_bridge:
 -	pci_dev_put(dev_priv->bridge_dev);
 -
 -	return ret;
 -}
 -
 -/**
 - * i915_driver_cleanup_mmio - cleanup the setup done in i915_driver_init_mmio()
 - * @dev_priv: device private
 - */
 -static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = &dev_priv->drm;
 -
 -	intel_uncore_fini(dev_priv);
 -	i915_mmio_cleanup(dev);
 -	pci_dev_put(dev_priv->bridge_dev);
 -}
 -
 -static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 -{
 -	i915.enable_execlists =
 -		intel_sanitize_enable_execlists(dev_priv,
 -						i915.enable_execlists);
 -
 -	/*
 -	 * i915.enable_ppgtt is read-only, so do an early pass to validate the
 -	 * user's requested state against the hardware/driver capabilities.  We
 -	 * do this now so that we can print out any log messages once rather
 -	 * than every time we check intel_enable_ppgtt().
 -	 */
 -	i915.enable_ppgtt =
 -		intel_sanitize_enable_ppgtt(dev_priv, i915.enable_ppgtt);
 -	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915.enable_ppgtt);
 -}
 -
 -/**
 - * i915_driver_init_hw - setup state requiring device access
 - * @dev_priv: device private
 - *
 - * Setup state that requires accessing the device, but doesn't require
 - * exposing the driver via kernel internal or userspace interfaces.
 - */
 -static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = &dev_priv->drm;
 -	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 -	uint32_t aperture_size;
 -	int ret;
 -
 -	if (i915_inject_load_failure())
 -		return -ENODEV;
 -
 -	intel_device_info_runtime_init(dev_priv);
 -
 -	intel_sanitize_options(dev_priv);
 -
 -	ret = i915_ggtt_init_hw(dev);
 -	if (ret)
 -		return ret;
 -
 -	ret = i915_ggtt_enable_hw(dev);
 -	if (ret) {
 -		DRM_ERROR("failed to enable GGTT\n");
 -		goto out_ggtt;
 -	}
 -
 -	/* WARNING: Apparently we must kick fbdev drivers before vgacon,
 -	 * otherwise the vga fbdev driver falls over. */
 -	ret = i915_kick_out_firmware_fb(dev_priv);
 -	if (ret) {
 -		DRM_ERROR("failed to remove conflicting framebuffer drivers\n");
 -		goto out_ggtt;
 -	}
 -
 -	ret = i915_kick_out_vgacon(dev_priv);
 -	if (ret) {
 -		DRM_ERROR("failed to remove conflicting VGA console\n");
 -		goto out_ggtt;
 -	}
 -
 -	pci_set_master(dev->pdev);
 -
 -	/* overlay on gen2 is broken and can't address above 1G */
 -	if (IS_GEN2(dev)) {
 -		ret = dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(30));
 -		if (ret) {
 -			DRM_ERROR("failed to set DMA mask\n");
 -
 -			goto out_ggtt;
 -		}
 -	}
 -
 -
 -	/* 965GM sometimes incorrectly writes to hardware status page (HWS)
 -	 * using 32bit addressing, overwriting memory if HWS is located
 -	 * above 4GB.
 -	 *
 -	 * The documentation also mentions an issue with undefined
 -	 * behaviour if any general state is accessed within a page above 4GB,
 -	 * which also needs to be handled carefully.
 -	 */
 -	if (IS_BROADWATER(dev) || IS_CRESTLINE(dev)) {
 -		ret = dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(32));
 -
 -		if (ret) {
 -			DRM_ERROR("failed to set DMA mask\n");
 -
 -			goto out_ggtt;
 -		}
 -	}
 -
 -	aperture_size = ggtt->mappable_end;
 -
 -	ggtt->mappable =
 -		io_mapping_create_wc(ggtt->mappable_base,
 -				     aperture_size);
 -	if (!ggtt->mappable) {
 -		ret = -EIO;
 -		goto out_ggtt;
 -	}
 -
 -	ggtt->mtrr = arch_phys_wc_add(ggtt->mappable_base,
 -					      aperture_size);
 -
 -	pm_qos_add_request(&dev_priv->pm_qos, PM_QOS_CPU_DMA_LATENCY,
 -			   PM_QOS_DEFAULT_VALUE);
 -
 -	intel_uncore_sanitize(dev_priv);
 -
 -	intel_opregion_setup(dev_priv);
 -
 -	i915_gem_load_init_fences(dev_priv);
 -
 -	/* On the 945G/GM, the chipset reports the MSI capability on the
 -	 * integrated graphics even though the support isn't actually there
 -	 * according to the published specs.  It doesn't appear to function
 -	 * correctly in testing on 945G.
 -	 * This may be a side effect of MSI having been made available for PEG
 -	 * and the registers being closely associated.
 -	 *
 -	 * According to chipset errata, on the 965GM, MSI interrupts may
 -	 * be lost or delayed, but we use them anyways to avoid
 -	 * stuck interrupts on some machines.
 -	 */
 -	if (!IS_I945G(dev) && !IS_I945GM(dev)) {
 -		if (pci_enable_msi(dev->pdev) < 0)
 -			DRM_DEBUG_DRIVER("can't enable MSI");
 -	}
 -
 -	return 0;
 -
 -out_ggtt:
 -	i915_ggtt_cleanup_hw(dev);
 -
 -	return ret;
 -}
 -
 -/**
 - * i915_driver_cleanup_hw - cleanup the setup done in i915_driver_init_hw()
 - * @dev_priv: device private
 - */
 -static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = &dev_priv->drm;
 -	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 -
 -	if (dev->pdev->msi_enabled)
 -		pci_disable_msi(dev->pdev);
 -
 -	pm_qos_remove_request(&dev_priv->pm_qos);
 -	arch_phys_wc_del(ggtt->mtrr);
 -	io_mapping_free(ggtt->mappable);
 -	i915_ggtt_cleanup_hw(dev);
 -}
 -
 -/**
 - * i915_driver_register - register the driver with the rest of the system
 - * @dev_priv: device private
 - *
 - * Perform any steps necessary to make the driver available via kernel
 - * internal or userspace interfaces.
 - */
 -static void i915_driver_register(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = &dev_priv->drm;
 -
 -	i915_gem_shrinker_init(dev_priv);
 -
 -	/*
 -	 * Notify a valid surface after modesetting,
 -	 * when running inside a VM.
 -	 */
 -	if (intel_vgpu_active(dev_priv))
 -		I915_WRITE(vgtif_reg(display_ready), VGT_DRV_DISPLAY_READY);
 -
 -	/* Reveal our presence to userspace */
 -	if (drm_dev_register(dev, 0) == 0) {
 -		i915_debugfs_register(dev_priv);
 -		i915_setup_sysfs(dev);
 -	} else
 -		DRM_ERROR("Failed to register driver for userspace access!\n");
 -
 -	if (INTEL_INFO(dev_priv)->num_pipes) {
 -		/* Must be done after probing outputs */
 -		intel_opregion_register(dev_priv);
 -		acpi_video_register();
 -	}
 -
 -	if (IS_GEN5(dev_priv))
 -		intel_gpu_ips_init(dev_priv);
 -
 -	i915_audio_component_init(dev_priv);
 -
 -	/*
 -	 * Some ports require correctly set-up hpd registers for detection to
 -	 * work properly (leading to ghost connected connector status), e.g. VGA
 -	 * on gm45.  Hence we can only set up the initial fbdev config after hpd
 -	 * irqs are fully enabled. We do it last so that the async config
 -	 * cannot run before the connectors are registered.
 -	 */
 -	intel_fbdev_initial_config_async(dev);
 -}
 -
 -/**
 - * i915_driver_unregister - cleanup the registration done in i915_driver_regiser()
 - * @dev_priv: device private
 - */
 -static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 -{
 -	i915_audio_component_cleanup(dev_priv);
 -
 -	intel_gpu_ips_teardown();
 -	acpi_video_unregister();
 -	intel_opregion_unregister(dev_priv);
 -
 -	i915_teardown_sysfs(&dev_priv->drm);
 -	i915_debugfs_unregister(dev_priv);
 -	drm_dev_unregister(&dev_priv->drm);
 -
 -	i915_gem_shrinker_cleanup(dev_priv);
 -}
 -
 -/**
 - * i915_driver_load - setup chip and create an initial config
 - * @dev: DRM device
 - * @flags: startup flags
 - *
 - * The driver load routine has to do several things:
 - *   - drive output discovery via intel_modeset_init()
 - *   - initialize the memory manager
 - *   - allocate initial config memory
 - *   - setup the DRM framebuffer with the allocated memory
 - */
 -int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 -{
 -	struct drm_i915_private *dev_priv;
 -	int ret;
 -
 -	if (i915.nuclear_pageflip)
 -		driver.driver_features |= DRIVER_ATOMIC;
 -
 -	ret = -ENOMEM;
 -	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
 -	if (dev_priv)
 -		ret = drm_dev_init(&dev_priv->drm, &driver, &pdev->dev);
 -	if (ret) {
 -		dev_printk(KERN_ERR, &pdev->dev,
 -			   "[" DRM_NAME ":%s] allocation failed\n", __func__);
 -		kfree(dev_priv);
 -		return ret;
 -	}
 -
 -	dev_priv->drm.pdev = pdev;
 -	dev_priv->drm.dev_private = dev_priv;
 -
 -	ret = pci_enable_device(pdev);
 -	if (ret)
 -		goto out_free_priv;
 -
 -	pci_set_drvdata(pdev, &dev_priv->drm);
 -
 -	ret = i915_driver_init_early(dev_priv, ent);
 -	if (ret < 0)
 -		goto out_pci_disable;
 -
 -	intel_runtime_pm_get(dev_priv);
 -
 -	ret = i915_driver_init_mmio(dev_priv);
 -	if (ret < 0)
 -		goto out_runtime_pm_put;
 -
 -	ret = i915_driver_init_hw(dev_priv);
 -	if (ret < 0)
 -		goto out_cleanup_mmio;
 -
 -	/*
 -	 * TODO: move the vblank init and parts of modeset init steps into one
 -	 * of the i915_driver_init_/i915_driver_register functions according
 -	 * to the role/effect of the given init step.
 -	 */
 -	if (INTEL_INFO(dev_priv)->num_pipes) {
 -		ret = drm_vblank_init(&dev_priv->drm,
 -				      INTEL_INFO(dev_priv)->num_pipes);
 -		if (ret)
 -			goto out_cleanup_hw;
 -	}
 -
 -	ret = i915_load_modeset_init(&dev_priv->drm);
 -	if (ret < 0)
 -		goto out_cleanup_vblank;
 -
 -	i915_driver_register(dev_priv);
 -
 -	intel_runtime_pm_enable(dev_priv);
 -
 -	intel_runtime_pm_put(dev_priv);
 -
 -	return 0;
 -
 -out_cleanup_vblank:
 -	drm_vblank_cleanup(&dev_priv->drm);
 -out_cleanup_hw:
 -	i915_driver_cleanup_hw(dev_priv);
 -out_cleanup_mmio:
 -	i915_driver_cleanup_mmio(dev_priv);
 -out_runtime_pm_put:
 -	intel_runtime_pm_put(dev_priv);
 -	i915_driver_cleanup_early(dev_priv);
 -out_pci_disable:
 -	pci_disable_device(pdev);
 -out_free_priv:
 -	i915_load_error(dev_priv, "Device initialization failed (%d)\n", ret);
 -	drm_dev_unref(&dev_priv->drm);
 -	return ret;
 -}
 -
 -void i915_driver_unload(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -
 -	intel_fbdev_fini(dev);
 -
 -	if (i915_gem_suspend(dev))
 -		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 -
 -	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
 -
 -	i915_driver_unregister(dev_priv);
 -
 -	drm_vblank_cleanup(dev);
 -
 -	intel_modeset_cleanup(dev);
++			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
++				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
++				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
++				    pch->subsystem_vendor ==
++					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
++				    pch->subsystem_device ==
++					    PCI_SUBDEVICE_ID_QEMU)) {
++				dev_priv->pch_type = intel_virt_detect_pch(dev);
++>>>>>>> 22dea0be50b2 (drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.)
 +			} else
 +				continue;
  
 -	/*
 -	 * free the memory space allocated for the child device
 -	 * config parsed from VBT
 -	 */
 -	if (dev_priv->vbt.child_dev && dev_priv->vbt.child_dev_num) {
 -		kfree(dev_priv->vbt.child_dev);
 -		dev_priv->vbt.child_dev = NULL;
 -		dev_priv->vbt.child_dev_num = 0;
 +			break;
 +		}
  	}
 -	kfree(dev_priv->vbt.sdvo_lvds_vbt_mode);
 -	dev_priv->vbt.sdvo_lvds_vbt_mode = NULL;
 -	kfree(dev_priv->vbt.lfp_lvds_vbt_mode);
 -	dev_priv->vbt.lfp_lvds_vbt_mode = NULL;
 -
 -	vga_switcheroo_unregister_client(dev->pdev);
 -	vga_client_register(dev->pdev, NULL, NULL, NULL);
 -
 -	intel_csr_ucode_fini(dev_priv);
 -
 -	/* Free error state after interrupts are fully disabled. */
 -	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
 -	i915_destroy_error_state(dev);
 -
 -	/* Flush any outstanding unpin_work. */
 -	flush_workqueue(dev_priv->wq);
 -
 -	intel_guc_fini(dev);
 -	i915_gem_fini(dev);
 -	intel_fbc_cleanup_cfb(dev_priv);
 +	if (!pch)
 +		DRM_DEBUG_KMS("No PCH found.\n");
  
 -	intel_power_domains_fini(dev_priv);
 +	pci_dev_put(pch);
 +}
  
 -	i915_driver_cleanup_hw(dev_priv);
 -	i915_driver_cleanup_mmio(dev_priv);
 +bool i915_semaphore_is_enabled(struct drm_device *dev)
 +{
 +	if (INTEL_INFO(dev)->gen < 6)
 +		return false;
  
 -	intel_display_power_put(dev_priv, POWER_DOMAIN_INIT);
 +	if (i915.semaphores >= 0)
 +		return i915.semaphores;
  
 -	i915_driver_cleanup_early(dev_priv);
 -}
 +	/* TODO: make semaphores and Execlists play nicely together */
 +	if (i915.enable_execlists)
 +		return false;
  
 -static int i915_driver_open(struct drm_device *dev, struct drm_file *file)
 -{
 -	int ret;
 +	/* Until we get further testing... */
 +	if (IS_GEN8(dev))
 +		return false;
  
 -	ret = i915_gem_open(dev, file);
 -	if (ret)
 -		return ret;
 +#ifdef CONFIG_INTEL_IOMMU
 +	/* Enable semaphores on SNB when IO remapping is off */
 +	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)
 +		return false;
 +#endif
  
 -	return 0;
 +	return true;
  }
  
 -/**
 - * i915_driver_lastclose - clean up after all DRM clients have exited
 - * @dev: DRM device
 - *
 - * Take care of cleaning up after all DRM clients have exited.  In the
 - * mode setting case, we want to restore the kernel's initial mode (just
 - * in case the last client left us in a bad state).
 - *
 - * Additionally, in the non-mode setting case, we'll tear down the GTT
 - * and DMA structures, since the kernel won't be using them, and clea
 - * up any GEM state.
 - */
 -static void i915_driver_lastclose(struct drm_device *dev)
 +void intel_hpd_cancel_work(struct drm_i915_private *dev_priv)
  {
 -	intel_fbdev_restore_mode(dev);
 -	vga_switcheroo_process_delayed_switch();
 -}
 +	spin_lock_irq(&dev_priv->irq_lock);
  
 -static void i915_driver_preclose(struct drm_device *dev, struct drm_file *file)
 -{
 -	mutex_lock(&dev->struct_mutex);
 -	i915_gem_context_close(dev, file);
 -	i915_gem_release(dev, file);
 -	mutex_unlock(&dev->struct_mutex);
 -}
 +	dev_priv->long_hpd_port_mask = 0;
 +	dev_priv->short_hpd_port_mask = 0;
 +	dev_priv->hpd_event_bits = 0;
  
 -static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
 -{
 -	struct drm_i915_file_private *file_priv = file->driver_priv;
 +	spin_unlock_irq(&dev_priv->irq_lock);
  
 -	kfree(file_priv);
 +	cancel_work_sync(&dev_priv->dig_port_work);
 +	cancel_work_sync(&dev_priv->hotplug_work);
 +	cancel_delayed_work_sync(&dev_priv->hotplug_reenable_work);
  }
  
  static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
diff --cc drivers/gpu/drm/i915/i915_drv.h
index b86c23f96df2,a46b57579da1..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -2415,10 -2884,17 +2416,18 @@@ struct drm_i915_cmd_table 
  #define INTEL_PCH_LPT_LP_DEVICE_ID_TYPE		0x9c00
  #define INTEL_PCH_SPT_DEVICE_ID_TYPE		0xA100
  #define INTEL_PCH_SPT_LP_DEVICE_ID_TYPE		0x9D00
++<<<<<<< HEAD
++=======
+ #define INTEL_PCH_KBP_DEVICE_ID_TYPE		0xA200
+ #define INTEL_PCH_P2X_DEVICE_ID_TYPE		0x7100
+ #define INTEL_PCH_P3X_DEVICE_ID_TYPE		0x7000
+ #define INTEL_PCH_QEMU_DEVICE_ID_TYPE		0x2900 /* qemu q35 has 2918 */
++>>>>>>> 22dea0be50b2 (drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.)
  
  #define INTEL_PCH_TYPE(dev) (__I915__(dev)->pch_type)
+ #define HAS_PCH_KBP(dev) (INTEL_PCH_TYPE(dev) == PCH_KBP)
  #define HAS_PCH_SPT(dev) (INTEL_PCH_TYPE(dev) == PCH_SPT)
  #define HAS_PCH_LPT(dev) (INTEL_PCH_TYPE(dev) == PCH_LPT)
 -#define HAS_PCH_LPT_LP(dev) (__I915__(dev)->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE)
 -#define HAS_PCH_LPT_H(dev) (__I915__(dev)->pch_id == INTEL_PCH_LPT_DEVICE_ID_TYPE)
  #define HAS_PCH_CPT(dev) (INTEL_PCH_TYPE(dev) == PCH_CPT)
  #define HAS_PCH_IBX(dev) (INTEL_PCH_TYPE(dev) == PCH_IBX)
  #define HAS_PCH_NOP(dev) (INTEL_PCH_TYPE(dev) == PCH_NOP)
diff --cc drivers/gpu/drm/i915/i915_irq.c
index b0df8d10482a,1c2aec392412..000000000000
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@@ -2161,6 -2276,168 +2161,171 @@@ static irqreturn_t ironlake_irq_handler
  		POSTING_READ(SDEIER);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* IRQs are synced during runtime_suspend, we don't require a wakeref */
+ 	enable_rpm_wakeref_asserts(dev_priv);
+ 
+ 	return ret;
+ }
+ 
+ static void bxt_hpd_irq_handler(struct drm_i915_private *dev_priv,
+ 				u32 hotplug_trigger,
+ 				const u32 hpd[HPD_NUM_PINS])
+ {
+ 	u32 dig_hotplug_reg, pin_mask = 0, long_mask = 0;
+ 
+ 	dig_hotplug_reg = I915_READ(PCH_PORT_HOTPLUG);
+ 	I915_WRITE(PCH_PORT_HOTPLUG, dig_hotplug_reg);
+ 
+ 	intel_get_hpd_pins(&pin_mask, &long_mask, hotplug_trigger,
+ 			   dig_hotplug_reg, hpd,
+ 			   bxt_port_hotplug_long_detect);
+ 
+ 	intel_hpd_irq_handler(dev_priv, pin_mask, long_mask);
+ }
+ 
+ static irqreturn_t
+ gen8_de_irq_handler(struct drm_i915_private *dev_priv, u32 master_ctl)
+ {
+ 	irqreturn_t ret = IRQ_NONE;
+ 	u32 iir;
+ 	enum pipe pipe;
+ 
+ 	if (master_ctl & GEN8_DE_MISC_IRQ) {
+ 		iir = I915_READ(GEN8_DE_MISC_IIR);
+ 		if (iir) {
+ 			I915_WRITE(GEN8_DE_MISC_IIR, iir);
+ 			ret = IRQ_HANDLED;
+ 			if (iir & GEN8_DE_MISC_GSE)
+ 				intel_opregion_asle_intr(dev_priv);
+ 			else
+ 				DRM_ERROR("Unexpected DE Misc interrupt\n");
+ 		}
+ 		else
+ 			DRM_ERROR("The master control interrupt lied (DE MISC)!\n");
+ 	}
+ 
+ 	if (master_ctl & GEN8_DE_PORT_IRQ) {
+ 		iir = I915_READ(GEN8_DE_PORT_IIR);
+ 		if (iir) {
+ 			u32 tmp_mask;
+ 			bool found = false;
+ 
+ 			I915_WRITE(GEN8_DE_PORT_IIR, iir);
+ 			ret = IRQ_HANDLED;
+ 
+ 			tmp_mask = GEN8_AUX_CHANNEL_A;
+ 			if (INTEL_INFO(dev_priv)->gen >= 9)
+ 				tmp_mask |= GEN9_AUX_CHANNEL_B |
+ 					    GEN9_AUX_CHANNEL_C |
+ 					    GEN9_AUX_CHANNEL_D;
+ 
+ 			if (iir & tmp_mask) {
+ 				dp_aux_irq_handler(dev_priv);
+ 				found = true;
+ 			}
+ 
+ 			if (IS_BROXTON(dev_priv)) {
+ 				tmp_mask = iir & BXT_DE_PORT_HOTPLUG_MASK;
+ 				if (tmp_mask) {
+ 					bxt_hpd_irq_handler(dev_priv, tmp_mask,
+ 							    hpd_bxt);
+ 					found = true;
+ 				}
+ 			} else if (IS_BROADWELL(dev_priv)) {
+ 				tmp_mask = iir & GEN8_PORT_DP_A_HOTPLUG;
+ 				if (tmp_mask) {
+ 					ilk_hpd_irq_handler(dev_priv,
+ 							    tmp_mask, hpd_bdw);
+ 					found = true;
+ 				}
+ 			}
+ 
+ 			if (IS_BROXTON(dev_priv) && (iir & BXT_DE_PORT_GMBUS)) {
+ 				gmbus_irq_handler(dev_priv);
+ 				found = true;
+ 			}
+ 
+ 			if (!found)
+ 				DRM_ERROR("Unexpected DE Port interrupt\n");
+ 		}
+ 		else
+ 			DRM_ERROR("The master control interrupt lied (DE PORT)!\n");
+ 	}
+ 
+ 	for_each_pipe(dev_priv, pipe) {
+ 		u32 flip_done, fault_errors;
+ 
+ 		if (!(master_ctl & GEN8_DE_PIPE_IRQ(pipe)))
+ 			continue;
+ 
+ 		iir = I915_READ(GEN8_DE_PIPE_IIR(pipe));
+ 		if (!iir) {
+ 			DRM_ERROR("The master control interrupt lied (DE PIPE)!\n");
+ 			continue;
+ 		}
+ 
+ 		ret = IRQ_HANDLED;
+ 		I915_WRITE(GEN8_DE_PIPE_IIR(pipe), iir);
+ 
+ 		if (iir & GEN8_PIPE_VBLANK &&
+ 		    intel_pipe_handle_vblank(dev_priv, pipe))
+ 			intel_check_page_flip(dev_priv, pipe);
+ 
+ 		flip_done = iir;
+ 		if (INTEL_INFO(dev_priv)->gen >= 9)
+ 			flip_done &= GEN9_PIPE_PLANE1_FLIP_DONE;
+ 		else
+ 			flip_done &= GEN8_PIPE_PRIMARY_FLIP_DONE;
+ 
+ 		if (flip_done)
+ 			intel_finish_page_flip_cs(dev_priv, pipe);
+ 
+ 		if (iir & GEN8_PIPE_CDCLK_CRC_DONE)
+ 			hsw_pipe_crc_irq_handler(dev_priv, pipe);
+ 
+ 		if (iir & GEN8_PIPE_FIFO_UNDERRUN)
+ 			intel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);
+ 
+ 		fault_errors = iir;
+ 		if (INTEL_INFO(dev_priv)->gen >= 9)
+ 			fault_errors &= GEN9_DE_PIPE_IRQ_FAULT_ERRORS;
+ 		else
+ 			fault_errors &= GEN8_DE_PIPE_IRQ_FAULT_ERRORS;
+ 
+ 		if (fault_errors)
+ 			DRM_ERROR("Fault errors on pipe %c\n: 0x%08x",
+ 				  pipe_name(pipe),
+ 				  fault_errors);
+ 	}
+ 
+ 	if (HAS_PCH_SPLIT(dev_priv) && !HAS_PCH_NOP(dev_priv) &&
+ 	    master_ctl & GEN8_DE_PCH_IRQ) {
+ 		/*
+ 		 * FIXME(BDW): Assume for now that the new interrupt handling
+ 		 * scheme also closed the SDE interrupt handling race we've seen
+ 		 * on older pch-split platforms. But this needs testing.
+ 		 */
+ 		iir = I915_READ(SDEIIR);
+ 		if (iir) {
+ 			I915_WRITE(SDEIIR, iir);
+ 			ret = IRQ_HANDLED;
+ 
+ 			if (HAS_PCH_SPT(dev_priv) || HAS_PCH_KBP(dev_priv))
+ 				spt_irq_handler(dev_priv, iir);
+ 			else
+ 				cpt_irq_handler(dev_priv, iir);
+ 		} else {
+ 			/*
+ 			 * Like on previous PCH there seems to be something
+ 			 * fishy going on with forwarding PCH interrupts.
+ 			 */
+ 			DRM_DEBUG_DRIVER("The master control interrupt lied (SDE)!\n");
+ 		}
+ 	}
+ 
++>>>>>>> 22dea0be50b2 (drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.)
  	return ret;
  }
  
@@@ -4287,7 -4586,12 +4452,16 @@@ void intel_irq_init(struct drm_i915_pri
  		dev->driver->irq_uninstall = gen8_irq_uninstall;
  		dev->driver->enable_vblank = gen8_enable_vblank;
  		dev->driver->disable_vblank = gen8_disable_vblank;
++<<<<<<< HEAD
 +		dev_priv->display.hpd_irq_setup = ibx_hpd_irq_setup;
++=======
+ 		if (IS_BROXTON(dev))
+ 			dev_priv->display.hpd_irq_setup = bxt_hpd_irq_setup;
+ 		else if (HAS_PCH_SPT(dev) || HAS_PCH_KBP(dev))
+ 			dev_priv->display.hpd_irq_setup = spt_hpd_irq_setup;
+ 		else
+ 			dev_priv->display.hpd_irq_setup = ilk_hpd_irq_setup;
++>>>>>>> 22dea0be50b2 (drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.)
  	} else if (HAS_PCH_SPLIT(dev)) {
  		dev->driver->irq_handler = ironlake_irq_handler;
  		dev->driver->irq_preinstall = ironlake_irq_reset;
diff --cc drivers/gpu/drm/i915/intel_panel.c
index 2bf92cba4a55,96c65d77e886..000000000000
--- a/drivers/gpu/drm/i915/intel_panel.c
+++ b/drivers/gpu/drm/i915/intel_panel.c
@@@ -1354,40 -1709,75 +1354,98 @@@ void intel_panel_destroy_backlight(stru
  }
  
  /* Set up chip specific backlight functions */
 -static void
 -intel_panel_init_backlight_funcs(struct intel_panel *panel)
 -{
 -	struct intel_connector *connector =
 -		container_of(panel, struct intel_connector, panel);
 -	struct drm_i915_private *dev_priv = to_i915(connector->base.dev);
 -
 +void intel_panel_init_backlight_funcs(struct drm_device *dev)
 +{
 +	struct drm_i915_private *dev_priv = dev->dev_private;
 +
++<<<<<<< HEAD
 +	if (IS_BROADWELL(dev) || (INTEL_INFO(dev)->gen >= 9)) {
 +		dev_priv->display.setup_backlight = bdw_setup_backlight;
 +		dev_priv->display.enable_backlight = bdw_enable_backlight;
 +		dev_priv->display.disable_backlight = pch_disable_backlight;
 +		dev_priv->display.set_backlight = bdw_set_backlight;
 +		dev_priv->display.get_backlight = bdw_get_backlight;
 +	} else if (HAS_PCH_SPLIT(dev)) {
 +		dev_priv->display.setup_backlight = pch_setup_backlight;
 +		dev_priv->display.enable_backlight = pch_enable_backlight;
 +		dev_priv->display.disable_backlight = pch_disable_backlight;
 +		dev_priv->display.set_backlight = pch_set_backlight;
 +		dev_priv->display.get_backlight = pch_get_backlight;
 +	} else if (IS_VALLEYVIEW(dev)) {
 +		dev_priv->display.setup_backlight = vlv_setup_backlight;
 +		dev_priv->display.enable_backlight = vlv_enable_backlight;
 +		dev_priv->display.disable_backlight = vlv_disable_backlight;
 +		dev_priv->display.set_backlight = vlv_set_backlight;
 +		dev_priv->display.get_backlight = vlv_get_backlight;
 +	} else if (IS_GEN4(dev)) {
 +		dev_priv->display.setup_backlight = i965_setup_backlight;
 +		dev_priv->display.enable_backlight = i965_enable_backlight;
 +		dev_priv->display.disable_backlight = i965_disable_backlight;
 +		dev_priv->display.set_backlight = i9xx_set_backlight;
 +		dev_priv->display.get_backlight = i9xx_get_backlight;
++=======
+ 	if (connector->base.connector_type == DRM_MODE_CONNECTOR_eDP &&
+ 	    intel_dp_aux_init_backlight_funcs(connector) == 0)
+ 		return;
+ 
+ 	if (connector->base.connector_type == DRM_MODE_CONNECTOR_DSI &&
+ 	    intel_dsi_dcs_init_backlight_funcs(connector) == 0)
+ 		return;
+ 
+ 	if (IS_BROXTON(dev_priv)) {
+ 		panel->backlight.setup = bxt_setup_backlight;
+ 		panel->backlight.enable = bxt_enable_backlight;
+ 		panel->backlight.disable = bxt_disable_backlight;
+ 		panel->backlight.set = bxt_set_backlight;
+ 		panel->backlight.get = bxt_get_backlight;
+ 		panel->backlight.hz_to_pwm = bxt_hz_to_pwm;
+ 	} else if (HAS_PCH_LPT(dev_priv) || HAS_PCH_SPT(dev_priv) ||
+ 		   HAS_PCH_KBP(dev_priv)) {
+ 		panel->backlight.setup = lpt_setup_backlight;
+ 		panel->backlight.enable = lpt_enable_backlight;
+ 		panel->backlight.disable = lpt_disable_backlight;
+ 		panel->backlight.set = lpt_set_backlight;
+ 		panel->backlight.get = lpt_get_backlight;
+ 		if (HAS_PCH_LPT(dev_priv))
+ 			panel->backlight.hz_to_pwm = lpt_hz_to_pwm;
+ 		else
+ 			panel->backlight.hz_to_pwm = spt_hz_to_pwm;
+ 	} else if (HAS_PCH_SPLIT(dev_priv)) {
+ 		panel->backlight.setup = pch_setup_backlight;
+ 		panel->backlight.enable = pch_enable_backlight;
+ 		panel->backlight.disable = pch_disable_backlight;
+ 		panel->backlight.set = pch_set_backlight;
+ 		panel->backlight.get = pch_get_backlight;
+ 		panel->backlight.hz_to_pwm = pch_hz_to_pwm;
+ 	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {
+ 		if (connector->base.connector_type == DRM_MODE_CONNECTOR_DSI) {
+ 			panel->backlight.setup = pwm_setup_backlight;
+ 			panel->backlight.enable = pwm_enable_backlight;
+ 			panel->backlight.disable = pwm_disable_backlight;
+ 			panel->backlight.set = pwm_set_backlight;
+ 			panel->backlight.get = pwm_get_backlight;
+ 		} else {
+ 			panel->backlight.setup = vlv_setup_backlight;
+ 			panel->backlight.enable = vlv_enable_backlight;
+ 			panel->backlight.disable = vlv_disable_backlight;
+ 			panel->backlight.set = vlv_set_backlight;
+ 			panel->backlight.get = vlv_get_backlight;
+ 			panel->backlight.hz_to_pwm = vlv_hz_to_pwm;
+ 		}
+ 	} else if (IS_GEN4(dev_priv)) {
+ 		panel->backlight.setup = i965_setup_backlight;
+ 		panel->backlight.enable = i965_enable_backlight;
+ 		panel->backlight.disable = i965_disable_backlight;
+ 		panel->backlight.set = i9xx_set_backlight;
+ 		panel->backlight.get = i9xx_get_backlight;
+ 		panel->backlight.hz_to_pwm = i965_hz_to_pwm;
++>>>>>>> 22dea0be50b2 (drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.)
  	} else {
 -		panel->backlight.setup = i9xx_setup_backlight;
 -		panel->backlight.enable = i9xx_enable_backlight;
 -		panel->backlight.disable = i9xx_disable_backlight;
 -		panel->backlight.set = i9xx_set_backlight;
 -		panel->backlight.get = i9xx_get_backlight;
 -		panel->backlight.hz_to_pwm = i9xx_hz_to_pwm;
 +		dev_priv->display.setup_backlight = i9xx_setup_backlight;
 +		dev_priv->display.enable_backlight = i9xx_enable_backlight;
 +		dev_priv->display.disable_backlight = i9xx_disable_backlight;
 +		dev_priv->display.set_backlight = i9xx_set_backlight;
 +		dev_priv->display.get_backlight = i9xx_get_backlight;
  	}
  }
  
* Unmerged path drivers/gpu/drm/i915/i915_drv.c
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
* Unmerged path drivers/gpu/drm/i915/i915_irq.c
* Unmerged path drivers/gpu/drm/i915/intel_panel.c
