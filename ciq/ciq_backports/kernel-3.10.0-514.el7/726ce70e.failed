net: Move napi polling code out of net_rx_action

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] Move napi polling code out of net_rx_action (Ivan Vecera) [1334372]
Rebuild_FUZZ: 94.51%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 726ce70e9e4050409243f3a1d735dc86bc6e6e57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/726ce70e.failed

This patch creates a new function napi_poll and moves the napi
polling code from net_rx_action into it.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 726ce70e9e4050409243f3a1d735dc86bc6e6e57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index ce5758e98847,493ae8ee569f..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4475,78 -4615,41 +4528,87 @@@ static void net_rx_action(struct softir
  	struct softnet_data *sd = this_cpu_ptr(&softnet_data);
  	unsigned long time_limit = jiffies + 2;
  	int budget = netdev_budget;
++<<<<<<< HEAD
 +	void *have;
++=======
+ 	LIST_HEAD(list);
+ 	LIST_HEAD(repoll);
++>>>>>>> 726ce70e9e40 (net: Move napi polling code out of net_rx_action)
  
  	local_irq_disable();
 -	list_splice_init(&sd->poll_list, &list);
 -	local_irq_enable();
  
 -	while (!list_empty(&list)) {
 +	while (!list_empty(&sd->poll_list)) {
  		struct napi_struct *n;
- 		int work, weight;
  
 -		/* If softirq window is exhausted then punt.
 +		/* If softirq window is exhuasted then punt.
  		 * Allow this to run for 2 jiffies since which will allow
  		 * an average latency of 1.5/HZ.
  		 */
  		if (unlikely(budget <= 0 || time_after_eq(jiffies, time_limit)))
  			goto softnet_break;
  
 +		local_irq_enable();
 +
++<<<<<<< HEAD
 +		/* Even though interrupts have been re-enabled, this
 +		 * access is safe because interrupts can only add new
 +		 * entries to the tail of this list, and only ->poll()
 +		 * calls can remove this head entry from the list.
 +		 */
 +		n = list_first_entry(&sd->poll_list, struct napi_struct, poll_list);
 +
 +		have = netpoll_poll_lock(n);
 +
 +		weight = n->weight;
 +
 +		/* This NAPI_STATE_SCHED test is for avoiding a race
 +		 * with netpoll's poll_napi().  Only the entity which
 +		 * obtains the lock and sees NAPI_STATE_SCHED set will
 +		 * actually make the ->poll() call.  Therefore we avoid
 +		 * accidentally calling ->poll() when NAPI is not scheduled.
 +		 */
 +		work = 0;
 +		if (test_bit(NAPI_STATE_SCHED, &n->state)) {
 +			work = n->poll(n, weight);
 +			trace_napi_poll(n);
 +		}
 +
 +		WARN_ON_ONCE(work > weight);
 +
 +		budget -= work;
 +
 +		local_irq_disable();
  
 +		/* Drivers must not modify the NAPI state if they
 +		 * consume the entire weight.  In such cases this code
 +		 * still "owns" the NAPI instance and therefore can
 +		 * move the instance around on the list at-will.
 +		 */
 +		if (unlikely(work == weight)) {
 +			if (unlikely(napi_disable_pending(n))) {
 +				local_irq_enable();
 +				napi_complete(n);
 +				local_irq_disable();
 +			} else {
 +				if (n->gro_list) {
 +					/* flush too old packets
 +					 * If HZ < 1000, flush all packets.
 +					 */
 +					local_irq_enable();
 +					napi_gro_flush(n, HZ >= 1000);
 +					local_irq_disable();
 +				}
 +				list_move_tail(&n->poll_list, &sd->poll_list);
 +			}
 +		}
 +
 +		netpoll_poll_unlock(have);
++=======
+ 		n = list_first_entry(&list, struct napi_struct, poll_list);
+ 		budget -= napi_poll(n, &repoll);
++>>>>>>> 726ce70e9e40 (net: Move napi polling code out of net_rx_action)
  	}
 -
 -	if (!sd_has_rps_ipi_waiting(sd) &&
 -	    list_empty(&list) &&
 -	    list_empty(&repoll))
 -		return;
  out:
 -	local_irq_disable();
 -
 -	list_splice_tail_init(&sd->poll_list, &list);
 -	list_splice_tail(&repoll, &list);
 -	list_splice(&list, &sd->poll_list);
 -	if (!list_empty(&sd->poll_list))
 -		__raise_softirq_irqoff(NET_RX_SOFTIRQ);
 -
  	net_rps_action_and_irq_enable(sd);
  
  	return;
* Unmerged path net/core/dev.c
