md: Export and rename kick_rdev_from_array

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [md] Export and rename kick_rdev_from_array (Jes Sorensen) [1250578 1265947 1273343 1299140 1307091 1312828 1320563 1340839]
Rebuild_FUZZ: 95.00%
commit-author Goldwyn Rodrigues <rgoldwyn@suse.de>
commit fb56dfef4e31f214cfbfa0eb8a1949591c20b118
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fb56dfef.failed

This export is required for clustering module in order to
co-ordinate remove/readd a rdev from all nodes.

	Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit fb56dfef4e31f214cfbfa0eb8a1949591c20b118)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
#	drivers/md/md.h
diff --cc drivers/md/md.c
index 5e267aa26783,bc1e43014292..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -2505,7 -2475,9 +2506,13 @@@ state_store(struct md_rdev *rdev, cons
  			err = -EBUSY;
  		else {
  			struct mddev *mddev = rdev->mddev;
++<<<<<<< HEAD
 +			kick_rdev_from_array(rdev);
++=======
+ 			if (mddev_is_clustered(mddev))
+ 				md_cluster_ops->metadata_update_start(mddev);
+ 			md_kick_rdev_from_array(rdev);
++>>>>>>> fb56dfef4e31 (md: Export and rename kick_rdev_from_array)
  			if (mddev->pers)
  				md_update_sb(mddev, 1);
  			md_new_event(mddev);
@@@ -3182,18 -3150,27 +3189,30 @@@ static void analyze_sbs(struct mddev *m
  			       "md: %s: %s: only %d devices permitted\n",
  			       mdname(mddev), bdevname(rdev->bdev, b),
  			       mddev->max_disks);
- 			kick_rdev_from_array(rdev);
+ 			md_kick_rdev_from_array(rdev);
  			continue;
  		}
 -		if (rdev != freshest) {
 +		if (rdev != freshest)
  			if (super_types[mddev->major_version].
  			    validate_super(mddev, rdev)) {
  				printk(KERN_WARNING "md: kicking non-fresh %s"
  					" from array!\n",
  					bdevname(rdev->bdev,b));
- 				kick_rdev_from_array(rdev);
+ 				md_kick_rdev_from_array(rdev);
  				continue;
  			}
++<<<<<<< HEAD
++=======
+ 			/* No device should have a Candidate flag
+ 			 * when reading devices
+ 			 */
+ 			if (test_bit(Candidate, &rdev->flags)) {
+ 				pr_info("md: kicking Cluster Candidate %s from array!\n",
+ 					bdevname(rdev->bdev, b));
+ 				md_kick_rdev_from_array(rdev);
+ 			}
+ 		}
++>>>>>>> fb56dfef4e31 (md: Export and rename kick_rdev_from_array)
  		if (mddev->level == LEVEL_MULTIPATH) {
  			rdev->desc_nr = i++;
  			rdev->raid_disk = rdev->desc_nr;
diff --cc drivers/md/md.h
index f8d82442ce8b,d98c0d764d8f..000000000000
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@@ -654,7 -669,9 +654,13 @@@ extern struct bio *bio_alloc_mddev(gfp_
  				   struct mddev *mddev);
  
  extern void md_unplug(struct blk_plug_cb *cb, bool from_schedule);
++<<<<<<< HEAD
 +struct md_rdev *md_find_rdev_nr_rcu(struct mddev *mddev, int nr);
++=======
+ extern void md_reload_sb(struct mddev *mddev);
+ extern void md_update_sb(struct mddev *mddev, int force);
+ extern void md_kick_rdev_from_array(struct md_rdev * rdev);
++>>>>>>> fb56dfef4e31 (md: Export and rename kick_rdev_from_array)
  static inline int mddev_check_plugged(struct mddev *mddev)
  {
  	return !!blk_check_plugged(md_unplug, mddev,
* Unmerged path drivers/md/md.c
* Unmerged path drivers/md/md.h
