net: create sysfs symlinks for neighbour devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] create sysfs symlinks for neighbour devices (Ivan Vecera) [1268334]
Rebuild_FUZZ: 94.51%
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 5831d66e8097aedfa3bc35941cf265ada2352317
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5831d66e.failed

Also, remove the same functionality from bonding - it will be already done
for any device that links to its lower/upper neighbour.

The links will be created for dev's kobject, and will look like
lower_eth0 for lower device eth0 and upper_bridge0 for upper device
bridge0.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: "David S. Miller" <davem@davemloft.net>
CC: Eric Dumazet <edumazet@google.com>
CC: Jiri Pirko <jiri@resnulli.us>
CC: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5831d66e8097aedfa3bc35941cf265ada2352317)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_sysfs.c
#	include/net/bonding.h
#	net/core/dev.c
diff --cc drivers/net/bonding/bond_main.c
index dd9219794eca,d5c3153226b7..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1622,15 -1610,13 +1622,24 @@@ int bond_enslave(struct net_device *bon
  	}
  #endif
  
++<<<<<<< HEAD
 +	res = bond_create_slave_symlinks(bond_dev, slave_dev);
 +	if (res)
 +		goto err_detach;
++=======
+ 	read_unlock(&bond->lock);
++>>>>>>> 5831d66e8097 (net: create sysfs symlinks for neighbour devices)
  
  	res = netdev_rx_handler_register(slave_dev, bond_handle_frame,
  					 new_slave);
  	if (res) {
++<<<<<<< HEAD
 +		netdev_dbg(bond_dev, "Error %d calling netdev_rx_handler_register\n", res);
 +		goto err_dest_symlinks;
++=======
+ 		pr_debug("Error %d calling netdev_rx_handler_register\n", res);
+ 		goto err_detach;
++>>>>>>> 5831d66e8097 (net: create sysfs symlinks for neighbour devices)
  	}
  
  	res = bond_master_upper_dev_link(bond_dev, slave_dev, new_slave);
@@@ -1675,11 -1638,8 +1684,8 @@@ err_upper_unlink
  err_unregister:
  	netdev_rx_handler_unregister(slave_dev);
  
- err_dest_symlinks:
- 	bond_destroy_slave_symlinks(bond_dev, slave_dev);
- 
  err_detach:
 -	if (!USES_PRIMARY(bond->params.mode))
 +	if (!bond_uses_primary(bond))
  		bond_hw_addr_flush(bond_dev, slave_dev);
  
  	vlan_vids_del_by_dev(slave_dev, bond_dev);
@@@ -1845,26 -1831,18 +1851,24 @@@ static int __bond_release_one(struct ne
  	bond_compute_features(bond);
  	if (!(bond_dev->features & NETIF_F_VLAN_CHALLENGED) &&
  	    (old_features & NETIF_F_VLAN_CHALLENGED))
 -		pr_info("%s: last VLAN challenged slave %s left bond %s. VLAN blocking is removed\n",
 -			bond_dev->name, slave_dev->name, bond_dev->name);
 +		netdev_info(bond_dev, "last VLAN challenged slave %s left bond %s - VLAN blocking is removed\n",
 +			    slave_dev->name, bond_dev->name);
  
  	/* must do this from outside any spinlocks */
- 	bond_destroy_slave_symlinks(bond_dev, slave_dev);
- 
  	vlan_vids_del_by_dev(slave_dev, bond_dev);
  
 -	/* If the mode USES_PRIMARY, then this cases was handled above by
 +	/* If the mode uses primary, then this case was handled above by
  	 * bond_change_active_slave(..., NULL)
  	 */
 -	if (!USES_PRIMARY(bond->params.mode)) {
 -		/* unset promiscuity level from slave */
 -		if (bond_dev->flags & IFF_PROMISC)
 +	if (!bond_uses_primary(bond)) {
 +		/* unset promiscuity level from slave
 +		 * NOTE: The NETDEV_CHANGEADDR call above may change the value
 +		 * of the IFF_PROMISC flag in the bond_dev, but we need the
 +		 * value of that flag before that change, as that was the value
 +		 * when this slave was attached, so we cache at the start of the
 +		 * function and use it here. Same goes for ALLMULTI below
 +		 */
 +		if (old_flags & IFF_PROMISC)
  			dev_set_promiscuity(slave_dev, -1);
  
  		/* unset allmulti level from slave */
diff --cc drivers/net/bonding/bond_sysfs.c
index 9fb1b6977ea8,e06c644470b1..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -163,60 -168,9 +163,66 @@@ static const struct class_attribute cla
  	.namespace = bonding_namespace,
  };
  
++<<<<<<< HEAD
 +int bond_create_slave_symlinks(struct net_device *master,
 +			       struct net_device *slave)
 +{
 +	char linkname[IFNAMSIZ+7];
 +	int ret = 0;
 +
 +	/* first, create a link from the slave back to the master */
 +	ret = sysfs_create_link(&(slave->dev.kobj), &(master->dev.kobj),
 +				"master");
 +	if (ret)
 +		return ret;
 +	/* next, create a link from the master to the slave */
 +	sprintf(linkname, "slave_%s", slave->name);
 +	ret = sysfs_create_link(&(master->dev.kobj), &(slave->dev.kobj),
 +				linkname);
 +
 +	/* free the master link created earlier in case of error */
 +	if (ret)
 +		sysfs_remove_link(&(slave->dev.kobj), "master");
 +
 +	return ret;
 +
 +}
 +
 +void bond_destroy_slave_symlinks(struct net_device *master,
 +				 struct net_device *slave)
 +{
 +	char linkname[IFNAMSIZ+7];
 +
 +	sysfs_remove_link(&(slave->dev.kobj), "master");
 +	sprintf(linkname, "slave_%s", slave->name);
 +	sysfs_remove_link(&(master->dev.kobj), linkname);
 +}
 +
 +/* Generic "store" method for bonding sysfs option setting */
 +static ssize_t bonding_sysfs_store_option(struct device *d,
 +					  struct device_attribute *attr,
 +					  const char *buffer, size_t count)
 +{
 +	struct bonding *bond = to_bond(d);
 +	const struct bond_option *opt;
 +	int ret;
 +
 +	opt = bond_opt_get_by_name(attr->attr.name);
 +	if (WARN_ON(!opt))
 +		return -ENOENT;
 +	ret = bond_opt_tryset_rtnl(bond, opt->id, (char *)buffer);
 +	if (!ret)
 +		ret = count;
 +
 +	return ret;
 +}
 +
 +/* Show the slaves in the current bond. */
++=======
+ /*
+  * Show the slaves in the current bond.
+  */
++>>>>>>> 5831d66e8097 (net: create sysfs symlinks for neighbour devices)
  static ssize_t bonding_show_slaves(struct device *d,
  				   struct device_attribute *attr, char *buf)
  {
diff --cc include/net/bonding.h
index 8c9030b1a51e,5b71601666cd..000000000000
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@@ -567,14 -436,13 +567,17 @@@ int bond_create(struct net *net, const 
  int bond_create_sysfs(struct bond_net *net);
  void bond_destroy_sysfs(struct bond_net *net);
  void bond_prepare_sysfs_group(struct bonding *bond);
++<<<<<<< HEAD:include/net/bonding.h
 +int bond_create_slave_symlinks(struct net_device *master, struct net_device *slave);
 +void bond_destroy_slave_symlinks(struct net_device *master, struct net_device *slave);
 +int bond_sysfs_slave_add(struct slave *slave);
 +void bond_sysfs_slave_del(struct slave *slave);
++=======
++>>>>>>> 5831d66e8097 (net: create sysfs symlinks for neighbour devices):drivers/net/bonding/bonding.h
  int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev);
  int bond_release(struct net_device *bond_dev, struct net_device *slave_dev);
 -void bond_mii_monitor(struct work_struct *);
 -void bond_loadbalance_arp_mon(struct work_struct *);
 -void bond_activebackup_arp_mon(struct work_struct *);
 -void bond_set_mode_ops(struct bonding *bond, int mode);
 -int bond_parse_parm(const char *mode_arg, const struct bond_parm_tbl *tbl);
 +u32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb);
 +int bond_set_carrier(struct bonding *bond);
  void bond_select_active_slave(struct bonding *bond);
  void bond_change_active_slave(struct bonding *bond, struct slave *new_active);
  void bond_create_debugfs(void);
diff --cc net/core/dev.c
index 004e3f31d664,25ab6fe80da2..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4650,10 -4578,203 +4650,204 @@@ struct net_device *netdev_master_upper_
  }
  EXPORT_SYMBOL(netdev_master_upper_dev_get_rcu);
  
++<<<<<<< HEAD
++=======
+ static int __netdev_adjacent_dev_insert(struct net_device *dev,
+ 					struct net_device *adj_dev,
+ 					struct list_head *dev_list,
+ 					void *private, bool master)
+ {
+ 	struct netdev_adjacent *adj;
+ 	char linkname[IFNAMSIZ+7];
+ 	int ret;
+ 
+ 	adj = __netdev_find_adj(dev, adj_dev, dev_list);
+ 
+ 	if (adj) {
+ 		adj->ref_nr++;
+ 		return 0;
+ 	}
+ 
+ 	adj = kmalloc(sizeof(*adj), GFP_KERNEL);
+ 	if (!adj)
+ 		return -ENOMEM;
+ 
+ 	adj->dev = adj_dev;
+ 	adj->master = master;
+ 	adj->ref_nr = 1;
+ 	adj->private = private;
+ 	dev_hold(adj_dev);
+ 
+ 	pr_debug("dev_hold for %s, because of link added from %s to %s\n",
+ 		 adj_dev->name, dev->name, adj_dev->name);
+ 
+ 	if (dev_list == &dev->adj_list.lower) {
+ 		sprintf(linkname, "lower_%s", adj_dev->name);
+ 		ret = sysfs_create_link(&(dev->dev.kobj),
+ 					&(adj_dev->dev.kobj), linkname);
+ 		if (ret)
+ 			goto free_adj;
+ 	} else if (dev_list == &dev->adj_list.upper) {
+ 		sprintf(linkname, "upper_%s", adj_dev->name);
+ 		ret = sysfs_create_link(&(dev->dev.kobj),
+ 					&(adj_dev->dev.kobj), linkname);
+ 		if (ret)
+ 			goto free_adj;
+ 	}
+ 
+ 	/* Ensure that master link is always the first item in list. */
+ 	if (master) {
+ 		ret = sysfs_create_link(&(dev->dev.kobj),
+ 					&(adj_dev->dev.kobj), "master");
+ 		if (ret)
+ 			goto remove_symlinks;
+ 
+ 		list_add_rcu(&adj->list, dev_list);
+ 	} else {
+ 		list_add_tail_rcu(&adj->list, dev_list);
+ 	}
+ 
+ 	return 0;
+ 
+ remove_symlinks:
+ 	if (dev_list == &dev->adj_list.lower) {
+ 		sprintf(linkname, "lower_%s", adj_dev->name);
+ 		sysfs_remove_link(&(dev->dev.kobj), linkname);
+ 	} else if (dev_list == &dev->adj_list.upper) {
+ 		sprintf(linkname, "upper_%s", adj_dev->name);
+ 		sysfs_remove_link(&(dev->dev.kobj), linkname);
+ 	}
+ 
+ free_adj:
+ 	kfree(adj);
+ 
+ 	return ret;
+ }
+ 
+ void __netdev_adjacent_dev_remove(struct net_device *dev,
+ 				  struct net_device *adj_dev,
+ 				  struct list_head *dev_list)
+ {
+ 	struct netdev_adjacent *adj;
+ 	char linkname[IFNAMSIZ+7];
+ 
+ 	adj = __netdev_find_adj(dev, adj_dev, dev_list);
+ 
+ 	if (!adj) {
+ 		pr_err("tried to remove device %s from %s\n",
+ 		       dev->name, adj_dev->name);
+ 		BUG();
+ 	}
+ 
+ 	if (adj->ref_nr > 1) {
+ 		pr_debug("%s to %s ref_nr-- = %d\n", dev->name, adj_dev->name,
+ 			 adj->ref_nr-1);
+ 		adj->ref_nr--;
+ 		return;
+ 	}
+ 
+ 	if (adj->master)
+ 		sysfs_remove_link(&(dev->dev.kobj), "master");
+ 
+ 	if (dev_list == &dev->adj_list.lower) {
+ 		sprintf(linkname, "lower_%s", adj_dev->name);
+ 		sysfs_remove_link(&(dev->dev.kobj), linkname);
+ 	} else if (dev_list == &dev->adj_list.upper) {
+ 		sprintf(linkname, "upper_%s", adj_dev->name);
+ 		sysfs_remove_link(&(dev->dev.kobj), linkname);
+ 	}
+ 
+ 	list_del_rcu(&adj->list);
+ 	pr_debug("dev_put for %s, because link removed from %s to %s\n",
+ 		 adj_dev->name, dev->name, adj_dev->name);
+ 	dev_put(adj_dev);
+ 	kfree_rcu(adj, rcu);
+ }
+ 
+ int __netdev_adjacent_dev_link_lists(struct net_device *dev,
+ 				     struct net_device *upper_dev,
+ 				     struct list_head *up_list,
+ 				     struct list_head *down_list,
+ 				     void *private, bool master)
+ {
+ 	int ret;
+ 
+ 	ret = __netdev_adjacent_dev_insert(dev, upper_dev, up_list, private,
+ 					   master);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = __netdev_adjacent_dev_insert(upper_dev, dev, down_list, private,
+ 					   false);
+ 	if (ret) {
+ 		__netdev_adjacent_dev_remove(dev, upper_dev, up_list);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int __netdev_adjacent_dev_link(struct net_device *dev,
+ 			       struct net_device *upper_dev)
+ {
+ 	return __netdev_adjacent_dev_link_lists(dev, upper_dev,
+ 						&dev->all_adj_list.upper,
+ 						&upper_dev->all_adj_list.lower,
+ 						NULL, false);
+ }
+ 
+ void __netdev_adjacent_dev_unlink_lists(struct net_device *dev,
+ 					struct net_device *upper_dev,
+ 					struct list_head *up_list,
+ 					struct list_head *down_list)
+ {
+ 	__netdev_adjacent_dev_remove(dev, upper_dev, up_list);
+ 	__netdev_adjacent_dev_remove(upper_dev, dev, down_list);
+ }
+ 
+ void __netdev_adjacent_dev_unlink(struct net_device *dev,
+ 				  struct net_device *upper_dev)
+ {
+ 	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,
+ 					   &dev->all_adj_list.upper,
+ 					   &upper_dev->all_adj_list.lower);
+ }
+ 
+ int __netdev_adjacent_dev_link_neighbour(struct net_device *dev,
+ 					 struct net_device *upper_dev,
+ 					 void *private, bool master)
+ {
+ 	int ret = __netdev_adjacent_dev_link(dev, upper_dev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = __netdev_adjacent_dev_link_lists(dev, upper_dev,
+ 					       &dev->adj_list.upper,
+ 					       &upper_dev->adj_list.lower,
+ 					       private, master);
+ 	if (ret) {
+ 		__netdev_adjacent_dev_unlink(dev, upper_dev);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
+ 					    struct net_device *upper_dev)
+ {
+ 	__netdev_adjacent_dev_unlink(dev, upper_dev);
+ 	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,
+ 					   &dev->adj_list.upper,
+ 					   &upper_dev->adj_list.lower);
+ }
+ 
++>>>>>>> 5831d66e8097 (net: create sysfs symlinks for neighbour devices)
  static int __netdev_upper_dev_link(struct net_device *dev,
 -				   struct net_device *upper_dev, bool master,
 -				   void *private)
 +				   struct net_device *upper_dev, bool master)
  {
 -	struct netdev_adjacent *i, *j, *to_i, *to_j;
 -	int ret = 0;
 +	struct netdev_adjacent *upper;
  
  	ASSERT_RTNL();
  
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_sysfs.c
* Unmerged path include/net/bonding.h
* Unmerged path net/core/dev.c
