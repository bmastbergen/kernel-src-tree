mmc: sdhci: fix dma memory leak in sdhci_pre_req()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: fix dma memory leak in sdhci_pre_req() (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 94.74%
commit-author Haibo Chen <haibo.chen@freescale.com>
commit d31911b9374a76560d2c8ea4aa6ce5781621e81d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d31911b9.failed

Currently one mrq->data maybe execute dma_map_sg() twice
when mmc subsystem prepare over one new request, and the
following log show up:
	sdhci[sdhci_pre_dma_transfer] invalid cookie: 24, next-cookie 25

In this condition, mrq->date map a dma-memory(1) in sdhci_pre_req
for the first time, and map another dma-memory(2) in sdhci_prepare_data
for the second time. But driver only unmap the dma-memory(2), and
dma-memory(1) never unmapped, which cause the dma memory leak issue.

This patch use another method to map the dma memory for the mrq->data
which can fix this dma memory leak issue.

Fixes: 348487cb28e6 ("mmc: sdhci: use pipeline mmc requests to improve performance")
Reported-and-tested-by: Jiri Slaby <jslaby@suse.cz>
	Signed-off-by: Haibo Chen <haibo.chen@freescale.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit d31911b9374a76560d2c8ea4aa6ce5781621e81d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.h
diff --cc drivers/mmc/host/sdhci.h
index 23802c7404be,7c02ff46c8ac..000000000000
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@@ -265,6 -269,246 +265,249 @@@
  #define SDHCI_DEFAULT_BOUNDARY_SIZE  (512 * 1024)
  #define SDHCI_DEFAULT_BOUNDARY_ARG   (ilog2(SDHCI_DEFAULT_BOUNDARY_SIZE) - 12)
  
++<<<<<<< HEAD
++=======
+ /* ADMA2 32-bit DMA descriptor size */
+ #define SDHCI_ADMA2_32_DESC_SZ	8
+ 
+ /* ADMA2 32-bit DMA alignment */
+ #define SDHCI_ADMA2_32_ALIGN	4
+ 
+ /* ADMA2 32-bit descriptor */
+ struct sdhci_adma2_32_desc {
+ 	__le16	cmd;
+ 	__le16	len;
+ 	__le32	addr;
+ }  __packed __aligned(SDHCI_ADMA2_32_ALIGN);
+ 
+ /* ADMA2 64-bit DMA descriptor size */
+ #define SDHCI_ADMA2_64_DESC_SZ	12
+ 
+ /* ADMA2 64-bit DMA alignment */
+ #define SDHCI_ADMA2_64_ALIGN	8
+ 
+ /*
+  * ADMA2 64-bit descriptor. Note 12-byte descriptor can't always be 8-byte
+  * aligned.
+  */
+ struct sdhci_adma2_64_desc {
+ 	__le16	cmd;
+ 	__le16	len;
+ 	__le32	addr_lo;
+ 	__le32	addr_hi;
+ }  __packed __aligned(4);
+ 
+ #define ADMA2_TRAN_VALID	0x21
+ #define ADMA2_NOP_END_VALID	0x3
+ #define ADMA2_END		0x2
+ 
+ /*
+  * Maximum segments assuming a 512KiB maximum requisition size and a minimum
+  * 4KiB page size.
+  */
+ #define SDHCI_MAX_SEGS		128
+ 
+ enum sdhci_cookie {
+ 	COOKIE_UNMAPPED,
+ 	COOKIE_MAPPED,
+ 	COOKIE_GIVEN,
+ };
+ 
+ struct sdhci_host {
+ 	/* Data set by hardware interface driver */
+ 	const char *hw_name;	/* Hardware bus name */
+ 
+ 	unsigned int quirks;	/* Deviations from spec. */
+ 
+ /* Controller doesn't honor resets unless we touch the clock register */
+ #define SDHCI_QUIRK_CLOCK_BEFORE_RESET			(1<<0)
+ /* Controller has bad caps bits, but really supports DMA */
+ #define SDHCI_QUIRK_FORCE_DMA				(1<<1)
+ /* Controller doesn't like to be reset when there is no card inserted. */
+ #define SDHCI_QUIRK_NO_CARD_NO_RESET			(1<<2)
+ /* Controller doesn't like clearing the power reg before a change */
+ #define SDHCI_QUIRK_SINGLE_POWER_WRITE			(1<<3)
+ /* Controller has flaky internal state so reset it on each ios change */
+ #define SDHCI_QUIRK_RESET_CMD_DATA_ON_IOS		(1<<4)
+ /* Controller has an unusable DMA engine */
+ #define SDHCI_QUIRK_BROKEN_DMA				(1<<5)
+ /* Controller has an unusable ADMA engine */
+ #define SDHCI_QUIRK_BROKEN_ADMA				(1<<6)
+ /* Controller can only DMA from 32-bit aligned addresses */
+ #define SDHCI_QUIRK_32BIT_DMA_ADDR			(1<<7)
+ /* Controller can only DMA chunk sizes that are a multiple of 32 bits */
+ #define SDHCI_QUIRK_32BIT_DMA_SIZE			(1<<8)
+ /* Controller can only ADMA chunks that are a multiple of 32 bits */
+ #define SDHCI_QUIRK_32BIT_ADMA_SIZE			(1<<9)
+ /* Controller needs to be reset after each request to stay stable */
+ #define SDHCI_QUIRK_RESET_AFTER_REQUEST			(1<<10)
+ /* Controller needs voltage and power writes to happen separately */
+ #define SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER		(1<<11)
+ /* Controller provides an incorrect timeout value for transfers */
+ #define SDHCI_QUIRK_BROKEN_TIMEOUT_VAL			(1<<12)
+ /* Controller has an issue with buffer bits for small transfers */
+ #define SDHCI_QUIRK_BROKEN_SMALL_PIO			(1<<13)
+ /* Controller does not provide transfer-complete interrupt when not busy */
+ #define SDHCI_QUIRK_NO_BUSY_IRQ				(1<<14)
+ /* Controller has unreliable card detection */
+ #define SDHCI_QUIRK_BROKEN_CARD_DETECTION		(1<<15)
+ /* Controller reports inverted write-protect state */
+ #define SDHCI_QUIRK_INVERTED_WRITE_PROTECT		(1<<16)
+ /* Controller does not like fast PIO transfers */
+ #define SDHCI_QUIRK_PIO_NEEDS_DELAY			(1<<18)
+ /* Controller has to be forced to use block size of 2048 bytes */
+ #define SDHCI_QUIRK_FORCE_BLK_SZ_2048			(1<<20)
+ /* Controller cannot do multi-block transfers */
+ #define SDHCI_QUIRK_NO_MULTIBLOCK			(1<<21)
+ /* Controller can only handle 1-bit data transfers */
+ #define SDHCI_QUIRK_FORCE_1_BIT_DATA			(1<<22)
+ /* Controller needs 10ms delay between applying power and clock */
+ #define SDHCI_QUIRK_DELAY_AFTER_POWER			(1<<23)
+ /* Controller uses SDCLK instead of TMCLK for data timeouts */
+ #define SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK		(1<<24)
+ /* Controller reports wrong base clock capability */
+ #define SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN		(1<<25)
+ /* Controller cannot support End Attribute in NOP ADMA descriptor */
+ #define SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC		(1<<26)
+ /* Controller is missing device caps. Use caps provided by host */
+ #define SDHCI_QUIRK_MISSING_CAPS			(1<<27)
+ /* Controller uses Auto CMD12 command to stop the transfer */
+ #define SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12		(1<<28)
+ /* Controller doesn't have HISPD bit field in HI-SPEED SD card */
+ #define SDHCI_QUIRK_NO_HISPD_BIT			(1<<29)
+ /* Controller treats ADMA descriptors with length 0000h incorrectly */
+ #define SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC		(1<<30)
+ /* The read-only detection via SDHCI_PRESENT_STATE register is unstable */
+ #define SDHCI_QUIRK_UNSTABLE_RO_DETECT			(1<<31)
+ 
+ 	unsigned int quirks2;	/* More deviations from spec. */
+ 
+ #define SDHCI_QUIRK2_HOST_OFF_CARD_ON			(1<<0)
+ #define SDHCI_QUIRK2_HOST_NO_CMD23			(1<<1)
+ /* The system physically doesn't support 1.8v, even if the host does */
+ #define SDHCI_QUIRK2_NO_1_8_V				(1<<2)
+ #define SDHCI_QUIRK2_PRESET_VALUE_BROKEN		(1<<3)
+ #define SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON		(1<<4)
+ /* Controller has a non-standard host control register */
+ #define SDHCI_QUIRK2_BROKEN_HOST_CONTROL		(1<<5)
+ /* Controller does not support HS200 */
+ #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
+ /* Controller does not support DDR50 */
+ #define SDHCI_QUIRK2_BROKEN_DDR50			(1<<7)
+ /* Stop command (CMD12) can set Transfer Complete when not using MMC_RSP_BUSY */
+ #define SDHCI_QUIRK2_STOP_WITH_TC			(1<<8)
+ /* Controller does not support 64-bit DMA */
+ #define SDHCI_QUIRK2_BROKEN_64_BIT_DMA			(1<<9)
+ /* need clear transfer mode register before send cmd */
+ #define SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD	(1<<10)
+ /* Capability register bit-63 indicates HS400 support */
+ #define SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400		(1<<11)
+ /* forced tuned clock */
+ #define SDHCI_QUIRK2_TUNING_WORK_AROUND			(1<<12)
+ /* disable the block count for single block transactions */
+ #define SDHCI_QUIRK2_SUPPORT_SINGLE			(1<<13)
+ /* Controller broken with using ACMD23 */
+ #define SDHCI_QUIRK2_ACMD23_BROKEN			(1<<14)
+ /* Broken Clock divider zero in controller */
+ #define SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN		(1<<15)
+ 
+ 	int irq;		/* Device IRQ */
+ 	void __iomem *ioaddr;	/* Mapped address */
+ 
+ 	const struct sdhci_ops *ops;	/* Low level hw interface */
+ 
+ 	/* Internal data */
+ 	struct mmc_host *mmc;	/* MMC structure */
+ 	u64 dma_mask;		/* custom DMA mask */
+ 
+ #if defined(CONFIG_LEDS_CLASS) || defined(CONFIG_LEDS_CLASS_MODULE)
+ 	struct led_classdev led;	/* LED control */
+ 	char led_name[32];
+ #endif
+ 
+ 	spinlock_t lock;	/* Mutex */
+ 
+ 	int flags;		/* Host attributes */
+ #define SDHCI_USE_SDMA		(1<<0)	/* Host is SDMA capable */
+ #define SDHCI_USE_ADMA		(1<<1)	/* Host is ADMA capable */
+ #define SDHCI_REQ_USE_DMA	(1<<2)	/* Use DMA for this req. */
+ #define SDHCI_DEVICE_DEAD	(1<<3)	/* Device unresponsive */
+ #define SDHCI_SDR50_NEEDS_TUNING (1<<4)	/* SDR50 needs tuning */
+ #define SDHCI_AUTO_CMD12	(1<<6)	/* Auto CMD12 support */
+ #define SDHCI_AUTO_CMD23	(1<<7)	/* Auto CMD23 support */
+ #define SDHCI_PV_ENABLED	(1<<8)	/* Preset value enabled */
+ #define SDHCI_SDIO_IRQ_ENABLED	(1<<9)	/* SDIO irq enabled */
+ #define SDHCI_SDR104_NEEDS_TUNING (1<<10)	/* SDR104/HS200 needs tuning */
+ #define SDHCI_USE_64_BIT_DMA	(1<<12)	/* Use 64-bit DMA */
+ #define SDHCI_HS400_TUNING	(1<<13)	/* Tuning for HS400 */
+ 
+ 	unsigned int version;	/* SDHCI spec. version */
+ 
+ 	unsigned int max_clk;	/* Max possible freq (MHz) */
+ 	unsigned int timeout_clk;	/* Timeout freq (KHz) */
+ 	unsigned int clk_mul;	/* Clock Muliplier value */
+ 
+ 	unsigned int clock;	/* Current clock (MHz) */
+ 	u8 pwr;			/* Current voltage */
+ 
+ 	bool runtime_suspended;	/* Host is runtime suspended */
+ 	bool bus_on;		/* Bus power prevents runtime suspend */
+ 	bool preset_enabled;	/* Preset is enabled */
+ 
+ 	struct mmc_request *mrq;	/* Current request */
+ 	struct mmc_command *cmd;	/* Current command */
+ 	struct mmc_data *data;	/* Current data request */
+ 	unsigned int data_early:1;	/* Data finished before cmd */
+ 	unsigned int busy_handle:1;	/* Handling the order of Busy-end */
+ 
+ 	struct sg_mapping_iter sg_miter;	/* SG state for PIO */
+ 	unsigned int blocks;	/* remaining PIO blocks */
+ 
+ 	int sg_count;		/* Mapped sg entries */
+ 
+ 	void *adma_table;	/* ADMA descriptor table */
+ 	void *align_buffer;	/* Bounce buffer */
+ 
+ 	size_t adma_table_sz;	/* ADMA descriptor table size */
+ 	size_t align_buffer_sz;	/* Bounce buffer size */
+ 
+ 	dma_addr_t adma_addr;	/* Mapped ADMA descr. table */
+ 	dma_addr_t align_addr;	/* Mapped bounce buffer */
+ 
+ 	unsigned int desc_sz;	/* ADMA descriptor size */
+ 	unsigned int align_sz;	/* ADMA alignment */
+ 	unsigned int align_mask;	/* ADMA alignment mask */
+ 
+ 	struct tasklet_struct finish_tasklet;	/* Tasklet structures */
+ 
+ 	struct timer_list timer;	/* Timer for timeouts */
+ 
+ 	u32 caps;		/* Alternative CAPABILITY_0 */
+ 	u32 caps1;		/* Alternative CAPABILITY_1 */
+ 
+ 	unsigned int            ocr_avail_sdio;	/* OCR bit masks */
+ 	unsigned int            ocr_avail_sd;
+ 	unsigned int            ocr_avail_mmc;
+ 	u32 ocr_mask;		/* available voltages */
+ 
+ 	unsigned		timing;		/* Current timing */
+ 
+ 	u32			thread_isr;
+ 
+ 	/* cached registers */
+ 	u32			ier;
+ 
+ 	wait_queue_head_t	buf_ready_int;	/* Waitqueue for Buffer Read Ready interrupt */
+ 	unsigned int		tuning_done;	/* Condition flag set when CMD19 succeeds */
+ 
+ 	unsigned int		tuning_count;	/* Timer count for re-tuning */
+ 	unsigned int		tuning_mode;	/* Re-tuning mode supported by host */
+ #define SDHCI_TUNING_MODE_1	0
+ 
+ 	unsigned long private[0] ____cacheline_aligned;
+ };
+ 
++>>>>>>> d31911b9374a (mmc: sdhci: fix dma memory leak in sdhci_pre_req())
  struct sdhci_ops {
  #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
  	u32		(*read_l)(struct sdhci_host *host, int reg);
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 0b59825ebddf..73db4f46638c 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -63,8 +63,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode);
 static void sdhci_tuning_timer(unsigned long data);
 static void sdhci_enable_preset_value(struct sdhci_host *host, bool enable);
 static int sdhci_pre_dma_transfer(struct sdhci_host *host,
-					struct mmc_data *data,
-					struct sdhci_host_next *next);
+					struct mmc_data *data);
 static int sdhci_do_get_cd(struct sdhci_host *host);
 
 #ifdef CONFIG_PM_RUNTIME
@@ -529,7 +528,7 @@ static int sdhci_adma_table_pre(struct sdhci_host *host,
 		goto fail;
 	BUG_ON(host->align_addr & 0x3);
 
-	host->sg_count = sdhci_pre_dma_transfer(host, data, NULL);
+	host->sg_count = sdhci_pre_dma_transfer(host, data);
 	if (host->sg_count < 0)
 		goto unmap_align;
 
@@ -665,9 +664,11 @@ static void sdhci_adma_table_post(struct sdhci_host *host,
 		}
 	}
 
-	if (!data->host_cookie)
+	if (data->host_cookie == COOKIE_MAPPED) {
 		dma_unmap_sg(mmc_dev(host->mmc), data->sg,
 			data->sg_len, direction);
+		data->host_cookie = COOKIE_UNMAPPED;
+	}
 }
 
 static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd)
@@ -847,7 +848,7 @@ static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
 		} else {
 			int sg_cnt;
 
-			sg_cnt = sdhci_pre_dma_transfer(host, data, NULL);
+			sg_cnt = sdhci_pre_dma_transfer(host, data);
 			if (sg_cnt <= 0) {
 				/*
 				 * This only happens when someone fed
@@ -952,11 +953,13 @@ static void sdhci_finish_data(struct sdhci_host *host)
 		if (host->flags & SDHCI_USE_ADMA)
 			sdhci_adma_table_post(host, data);
 		else {
-			if (!data->host_cookie)
+			if (data->host_cookie == COOKIE_MAPPED) {
 				dma_unmap_sg(mmc_dev(host->mmc),
 					data->sg, data->sg_len,
 					(data->flags & MMC_DATA_READ) ?
 					DMA_FROM_DEVICE : DMA_TO_DEVICE);
+				data->host_cookie = COOKIE_UNMAPPED;
+			}
 		}
 	}
 
@@ -2123,49 +2126,36 @@ static void sdhci_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
 	struct mmc_data *data = mrq->data;
 
 	if (host->flags & SDHCI_REQ_USE_DMA) {
-		if (data->host_cookie)
+		if (data->host_cookie == COOKIE_GIVEN ||
+				data->host_cookie == COOKIE_MAPPED)
 			dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
 					 data->flags & MMC_DATA_WRITE ?
 					 DMA_TO_DEVICE : DMA_FROM_DEVICE);
-		mrq->data->host_cookie = 0;
+		data->host_cookie = COOKIE_UNMAPPED;
 	}
 }
 
 static int sdhci_pre_dma_transfer(struct sdhci_host *host,
-				       struct mmc_data *data,
-				       struct sdhci_host_next *next)
+				       struct mmc_data *data)
 {
 	int sg_count;
 
-	if (!next && data->host_cookie &&
-	    data->host_cookie != host->next_data.cookie) {
-		pr_debug(DRIVER_NAME "[%s] invalid cookie: %d, next-cookie %d\n",
-			__func__, data->host_cookie, host->next_data.cookie);
-		data->host_cookie = 0;
+	if (data->host_cookie == COOKIE_MAPPED) {
+		data->host_cookie = COOKIE_GIVEN;
+		return data->sg_count;
 	}
 
-	/* Check if next job is already prepared */
-	if (next ||
-	    (!next && data->host_cookie != host->next_data.cookie)) {
-		sg_count = dma_map_sg(mmc_dev(host->mmc), data->sg,
-				     data->sg_len,
-				     data->flags & MMC_DATA_WRITE ?
-				     DMA_TO_DEVICE : DMA_FROM_DEVICE);
-
-	} else {
-		sg_count = host->next_data.sg_count;
-		host->next_data.sg_count = 0;
-	}
+	WARN_ON(data->host_cookie == COOKIE_GIVEN);
 
+	sg_count = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+				data->flags & MMC_DATA_WRITE ?
+				DMA_TO_DEVICE : DMA_FROM_DEVICE);
 
 	if (sg_count == 0)
-		return -EINVAL;
+		return -ENOSPC;
 
-	if (next) {
-		next->sg_count = sg_count;
-		data->host_cookie = ++next->cookie < 0 ? 1 : next->cookie;
-	} else
-		host->sg_count = sg_count;
+	data->sg_count = sg_count;
+	data->host_cookie = COOKIE_MAPPED;
 
 	return sg_count;
 }
@@ -2175,16 +2165,10 @@ static void sdhci_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,
 {
 	struct sdhci_host *host = mmc_priv(mmc);
 
-	if (mrq->data->host_cookie) {
-		mrq->data->host_cookie = 0;
-		return;
-	}
+	mrq->data->host_cookie = COOKIE_UNMAPPED;
 
 	if (host->flags & SDHCI_REQ_USE_DMA)
-		if (sdhci_pre_dma_transfer(host,
-					mrq->data,
-					&host->next_data) < 0)
-			mrq->data->host_cookie = 0;
+		sdhci_pre_dma_transfer(host, mrq->data);
 }
 
 static void sdhci_card_event(struct mmc_host *mmc)
@@ -3035,7 +3019,6 @@ int sdhci_add_host(struct sdhci_host *host)
 		host->max_clk = host->ops->get_max_clock(host);
 	}
 
-	host->next_data.cookie = 1;
 	/*
 	 * In case of Host Controller v3.00, find out whether clock
 	 * multiplier is supported.
* Unmerged path drivers/mmc/host/sdhci.h
