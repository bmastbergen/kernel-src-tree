drm/dp: move hw_mutex up the call stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] dp: move hw_mutex up the call stack (Rob Clark) [1072036 1115530 1202702 1211398 1272159 1274157]
Rebuild_FUZZ: 94.59%
commit-author Rob Clark <robdclark@gmail.com>
commit 7779c5e23c5132c22a219f1f5554ef81dd15ee91
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7779c5e2.failed

1) don't let other threads trying to bang on aux channel interrupt the
defer timeout/logic
2) don't let other threads interrupt the i2c over aux logic

Technically, according to people who actually have the DP spec, this
should not be required.  In practice, it makes some troublesome Dell
monitor (and perhaps others) work, so probably a case of "It's compliant
if it works with windows" on the hw vendor's part..

v2: rebased to come before DPCD/AUX logging patch for easier backport
to stable branches.

	Reported-by: Dave Wysochanski <dwysocha@redhat.com>
Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1274157
	Cc: stable@vger.kernel.org
	Signed-off-by: Rob Clark <robdclark@gmail.com>
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 7779c5e23c5132c22a219f1f5554ef81dd15ee91)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_dp_helper.c
diff --cc drivers/gpu/drm/drm_dp_helper.c
index 61035778ac4a,df64ed1c0139..000000000000
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@@ -206,14 -209,15 +206,15 @@@ static int drm_dp_dpcd_access(struct dr
  		switch (msg.reply & DP_AUX_NATIVE_REPLY_MASK) {
  		case DP_AUX_NATIVE_REPLY_ACK:
  			if (err < size)
- 				return -EPROTO;
- 			return err;
+ 				err = -EPROTO;
+ 			goto unlock;
  
  		case DP_AUX_NATIVE_REPLY_NACK:
- 			return -EIO;
+ 			err = -EIO;
+ 			goto unlock;
  
  		case DP_AUX_NATIVE_REPLY_DEFER:
 -			usleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);
 +			usleep_range(400, 500);
  			break;
  		}
  	}
@@@ -439,11 -543,13 +444,16 @@@ static int drm_dp_i2c_do_msg(struct drm
  	 * DP1.2 sections 2.7.7.1.5.6.1 and 2.7.7.1.6.6.1: A DP Source device
  	 * is required to retry at least seven times upon receiving AUX_DEFER
  	 * before giving up the AUX transaction.
 -	 *
 -	 * We also try to account for the i2c bus speed.
  	 */
++<<<<<<< HEAD
 +	for (retry = 0; retry < 7; retry++) {
 +		mutex_lock(&aux->hw_mutex);
++=======
+ 	int max_retries = max(7, drm_dp_i2c_retry_count(msg, dp_aux_i2c_speed_khz));
+ 
+ 	for (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c); retry++) {
++>>>>>>> 7779c5e23c51 (drm/dp: move hw_mutex up the call stack)
  		ret = aux->transfer(aux, msg);
- 		mutex_unlock(&aux->hw_mutex);
  		if (ret < 0) {
  			if (ret == -EBUSY)
  				continue;
@@@ -564,12 -688,11 +574,14 @@@ static int drm_dp_i2c_xfer(struct i2c_a
  
  	memset(&msg, 0, sizeof(msg));
  
+ 	mutex_lock(&aux->hw_mutex);
+ 
  	for (i = 0; i < num; i++) {
  		msg.address = msgs[i].addr;
 -		drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
 +		msg.request = (msgs[i].flags & I2C_M_RD) ?
 +			DP_AUX_I2C_READ :
 +			DP_AUX_I2C_WRITE;
 +		msg.request |= DP_AUX_I2C_MOT;
  		/* Send a bare address packet to start the transaction.
  		 * Zero sized messages specify an address only (bare
  		 * address) transaction.
* Unmerged path drivers/gpu/drm/drm_dp_helper.c
