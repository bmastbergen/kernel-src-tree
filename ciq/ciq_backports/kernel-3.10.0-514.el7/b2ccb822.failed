drm/i915: Enable/disable TMDS output buffers in DP++ adaptor as needed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915: Enable/disable TMDS output buffers in DP++ adaptor as needed (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 97.06%
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit b2ccb822d376d1bbbe5d1f9118d1488b25e6bc6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b2ccb822.failed

To save a bit of power, let's try to turn off the TMDS output buffers
in DP++ adaptors when we're not driving the port.

v2: Let's not forget DDI, toss in a debug message while at it
v3: Just do the TMDS output control based on adaptor type. With the
    helper getting passed the type, we wouldn't actually have to
    check at all in the driver, but the check eliminates the debug
    output more honest

	Cc: stable@vger.kernel.org
	Cc: Tore Anderson <tore@fud.no>
	Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
	Cc: Shashank Sharma <shashank.sharma@intel.com>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1462216105-20881-4-git-send-email-ville.syrjala@linux.intel.com
	Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
(cherry picked from commit b2ccb822d376d1bbbe5d1f9118d1488b25e6bc6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
#	drivers/gpu/drm/i915/intel_hdmi.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index 486f6fa68db1,01e523df363b..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -1565,10 -1587,34 +1565,37 @@@ static void intel_ddi_pre_enable(struc
  
  		I915_WRITE(DPLL_CTRL2, val);
  
 -	} else if (INTEL_INFO(dev_priv)->gen < 9) {
 -		WARN_ON(pipe_config->ddi_pll_sel == PORT_CLK_SEL_NONE);
 -		I915_WRITE(PORT_CLK_SEL(port), pipe_config->ddi_pll_sel);
 +	} else {
 +		WARN_ON(crtc->config->ddi_pll_sel == PORT_CLK_SEL_NONE);
 +		I915_WRITE(PORT_CLK_SEL(port), crtc->config->ddi_pll_sel);
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ static void intel_ddi_pre_enable(struct intel_encoder *intel_encoder)
+ {
+ 	struct drm_encoder *encoder = &intel_encoder->base;
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->dev);
+ 	struct intel_crtc *crtc = to_intel_crtc(encoder->crtc);
+ 	enum port port = intel_ddi_get_encoder_port(intel_encoder);
+ 	int type = intel_encoder->type;
+ 
+ 	if (type == INTEL_OUTPUT_HDMI) {
+ 		struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);
+ 
+ 		intel_dp_dual_mode_set_tmds_output(intel_hdmi, true);
+ 	}
+ 
+ 	intel_prepare_ddi_buffer(intel_encoder);
+ 
+ 	if (type == INTEL_OUTPUT_EDP) {
+ 		struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
+ 		intel_edp_panel_on(intel_dp);
+ 	}
+ 
+ 	intel_ddi_clk_select(intel_encoder, crtc->config);
++>>>>>>> b2ccb822d376 (drm/i915: Enable/disable TMDS output buffers in DP++ adaptor as needed)
  
  	if (type == INTEL_OUTPUT_DISPLAYPORT || type == INTEL_OUTPUT_EDP) {
  		struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
@@@ -1621,11 -1668,17 +1648,17 @@@ static void intel_ddi_post_disable(stru
  		intel_edp_panel_off(intel_dp);
  	}
  
 -	if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev))
 +	if (IS_SKYLAKE(dev))
  		I915_WRITE(DPLL_CTRL2, (I915_READ(DPLL_CTRL2) |
  					DPLL_CTRL2_DDI_CLK_OFF(port)));
 -	else if (INTEL_INFO(dev)->gen < 9)
 +	else
  		I915_WRITE(PORT_CLK_SEL(port), PORT_CLK_SEL_NONE);
+ 
+ 	if (type == INTEL_OUTPUT_HDMI) {
+ 		struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);
+ 
+ 		intel_dp_dual_mode_set_tmds_output(intel_hdmi, false);
+ 	}
  }
  
  static void intel_enable_ddi(struct intel_encoder *intel_encoder)
diff --cc drivers/gpu/drm/i915/intel_hdmi.c
index bfbe07b6ddce,c4d93e6b4bed..000000000000
--- a/drivers/gpu/drm/i915/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/intel_hdmi.c
@@@ -701,12 -858,14 +717,14 @@@ static void intel_hdmi_prepare(struct i
  	struct drm_i915_private *dev_priv = dev->dev_private;
  	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
  	struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(&encoder->base);
 -	const struct drm_display_mode *adjusted_mode = &crtc->config->base.adjusted_mode;
 +	struct drm_display_mode *adjusted_mode = &crtc->config->base.adjusted_mode;
  	u32 hdmi_val;
  
+ 	intel_dp_dual_mode_set_tmds_output(intel_hdmi, true);
+ 
  	hdmi_val = SDVO_ENCODING_HDMI;
 -	if (!HAS_PCH_SPLIT(dev) && crtc->config->limited_color_range)
 -		hdmi_val |= HDMI_COLOR_RANGE_16_235;
 +	if (!HAS_PCH_SPLIT(dev))
 +		hdmi_val |= intel_hdmi->color_range;
  	if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
  		hdmi_val |= SDVO_VSYNC_ACTIVE_HIGH;
  	if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
@@@ -872,59 -1122,76 +890,66 @@@ static void intel_disable_hdmi(struct i
  
  	temp = I915_READ(intel_hdmi->hdmi_reg);
  
 -	temp &= ~(SDVO_ENABLE | SDVO_AUDIO_ENABLE);
 -	I915_WRITE(intel_hdmi->hdmi_reg, temp);
 -	POSTING_READ(intel_hdmi->hdmi_reg);
 +	/* HW workaround for IBX, we need to move the port to transcoder A
 +	 * before disabling it. */
 +	if (HAS_PCH_IBX(dev)) {
 +		struct drm_crtc *crtc = encoder->base.crtc;
 +		int pipe = crtc ? to_intel_crtc(crtc)->pipe : -1;
 +
 +		if (temp & SDVO_PIPE_B_SELECT) {
 +			temp &= ~SDVO_PIPE_B_SELECT;
 +			I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +			POSTING_READ(intel_hdmi->hdmi_reg);
 +
 +			/* Again we need to write this twice. */
 +			I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +			POSTING_READ(intel_hdmi->hdmi_reg);
 +
 +			/* Transcoder selection bits only update
 +			 * effectively on vblank. */
 +			if (crtc)
 +				intel_wait_for_vblank(dev, pipe);
 +			else
 +				msleep(50);
 +		}
 +	}
  
 -	/*
 -	 * HW workaround for IBX, we need to move the port
 -	 * to transcoder A after disabling it to allow the
 -	 * matching DP port to be enabled on transcoder A.
 +	/* HW workaround, need to toggle enable bit off and on for 12bpc, but
 +	 * we do this anyway which shows more stable in testing.
  	 */
 -	if (HAS_PCH_IBX(dev) && crtc->pipe == PIPE_B) {
 -		/*
 -		 * We get CPU/PCH FIFO underruns on the other pipe when
 -		 * doing the workaround. Sweep them under the rug.
 -		 */
 -		intel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, false);
 -		intel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);
 -
 -		temp &= ~SDVO_PIPE_B_SELECT;
 -		temp |= SDVO_ENABLE;
 -		/*
 -		 * HW workaround, need to write this twice for issue
 -		 * that may result in first write getting masked.
 -		 */
 -		I915_WRITE(intel_hdmi->hdmi_reg, temp);
 -		POSTING_READ(intel_hdmi->hdmi_reg);
 -		I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +	if (HAS_PCH_SPLIT(dev)) {
 +		I915_WRITE(intel_hdmi->hdmi_reg, temp & ~SDVO_ENABLE);
  		POSTING_READ(intel_hdmi->hdmi_reg);
 +	}
 +
 +	temp &= ~enable_bits;
 +
 +	I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +	POSTING_READ(intel_hdmi->hdmi_reg);
  
 -		temp &= ~SDVO_ENABLE;
 +	/* HW workaround, need to write this twice for issue that may result
 +	 * in first write getting masked.
 +	 */
 +	if (HAS_PCH_SPLIT(dev)) {
  		I915_WRITE(intel_hdmi->hdmi_reg, temp);
  		POSTING_READ(intel_hdmi->hdmi_reg);
 -
 -		intel_wait_for_vblank_if_active(dev_priv->dev, PIPE_A);
 -		intel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, true);
 -		intel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	intel_hdmi->set_infoframes(&encoder->base, false, NULL);
+ 
+ 	intel_dp_dual_mode_set_tmds_output(intel_hdmi, false);
++>>>>>>> b2ccb822d376 (drm/i915: Enable/disable TMDS output buffers in DP++ adaptor as needed)
  }
  
 -static void g4x_disable_hdmi(struct intel_encoder *encoder)
 -{
 -	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
 -
 -	if (crtc->config->has_audio)
 -		intel_audio_codec_disable(encoder);
 -
 -	intel_disable_hdmi(encoder);
 -}
 -
 -static void pch_disable_hdmi(struct intel_encoder *encoder)
 +static int hdmi_portclock_limit(struct intel_hdmi *hdmi, bool respect_dvi_limit)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
 -
 -	if (crtc->config->has_audio)
 -		intel_audio_codec_disable(encoder);
 -}
 -
 -static void pch_post_disable_hdmi(struct intel_encoder *encoder)
 -{
 -	intel_disable_hdmi(encoder);
 -}
 +	struct drm_device *dev = intel_hdmi_to_dev(hdmi);
  
 -static int intel_hdmi_source_max_tmds_clock(struct drm_i915_private *dev_priv)
 -{
 -	if (IS_G4X(dev_priv))
 +	if ((respect_dvi_limit && !hdmi->has_hdmi_sink) || IS_G4X(dev))
  		return 165000;
 -	else if (IS_HASWELL(dev_priv) || INTEL_INFO(dev_priv)->gen >= 8)
 +	else if (IS_HASWELL(dev) || INTEL_INFO(dev)->gen >= 8)
  		return 300000;
  	else
  		return 225000;
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 640e923ced09..bf64866d8abb 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -1152,6 +1152,7 @@ void intel_hdmi_init_connector(struct intel_digital_port *intel_dig_port,
 struct intel_hdmi *enc_to_intel_hdmi(struct drm_encoder *encoder);
 bool intel_hdmi_compute_config(struct intel_encoder *encoder,
 			       struct intel_crtc_state *pipe_config);
+void intel_dp_dual_mode_set_tmds_output(struct intel_hdmi *hdmi, bool enable);
 
 
 /* intel_lvds.c */
* Unmerged path drivers/gpu/drm/i915/intel_hdmi.c
