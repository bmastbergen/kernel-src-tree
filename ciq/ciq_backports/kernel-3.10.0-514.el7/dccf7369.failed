spi: pxa2xx: Prepare for new Intel LPSS SPI type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jarkko Nikula <jarkko.nikula@linux.intel.com>
commit dccf7369652f3934456345aab6a92fa905177886
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dccf7369.failed

Some of the Intel LPSS SPI properties will be different in upcoming
platforms compared to existing Lynxpoint and BayTrail/Braswell. LPSS SPI
private registers will be at different offset and there will be changes in
individual registers and default FIFO thresholds too.

Add configuration for these differences and use them in runtime based on
LPSS SSP type. With this change private registers offset autodetection
becomes needless.

	Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit dccf7369652f3934456345aab6a92fa905177886)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/spi/spi-pxa2xx.c
#	include/linux/pxa2xx_ssp.h
diff --cc drivers/spi/spi-pxa2xx.c
index 60b6ff325053,3fec31dbf972..000000000000
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@@ -64,19 -54,155 +64,70 @@@ MODULE_ALIAS("platform:pxa2xx-spi")
  				| SSCR1_RFT | SSCR1_TFT | SSCR1_MWDS \
  				| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
  
++<<<<<<< HEAD
 +#define LPSS_RX_THRESH_DFLT	64
 +#define LPSS_TX_LOTHRESH_DFLT	160
 +#define LPSS_TX_HITHRESH_DFLT	224
 +
 +/* Offset from drv_data->lpss_base */
 +#define SSP_REG			0x0c
 +#define SPI_CS_CONTROL		0x18
++=======
+ #define QUARK_X1000_SSCR1_CHANGE_MASK (QUARK_X1000_SSCR1_STRF	\
+ 				| QUARK_X1000_SSCR1_EFWR	\
+ 				| QUARK_X1000_SSCR1_RFT		\
+ 				| QUARK_X1000_SSCR1_TFT		\
+ 				| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
+ 
+ #define GENERAL_REG_RXTO_HOLDOFF_DISABLE BIT(24)
++>>>>>>> dccf7369652f (spi: pxa2xx: Prepare for new Intel LPSS SPI type)
  #define SPI_CS_CONTROL_SW_MODE	BIT(0)
  #define SPI_CS_CONTROL_CS_HIGH	BIT(1)
  
+ struct lpss_config {
+ 	/* LPSS offset from drv_data->ioaddr */
+ 	unsigned offset;
+ 	/* Register offsets from drv_data->lpss_base or -1 */
+ 	int reg_general;
+ 	int reg_ssp;
+ 	int reg_cs_ctrl;
+ 	/* FIFO thresholds */
+ 	u32 rx_threshold;
+ 	u32 tx_threshold_lo;
+ 	u32 tx_threshold_hi;
+ };
+ 
+ /* Keep these sorted with enum pxa_ssp_type */
+ static const struct lpss_config lpss_platforms[] = {
+ 	{	/* LPSS_LPT_SSP */
+ 		.offset = 0x800,
+ 		.reg_general = 0x08,
+ 		.reg_ssp = 0x0c,
+ 		.reg_cs_ctrl = 0x18,
+ 		.rx_threshold = 64,
+ 		.tx_threshold_lo = 160,
+ 		.tx_threshold_hi = 224,
+ 	},
+ 	{	/* LPSS_BYT_SSP */
+ 		.offset = 0x400,
+ 		.reg_general = 0x08,
+ 		.reg_ssp = 0x0c,
+ 		.reg_cs_ctrl = 0x18,
+ 		.rx_threshold = 64,
+ 		.tx_threshold_lo = 160,
+ 		.tx_threshold_hi = 224,
+ 	},
+ };
+ 
+ static inline const struct lpss_config
+ *lpss_get_config(const struct driver_data *drv_data)
+ {
+ 	return &lpss_platforms[drv_data->ssp_type - LPSS_LPT_SSP];
+ }
+ 
  static bool is_lpss_ssp(const struct driver_data *drv_data)
  {
 -	switch (drv_data->ssp_type) {
 -	case LPSS_LPT_SSP:
 -	case LPSS_BYT_SSP:
 -		return true;
 -	default:
 -		return false;
 -	}
 -}
 -
 -static bool is_quark_x1000_ssp(const struct driver_data *drv_data)
 -{
 -	return drv_data->ssp_type == QUARK_X1000_SSP;
 -}
 -
 -static u32 pxa2xx_spi_get_ssrc1_change_mask(const struct driver_data *drv_data)
 -{
 -	switch (drv_data->ssp_type) {
 -	case QUARK_X1000_SSP:
 -		return QUARK_X1000_SSCR1_CHANGE_MASK;
 -	default:
 -		return SSCR1_CHANGE_MASK;
 -	}
 -}
 -
 -static u32
 -pxa2xx_spi_get_rx_default_thre(const struct driver_data *drv_data)
 -{
 -	switch (drv_data->ssp_type) {
 -	case QUARK_X1000_SSP:
 -		return RX_THRESH_QUARK_X1000_DFLT;
 -	default:
 -		return RX_THRESH_DFLT;
 -	}
 -}
 -
 -static bool pxa2xx_spi_txfifo_full(const struct driver_data *drv_data)
 -{
 -	u32 mask;
 -
 -	switch (drv_data->ssp_type) {
 -	case QUARK_X1000_SSP:
 -		mask = QUARK_X1000_SSSR_TFL_MASK;
 -		break;
 -	default:
 -		mask = SSSR_TFL_MASK;
 -		break;
 -	}
 -
 -	return (pxa2xx_spi_read(drv_data, SSSR) & mask) == mask;
 -}
 -
 -static void pxa2xx_spi_clear_rx_thre(const struct driver_data *drv_data,
 -				     u32 *sccr1_reg)
 -{
 -	u32 mask;
 -
 -	switch (drv_data->ssp_type) {
 -	case QUARK_X1000_SSP:
 -		mask = QUARK_X1000_SSCR1_RFT;
 -		break;
 -	default:
 -		mask = SSCR1_RFT;
 -		break;
 -	}
 -	*sccr1_reg &= ~mask;
 -}
 -
 -static void pxa2xx_spi_set_rx_thre(const struct driver_data *drv_data,
 -				   u32 *sccr1_reg, u32 threshold)
 -{
 -	switch (drv_data->ssp_type) {
 -	case QUARK_X1000_SSP:
 -		*sccr1_reg |= QUARK_X1000_SSCR1_RxTresh(threshold);
 -		break;
 -	default:
 -		*sccr1_reg |= SSCR1_RxTresh(threshold);
 -		break;
 -	}
 -}
 -
 -static u32 pxa2xx_configure_sscr0(const struct driver_data *drv_data,
 -				  u32 clk_div, u8 bits)
 -{
 -	switch (drv_data->ssp_type) {
 -	case QUARK_X1000_SSP:
 -		return clk_div
 -			| QUARK_X1000_SSCR0_Motorola
 -			| QUARK_X1000_SSCR0_DataSize(bits > 32 ? 8 : bits)
 -			| SSCR0_SSE;
 -	default:
 -		return clk_div
 -			| SSCR0_Motorola
 -			| SSCR0_DataSize(bits > 16 ? bits - 16 : bits)
 -			| SSCR0_SSE
 -			| (bits > 16 ? SSCR0_EDSS : 0);
 -	}
 +	return drv_data->ssp_type == LPSS_SSP;
  }
  
  /*
@@@ -105,59 -231,34 +156,81 @@@ static void __lpss_ssp_write_priv(struc
   */
  static void lpss_ssp_setup(struct driver_data *drv_data)
  {
- 	unsigned offset = 0x400;
- 	u32 value, orig;
+ 	const struct lpss_config *config;
+ 	u32 value;
  
++<<<<<<< HEAD
 +	if (!is_lpss_ssp(drv_data))
 +		return;
 +
 +	/*
 +	 * Perform auto-detection of the LPSS SSP private registers. They
 +	 * can be either at 1k or 2k offset from the base address.
 +	 */
 +	orig = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
 +
 +	/* Test SPI_CS_CONTROL_SW_MODE bit enabling */
 +	value = orig | SPI_CS_CONTROL_SW_MODE;
 +	writel(value, drv_data->ioaddr + offset + SPI_CS_CONTROL);
 +	value = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
 +	if (value != (orig | SPI_CS_CONTROL_SW_MODE)) {
 +		offset = 0x800;
 +		goto detection_done;
 +	}
 +
 +	orig = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
 +
 +	/* Test SPI_CS_CONTROL_SW_MODE bit disabling */
 +	value = orig & ~SPI_CS_CONTROL_SW_MODE;
 +	writel(value, drv_data->ioaddr + offset + SPI_CS_CONTROL);
 +	value = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
 +	if (value != (orig & ~SPI_CS_CONTROL_SW_MODE)) {
 +		offset = 0x800;
 +		goto detection_done;
 +	}
 +
 +detection_done:
 +	/* Now set the LPSS base */
 +	drv_data->lpss_base = drv_data->ioaddr + offset;
++=======
+ 	config = lpss_get_config(drv_data);
+ 	drv_data->lpss_base = drv_data->ioaddr + config->offset;
++>>>>>>> dccf7369652f (spi: pxa2xx: Prepare for new Intel LPSS SPI type)
  
  	/* Enable software chip select control */
  	value = SPI_CS_CONTROL_SW_MODE | SPI_CS_CONTROL_CS_HIGH;
- 	__lpss_ssp_write_priv(drv_data, SPI_CS_CONTROL, value);
+ 	__lpss_ssp_write_priv(drv_data, config->reg_cs_ctrl, value);
  
  	/* Enable multiblock DMA transfers */
++<<<<<<< HEAD
 +	if (drv_data->master_info->enable_dma)
 +		__lpss_ssp_write_priv(drv_data, SSP_REG, 1);
++=======
+ 	if (drv_data->master_info->enable_dma) {
+ 		__lpss_ssp_write_priv(drv_data, config->reg_ssp, 1);
+ 
+ 		value = __lpss_ssp_read_priv(drv_data, config->reg_general);
+ 		value |= GENERAL_REG_RXTO_HOLDOFF_DISABLE;
+ 		__lpss_ssp_write_priv(drv_data, config->reg_general, value);
+ 	}
++>>>>>>> dccf7369652f (spi: pxa2xx: Prepare for new Intel LPSS SPI type)
  }
  
  static void lpss_ssp_cs_control(struct driver_data *drv_data, bool enable)
  {
+ 	const struct lpss_config *config;
  	u32 value;
  
++<<<<<<< HEAD
 +	if (!is_lpss_ssp(drv_data))
 +		return;
 +
 +	value = __lpss_ssp_read_priv(drv_data, SPI_CS_CONTROL);
++=======
+ 	config = lpss_get_config(drv_data);
+ 
+ 	value = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);
++>>>>>>> dccf7369652f (spi: pxa2xx: Prepare for new Intel LPSS SPI type)
  	if (enable)
  		value &= ~SPI_CS_CONTROL_CS_HIGH;
  	else
@@@ -875,11 -1095,20 +949,28 @@@ static int setup(struct spi_device *spi
  	unsigned int clk_div;
  	uint tx_thres, tx_hi_thres, rx_thres;
  
++<<<<<<< HEAD
 +	if (is_lpss_ssp(drv_data)) {
 +		tx_thres = LPSS_TX_LOTHRESH_DFLT;
 +		tx_hi_thres = LPSS_TX_HITHRESH_DFLT;
 +		rx_thres = LPSS_RX_THRESH_DFLT;
 +	} else {
++=======
+ 	switch (drv_data->ssp_type) {
+ 	case QUARK_X1000_SSP:
+ 		tx_thres = TX_THRESH_QUARK_X1000_DFLT;
+ 		tx_hi_thres = 0;
+ 		rx_thres = RX_THRESH_QUARK_X1000_DFLT;
+ 		break;
+ 	case LPSS_LPT_SSP:
+ 	case LPSS_BYT_SSP:
+ 		config = lpss_get_config(drv_data);
+ 		tx_thres = config->tx_threshold_lo;
+ 		tx_hi_thres = config->tx_threshold_hi;
+ 		rx_thres = config->rx_threshold;
+ 		break;
+ 	default:
++>>>>>>> dccf7369652f (spi: pxa2xx: Prepare for new Intel LPSS SPI type)
  		tx_thres = TX_THRESH_DFLT;
  		tx_hi_thres = 0;
  		rx_thres = RX_THRESH_DFLT;
diff --cc include/linux/pxa2xx_ssp.h
index 467cc6307b62,0485bab061fd..000000000000
--- a/include/linux/pxa2xx_ssp.h
+++ b/include/linux/pxa2xx_ssp.h
@@@ -172,7 -194,9 +172,13 @@@ enum pxa_ssp_type 
  	PXA168_SSP,
  	PXA910_SSP,
  	CE4100_SSP,
++<<<<<<< HEAD
 +	LPSS_SSP,
++=======
+ 	QUARK_X1000_SSP,
+ 	LPSS_LPT_SSP, /* Keep LPSS types sorted with lpss_platforms[] */
+ 	LPSS_BYT_SSP,
++>>>>>>> dccf7369652f (spi: pxa2xx: Prepare for new Intel LPSS SPI type)
  };
  
  struct ssp_device {
* Unmerged path drivers/spi/spi-pxa2xx.c
* Unmerged path include/linux/pxa2xx_ssp.h
