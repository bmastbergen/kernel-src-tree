netfilter: tee: select NF_DUP_IPV6 unconditionally

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 08a7f5d3f5c38ed745c3e99ee91975f20562d272
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/08a7f5d3.failed

The NETFILTER_XT_TARGET_TEE option selects NF_DUP_IPV6 whenever
IP6_NF_IPTABLES is enabled, and it ensures that it cannot be
builtin itself if NF_CONNTRACK is a loadable module, as that
is a dependency for NF_DUP_IPV6.

However, NF_DUP_IPV6 can be enabled even if IP6_NF_IPTABLES is
turned off, and it only really depends on IPV6. With the current
check in tee_tg6, we call nf_dup_ipv6() whenever NF_DUP_IPV6
is enabled. This can however be a loadable module which is
unreachable from a built-in xt_TEE:

net/built-in.o: In function `tee_tg6':
:(.text+0x67728): undefined reference to `nf_dup_ipv6'

The bug was originally introduced in the split of the xt_TEE module
into separate modules for ipv4 and ipv6, and two patches tried
to fix it unsuccessfully afterwards.

This is a revert of the the first incorrect attempt to fix it,
going back to depending on IPV6 as the dependency, and we
adapt the 'select' condition accordingly.

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Fixes: bbde9fc1824a ("netfilter: factor out packet duplication for IPv4/IPv6")
Fixes: 116984a316c3 ("netfilter: xt_TEE: use IS_ENABLED(CONFIG_NF_DUP_IPV6)")
Fixes: 74ec4d55c4d2 ("netfilter: fix xt_TEE and xt_TPROXY dependencies")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 08a7f5d3f5c38ed745c3e99ee91975f20562d272)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/Kconfig
#	net/netfilter/xt_TEE.c
diff --cc net/netfilter/Kconfig
index 5b77f171d80e,95e757c377f9..000000000000
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@@ -863,8 -888,10 +863,13 @@@ config NETFILTER_XT_TARGET_REDIREC
  config NETFILTER_XT_TARGET_TEE
  	tristate '"TEE" - packet cloning to alternate destination'
  	depends on NETFILTER_ADVANCED
 -	depends on IPV6 || IPV6=n
 +	depends on (IPV6 || IPV6=n)
  	depends on !NF_CONNTRACK || NF_CONNTRACK
++<<<<<<< HEAD
++=======
+ 	select NF_DUP_IPV4
+ 	select NF_DUP_IPV6 if IPV6
++>>>>>>> 08a7f5d3f5c3 (netfilter: tee: select NF_DUP_IPV6 unconditionally)
  	---help---
  	This option adds a "TEE" target with which a packet can be cloned and
  	this clone be rerouted to another nexthop.
diff --cc net/netfilter/xt_TEE.c
index 1323252c4f67,6e57a3966dc5..000000000000
--- a/net/netfilter/xt_TEE.c
+++ b/net/netfilter/xt_TEE.c
@@@ -132,36 -39,6 +132,39 @@@ tee_tg4(struct sk_buff *skb, const stru
  }
  
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +static bool
 +tee_tg_route6(struct sk_buff *skb, const struct xt_tee_tginfo *info)
 +{
 +	const struct ipv6hdr *iph = ipv6_hdr(skb);
 +	struct net *net = pick_net(skb);
 +	struct dst_entry *dst;
 +	struct flowi6 fl6;
 +
 +	memset(&fl6, 0, sizeof(fl6));
 +	if (info->priv) {
 +		if (info->priv->oif == -1)
 +			return false;
 +		fl6.flowi6_oif = info->priv->oif;
 +	}
 +	fl6.daddr = info->gw.in6;
 +	fl6.flowlabel = ((iph->flow_lbl[0] & 0xF) << 16) |
 +			   (iph->flow_lbl[1] << 8) | iph->flow_lbl[2];
 +	fl6.flowi6_flags = FLOWI_FLAG_KNOWN_NH;
 +	dst = ip6_route_output(net, NULL, &fl6);
 +	if (dst->error) {
 +		dst_release(dst);
 +		return false;
 +	}
 +	skb_dst_drop(skb);
 +	skb_dst_set(skb, dst);
 +	skb->dev      = dst->dev;
 +	skb->protocol = htons(ETH_P_IPV6);
 +	return true;
 +}
 +
++=======
++>>>>>>> 08a7f5d3f5c3 (netfilter: tee: select NF_DUP_IPV6 unconditionally)
  static unsigned int
  tee_tg6(struct sk_buff *skb, const struct xt_action_param *par)
  {
* Unmerged path net/netfilter/Kconfig
* Unmerged path net/netfilter/xt_TEE.c
