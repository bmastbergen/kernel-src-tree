drm/i915/gen9: Calculate plane WM's from state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Roper <matthew.d.roper@intel.com>
commit 33815fa55b31a5de4b197c09926ecab3dfb79732
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/33815fa5.failed

In a future patch we'll want to calculate plane watermarks for in-flight
atomic state rather than the already-committed state.

	Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1463061971-19638-12-git-send-email-matthew.d.roper@intel.com
(cherry picked from commit 33815fa55b31a5de4b197c09926ecab3dfb79732)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index cca54888a5ac,6073fcb70bbe..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2793,113 -3238,56 +2793,149 @@@ static bool skl_ddb_allocation_changed(
  	return false;
  }
  
 +static void skl_compute_wm_global_parameters(struct drm_device *dev,
 +					     struct intel_wm_config *config)
 +{
 +	struct drm_crtc *crtc;
 +	struct drm_plane *plane;
 +
 +	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
 +		config->num_pipes_active += to_intel_crtc(crtc)->active;
 +
 +	/* FIXME: I don't think we need those two global parameters on SKL */
 +	list_for_each_entry(plane, &dev->mode_config.plane_list, head) {
 +		struct intel_plane *intel_plane = to_intel_plane(plane);
 +
 +		config->sprites_enabled |= intel_plane->wm.enabled;
 +		config->sprites_scaled |= intel_plane->wm.scaled;
 +	}
 +}
 +
 +static void skl_compute_wm_pipe_parameters(struct drm_crtc *crtc,
 +					   struct skl_pipe_wm_parameters *p)
 +{
 +	struct drm_device *dev = crtc->dev;
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +	enum pipe pipe = intel_crtc->pipe;
 +	struct drm_plane *plane;
 +	struct drm_framebuffer *fb;
 +	int i = 1; /* Index for sprite planes start */
 +
 +	p->active = intel_crtc->active;
 +	if (p->active) {
 +		p->pipe_htotal = intel_crtc->config->base.adjusted_mode.crtc_htotal;
 +		p->pixel_rate = skl_pipe_pixel_rate(intel_crtc->config);
 +
 +		fb = crtc->primary->state->fb;
 +		if (fb) {
 +			p->plane[0].enabled = true;
 +			p->plane[0].bytes_per_pixel = fb->bits_per_pixel / 8;
 +			p->plane[0].tiling = fb->modifier[0];
 +		} else {
 +			p->plane[0].enabled = false;
 +			p->plane[0].bytes_per_pixel = 0;
 +			p->plane[0].tiling = DRM_FORMAT_MOD_NONE;
 +		}
 +		p->plane[0].horiz_pixels = intel_crtc->config->pipe_src_w;
 +		p->plane[0].vert_pixels = intel_crtc->config->pipe_src_h;
 +		p->plane[0].rotation = crtc->primary->state->rotation;
 +
 +		fb = crtc->cursor->state->fb;
 +		if (fb) {
 +			p->cursor.enabled = true;
 +			p->cursor.bytes_per_pixel = fb->bits_per_pixel / 8;
 +			p->cursor.horiz_pixels = crtc->cursor->state->crtc_w;
 +			p->cursor.vert_pixels = crtc->cursor->state->crtc_h;
 +		} else {
 +			p->cursor.enabled = false;
 +			p->cursor.bytes_per_pixel = 0;
 +			p->cursor.horiz_pixels = 64;
 +			p->cursor.vert_pixels = 64;
 +		}
 +	}
 +
 +	list_for_each_entry(plane, &dev->mode_config.plane_list, head) {
 +		struct intel_plane *intel_plane = to_intel_plane(plane);
 +
 +		if (intel_plane->pipe == pipe &&
 +			plane->type == DRM_PLANE_TYPE_OVERLAY)
 +			p->plane[i++] = intel_plane->wm;
 +	}
 +}
 +
  static bool skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
++<<<<<<< HEAD
 +				 struct skl_pipe_wm_parameters *p,
 +				 struct intel_plane_wm_parameters *p_params,
++=======
+ 				 struct intel_crtc_state *cstate,
+ 				 struct intel_plane_state *intel_pstate,
++>>>>>>> 33815fa55b31 (drm/i915/gen9: Calculate plane WM's from state)
  				 uint16_t ddb_allocation,
  				 int level,
  				 uint16_t *out_blocks, /* out */
  				 uint8_t *out_lines /* out */)
  {
++<<<<<<< HEAD
++=======
+ 	struct drm_plane_state *pstate = &intel_pstate->base;
+ 	struct drm_framebuffer *fb = pstate->fb;
++>>>>>>> 33815fa55b31 (drm/i915/gen9: Calculate plane WM's from state)
  	uint32_t latency = dev_priv->wm.skl_latency[level];
  	uint32_t method1, method2;
  	uint32_t plane_bytes_per_line, plane_blocks_per_line;
  	uint32_t res_blocks, res_lines;
  	uint32_t selected_result;
 -	uint8_t cpp;
 -	uint32_t width = 0, height = 0;
  
 -	if (latency == 0 || !cstate->base.active || !intel_pstate->visible)
 +	if (latency == 0 || !p->active || !p_params->enabled)
  		return false;
  
++<<<<<<< HEAD
 +	method1 = skl_wm_method1(p->pixel_rate,
 +				 p_params->bytes_per_pixel,
 +				 latency);
 +	method2 = skl_wm_method2(p->pixel_rate,
 +				 p->pipe_htotal,
 +				 p_params->horiz_pixels,
 +				 p_params->bytes_per_pixel,
 +				 p_params->tiling,
++=======
+ 	width = drm_rect_width(&intel_pstate->src) >> 16;
+ 	height = drm_rect_height(&intel_pstate->src) >> 16;
+ 
+ 	if (intel_rotation_90_or_270(pstate->rotation))
+ 		swap(width, height);
+ 
+ 	cpp = drm_format_plane_cpp(fb->pixel_format, 0);
+ 	method1 = skl_wm_method1(skl_pipe_pixel_rate(cstate),
+ 				 cpp, latency);
+ 	method2 = skl_wm_method2(skl_pipe_pixel_rate(cstate),
+ 				 cstate->base.adjusted_mode.crtc_htotal,
+ 				 width,
+ 				 cpp,
+ 				 fb->modifier[0],
++>>>>>>> 33815fa55b31 (drm/i915/gen9: Calculate plane WM's from state)
  				 latency);
  
 -	plane_bytes_per_line = width * cpp;
 +	plane_bytes_per_line = p_params->horiz_pixels *
 +					p_params->bytes_per_pixel;
  	plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
  
 -	if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
 -	    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
 +	if (p_params->tiling == I915_FORMAT_MOD_Y_TILED ||
 +	    p_params->tiling == I915_FORMAT_MOD_Yf_TILED) {
  		uint32_t min_scanlines = 4;
  		uint32_t y_tile_minimum;
++<<<<<<< HEAD
 +		if (intel_rotation_90_or_270(p_params->rotation)) {
 +			switch (p_params->bytes_per_pixel) {
++=======
+ 		if (intel_rotation_90_or_270(pstate->rotation)) {
+ 			int cpp = (fb->pixel_format == DRM_FORMAT_NV12) ?
+ 				drm_format_plane_cpp(fb->pixel_format, 1) :
+ 				drm_format_plane_cpp(fb->pixel_format, 0);
+ 
+ 			switch (cpp) {
++>>>>>>> 33815fa55b31 (drm/i915/gen9: Calculate plane WM's from state)
  			case 1:
  				min_scanlines = 16;
  				break;
@@@ -2941,20 -3329,26 +2977,36 @@@
  
  static void skl_compute_wm_level(const struct drm_i915_private *dev_priv,
  				 struct skl_ddb_allocation *ddb,
 -				 struct intel_crtc_state *cstate,
 +				 struct skl_pipe_wm_parameters *p,
 +				 enum pipe pipe,
  				 int level,
 +				 int num_planes,
  				 struct skl_wm_level *result)
  {
++<<<<<<< HEAD
++=======
+ 	struct drm_device *dev = dev_priv->dev;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);
+ 	struct intel_plane *intel_plane;
+ 	struct intel_plane_state *intel_pstate;
++>>>>>>> 33815fa55b31 (drm/i915/gen9: Calculate plane WM's from state)
  	uint16_t ddb_blocks;
 -	enum pipe pipe = intel_crtc->pipe;
 +	int i;
  
 -	for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane) {
 -		int i = skl_wm_plane_id(intel_plane);
++<<<<<<< HEAD
 +	for (i = 0; i < num_planes; i++) {
 +		ddb_blocks = skl_ddb_entry_size(&ddb->plane[pipe][i]);
  
 +		result->plane_en[i] = skl_compute_plane_wm(dev_priv,
 +						p, &p->plane[i],
++=======
+ 		intel_pstate = to_intel_plane_state(intel_plane->base.state);
+ 		ddb_blocks = skl_ddb_entry_size(&ddb->plane[pipe][i]);
+ 
+ 		result->plane_en[i] = skl_compute_plane_wm(dev_priv,
+ 						cstate,
+ 						intel_pstate,
++>>>>>>> 33815fa55b31 (drm/i915/gen9: Calculate plane WM's from state)
  						ddb_blocks,
  						level,
  						&result->plane_res_b[i],
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
