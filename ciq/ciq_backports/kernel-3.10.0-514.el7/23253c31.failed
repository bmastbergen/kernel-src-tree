mei: do not access freed cb in blocking write

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 23253c31c6a7a3c5a437ec31830e2100484c0748
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/23253c31.failed

The mei_cl_write function is giving up on a write cb ownership after it
was sent or queued. The write cb is then freed in the completion
handler. Especially during blocking write mei_cl_write function waits
for the completion handler and then access the freed memory to fetch the
written size.  The quick fix is to store the buffer size prior to
sending, the size is not altered during the flow.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 23253c31c6a7a3c5a437ec31830e2100484c0748)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,1987a201c7f3..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -900,14 -1368,14 +901,21 @@@ int mei_cl_write(struct mei_cl *cl, str
  
  	dev = cl->dev;
  
++<<<<<<< HEAD
 +
 +	buf = &cb->request_buffer;
 +
 +	cl_dbg(dev, cl, "mei_cl_write %d\n", buf->size);
++=======
+ 	buf = &cb->buf;
+ 	size = buf->size;
+ 
+ 	cl_dbg(dev, cl, "size=%d\n", size);
++>>>>>>> 23253c31c6a7 (mei: do not access freed cb in blocking write)
  
 -	rets = pm_runtime_get(dev->dev);
 +	rets = pm_runtime_get(&dev->pdev->dev);
  	if (rets < 0 && rets != -EINPROGRESS) {
 -		pm_runtime_put_noidle(dev->dev);
 +		pm_runtime_put_noidle(&dev->pdev->dev);
  		cl_err(dev, cl, "rpm: get failed %d\n", rets);
  		return rets;
  	}
@@@ -950,21 -1417,21 +958,22 @@@
  	if (rets)
  		goto err;
  
 -	rets = mei_cl_flow_ctrl_reduce(cl);
 -	if (rets)
 -		goto err;
 -
  	cl->writing_state = MEI_WRITING;
  	cb->buf_idx = mei_hdr.length;
 -	cb->completed = mei_hdr.msg_complete == 1;
  
  out:
 -	if (mei_hdr.msg_complete)
 +	if (mei_hdr.msg_complete) {
 +		rets = mei_cl_flow_ctrl_reduce(cl);
 +		if (rets < 0)
 +			goto err;
 +
  		list_add_tail(&cb->list, &dev->write_waiting_list.list);
 -	else
 +	} else {
  		list_add_tail(&cb->list, &dev->write_list.list);
 +	}
 +
  
+ 	cb = NULL;
  	if (blocking && cl->writing_state != MEI_WRITE_COMPLETE) {
  
  		mutex_unlock(&dev->device_lock);
@@@ -979,11 -1446,11 +988,11 @@@
  		}
  	}
  
- 	rets = buf->size;
+ 	rets = size;
  err:
  	cl_dbg(dev, cl, "rpm: autosuspend\n");
 -	pm_runtime_mark_last_busy(dev->dev);
 -	pm_runtime_put_autosuspend(dev->dev);
 +	pm_runtime_mark_last_busy(&dev->pdev->dev);
 +	pm_runtime_put_autosuspend(&dev->pdev->dev);
  
  	return rets;
  }
* Unmerged path drivers/misc/mei/client.c
