sctp: signal sk_data_ready earlier on data chunks reception

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit 0970f5b3665933f5f0d069607c78fb10bd918b62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0970f5b3.failed

Dave Miller pointed out that fb586f25300f ("sctp: delay calls to
sk_data_ready() as much as possible") may insert latency specially if
the receiving application is running on another CPU and that it would be
better if we signalled as early as possible.

This patch thus basically inverts the logic on fb586f25300f and signals
it as early as possible, similar to what we had before.

Fixes: fb586f25300f ("sctp: delay calls to sk_data_ready() as much as possible")
	Reported-by: Dave Miller <davem@davemloft.net>
	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0970f5b3665933f5f0d069607c78fb10bd918b62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sctp/structs.h
#	net/sctp/sm_sideeffect.c
#	net/sctp/ulpqueue.c
diff --cc include/net/sctp/structs.h
index f67eb807b1dd,16b013a6191c..000000000000
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@@ -218,14 -206,19 +218,24 @@@ struct sctp_sock 
  	struct sctp_paddrparams paddrparam;
  	struct sctp_event_subscribe subscribe;
  	struct sctp_assocparams assocparams;
 -
  	int user_frag;
 -
  	__u32 autoclose;
 +	__u8 nodelay;
 +	__u8 disable_fragments;
 +	__u8 v4mapped;
 +	__u8 frag_interleave;
  	__u32 adaptation_ind;
  	__u32 pd_point;
++<<<<<<< HEAD
++=======
+ 	__u16	nodelay:1,
+ 		disable_fragments:1,
+ 		v4mapped:1,
+ 		frag_interleave:1,
+ 		recvrcvinfo:1,
+ 		recvnxtinfo:1,
+ 		data_ready_signalled:1;
++>>>>>>> 0970f5b36659 (sctp: signal sk_data_ready earlier on data chunks reception)
  
  	atomic_t pd_mode;
  	/* Receive to here while partial delivery is in effect. */
diff --cc net/sctp/sm_sideeffect.c
index 3850ffd28208,aa3712259368..000000000000
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@@ -1768,9 -1737,13 +1768,17 @@@ out
  	 */
  	if (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {
  		if (chunk->end_of_packet || chunk->singleton)
 -			error = sctp_outq_uncork(&asoc->outqueue, gfp);
 +			error = sctp_outq_uncork(&asoc->outqueue);
  	} else if (local_cork)
++<<<<<<< HEAD
 +		error = sctp_outq_uncork(&asoc->outqueue);
++=======
+ 		error = sctp_outq_uncork(&asoc->outqueue, gfp);
+ 
+ 	if (sp->data_ready_signalled)
+ 		sp->data_ready_signalled = 0;
+ 
++>>>>>>> 0970f5b36659 (sctp: signal sk_data_ready earlier on data chunks reception)
  	return error;
  nomem:
  	error = -ENOMEM;
diff --cc net/sctp/ulpqueue.c
index 04e3d470f877,ec166d2bd2d9..000000000000
--- a/net/sctp/ulpqueue.c
+++ b/net/sctp/ulpqueue.c
@@@ -211,8 -207,12 +212,8 @@@ int sctp_ulpq_tail_event(struct sctp_ul
  	if (sock_flag(sk, SOCK_DEAD) || (sk->sk_shutdown & RCV_SHUTDOWN))
  		goto out_free;
  
 -	if (!sctp_ulpevent_is_notification(event)) {
 -		sk_mark_napi_id(sk, skb);
 -		sk_incoming_cpu_update(sk);
 -	}
  	/* Check if the user wishes to receive this event.  */
- 	if (!sctp_ulpevent_is_enabled(event, &sctp_sk(sk)->subscribe))
+ 	if (!sctp_ulpevent_is_enabled(event, &sp->subscribe))
  		goto out_free;
  
  	/* If we are in partial delivery mode, post to the lobby until
@@@ -265,8 -265,10 +266,15 @@@
  	if (clear_pd)
  		sctp_ulpq_clear_pd(ulpq);
  
++<<<<<<< HEAD
 +	if (queue == &sk->sk_receive_queue)
 +		sk->sk_data_ready(sk, 0);
++=======
+ 	if (queue == &sk->sk_receive_queue && !sp->data_ready_signalled) {
+ 		sp->data_ready_signalled = 1;
+ 		sk->sk_data_ready(sk);
+ 	}
++>>>>>>> 0970f5b36659 (sctp: signal sk_data_ready earlier on data chunks reception)
  	return 1;
  
  out_free:
@@@ -1140,6 -1145,8 +1150,13 @@@ void sctp_ulpq_abort_pd(struct sctp_ulp
  		__skb_queue_tail(&sk->sk_receive_queue, sctp_event2skb(ev));
  
  	/* If there is data waiting, send it up the socket now. */
++<<<<<<< HEAD
 +	if (sctp_ulpq_clear_pd(ulpq) || ev)
 +		sk->sk_data_ready(sk, 0);
++=======
+ 	if ((sctp_ulpq_clear_pd(ulpq) || ev) && !sp->data_ready_signalled) {
+ 		sp->data_ready_signalled = 1;
+ 		sk->sk_data_ready(sk);
+ 	}
++>>>>>>> 0970f5b36659 (sctp: signal sk_data_ready earlier on data chunks reception)
  }
* Unmerged path include/net/sctp/structs.h
* Unmerged path net/sctp/sm_sideeffect.c
* Unmerged path net/sctp/ulpqueue.c
