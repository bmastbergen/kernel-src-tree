zram: correct offset usage in zram_bio_discard

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Weijie Yang <weijie.yang@samsung.com>
commit 38515c73398a4c58059ecf1087e844561b58ee0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/38515c73.failed

We want to skip the physical block(PAGE_SIZE) which is partially covered
by the discard bio, so we check the remaining size and subtract it if
there is a need to goto the next physical block.

The current offset usage in zram_bio_discard is incorrect, it will cause
its upper filesystem breakdown.  Consider the following scenario:

On some architecture or config, PAGE_SIZE is 64K for example, filesystem
is set up on zram disk without PAGE_SIZE aligned, a discard bio leads to a
offset = 4K and size=72K, normally, it should not really discard any
physical block as it partially cover two physical blocks.  However, with
the current offset usage, it will discard the second physical block and
free its memory, which will cause filesystem breakdown.

This patch corrects the offset usage in zram_bio_discard.

	Signed-off-by: Weijie Yang <weijie.yang@samsung.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Nitin Gupta <ngupta@vflare.org>
	Acked-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Cc: Bob Liu <bob.liu@oracle.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 38515c73398a4c58059ecf1087e844561b58ee0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index b625e985f469,48eccb350180..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -546,6 -551,47 +546,50 @@@ static int zram_bvec_rw(struct zram *zr
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * zram_bio_discard - handler on discard request
+  * @index: physical block index in PAGE_SIZE units
+  * @offset: byte offset within physical block
+  */
+ static void zram_bio_discard(struct zram *zram, u32 index,
+ 			     int offset, struct bio *bio)
+ {
+ 	size_t n = bio->bi_iter.bi_size;
+ 
+ 	/*
+ 	 * zram manages data in physical block size units. Because logical block
+ 	 * size isn't identical with physical block size on some arch, we
+ 	 * could get a discard request pointing to a specific offset within a
+ 	 * certain physical block.  Although we can handle this request by
+ 	 * reading that physiclal block and decompressing and partially zeroing
+ 	 * and re-compressing and then re-storing it, this isn't reasonable
+ 	 * because our intent with a discard request is to save memory.  So
+ 	 * skipping this logical block is appropriate here.
+ 	 */
+ 	if (offset) {
+ 		if (n <= (PAGE_SIZE - offset))
+ 			return;
+ 
+ 		n -= (PAGE_SIZE - offset);
+ 		index++;
+ 	}
+ 
+ 	while (n >= PAGE_SIZE) {
+ 		/*
+ 		 * Discard request can be large so the lock hold times could be
+ 		 * lengthy.  So take the lock once per page.
+ 		 */
+ 		write_lock(&zram->meta->tb_lock);
+ 		zram_free_page(zram, index);
+ 		write_unlock(&zram->meta->tb_lock);
+ 		index++;
+ 		n -= PAGE_SIZE;
+ 	}
+ }
+ 
++>>>>>>> 38515c73398a (zram: correct offset usage in zram_bio_discard)
  static void zram_reset_device(struct zram *zram, bool reset_capacity)
  {
  	size_t index;
* Unmerged path drivers/block/zram/zram_drv.c
