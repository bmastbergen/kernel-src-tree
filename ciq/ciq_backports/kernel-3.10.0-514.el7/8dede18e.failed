mmc: core: Refactor code to register the MMC PM notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit 8dede18e2e86c8e272cd74e66b0e86872cbe7e02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8dede18e.failed

Instead of checking for "#ifdef" directly in the code, let's invent a pair
of mmc core functions to deal with register/unregister the MMC PM notifier
block. Implement stubs for these functions when CONFIG_PM_SLEEP is unset,
as in that case the PM notifiers isn't used.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 8dede18e2e86c8e272cd74e66b0e86872cbe7e02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.h
#	drivers/mmc/core/host.c
diff --cc drivers/mmc/core/core.h
index f712f6e0bc34,bd00ac2cdc1b..000000000000
--- a/drivers/mmc/core/core.h
+++ b/drivers/mmc/core/core.h
@@@ -84,5 -85,18 +84,21 @@@ void mmc_add_card_debugfs(struct mmc_ca
  void mmc_remove_card_debugfs(struct mmc_card *card);
  
  void mmc_init_context_info(struct mmc_host *host);
++<<<<<<< HEAD
++=======
+ 
+ int mmc_execute_tuning(struct mmc_card *card);
+ int mmc_hs200_to_hs400(struct mmc_card *card);
+ int mmc_hs400_to_hs200(struct mmc_card *card);
+ 
+ #ifdef CONFIG_PM_SLEEP
+ void mmc_register_pm_notifier(struct mmc_host *host);
+ void mmc_unregister_pm_notifier(struct mmc_host *host);
+ #else
+ static void mmc_register_pm_notifier(struct mmc_host *host) { }
+ static void mmc_unregister_pm_notifier(struct mmc_host *host) { }
+ #endif
+ 
++>>>>>>> 8dede18e2e86 (mmc: core: Refactor code to register the MMC PM notifier)
  #endif
  
diff --cc drivers/mmc/core/host.c
index 1ef8c2a03585,0aecd5c00b86..000000000000
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@@ -515,9 -348,7 +514,13 @@@ struct mmc_host *mmc_alloc_host(int ext
  	spin_lock_init(&host->lock);
  	init_waitqueue_head(&host->wq);
  	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
++<<<<<<< HEAD
 +#ifdef CONFIG_PM
 +	host->pm_notify.notifier_call = mmc_pm_notify;
 +#endif
++=======
+ 	setup_timer(&host->retune_timer, mmc_retune_timer, (unsigned long)host);
++>>>>>>> 8dede18e2e86 (mmc: core: Refactor code to register the MMC PM notifier)
  
  	/*
  	 * By default, hosts do not support SGIO or large requests.
@@@ -563,10 -390,9 +566,10 @@@ int mmc_add_host(struct mmc_host *host
  #ifdef CONFIG_DEBUG_FS
  	mmc_add_host_debugfs(host);
  #endif
 +	mmc_host_clk_sysfs_init(host);
  
  	mmc_start_host(host);
- 	register_pm_notifier(&host->pm_notify);
+ 	mmc_register_pm_notifier(host);
  
  	return 0;
  }
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bcb8d46a75ae..9637ea195030 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2813,14 +2813,13 @@ int mmc_flush_cache(struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_flush_cache);
 
-#ifdef CONFIG_PM
-
+#ifdef CONFIG_PM_SLEEP
 /* Do the card removal on suspend if card is assumed removeable
  * Do that in pm notifier while userspace isn't yet frozen, so we will be able
    to sync the card.
 */
-int mmc_pm_notify(struct notifier_block *notify_block,
-					unsigned long mode, void *unused)
+static int mmc_pm_notify(struct notifier_block *notify_block,
+			unsigned long mode, void *unused)
 {
 	struct mmc_host *host = container_of(
 		notify_block, struct mmc_host, pm_notify);
@@ -2867,6 +2866,17 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 
 	return 0;
 }
+
+void mmc_register_pm_notifier(struct mmc_host *host)
+{
+	host->pm_notify.notifier_call = mmc_pm_notify;
+	register_pm_notifier(&host->pm_notify);
+}
+
+void mmc_unregister_pm_notifier(struct mmc_host *host)
+{
+	unregister_pm_notifier(&host->pm_notify);
+}
 #endif
 
 /**
* Unmerged path drivers/mmc/core/core.h
* Unmerged path drivers/mmc/core/host.c
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f50d9ac623df..fbe856de9418 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -210,7 +210,9 @@ struct mmc_host {
 	u32			ocr_avail_sdio;	/* SDIO-specific OCR */
 	u32			ocr_avail_sd;	/* SD-specific OCR */
 	u32			ocr_avail_mmc;	/* MMC-specific OCR */
+#ifdef CONFIG_PM_SLEEP
 	struct notifier_block	pm_notify;
+#endif
 	u32			max_current_330;
 	u32			max_current_300;
 	u32			max_current_180;
@@ -427,8 +429,6 @@ static inline int mmc_regulator_set_vqmmc(struct mmc_host *mmc,
 
 int mmc_regulator_get_supply(struct mmc_host *mmc);
 
-int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
-
 static inline int mmc_card_is_removable(struct mmc_host *host)
 {
 	return !(host->caps & MMC_CAP_NONREMOVABLE);
