lwt: Add support to redirect dst.input

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] lwtunnel: Add support to redirect dst.input (Lance Richardson) [1283886]
Rebuild_FUZZ: 93.83%
commit-author Tom Herbert <tom@herbertland.com>
commit 2536862311d2276454ddef9dc36d6551a4b400fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/25368623.failed

This patch adds the capability to redirect dst input in the same way
that dst output is redirected by LWT.

Also, save the original dst.input and and dst.out when setting up
lwtunnel redirection. These can be called by the client as a pass-
through.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2536862311d2276454ddef9dc36d6551a4b400fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/lwtunnel.h
#	net/core/lwtunnel.c
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index 1b3524b3978c,c3733049715e..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1610,12 -1777,28 +1610,33 @@@ int ip6_route_add(struct fib6_config *c
  
  	rt->dst.output = ip6_output;
  
++<<<<<<< HEAD
++=======
+ 	if (cfg->fc_encap) {
+ 		struct lwtunnel_state *lwtstate;
+ 
+ 		err = lwtunnel_build_state(dev, cfg->fc_encap_type,
+ 					   cfg->fc_encap, &lwtstate);
+ 		if (err)
+ 			goto out;
+ 		rt->rt6i_lwtstate = lwtstate_get(lwtstate);
+ 		if (lwtunnel_output_redirect(rt->rt6i_lwtstate)) {
+ 			rt->rt6i_lwtstate->orig_output = rt->dst.output;
+ 			rt->dst.output = lwtunnel_output6;
+ 		}
+ 		if (lwtunnel_input_redirect(rt->rt6i_lwtstate)) {
+ 			rt->rt6i_lwtstate->orig_input = rt->dst.input;
+ 			rt->dst.input = lwtunnel_input6;
+ 		}
+ 	}
+ 
++>>>>>>> 2536862311d2 (lwt: Add support to redirect dst.input)
  	ipv6_addr_prefix(&rt->rt6i_dst.addr, &cfg->fc_dst, cfg->fc_dst_len);
  	rt->rt6i_dst.plen = cfg->fc_dst_len;
 -	if (rt->rt6i_dst.plen == 128)
 +	if (rt->rt6i_dst.plen == 128) {
  		rt->dst.flags |= DST_HOST;
 +		dst_metrics_set_force_overwrite(&rt->dst);
 +	}
  
  #ifdef CONFIG_IPV6_SUBTREES
  	ipv6_addr_prefix(&rt->rt6i_src.addr, &cfg->fc_src, cfg->fc_src_len);
* Unmerged path include/net/lwtunnel.h
* Unmerged path net/core/lwtunnel.c
* Unmerged path include/net/lwtunnel.h
* Unmerged path net/core/lwtunnel.c
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 31700d4dc025..e169b209fc03 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1600,8 +1600,14 @@ static int __mkroute_input(struct sk_buff *skb,
 	rth->dst.output = ip_output;
 
 	rt_set_nexthop(rth, daddr, res, fnhe, res->fi, res->type, itag);
-	if (lwtunnel_output_redirect(rth->rt_lwtstate))
+	if (lwtunnel_output_redirect(rth->rt_lwtstate)) {
+		rth->rt_lwtstate->orig_output = rth->dst.output;
 		rth->dst.output = lwtunnel_output;
+	}
+	if (lwtunnel_input_redirect(rth->rt_lwtstate)) {
+		rth->rt_lwtstate->orig_input = rth->dst.input;
+		rth->dst.input = lwtunnel_input;
+	}
 	skb_dst_set(skb, &rth->dst);
 out:
 	err = 0;
* Unmerged path net/ipv6/route.c
