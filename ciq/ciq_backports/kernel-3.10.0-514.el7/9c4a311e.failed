staging/rdma/hfi1: Remove create and free mad agents

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Remove create and free mad agents (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 91.67%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 9c4a311e6ca03db4e16c4c06bb37a1189ba0bc03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9c4a311e.failed

Get rid of create and free mad agent from the driver and use rdmavt
version.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9c4a311e6ca03db4e16c4c06bb37a1189ba0bc03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/mad.c
#	drivers/staging/hfi1/verbs.c
#	drivers/staging/rdma/hfi1/verbs.h
diff --cc drivers/staging/hfi1/mad.c
index a26383d2332e,9cadf77427a2..000000000000
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@@ -127,26 -128,26 +127,36 @@@ static void send_trap(struct hfi1_ibpor
  	/* o14-1: smp->mkey = 0; */
  	memcpy(smp->route.lid.data, data, len);
  
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +	spin_lock_irqsave(&ibp->lock, flags);
 +	if (!ibp->sm_ah) {
 +		if (ibp->sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {
++=======
+ 	spin_lock_irqsave(&ibp->rvp.lock, flags);
+ 	if (!ibp->rvp.sm_ah) {
+ 		if (ibp->rvp.sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {
++>>>>>>> 9c4a311e6ca0 (staging/rdma/hfi1: Remove create and free mad agents):drivers/staging/rdma/hfi1/mad.c
  			struct ib_ah *ah;
  
 -			ah = hfi1_create_qp0_ah(ibp, ibp->rvp.sm_lid);
 +			ah = hfi1_create_qp0_ah(ibp, ibp->sm_lid);
  			if (IS_ERR(ah))
  				ret = PTR_ERR(ah);
  			else {
  				send_buf->ah = ah;
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +				ibp->sm_ah = to_iah(ah);
++=======
+ 				ibp->rvp.sm_ah = ibah_to_rvtah(ah);
++>>>>>>> 9c4a311e6ca0 (staging/rdma/hfi1: Remove create and free mad agents):drivers/staging/rdma/hfi1/mad.c
  				ret = 0;
  			}
  		} else
  			ret = -EINVAL;
  	} else {
- 		send_buf->ah = &ibp->sm_ah->ibah;
+ 		send_buf->ah = &ibp->rvp.sm_ah->ibah;
  		ret = 0;
  	}
 -	spin_unlock_irqrestore(&ibp->rvp.lock, flags);
 +	spin_unlock_irqrestore(&ibp->lock, flags);
  
  	if (!ret)
  		ret = ib_post_send_mad(send_buf, NULL);
@@@ -1130,23 -1132,23 +1140,32 @@@ static int __subn_set_opa_portinfo(stru
  
  	/* Must be a valid unicast LID address. */
  	if ((smlid == 0 && ls_old > IB_PORT_INIT) ||
 -	     smlid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) {
 +	     smlid >= HFI1_MULTICAST_LID_BASE) {
  		smp->status |= IB_SMP_INVALID_FIELD;
  		pr_warn("SubnSet(OPA_PortInfo) smlid invalid 0x%x\n", smlid);
 -	} else if (smlid != ibp->rvp.sm_lid || msl != ibp->rvp.sm_sl) {
 +	} else if (smlid != ibp->sm_lid || msl != ibp->sm_sl) {
  		pr_warn("SubnSet(OPA_PortInfo) smlid 0x%x\n", smlid);
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +		spin_lock_irqsave(&ibp->lock, flags);
 +		if (ibp->sm_ah) {
 +			if (smlid != ibp->sm_lid)
 +				ibp->sm_ah->attr.dlid = smlid;
 +			if (msl != ibp->sm_sl)
 +				ibp->sm_ah->attr.sl = msl;
++=======
+ 		spin_lock_irqsave(&ibp->rvp.lock, flags);
+ 		if (ibp->rvp.sm_ah) {
+ 			if (smlid != ibp->rvp.sm_lid)
+ 				ibp->rvp.sm_ah->attr.dlid = smlid;
+ 			if (msl != ibp->rvp.sm_sl)
+ 				ibp->rvp.sm_ah->attr.sl = msl;
++>>>>>>> 9c4a311e6ca0 (staging/rdma/hfi1: Remove create and free mad agents):drivers/staging/rdma/hfi1/mad.c
  		}
 -		spin_unlock_irqrestore(&ibp->rvp.lock, flags);
 -		if (smlid != ibp->rvp.sm_lid)
 -			ibp->rvp.sm_lid = smlid;
 -		if (msl != ibp->rvp.sm_sl)
 -			ibp->rvp.sm_sl = msl;
 +		spin_unlock_irqrestore(&ibp->lock, flags);
 +		if (smlid != ibp->sm_lid)
 +			ibp->sm_lid = smlid;
 +		if (msl != ibp->sm_sl)
 +			ibp->sm_sl = msl;
  		event.event = IB_EVENT_SM_CHANGE;
  		ib_dispatch_event(&event);
  	}
@@@ -4154,66 -4157,3 +4173,69 @@@ int hfi1_process_mad(struct ib_device *
  
  	return IB_MAD_RESULT_FAILURE;
  }
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +
 +static void send_handler(struct ib_mad_agent *agent,
 +			 struct ib_mad_send_wc *mad_send_wc)
 +{
 +	ib_free_send_mad(mad_send_wc->send_buf);
 +}
 +
 +int hfi1_create_agents(struct hfi1_ibdev *dev)
 +{
 +	struct hfi1_devdata *dd = dd_from_dev(dev);
 +	struct ib_mad_agent *agent;
 +	struct hfi1_ibport *ibp;
 +	int p;
 +	int ret;
 +
 +	for (p = 0; p < dd->num_pports; p++) {
 +		ibp = &dd->pport[p].ibport_data;
 +		agent = ib_register_mad_agent(&dev->ibdev, p + 1, IB_QPT_SMI,
 +					      NULL, 0, send_handler,
 +					      NULL, NULL, 0);
 +		if (IS_ERR(agent)) {
 +			ret = PTR_ERR(agent);
 +			goto err;
 +		}
 +
 +		ibp->send_agent = agent;
 +	}
 +
 +	return 0;
 +
 +err:
 +	for (p = 0; p < dd->num_pports; p++) {
 +		ibp = &dd->pport[p].ibport_data;
 +		if (ibp->send_agent) {
 +			agent = ibp->send_agent;
 +			ibp->send_agent = NULL;
 +			ib_unregister_mad_agent(agent);
 +		}
 +	}
 +
 +	return ret;
 +}
 +
 +void hfi1_free_agents(struct hfi1_ibdev *dev)
 +{
 +	struct hfi1_devdata *dd = dd_from_dev(dev);
 +	struct ib_mad_agent *agent;
 +	struct hfi1_ibport *ibp;
 +	int p;
 +
 +	for (p = 0; p < dd->num_pports; p++) {
 +		ibp = &dd->pport[p].ibport_data;
 +		if (ibp->send_agent) {
 +			agent = ibp->send_agent;
 +			ibp->send_agent = NULL;
 +			ib_unregister_mad_agent(agent);
 +		}
 +		if (ibp->sm_ah) {
 +			ib_destroy_ah(&ibp->sm_ah->ibah);
 +			ibp->sm_ah = NULL;
 +		}
 +	}
 +}
++=======
++>>>>>>> 9c4a311e6ca0 (staging/rdma/hfi1: Remove create and free mad agents):drivers/staging/rdma/hfi1/mad.c
diff --cc drivers/staging/hfi1/verbs.c
index d228eb7fc4f0,68f4045dfa99..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -2000,33 -1527,82 +2000,32 @@@ int hfi1_register_ib_device(struct hfi1
  	strncpy(ibdev->node_desc, init_utsname()->nodename,
  		sizeof(ibdev->node_desc));
  
 -	/*
 -	 * Fill in rvt info object.
 -	 */
 -	dd->verbs_dev.rdi.driver_f.port_callback = hfi1_create_port_files;
 -	dd->verbs_dev.rdi.driver_f.get_card_name = get_card_name;
 -	dd->verbs_dev.rdi.driver_f.get_pci_dev = get_pci_dev;
 -	dd->verbs_dev.rdi.driver_f.check_ah = hfi1_check_ah;
 -	dd->verbs_dev.rdi.driver_f.notify_new_ah = hfi1_notify_new_ah;
 -	/*
 -	 * Fill in rvt info device attributes.
 -	 */
 -	hfi1_fill_device_attr(dd);
 -
 -	/* queue pair */
 -	dd->verbs_dev.rdi.dparms.qp_table_size = hfi1_qp_table_size;
 -	dd->verbs_dev.rdi.dparms.qpn_start = 0;
 -	dd->verbs_dev.rdi.dparms.qpn_inc = 1;
 -	dd->verbs_dev.rdi.dparms.qos_shift = dd->qos_shift;
 -	dd->verbs_dev.rdi.dparms.qpn_res_start = kdeth_qp << 16;
 -	dd->verbs_dev.rdi.dparms.qpn_res_end =
 -	dd->verbs_dev.rdi.dparms.qpn_res_start + 65535;
 -	dd->verbs_dev.rdi.dparms.max_rdma_atomic = HFI1_MAX_RDMA_ATOMIC;
 -	dd->verbs_dev.rdi.dparms.psn_mask = PSN_MASK;
 -	dd->verbs_dev.rdi.dparms.psn_shift = PSN_SHIFT;
 -	dd->verbs_dev.rdi.dparms.psn_modify_mask = PSN_MODIFY_MASK;
 -	dd->verbs_dev.rdi.driver_f.qp_priv_alloc = qp_priv_alloc;
 -	dd->verbs_dev.rdi.driver_f.qp_priv_free = qp_priv_free;
 -	dd->verbs_dev.rdi.driver_f.free_all_qps = free_all_qps;
 -	dd->verbs_dev.rdi.driver_f.notify_qp_reset = notify_qp_reset;
 -	dd->verbs_dev.rdi.driver_f.do_send = hfi1_do_send;
 -	dd->verbs_dev.rdi.driver_f.schedule_send = hfi1_schedule_send;
 -	dd->verbs_dev.rdi.driver_f.get_pmtu_from_attr = get_pmtu_from_attr;
 -	dd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;
 -	dd->verbs_dev.rdi.driver_f.flush_qp_waiters = flush_qp_waiters;
 -	dd->verbs_dev.rdi.driver_f.stop_send_queue = stop_send_queue;
 -	dd->verbs_dev.rdi.driver_f.quiesce_qp = quiesce_qp;
 -	dd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;
 -	dd->verbs_dev.rdi.driver_f.mtu_from_qp = mtu_from_qp;
 -	dd->verbs_dev.rdi.driver_f.mtu_to_path_mtu = mtu_to_path_mtu;
 -	dd->verbs_dev.rdi.driver_f.check_modify_qp = hfi1_check_modify_qp;
 -	dd->verbs_dev.rdi.driver_f.modify_qp = hfi1_modify_qp;
 -
 -	/* completeion queue */
 -	snprintf(dd->verbs_dev.rdi.dparms.cq_name,
 -		 sizeof(dd->verbs_dev.rdi.dparms.cq_name),
 -		 "hfi1_cq%d", dd->unit);
 -	dd->verbs_dev.rdi.dparms.node = dd->assigned_node_id;
 -
 -	/* misc settings */
 -	dd->verbs_dev.rdi.flags = 0; /* Let rdmavt handle it all */
 -	dd->verbs_dev.rdi.dparms.lkey_table_size = hfi1_lkey_table_size;
 -	dd->verbs_dev.rdi.dparms.nports = dd->num_pports;
 -	dd->verbs_dev.rdi.dparms.npkeys = hfi1_get_npkeys(dd);
 -
 -	ppd = dd->pport;
 -	for (i = 0; i < dd->num_pports; i++, ppd++)
 -		rvt_init_port(&dd->verbs_dev.rdi,
 -			      &ppd->ibport_data.rvp,
 -			      i,
 -			      ppd->pkeys);
 -
 -	ret = rvt_register_device(&dd->verbs_dev.rdi);
 +	ret = ib_register_device(ibdev, hfi1_create_port_files);
  	if (ret)
- 		goto err_reg;
- 
- 	ret = hfi1_create_agents(dev);
- 	if (ret)
- 		goto err_agents;
+ 		goto err_verbs_txreq;
  
  	ret = hfi1_verbs_register_sysfs(dd);
  	if (ret)
  		goto err_class;
  
- 	goto bail;
+ 	return ret;
  
  err_class:
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	hfi1_free_agents(dev);
 +err_agents:
 +	ib_unregister_device(ibdev);
 +err_reg:
++=======
+ 	rvt_unregister_device(&dd->verbs_dev.rdi);
++>>>>>>> 9c4a311e6ca0 (staging/rdma/hfi1: Remove create and free mad agents):drivers/staging/rdma/hfi1/verbs.c
  err_verbs_txreq:
  	kmem_cache_destroy(dev->verbs_txreq_cache);
 +	vfree(dev->lk_table.table);
 +err_lk:
 +	hfi1_qp_exit(dev);
 +err_qp_init:
  	dd_dev_err(dd, "cannot register verbs: %d!\n", -ret);
- bail:
  	return ret;
  }
  
@@@ -2037,9 -1612,7 +2036,13 @@@ void hfi1_unregister_ib_device(struct h
  
  	hfi1_verbs_unregister_sysfs(dd);
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	hfi1_free_agents(dev);
 +
 +	ib_unregister_device(ibdev);
++=======
+ 	rvt_unregister_device(&dd->verbs_dev.rdi);
++>>>>>>> 9c4a311e6ca0 (staging/rdma/hfi1: Remove create and free mad agents):drivers/staging/rdma/hfi1/verbs.c
  
  	if (!list_empty(&dev->txwait))
  		dd_dev_err(dd, "txwait list not empty!\n");
* Unmerged path drivers/staging/rdma/hfi1/verbs.h
* Unmerged path drivers/staging/hfi1/mad.c
* Unmerged path drivers/staging/hfi1/verbs.c
* Unmerged path drivers/staging/rdma/hfi1/verbs.h
