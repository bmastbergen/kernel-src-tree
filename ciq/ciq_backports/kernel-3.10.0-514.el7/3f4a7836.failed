x86/efi: Rip out phys_efi_get_time()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] efi: Rip out phys_efi_get_time() (Lenny Szubowicz) [1310154]
Rebuild_FUZZ: 94.12%
commit-author Matt Fleming <matt.fleming@intel.com>
commit 3f4a7836e33134d4ac34fa7c99788f0c6a79fa1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3f4a7836.failed

Dan reported that phys_efi_get_time() is doing kmalloc(..., GFP_KERNEL)
under a spinlock which is very clearly a bug. Since phys_efi_get_time()
has no users let's just delete it instead of trying to fix it.

Note that since there are no users of phys_efi_get_time(), it is not
possible to actually trigger a GFP_KERNEL alloc under the spinlock.

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Nathan Zimmer <nzimmer@sgi.com>
	Cc: Matthew Garrett <mjg59@srcf.ucam.org>
	Cc: Jan Beulich <JBeulich@suse.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 3f4a7836e33134d4ac34fa7c99788f0c6a79fa1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/efi/efi.c
diff --cc arch/x86/platform/efi/efi.c
index 4374bb91ee4e,3781dd39e8bd..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -606,6 -556,56 +591,59 @@@ static int __init efi_systab_init(void 
  		       efi.systab->hdr.revision >> 16,
  		       efi.systab->hdr.revision & 0xffff);
  
++<<<<<<< HEAD
++=======
+ 	set_bit(EFI_SYSTEM_TABLES, &efi.flags);
+ 
+ 	return 0;
+ }
+ 
+ static int __init efi_runtime_init32(void)
+ {
+ 	efi_runtime_services_32_t *runtime;
+ 
+ 	runtime = early_ioremap((unsigned long)efi.systab->runtime,
+ 			sizeof(efi_runtime_services_32_t));
+ 	if (!runtime) {
+ 		pr_err("Could not map the runtime service table!\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/*
+ 	 * We will only need *early* access to the following two
+ 	 * EFI runtime services before set_virtual_address_map
+ 	 * is invoked.
+ 	 */
+ 	efi_phys.set_virtual_address_map =
+ 			(efi_set_virtual_address_map_t *)
+ 			(unsigned long)runtime->set_virtual_address_map;
+ 	early_iounmap(runtime, sizeof(efi_runtime_services_32_t));
+ 
+ 	return 0;
+ }
+ 
+ static int __init efi_runtime_init64(void)
+ {
+ 	efi_runtime_services_64_t *runtime;
+ 
+ 	runtime = early_ioremap((unsigned long)efi.systab->runtime,
+ 			sizeof(efi_runtime_services_64_t));
+ 	if (!runtime) {
+ 		pr_err("Could not map the runtime service table!\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/*
+ 	 * We will only need *early* access to the following two
+ 	 * EFI runtime services before set_virtual_address_map
+ 	 * is invoked.
+ 	 */
+ 	efi_phys.set_virtual_address_map =
+ 			(efi_set_virtual_address_map_t *)
+ 			(unsigned long)runtime->set_virtual_address_map;
+ 	early_iounmap(runtime, sizeof(efi_runtime_services_64_t));
+ 
++>>>>>>> 3f4a7836e331 (x86/efi: Rip out phys_efi_get_time())
  	return 0;
  }
  
* Unmerged path arch/x86/platform/efi/efi.c
