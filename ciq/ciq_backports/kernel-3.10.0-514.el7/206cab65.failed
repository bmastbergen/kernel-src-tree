perf stat: Add --metric-only support for -A

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andi Kleen <ak@linux.intel.com>
commit 206cab651d07563d766c7f4cb73f858c5df3dec5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/206cab65.failed

Add metric only support for -A too. This requires a new print function
that prints the metrics in the right order.

v2: Fix manpage
v3: Simplify nrcpus computation

	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
Link: http://lkml.kernel.org/r/1457049458-28956-7-git-send-email-andi@firstfloor.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 206cab651d07563d766c7f4cb73f858c5df3dec5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-stat.txt
#	tools/perf/builtin-stat.c
diff --cc tools/perf/Documentation/perf-stat.txt
index 6f76e661d983,04f23b404bbc..000000000000
--- a/tools/perf/Documentation/perf-stat.txt
+++ b/tools/perf/Documentation/perf-stat.txt
@@@ -140,6 -147,10 +140,13 @@@ Print count deltas every N millisecond
  The overhead percentage could be high in some cases, for instance with small, sub 100ms intervals.  Use with caution.
  	example: 'perf stat -I 1000 -e cycles -a sleep 5'
  
++<<<<<<< HEAD
++=======
+ --metric-only::
+ Only print computed metrics. Print them in a single line.
+ Don't show any raw values. Not supported with --per-thread.
+ 
++>>>>>>> 206cab651d07 (perf stat: Add --metric-only support for -A)
  --per-socket::
  Aggregate counts per processor socket for system-wide mode measurements.  This
  is a useful mode to detect imbalance between sockets.  To enable this mode,
diff --cc tools/perf/builtin-stat.c
index 35c69cb8a5c1,1f19f2f999c8..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -893,6 -1250,73 +893,76 @@@ static void print_counter(struct perf_e
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void print_no_aggr_metric(char *prefix)
+ {
+ 	int cpu;
+ 	int nrcpus = 0;
+ 	struct perf_evsel *counter;
+ 	u64 ena, run, val;
+ 	double uval;
+ 
+ 	nrcpus = evsel_list->cpus->nr;
+ 	for (cpu = 0; cpu < nrcpus; cpu++) {
+ 		bool first = true;
+ 
+ 		if (prefix)
+ 			fputs(prefix, stat_config.output);
+ 		evlist__for_each(evsel_list, counter) {
+ 			if (first) {
+ 				aggr_printout(counter, cpu, 0);
+ 				first = false;
+ 			}
+ 			val = perf_counts(counter->counts, cpu, 0)->val;
+ 			ena = perf_counts(counter->counts, cpu, 0)->ena;
+ 			run = perf_counts(counter->counts, cpu, 0)->run;
+ 
+ 			uval = val * counter->scale;
+ 			printout(cpu, 0, counter, uval, prefix, run, ena, 1.0);
+ 		}
+ 		fputc('\n', stat_config.output);
+ 	}
+ }
+ 
+ static int aggr_header_lens[] = {
+ 	[AGGR_CORE] = 18,
+ 	[AGGR_SOCKET] = 12,
+ 	[AGGR_NONE] = 6,
+ 	[AGGR_THREAD] = 24,
+ 	[AGGR_GLOBAL] = 0,
+ };
+ 
+ static void print_metric_headers(char *prefix)
+ {
+ 	struct perf_stat_output_ctx out;
+ 	struct perf_evsel *counter;
+ 	struct outstate os = {
+ 		.fh = stat_config.output
+ 	};
+ 
+ 	if (prefix)
+ 		fprintf(stat_config.output, "%s", prefix);
+ 
+ 	if (!csv_output)
+ 		fprintf(stat_config.output, "%*s",
+ 			aggr_header_lens[stat_config.aggr_mode], "");
+ 
+ 	/* Print metrics headers only */
+ 	evlist__for_each(evsel_list, counter) {
+ 		os.evsel = counter;
+ 		out.ctx = &os;
+ 		out.print_metric = print_metric_header;
+ 		out.new_line = new_line_metric;
+ 		os.evsel = counter;
+ 		perf_stat__print_shadow_stats(counter, 0,
+ 					      0,
+ 					      &out);
+ 	}
+ 	fputc('\n', stat_config.output);
+ }
+ 
++>>>>>>> 206cab651d07 (perf stat: Add --metric-only support for -A)
  static void print_interval(char *prefix, struct timespec *ts)
  {
  	FILE *output = stat_config.output;
@@@ -995,10 -1434,16 +1065,14 @@@ static void print_counters(struct times
  	case AGGR_GLOBAL:
  		evlist__for_each(evsel_list, counter)
  			print_counter_aggr(counter, prefix);
 -		if (metric_only)
 -			fputc('\n', stat_config.output);
  		break;
  	case AGGR_NONE:
- 		evlist__for_each(evsel_list, counter)
- 			print_counter(counter, prefix);
+ 		if (metric_only)
+ 			print_no_aggr_metric(prefix);
+ 		else {
+ 			evlist__for_each(evsel_list, counter)
+ 				print_counter(counter, prefix);
+ 		}
  		break;
  	case AGGR_UNSET:
  	default:
@@@ -1363,8 -2202,18 +1437,23 @@@ int cmd_stat(int argc, const char **arg
  
  	if (output_name && output_fd) {
  		fprintf(stderr, "cannot use both --output and --log-fd\n");
++<<<<<<< HEAD
 +		parse_options_usage(stat_usage, options, "o", 1);
 +		parse_options_usage(NULL, options, "log-fd", 0);
++=======
+ 		parse_options_usage(stat_usage, stat_options, "o", 1);
+ 		parse_options_usage(NULL, stat_options, "log-fd", 0);
+ 		goto out;
+ 	}
+ 
+ 	if (metric_only && stat_config.aggr_mode == AGGR_THREAD) {
+ 		fprintf(stderr, "--metric-only is not supported with --per-thread\n");
+ 		goto out;
+ 	}
+ 
+ 	if (metric_only && run_count > 1) {
+ 		fprintf(stderr, "--metric-only is not supported with -r\n");
++>>>>>>> 206cab651d07 (perf stat: Add --metric-only support for -A)
  		goto out;
  	}
  
* Unmerged path tools/perf/Documentation/perf-stat.txt
* Unmerged path tools/perf/builtin-stat.c
