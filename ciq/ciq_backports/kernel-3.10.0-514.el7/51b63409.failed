powercap / RAPL: Floor frequency setting in Atom SoC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [powercap] rapl: Floor frequency setting in Atom SoC (Steve Best) [1274035]
Rebuild_FUZZ: 88.17%
commit-author Ajay Thomas <ajay.thomas.david.rajamanickam@intel.com>
commit 51b63409b75980753f52edb45da7d1b3e2b9405d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/51b63409.failed

CPU Floor frequency is set in BIOS for newer Atom
SoCs. This patch handles configuration of floor
frequency for different variants of Atom SoCs
appropriately and ensures configuration of floor
frequency is not done from driver for these
newer Atom SoCs.

Since address of the register for configuring
floor frequency might change for different
Atom SoCs, this patch also prevents potential
overwriting of wrong registers.

	Reviewed-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Ajay Thomas <ajay.thomas.david.rajamanickam@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 51b63409b75980753f52edb45da7d1b3e2b9405d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/powercap/intel_rapl.c
diff --cc drivers/powercap/intel_rapl.c
index 0fe8b75d996c,f33262843453..000000000000
--- a/drivers/powercap/intel_rapl.c
+++ b/drivers/powercap/intel_rapl.c
@@@ -188,6 -185,21 +188,24 @@@ struct rapl_package 
  					*/
  	struct list_head plist;
  };
++<<<<<<< HEAD
++=======
+ 
+ struct rapl_defaults {
+ 	u8 floor_freq_reg_addr;
+ 	int (*check_unit)(struct rapl_package *rp, int cpu);
+ 	void (*set_floor_freq)(struct rapl_domain *rd, bool mode);
+ 	u64 (*compute_time_window)(struct rapl_package *rp, u64 val,
+ 				bool to_raw);
+ 	unsigned int dram_domain_energy_unit;
+ };
+ static struct rapl_defaults *rapl_defaults;
+ 
+ /* Sideband MBI registers */
+ #define IOSF_CPU_POWER_BUDGET_CTL_BYT (0x2)
+ #define IOSF_CPU_POWER_BUDGET_CTL_TNG (0xdf)
+ 
++>>>>>>> 51b63409b759 (powercap / RAPL: Floor frequency setting in Atom SoC)
  #define PACKAGE_PLN_INT_SAVED   BIT(0)
  #define MAX_PRIM_NAME (32)
  
@@@ -343,19 -357,11 +361,24 @@@ static int set_domain_enable(struct pow
  
  	if (rd->state & DOMAIN_STATE_BIOS_LOCKED)
  		return -EACCES;
 -
  	get_online_cpus();
 +	nr_powerlimit = find_nr_power_limit(rd);
 +	/* here we activate/deactivate the hardware for power limiting */
  	rapl_write_data_raw(rd, PL1_ENABLE, mode);
++<<<<<<< HEAD
 +	/* always enable clamp such that p-state can go below OS requested
 +	 * range. power capping priority over guranteed frequency.
 +	 */
 +	rapl_write_data_raw(rd, PL1_CLAMP, mode);
 +	/* some domains have pl2 */
 +	if (nr_powerlimit > 1) {
 +		rapl_write_data_raw(rd, PL2_ENABLE, mode);
 +		rapl_write_data_raw(rd, PL2_CLAMP, mode);
 +	}
++=======
+ 	if (rapl_defaults->set_floor_freq)
+ 		rapl_defaults->set_floor_freq(rd, mode);
++>>>>>>> 51b63409b759 (powercap / RAPL: Floor frequency setting in Atom SoC)
  	put_online_cpus();
  
  	return 0;
@@@ -946,22 -961,146 +969,165 @@@ static void package_power_limit_irq_res
  	wrmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);
  }
  
++<<<<<<< HEAD
 +static const struct x86_cpu_id rapl_ids[] = {
 +	{ X86_VENDOR_INTEL, 6, 0x2a},/* Sandy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x2d},/* Sandy Bridge EP */
 +	{ X86_VENDOR_INTEL, 6, 0x37},/* Valleyview */
 +	{ X86_VENDOR_INTEL, 6, 0x3a},/* Ivy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x3c},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x3d},/* Broadwell */
 +	{ X86_VENDOR_INTEL, 6, 0x3f},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x4f},/* Broadwell servers */
 +	{ X86_VENDOR_INTEL, 6, 0x45},/* Haswell ULT */
 +	{ X86_VENDOR_INTEL, 6, 0x47},/* Broadwell-H */
 +	{ X86_VENDOR_INTEL, 6, 0x4E},/* Skylake */
 +	{ X86_VENDOR_INTEL, 6, 0x56},/* Future Xeon */
 +	{ X86_VENDOR_INTEL, 6, 0x57},/* Knights Landing */
 +	{ X86_VENDOR_INTEL, 6, 0x5E},/* Skylake-H/S */
 +	/* TODO: Add more CPU IDs after testing */
++=======
+ static void set_floor_freq_default(struct rapl_domain *rd, bool mode)
+ {
+ 	int nr_powerlimit = find_nr_power_limit(rd);
+ 
+ 	/* always enable clamp such that p-state can go below OS requested
+ 	 * range. power capping priority over guranteed frequency.
+ 	 */
+ 	rapl_write_data_raw(rd, PL1_CLAMP, mode);
+ 
+ 	/* some domains have pl2 */
+ 	if (nr_powerlimit > 1) {
+ 		rapl_write_data_raw(rd, PL2_ENABLE, mode);
+ 		rapl_write_data_raw(rd, PL2_CLAMP, mode);
+ 	}
+ }
+ 
+ static void set_floor_freq_atom(struct rapl_domain *rd, bool enable)
+ {
+ 	static u32 power_ctrl_orig_val;
+ 	u32 mdata;
+ 
+ 	if (!rapl_defaults->floor_freq_reg_addr) {
+ 		pr_err("Invalid floor frequency config register\n");
+ 		return;
+ 	}
+ 
+ 	if (!power_ctrl_orig_val)
+ 		iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_PMC_READ,
+ 			rapl_defaults->floor_freq_reg_addr,
+ 				&power_ctrl_orig_val);
+ 	mdata = power_ctrl_orig_val;
+ 	if (enable) {
+ 		mdata &= ~(0x7f << 8);
+ 		mdata |= 1 << 8;
+ 	}
+ 	iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_PMC_WRITE,
+ 		rapl_defaults->floor_freq_reg_addr, mdata);
+ }
+ 
+ static u64 rapl_compute_time_window_core(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	u64 f, y; /* fraction and exp. used for time unit */
+ 
+ 	/*
+ 	 * Special processing based on 2^Y*(1+F/4), refer
+ 	 * to Intel Software Developer's manual Vol.3B: CH 14.9.3.
+ 	 */
+ 	if (!to_raw) {
+ 		f = (value & 0x60) >> 5;
+ 		y = value & 0x1f;
+ 		value = (1 << y) * (4 + f) * rp->time_unit / 4;
+ 	} else {
+ 		do_div(value, rp->time_unit);
+ 		y = ilog2(value);
+ 		f = div64_u64(4 * (value - (1 << y)), 1 << y);
+ 		value = (y & 0x1f) | ((f & 0x3) << 5);
+ 	}
+ 	return value;
+ }
+ 
+ static u64 rapl_compute_time_window_atom(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	/*
+ 	 * Atom time unit encoding is straight forward val * time_unit,
+ 	 * where time_unit is default to 1 sec. Never 0.
+ 	 */
+ 	if (!to_raw)
+ 		return (value) ? value *= rp->time_unit : rp->time_unit;
+ 	else
+ 		value = div64_u64(value, rp->time_unit);
+ 
+ 	return value;
+ }
+ 
+ static const struct rapl_defaults rapl_defaults_core = {
+ 	.floor_freq_reg_addr = 0,
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_hsw_server = {
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ 	.dram_domain_energy_unit = 15300,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_byt = {
+ 	.floor_freq_reg_addr = IOSF_CPU_POWER_BUDGET_CTL_BYT,
+ 	.check_unit = rapl_check_unit_atom,
+ 	.set_floor_freq = set_floor_freq_atom,
+ 	.compute_time_window = rapl_compute_time_window_atom,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_tng = {
+ 	.floor_freq_reg_addr = IOSF_CPU_POWER_BUDGET_CTL_TNG,
+ 	.check_unit = rapl_check_unit_atom,
+ 	.set_floor_freq = set_floor_freq_atom,
+ 	.compute_time_window = rapl_compute_time_window_atom,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_ann = {
+ 	.floor_freq_reg_addr = 0,
+ 	.check_unit = rapl_check_unit_atom,
+ 	.set_floor_freq = NULL,
+ 	.compute_time_window = rapl_compute_time_window_atom,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_cht = {
+ 	.floor_freq_reg_addr = 0,
+ 	.check_unit = rapl_check_unit_atom,
+ 	.set_floor_freq = NULL,
+ 	.compute_time_window = rapl_compute_time_window_atom,
+ };
+ 
+ #define RAPL_CPU(_model, _ops) {			\
+ 		.vendor = X86_VENDOR_INTEL,		\
+ 		.family = 6,				\
+ 		.model = _model,			\
+ 		.driver_data = (kernel_ulong_t)&_ops,	\
+ 		}
+ 
+ static const struct x86_cpu_id rapl_ids[] __initconst = {
+ 	RAPL_CPU(0x2a, rapl_defaults_core),/* Sandy Bridge */
+ 	RAPL_CPU(0x2d, rapl_defaults_core),/* Sandy Bridge EP */
+ 	RAPL_CPU(0x37, rapl_defaults_byt),/* Valleyview */
+ 	RAPL_CPU(0x3a, rapl_defaults_core),/* Ivy Bridge */
+ 	RAPL_CPU(0x3c, rapl_defaults_core),/* Haswell */
+ 	RAPL_CPU(0x3d, rapl_defaults_core),/* Broadwell */
+ 	RAPL_CPU(0x3f, rapl_defaults_hsw_server),/* Haswell servers */
+ 	RAPL_CPU(0x4f, rapl_defaults_hsw_server),/* Broadwell servers */
+ 	RAPL_CPU(0x45, rapl_defaults_core),/* Haswell ULT */
+ 	RAPL_CPU(0x4E, rapl_defaults_core),/* Skylake */
+ 	RAPL_CPU(0x4C, rapl_defaults_cht),/* Braswell/Cherryview */
+ 	RAPL_CPU(0x4A, rapl_defaults_tng),/* Tangier */
+ 	RAPL_CPU(0x56, rapl_defaults_core),/* Future Xeon */
+ 	RAPL_CPU(0x5A, rapl_defaults_ann),/* Annidale */
++>>>>>>> 51b63409b759 (powercap / RAPL: Floor frequency setting in Atom SoC)
  	{}
  };
  MODULE_DEVICE_TABLE(x86cpu, rapl_ids);
* Unmerged path drivers/powercap/intel_rapl.c
