Driver core: wakeup the parent device before trying probe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit ddef08dd00f5548f943422c86e4ffe67dd040b6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ddef08dd.failed

If the parent is still suspended when driver probe is
attempted, the result may be failure.

For example, if the parent is a PCI MFD device that has been
suspended when we try to probe our device, any register
reads will return 0xffffffff.

To fix the problem, making sure the parent is always awake
before attempting driver probe.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Lee Jones <lee.jones@linaro.org>
(cherry picked from commit ddef08dd00f5548f943422c86e4ffe67dd040b6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/dd.c
diff --cc drivers/base/dd.c
index 06051767393f,2d6df1dd3852..000000000000
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@@ -395,6 -496,93 +403,88 @@@ static int __device_attach(struct devic
  	return driver_probe_device(drv, dev);
  }
  
++<<<<<<< HEAD
++=======
+ static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)
+ {
+ 	struct device *dev = _dev;
+ 	struct device_attach_data data = {
+ 		.dev		= dev,
+ 		.check_async	= true,
+ 		.want_async	= true,
+ 	};
+ 
+ 	device_lock(dev);
+ 
+ 	if (dev->parent)
+ 		pm_runtime_get_sync(dev->parent);
+ 
+ 	bus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver);
+ 	dev_dbg(dev, "async probe completed\n");
+ 
+ 	pm_request_idle(dev);
+ 
+ 	if (dev->parent)
+ 		pm_runtime_put(dev->parent);
+ 
+ 	device_unlock(dev);
+ 
+ 	put_device(dev);
+ }
+ 
+ static int __device_attach(struct device *dev, bool allow_async)
+ {
+ 	int ret = 0;
+ 
+ 	device_lock(dev);
+ 	if (dev->driver) {
+ 		if (klist_node_attached(&dev->p->knode_driver)) {
+ 			ret = 1;
+ 			goto out_unlock;
+ 		}
+ 		ret = device_bind_driver(dev);
+ 		if (ret == 0)
+ 			ret = 1;
+ 		else {
+ 			dev->driver = NULL;
+ 			ret = 0;
+ 		}
+ 	} else {
+ 		struct device_attach_data data = {
+ 			.dev = dev,
+ 			.check_async = allow_async,
+ 			.want_async = false,
+ 		};
+ 
+ 		if (dev->parent)
+ 			pm_runtime_get_sync(dev->parent);
+ 
+ 		ret = bus_for_each_drv(dev->bus, NULL, &data,
+ 					__device_attach_driver);
+ 		if (!ret && allow_async && data.have_async) {
+ 			/*
+ 			 * If we could not find appropriate driver
+ 			 * synchronously and we are allowed to do
+ 			 * async probes and there are drivers that
+ 			 * want to probe asynchronously, we'll
+ 			 * try them.
+ 			 */
+ 			dev_dbg(dev, "scheduling asynchronous probe\n");
+ 			get_device(dev);
+ 			async_schedule(__device_attach_async_helper, dev);
+ 		} else {
+ 			pm_request_idle(dev);
+ 		}
+ 
+ 		if (dev->parent)
+ 			pm_runtime_put(dev->parent);
+ 	}
+ out_unlock:
+ 	device_unlock(dev);
+ 	return ret;
+ }
+ 
++>>>>>>> ddef08dd00f5 (Driver core: wakeup the parent device before trying probe)
  /**
   * device_attach - try to attach device to a driver.
   * @dev: device.
* Unmerged path drivers/base/dd.c
