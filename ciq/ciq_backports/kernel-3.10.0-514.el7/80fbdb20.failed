ipv6: datagram: Refactor flowi6 init codes to a new function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 80fbdb208f37740774652ba095a5b2045205ed59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/80fbdb20.failed

Move flowi6 init codes for connected datagram sk to a newly created
function ip6_datagram_flow_key_init().

Notes:
1. fl6_flowlabel is used instead of fl6.flowlabel in __ip6_datagram_connect
2. ipv6_addr_is_multicast(&fl6->daddr) is used instead of
   (addr_type & IPV6_ADDR_MULTICAST) in ip6_datagram_flow_key_init()

This new function will be reused during pmtu update in the later patch.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Cc: Cong Wang <xiyou.wangcong@gmail.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Wei Wang <weiwan@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 80fbdb208f37740774652ba095a5b2045205ed59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/datagram.c
diff --cc net/ipv6/datagram.c
index 88fda1924015,f07c1ddb5cac..000000000000
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@@ -40,18 -40,43 +40,47 @@@ static bool ipv6_mapped_addr_any(const 
  	return ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);
  }
  
++<<<<<<< HEAD
 +int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
++=======
+ static void ip6_datagram_flow_key_init(struct flowi6 *fl6, struct sock *sk)
+ {
+ 	struct inet_sock *inet = inet_sk(sk);
+ 	struct ipv6_pinfo *np = inet6_sk(sk);
+ 
+ 	memset(fl6, 0, sizeof(*fl6));
+ 	fl6->flowi6_proto = sk->sk_protocol;
+ 	fl6->daddr = sk->sk_v6_daddr;
+ 	fl6->saddr = np->saddr;
+ 	fl6->flowi6_oif = sk->sk_bound_dev_if;
+ 	fl6->flowi6_mark = sk->sk_mark;
+ 	fl6->fl6_dport = inet->inet_dport;
+ 	fl6->fl6_sport = inet->inet_sport;
+ 	fl6->flowlabel = np->flow_label;
+ 
+ 	if (!fl6->flowi6_oif)
+ 		fl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;
+ 
+ 	if (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr))
+ 		fl6->flowi6_oif = np->mcast_oif;
+ 
+ 	security_sk_classify_flow(sk, flowi6_to_flowi(fl6));
+ }
+ 
+ static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
++>>>>>>> 80fbdb208f37 (ipv6: datagram: Refactor flowi6 init codes to a new function)
  {
  	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 -	struct inet_sock	*inet = inet_sk(sk);
 -	struct ipv6_pinfo	*np = inet6_sk(sk);
 -	struct in6_addr	*daddr, *final_p, final;
 +	struct inet_sock      	*inet = inet_sk(sk);
 +	struct ipv6_pinfo      	*np = inet6_sk(sk);
 +	struct in6_addr		*daddr, *final_p, final;
  	struct dst_entry	*dst;
  	struct flowi6		fl6;
  	struct ip6_flowlabel	*flowlabel = NULL;
 -	struct ipv6_txoptions	*opt;
 +	struct ipv6_txoptions   *opt;
  	int			addr_type;
  	int			err;
+ 	__be32			fl6_flowlabel = 0;
  
  	if (usin->sin6_family == AF_INET) {
  		if (__ipv6_only_sock(sk))
@@@ -66,12 -91,11 +95,18 @@@
  	if (usin->sin6_family != AF_INET6)
  		return -EAFNOSUPPORT;
  
- 	memset(&fl6, 0, sizeof(fl6));
  	if (np->sndflow) {
++<<<<<<< HEAD
 +		fl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
 +		if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {
 +			flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
 +			if (flowlabel == NULL)
++=======
+ 		fl6_flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;
+ 		if (fl6_flowlabel & IPV6_FLOWLABEL_MASK) {
+ 			flowlabel = fl6_sock_lookup(sk, fl6_flowlabel);
+ 			if (!flowlabel)
++>>>>>>> 80fbdb208f37 (ipv6: datagram: Refactor flowi6 init codes to a new function)
  				return -EINVAL;
  		}
  	}
@@@ -154,24 -178,12 +189,10 @@@ ipv4_connected
  	 *	destination cache for it.
  	 */
  
- 	fl6.flowi6_proto = sk->sk_protocol;
- 	fl6.daddr = sk->sk_v6_daddr;
- 	fl6.saddr = np->saddr;
- 	fl6.flowi6_oif = sk->sk_bound_dev_if;
- 	fl6.flowi6_mark = sk->sk_mark;
- 	fl6.fl6_dport = inet->inet_dport;
- 	fl6.fl6_sport = inet->inet_sport;
- 
- 	if (!fl6.flowi6_oif)
- 		fl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;
- 
- 	if (!fl6.flowi6_oif && (addr_type&IPV6_ADDR_MULTICAST))
- 		fl6.flowi6_oif = np->mcast_oif;
- 
- 	security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
+ 	ip6_datagram_flow_key_init(&fl6, sk);
  
 -	rcu_read_lock();
 -	opt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);
 +	opt = flowlabel ? flowlabel->opt : np->opt;
  	final_p = fl6_update_dst(&fl6, opt, &final);
 -	rcu_read_unlock();
  
  	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
  	err = 0;
* Unmerged path net/ipv6/datagram.c
