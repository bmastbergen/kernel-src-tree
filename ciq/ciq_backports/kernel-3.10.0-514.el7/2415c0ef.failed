mmc: identify available device type to select

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Seungwon Jeon <tgih.jun@samsung.com>
commit 2415c0ef618b3cd95581c7f633cbab78b29b7ab0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2415c0ef.failed

Device types which are supported by both host and device can be
identified when EXT_CSD is read. There is no need to check host's
capability anymore.

	Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
	Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
	Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 2415c0ef618b3cd95581c7f633cbab78b29b7ab0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index fbcf93d81858,b5691fee9629..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -1081,15 -1096,11 +1096,21 @@@ static int mmc_init_card(struct mmc_hos
  			       mmc_hostname(card->host));
  			err = 0;
  		} else {
++<<<<<<< HEAD
 +			if (card->ext_csd.hs_max_dtr > 52000000 &&
 +			    host->caps2 & MMC_CAP2_HS200) {
 +				mmc_card_set_hs200(card);
 +				mmc_set_timing(card->host,
 +					       MMC_TIMING_MMC_HS200);
 +			} else {
 +				mmc_card_set_highspeed(card);
++=======
+ 			if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
+ 				mmc_set_timing(card->host,
+ 					       MMC_TIMING_MMC_HS200);
+ 			else
++>>>>>>> 2415c0ef618b (mmc: identify available device type to select)
  				mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
- 			}
  		}
  	}
  
@@@ -1112,14 -1123,8 +1133,19 @@@
  	/*
  	 * Indicate DDR mode (if supported).
  	 */
++<<<<<<< HEAD
 +	if (mmc_card_highspeed(card)) {
 +		if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_8V)
 +			&& (host->caps & MMC_CAP_1_8V_DDR))
 +				ddr = MMC_1_8V_DDR_MODE;
 +		else if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
 +			&& (host->caps & MMC_CAP_1_2V_DDR))
 +				ddr = MMC_1_2V_DDR_MODE;
 +	}
++=======
+ 	if (mmc_card_hs(card))
+ 		ddr = card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52;
++>>>>>>> 2415c0ef618b (mmc: identify available device type to select)
  
  	/*
  	 * Indicate HS200 SDR mode (if supported).
* Unmerged path drivers/mmc/core/mmc.c
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index aa7e57f60fb2..fb78a3395f8a 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -68,7 +68,6 @@ struct mmc_ext_csd {
 #define MMC_HIGH_DDR_MAX_DTR	52000000
 #define MMC_HS200_MAX_DTR	200000000
 	unsigned int		sectors;
-	unsigned int		card_type;
 	unsigned int		hc_erase_size;		/* In sectors */
 	unsigned int		hc_erase_timeout;	/* In milliseconds */
 	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
@@ -301,6 +300,7 @@ struct mmc_card {
 	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
 
 	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
+	unsigned int		mmc_avail_type;	/* supported device type by both host and card */
 
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0cf705c83998..dccd7dd5f80b 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -61,12 +61,6 @@ struct mmc_ios {
 #define MMC_TIMING_MMC_DDR52	8
 #define MMC_TIMING_MMC_HS200	9
 
-#define MMC_SDR_MODE		0
-#define MMC_1_2V_DDR_MODE	1
-#define MMC_1_8V_DDR_MODE	2
-#define MMC_1_2V_SDR_MODE	3
-#define MMC_1_8V_SDR_MODE	4
-
 	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 
 #define MMC_SIGNAL_VOLTAGE_330	0
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 50bcde3677ca..f734c0c64575 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -354,18 +354,22 @@ struct _mmc_csd {
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)
 #define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
 
-#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
-#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
 #define EXT_CSD_CARD_TYPE_MASK	0x3F	/* Mask out reserved bits */
+#define EXT_CSD_CARD_TYPE_HS_26	(1<<0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_HS_52	(1<<1)	/* Card can run at 52MHz */
+#define EXT_CSD_CARD_TYPE_HS	(EXT_CSD_CARD_TYPE_HS_26 | \
+				 EXT_CSD_CARD_TYPE_HS_52)
 #define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
 					     /* DDR mode @1.8V or 3V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
 					     /* DDR mode @1.2V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
 					| EXT_CSD_CARD_TYPE_DDR_1_2V)
-#define EXT_CSD_CARD_TYPE_SDR_1_8V	(1<<4)	/* Card can run at 200MHz */
-#define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200_1_8V	(1<<4)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200_1_2V	(1<<5)	/* Card can run at 200MHz */
 						/* SDR mode @1.2V I/O */
+#define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
+					 EXT_CSD_CARD_TYPE_HS200_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
