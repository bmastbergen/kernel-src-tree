KVM: x86: fix *NULL on invalid low-prio irq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 4efd805fca5590af181f89ad122b8695c63b5f2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4efd805f.failed

Smatch noticed a NULL dereference in kvm_intr_is_single_vcpu_fast that
happens if VM already warned about invalid lowest-priority interrupt.

Create a function for common code while fixing it.

Fixes: 6228a0da8057 ("KVM: x86: Add lowest-priority support for vt-d posted-interrupts")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4efd805fca5590af181f89ad122b8695c63b5f2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 1ea3691b454e,cf74404230ca..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -680,6 -669,31 +680,34 @@@ bool kvm_apic_match_dest(struct kvm_vcp
  	}
  }
  
++<<<<<<< HEAD
++=======
+ int kvm_vector_to_index(u32 vector, u32 dest_vcpus,
+ 		       const unsigned long *bitmap, u32 bitmap_size)
+ {
+ 	u32 mod;
+ 	int i, idx = -1;
+ 
+ 	mod = vector % dest_vcpus;
+ 
+ 	for (i = 0; i <= mod; i++) {
+ 		idx = find_next_bit(bitmap, bitmap_size, idx + 1);
+ 		BUG_ON(idx == bitmap_size);
+ 	}
+ 
+ 	return idx;
+ }
+ 
+ static void kvm_apic_disabled_lapic_found(struct kvm *kvm)
+ {
+ 	if (!kvm->arch.disabled_lapic_found) {
+ 		kvm->arch.disabled_lapic_found = true;
+ 		printk(KERN_INFO
+ 		       "Disabled LAPIC found during irq injection\n");
+ 	}
+ }
+ 
++>>>>>>> 4efd805fca55 (KVM: x86: fix *NULL on invalid low-prio irq)
  bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
  		struct kvm_lapic_irq *irq, int *r, unsigned long *dest_map)
  {
@@@ -738,11 -756,28 +766,31 @@@
  					continue;
  				if (l < 0)
  					l = i;
 -				else if (kvm_apic_compare_prio(dst[i]->vcpu,
 -							dst[l]->vcpu) < 0)
 +				else if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)
  					l = i;
  			}
 +
  			bitmap = (l >= 0) ? 1 << l : 0;
++<<<<<<< HEAD
++=======
+ 		} else {
+ 			int idx;
+ 			unsigned int dest_vcpus;
+ 
+ 			dest_vcpus = hweight16(bitmap);
+ 			if (dest_vcpus == 0)
+ 				goto out;
+ 
+ 			idx = kvm_vector_to_index(irq->vector,
+ 				dest_vcpus, &bitmap, 16);
+ 
+ 			if (!dst[idx]) {
+ 				kvm_apic_disabled_lapic_found(kvm);
+ 				goto out;
+ 			}
+ 
+ 			bitmap = (idx >= 0) ? 1 << idx : 0;
++>>>>>>> 4efd805fca55 (KVM: x86: fix *NULL on invalid low-prio irq)
  		}
  	}
  
* Unmerged path arch/x86/kvm/lapic.c
