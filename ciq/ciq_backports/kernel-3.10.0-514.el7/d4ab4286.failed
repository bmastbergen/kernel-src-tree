ethtool: correctly ensure {GS}CHANNELS doesn't conflict with GS{RXFH}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Keller, Jacob E <jacob.e.keller@intel.com>
commit d4ab4286276fcd6c155bafdf4422b712068d2516
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d4ab4286.failed

Ethernet drivers implementing both {GS}RXFH and {GS}CHANNELS ethtool ops
incorrectly allow SCHANNELS when it would conflict with the settings
from SRXFH. This occurs because it is not possible for drivers to
understand whether their Rx flow indirection table has been configured
or is in the default state. In addition, drivers currently behave in
various ways when increasing the number of Rx channels.

Some drivers will always destroy the Rx flow indirection table when this
occurs, whether it has been set by the user or not. Other drivers will
attempt to preserve the table even if the user has never modified it
from the default driver settings. Neither of these situation is
desirable because it leads to unexpected behavior or loss of user
configuration.

The correct behavior is to simply return -EINVAL when SCHANNELS would
conflict with the current Rx flow table settings. However, it should
only do so if the current settings were modified by the user. If we
required that the new settings never conflict with the current (default)
Rx flow settings, we would force users to first reduce their Rx flow
settings and then reduce the number of Rx channels.

This patch proposes a solution implemented in net/core/ethtool.c which
ensures that all drivers behave correctly. It checks whether the RXFH
table has been configured to non-default settings, and stores this
information in a private netdev flag. When the number of channels is
requested to change, it first ensures that the current Rx flow table is
not going to assign flows to now disabled channels.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4ab4286276fcd6c155bafdf4422b712068d2516)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/ethtool.c
diff --cc include/linux/netdevice.h
index eb7e9fa3e472,0499569c256d..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1214,31 -1286,40 +1214,67 @@@ struct net_device_ops 
   * @IFF_LIVE_ADDR_CHANGE: device supports hardware address
   *	change when it's running
   * @IFF_MACVLAN: Macvlan device
++<<<<<<< HEAD
++=======
+  * @IFF_L3MDEV_MASTER: device is an L3 master device
+  * @IFF_NO_QUEUE: device can run without qdisc attached
+  * @IFF_OPENVSWITCH: device is a Open vSwitch master
+  * @IFF_L3MDEV_SLAVE: device is enslaved to an L3 master device
+  * @IFF_TEAM: device is a team device
+  * @IFF_RXFH_CONFIGURED: device has had Rx Flow indirection table configured
++>>>>>>> d4ab4286276f (ethtool: correctly ensure {GS}CHANNELS doesn't conflict with GS{RXFH})
   */
  enum netdev_priv_flags {
  	IFF_802_1Q_VLAN			= 1<<0,
  	IFF_EBRIDGE			= 1<<1,
++<<<<<<< HEAD
 +	IFF_SLAVE_INACTIVE		= 1<<2,
 +	IFF_MASTER_8023AD		= 1<<3,
 +	IFF_MASTER_ALB			= 1<<4,
 +	IFF_BONDING			= 1<<5,
 +	IFF_SLAVE_NEEDARP		= 1<<6,
 +	IFF_ISATAP			= 1<<7,
 +	IFF_MASTER_ARPMON		= 1<<8,
 +	IFF_WAN_HDLC			= 1<<9,
 +	IFF_XMIT_DST_RELEASE		= 1<<10,
 +	IFF_DONT_BRIDGE			= 1<<11,
 +	IFF_DISABLE_NETPOLL		= 1<<12,
 +	IFF_MACVLAN_PORT		= 1<<13,
 +	IFF_BRIDGE_PORT			= 1<<14,
 +	IFF_OVS_DATAPATH		= 1<<15,
 +	IFF_TX_SKB_SHARING		= 1<<16,
 +	IFF_UNICAST_FLT			= 1<<17,
 +	IFF_TEAM_PORT			= 1<<18,
 +	IFF_SUPP_NOFCS			= 1<<19,
 +	IFF_LIVE_ADDR_CHANGE		= 1<<20,
 +	IFF_MACVLAN			= 1<<21,
 +	IFF_XMIT_DST_RELEASE_PERM	= 1<<22,
++=======
+ 	IFF_BONDING			= 1<<2,
+ 	IFF_ISATAP			= 1<<3,
+ 	IFF_WAN_HDLC			= 1<<4,
+ 	IFF_XMIT_DST_RELEASE		= 1<<5,
+ 	IFF_DONT_BRIDGE			= 1<<6,
+ 	IFF_DISABLE_NETPOLL		= 1<<7,
+ 	IFF_MACVLAN_PORT		= 1<<8,
+ 	IFF_BRIDGE_PORT			= 1<<9,
+ 	IFF_OVS_DATAPATH		= 1<<10,
+ 	IFF_TX_SKB_SHARING		= 1<<11,
+ 	IFF_UNICAST_FLT			= 1<<12,
+ 	IFF_TEAM_PORT			= 1<<13,
+ 	IFF_SUPP_NOFCS			= 1<<14,
+ 	IFF_LIVE_ADDR_CHANGE		= 1<<15,
+ 	IFF_MACVLAN			= 1<<16,
+ 	IFF_XMIT_DST_RELEASE_PERM	= 1<<17,
+ 	IFF_IPVLAN_MASTER		= 1<<18,
+ 	IFF_IPVLAN_SLAVE		= 1<<19,
+ 	IFF_L3MDEV_MASTER		= 1<<20,
+ 	IFF_NO_QUEUE			= 1<<21,
+ 	IFF_OPENVSWITCH			= 1<<22,
+ 	IFF_L3MDEV_SLAVE		= 1<<23,
+ 	IFF_TEAM			= 1<<24,
+ 	IFF_RXFH_CONFIGURED		= 1<<25,
++>>>>>>> d4ab4286276f (ethtool: correctly ensure {GS}CHANNELS doesn't conflict with GS{RXFH})
  };
  
  #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
@@@ -1264,12 -1340,223 +1300,23 @@@
  #define IFF_LIVE_ADDR_CHANGE		IFF_LIVE_ADDR_CHANGE
  #define IFF_MACVLAN			IFF_MACVLAN
  #define IFF_XMIT_DST_RELEASE_PERM	IFF_XMIT_DST_RELEASE_PERM
++<<<<<<< HEAD
++=======
+ #define IFF_IPVLAN_MASTER		IFF_IPVLAN_MASTER
+ #define IFF_IPVLAN_SLAVE		IFF_IPVLAN_SLAVE
+ #define IFF_L3MDEV_MASTER		IFF_L3MDEV_MASTER
+ #define IFF_NO_QUEUE			IFF_NO_QUEUE
+ #define IFF_OPENVSWITCH			IFF_OPENVSWITCH
+ #define IFF_L3MDEV_SLAVE		IFF_L3MDEV_SLAVE
+ #define IFF_TEAM			IFF_TEAM
+ #define IFF_RXFH_CONFIGURED		IFF_RXFH_CONFIGURED
++>>>>>>> d4ab4286276f (ethtool: correctly ensure {GS}CHANNELS doesn't conflict with GS{RXFH})
  
 -/**
 - *	struct net_device - The DEVICE structure.
 - *		Actually, this whole structure is a big mistake.  It mixes I/O
 - *		data with strictly "high-level" data, and it has to know about
 - *		almost every data structure used in the INET module.
 - *
 - *	@name:	This is the first field of the "visible" part of this structure
 - *		(i.e. as seen by users in the "Space.c" file).  It is the name
 - *	 	of the interface.
 - *
 - *	@name_hlist: 	Device name hash chain, please keep it close to name[]
 - *	@ifalias:	SNMP alias
 - *	@mem_end:	Shared memory end
 - *	@mem_start:	Shared memory start
 - *	@base_addr:	Device I/O address
 - *	@irq:		Device IRQ number
 - *
 - *	@carrier_changes:	Stats to monitor carrier on<->off transitions
 - *
 - *	@state:		Generic network queuing layer state, see netdev_state_t
 - *	@dev_list:	The global list of network devices
 - *	@napi_list:	List entry, that is used for polling napi devices
 - *	@unreg_list:	List entry, that is used, when we are unregistering the
 - *			device, see the function unregister_netdev
 - *	@close_list:	List entry, that is used, when we are closing the device
 - *
 - *	@adj_list:	Directly linked devices, like slaves for bonding
 - *	@all_adj_list:	All linked devices, *including* neighbours
 - *	@features:	Currently active device features
 - *	@hw_features:	User-changeable features
 - *
 - *	@wanted_features:	User-requested features
 - *	@vlan_features:		Mask of features inheritable by VLAN devices
 - *
 - *	@hw_enc_features:	Mask of features inherited by encapsulating devices
 - *				This field indicates what encapsulation
 - *				offloads the hardware is capable of doing,
 - *				and drivers will need to set them appropriately.
 - *
 - *	@mpls_features:	Mask of features inheritable by MPLS
 - *
 - *	@ifindex:	interface index
 - *	@group:		The group, that the device belongs to
 - *
 - *	@stats:		Statistics struct, which was left as a legacy, use
 - *			rtnl_link_stats64 instead
 - *
 - *	@rx_dropped:	Dropped packets by core network,
 - *			do not use this in drivers
 - *	@tx_dropped:	Dropped packets by core network,
 - *			do not use this in drivers
 - *	@rx_nohandler:	nohandler dropped packets by core network on
 - *			inactive devices, do not use this in drivers
 - *
 - *	@wireless_handlers:	List of functions to handle Wireless Extensions,
 - *				instead of ioctl,
 - *				see <net/iw_handler.h> for details.
 - *	@wireless_data:	Instance data managed by the core of wireless extensions
 - *
 - *	@netdev_ops:	Includes several pointers to callbacks,
 - *			if one wants to override the ndo_*() functions
 - *	@ethtool_ops:	Management operations
 - *	@header_ops:	Includes callbacks for creating,parsing,caching,etc
 - *			of Layer 2 headers.
 - *
 - *	@flags:		Interface flags (a la BSD)
 - *	@priv_flags:	Like 'flags' but invisible to userspace,
 - *			see if.h for the definitions
 - *	@gflags:	Global flags ( kept as legacy )
 - *	@padded:	How much padding added by alloc_netdev()
 - *	@operstate:	RFC2863 operstate
 - *	@link_mode:	Mapping policy to operstate
 - *	@if_port:	Selectable AUI, TP, ...
 - *	@dma:		DMA channel
 - *	@mtu:		Interface MTU value
 - *	@type:		Interface hardware type
 - *	@hard_header_len: Hardware header length, which means that this is the
 - *			  minimum size of a packet.
 - *
 - *	@needed_headroom: Extra headroom the hardware may need, but not in all
 - *			  cases can this be guaranteed
 - *	@needed_tailroom: Extra tailroom the hardware may need, but not in all
 - *			  cases can this be guaranteed. Some cases also use
 - *			  LL_MAX_HEADER instead to allocate the skb
 - *
 - *	interface address info:
 - *
 - * 	@perm_addr:		Permanent hw address
 - * 	@addr_assign_type:	Hw address assignment type
 - * 	@addr_len:		Hardware address length
 - * 	@neigh_priv_len;	Used in neigh_alloc(),
 - * 				initialized only in atm/clip.c
 - * 	@dev_id:		Used to differentiate devices that share
 - * 				the same link layer address
 - * 	@dev_port:		Used to differentiate devices that share
 - * 				the same function
 - *	@addr_list_lock:	XXX: need comments on this one
 - *	@uc_promisc:		Counter, that indicates, that promiscuous mode
 - *				has been enabled due to the need to listen to
 - *				additional unicast addresses in a device that
 - *				does not implement ndo_set_rx_mode()
 - *	@uc:			unicast mac addresses
 - *	@mc:			multicast mac addresses
 - *	@dev_addrs:		list of device hw addresses
 - *	@queues_kset:		Group of all Kobjects in the Tx and RX queues
 - *	@promiscuity:		Number of times, the NIC is told to work in
 - *				Promiscuous mode, if it becomes 0 the NIC will
 - *				exit from working in Promiscuous mode
 - *	@allmulti:		Counter, enables or disables allmulticast mode
 - *
 - *	@vlan_info:	VLAN info
 - *	@dsa_ptr:	dsa specific data
 - *	@tipc_ptr:	TIPC specific data
 - *	@atalk_ptr:	AppleTalk link
 - *	@ip_ptr:	IPv4 specific data
 - *	@dn_ptr:	DECnet specific data
 - *	@ip6_ptr:	IPv6 specific data
 - *	@ax25_ptr:	AX.25 specific data
 - *	@ieee80211_ptr:	IEEE 802.11 specific data, assign before registering
 - *
 - *	@last_rx:	Time of last Rx
 - *	@dev_addr:	Hw address (before bcast,
 - *			because most packets are unicast)
 - *
 - *	@_rx:			Array of RX queues
 - *	@num_rx_queues:		Number of RX queues
 - *				allocated at register_netdev() time
 - *	@real_num_rx_queues: 	Number of RX queues currently active in device
 - *
 - *	@rx_handler:		handler for received packets
 - *	@rx_handler_data: 	XXX: need comments on this one
 - *	@ingress_queue:		XXX: need comments on this one
 - *	@broadcast:		hw bcast address
 - *
 - *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
 - *			indexed by RX queue number. Assigned by driver.
 - *			This must only be set if the ndo_rx_flow_steer
 - *			operation is defined
 - *	@index_hlist:		Device index hash chain
 - *
 - *	@_tx:			Array of TX queues
 - *	@num_tx_queues:		Number of TX queues allocated at alloc_netdev_mq() time
 - *	@real_num_tx_queues: 	Number of TX queues currently active in device
 - *	@qdisc:			Root qdisc from userspace point of view
 - *	@tx_queue_len:		Max frames per queue allowed
 - *	@tx_global_lock: 	XXX: need comments on this one
 - *
 - *	@xps_maps:	XXX: need comments on this one
 - *
 - *	@offload_fwd_mark:	Offload device fwding mark
 - *
 - *	@trans_start:		Time (in jiffies) of last Tx
 - *	@watchdog_timeo:	Represents the timeout that is used by
 - *				the watchdog ( see dev_watchdog() )
 - *	@watchdog_timer:	List of timers
 - *
 - *	@pcpu_refcnt:		Number of references to this device
 - *	@todo_list:		Delayed register/unregister
 - *	@link_watch_list:	XXX: need comments on this one
 - *
 - *	@reg_state:		Register/unregister state machine
 - *	@dismantle:		Device is going to be freed
 - *	@rtnl_link_state:	This enum represents the phases of creating
 - *				a new link
 - *
 - *	@destructor:		Called from unregister,
 - *				can be used to call free_netdev
 - *	@npinfo:		XXX: need comments on this one
 - * 	@nd_net:		Network namespace this network device is inside
 - *
 - * 	@ml_priv:	Mid-layer private
 - * 	@lstats:	Loopback statistics
 - * 	@tstats:	Tunnel statistics
 - * 	@dstats:	Dummy statistics
 - * 	@vstats:	Virtual ethernet statistics
 - *
 - *	@garp_port:	GARP
 - *	@mrp_port:	MRP
 - *
 - *	@dev:		Class/net/name entry
 - *	@sysfs_groups:	Space for optional device, statistics and wireless
 - *			sysfs groups
 - *
 - *	@sysfs_rx_queue_group:	Space for optional per-rx queue attributes
 - *	@rtnl_link_ops:	Rtnl_link_ops
 - *
 - *	@gso_max_size:	Maximum size of generic segmentation offload
 - *	@gso_max_segs:	Maximum number of segments that can be passed to the
 - *			NIC for GSO
 - *	@gso_min_segs:	Minimum number of segments that can be passed to the
 - *			NIC for GSO
 - *
 - *	@dcbnl_ops:	Data Center Bridging netlink ops
 - *	@num_tc:	Number of traffic classes in the net device
 - *	@tc_to_txq:	XXX: need comments on this one
 - *	@prio_tc_map	XXX: need comments on this one
 - *
 - *	@fcoe_ddp_xid:	Max exchange id for FCoE LRO by ddp
 - *
 - *	@priomap:	XXX: need comments on this one
 - *	@phydev:	Physical device may attach itself
 - *			for hardware timestamping
 - *
 - *	@qdisc_tx_busylock:	XXX: need comments on this one
 - *
 - *	@proto_down:	protocol port state information can be sent to the
 - *			switch driver and used to set the phys state of the
 - *			switch port.
 +/*
 + *	The DEVICE structure.
 + *	Actually, this whole structure is a big mistake.  It mixes I/O
 + *	data with strictly "high-level" data, and it has to know about
 + *	almost every data structure used in the INET module.
   *
   *	FIXME: cleanup struct net_device such that network protocol info
   *	moves out.
@@@ -3481,6 -4006,56 +3528,59 @@@ static inline bool netif_supports_nofcs
  	return dev->priv_flags & IFF_SUPP_NOFCS;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool netif_is_l3_master(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_L3MDEV_MASTER;
+ }
+ 
+ static inline bool netif_is_l3_slave(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_L3MDEV_SLAVE;
+ }
+ 
+ static inline bool netif_is_bridge_master(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_EBRIDGE;
+ }
+ 
+ static inline bool netif_is_bridge_port(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_BRIDGE_PORT;
+ }
+ 
+ static inline bool netif_is_ovs_master(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_OPENVSWITCH;
+ }
+ 
+ static inline bool netif_is_team_master(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_TEAM;
+ }
+ 
+ static inline bool netif_is_team_port(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_TEAM_PORT;
+ }
+ 
+ static inline bool netif_is_lag_master(const struct net_device *dev)
+ {
+ 	return netif_is_bond_master(dev) || netif_is_team_master(dev);
+ }
+ 
+ static inline bool netif_is_lag_port(const struct net_device *dev)
+ {
+ 	return netif_is_bond_slave(dev) || netif_is_team_port(dev);
+ }
+ 
+ static inline bool netif_is_rxfh_configured(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_RXFH_CONFIGURED;
+ }
+ 
++>>>>>>> d4ab4286276f (ethtool: correctly ensure {GS}CHANNELS doesn't conflict with GS{RXFH})
  /* This device needs to keep skb dst for qdisc enqueue or ndo_start_xmit() */
  static inline void netif_keep_dst(struct net_device *dev)
  {
diff --cc net/core/ethtool.c
index 7158422fa5fd,379bdc59b1c8..000000000000
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@@ -706,9 -768,15 +737,21 @@@ static noinline_for_stack int ethtool_s
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = ops->set_rxfh ?
 +		ops->set_rxfh(dev, indir, NULL, ETH_RSS_HASH_NO_CHANGE) :
 +		ops->set_rxfh_indir(dev, indir);
++=======
+ 	ret = ops->set_rxfh(dev, indir, NULL, ETH_RSS_HASH_NO_CHANGE);
+ 	if (ret)
+ 		goto out;
+ 
+ 	/* indicate whether rxfh was set to default */
+ 	if (user_size == 0)
+ 		dev->priv_flags &= ~IFF_RXFH_CONFIGURED;
+ 	else
+ 		dev->priv_flags |= IFF_RXFH_CONFIGURED;
++>>>>>>> d4ab4286276f (ethtool: correctly ensure {GS}CHANNELS doesn't conflict with GS{RXFH})
  
  out:
  	kfree(indir);
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/ethtool.c
