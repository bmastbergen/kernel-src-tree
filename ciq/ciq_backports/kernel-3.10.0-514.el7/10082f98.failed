hv_netvsc: Eliminate status from struct hv_netvsc_packet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author KY Srinivasan <kys@microsoft.com>
commit 10082f98878a9dff1563745f9f1dd9d1ff142700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/10082f98.failed

Eliminate status from struct hv_netvsc_packet.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 10082f98878a9dff1563745f9f1dd9d1ff142700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/netvsc_drv.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index cf498664d989,c4397f1ed43b..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -128,28 -127,20 +128,36 @@@ struct ndis_tcp_ip_checksum_info
   */
  struct hv_netvsc_packet {
  	/* Bookkeeping stuff */
++<<<<<<< HEAD
 +	u32 status;
++=======
+ 	u8 cp_partial; /* partial copy into send buffer */
+ 
+ 	u8 rmsg_size; /* RNDIS header and PPI size */
+ 	u8 rmsg_pgcnt; /* page count of RNDIS header and PPI */
+ 	u8 page_buf_cnt;
++>>>>>>> 10082f98878a (hv_netvsc: Eliminate status from struct hv_netvsc_packet)
  
 +	bool is_data_pkt;
  	u16 vlan_tci;
 +
  	u16 q_idx;
 +	struct vmbus_channel *channel;
 +
 +	u64 send_completion_tid;
 +	void *send_completion_ctx;
 +	void (*send_completion)(void *context);
 +
  	u32 send_buf_index;
  
 +	/* This points to the memory after page_buf */
 +	struct rndis_message *rndis_msg;
 +
  	u32 total_data_buflen;
 +	/* Points to the send/receive buffer where the ethernet frame is */
 +	void *data;
 +	u32 page_buf_cnt;
 +	struct hv_page_buffer page_buf[0];
  };
  
  struct netvsc_device_info {
diff --cc drivers/net/hyperv/netvsc.c
index 74ee1b57e623,02bab9a7c9ff..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -924,17 -1045,15 +924,24 @@@ static void netvsc_receive(struct netvs
  	/* Each range represents 1 RNDIS pkt that contains 1 ethernet frame */
  	for (i = 0; i < count; i++) {
  		/* Initialize the netvsc packet */
++<<<<<<< HEAD
 +		netvsc_packet->status = NVSP_STAT_SUCCESS;
 +		netvsc_packet->data = (void *)((unsigned long)net_device->
++=======
+ 		data = (void *)((unsigned long)net_device->
++>>>>>>> 10082f98878a (hv_netvsc: Eliminate status from struct hv_netvsc_packet)
  			recv_buf + vmxferpage_packet->ranges[i].byte_offset);
  		netvsc_packet->total_data_buflen =
  					vmxferpage_packet->ranges[i].byte_count;
  
  		/* Pass it to the upper layer */
++<<<<<<< HEAD
 +		rndis_filter_receive(device, netvsc_packet);
++=======
+ 		status = rndis_filter_receive(device, netvsc_packet, &data,
+ 					      channel);
++>>>>>>> 10082f98878a (hv_netvsc: Eliminate status from struct hv_netvsc_packet)
  
- 		if (netvsc_packet->status != NVSP_STAT_SUCCESS)
- 			status = NVSP_STAT_FAIL;
  	}
  
  	netvsc_send_recv_completion(device, channel, net_device,
diff --cc drivers/net/hyperv/netvsc_drv.c
index 56b76b7b9a27,a34547497d18..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -429,31 -433,44 +429,34 @@@ static int netvsc_start_xmit(struct sk_
  
  	/* We will atmost need two pages to describe the rndis
  	 * header. We can only transmit MAX_PAGE_BUFFER_COUNT number
 -	 * of pages in a single packet. If skb is scattered around
 -	 * more pages we try linearizing it.
 +	 * of pages in a single packet.
  	 */
 -
 -check_size:
 -	skb_length = skb->len;
  	num_data_pgs = netvsc_get_slots(skb) + 2;
 -	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT && linear) {
 -		net_alert_ratelimited("packet too big: %u pages (%u bytes)\n",
 -				      num_data_pgs, skb->len);
 -		ret = -EFAULT;
 -		goto drop;
 -	} else if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 -		if (skb_linearize(skb)) {
 -			net_alert_ratelimited("failed to linearize skb\n");
 -			ret = -ENOMEM;
 -			goto drop;
 -		}
 -		linear = true;
 -		goto check_size;
 -	}
 -
 -	/*
 -	 * Place the rndis header in the skb head room and
 -	 * the skb->cb will be used for hv_netvsc_packet
 -	 * structure.
 -	 */
 -	ret = skb_cow_head(skb, RNDIS_AND_PPI_SIZE);
 -	if (ret) {
 -		netdev_err(net, "unable to alloc hv_netvsc_packet\n");
 -		ret = -ENOMEM;
 -		goto drop;
 -	}
 -	/* Use the skb control buffer for building up the packet */
 -	BUILD_BUG_ON(sizeof(struct hv_netvsc_packet) >
 -			FIELD_SIZEOF(struct sk_buff, cb));
 -	packet = (struct hv_netvsc_packet *)skb->cb;
 -
 +	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 +		netdev_err(net, "Packet too big: %u\n", skb->len);
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
 +	}
 +
 +	/* Allocate a netvsc packet based on # of frags. */
 +	packet = kzalloc(sizeof(struct hv_netvsc_packet) +
 +			 (num_data_pgs * sizeof(struct hv_page_buffer)) +
 +			 sizeof(struct rndis_message) +
 +			 NDIS_VLAN_PPI_SIZE + NDIS_CSUM_PPI_SIZE +
 +			 NDIS_LSO_PPI_SIZE + NDIS_HASH_PPI_SIZE, GFP_ATOMIC);
 +	if (!packet) {
 +		/* out of memory, drop packet */
 +		netdev_err(net, "unable to allocate hv_netvsc_packet\n");
 +
++<<<<<<< HEAD
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
 +	}
 +
++=======
++>>>>>>> 10082f98878a (hv_netvsc: Eliminate status from struct hv_netvsc_packet)
  	packet->vlan_tci = skb->vlan_tci;
  
  	packet->q_idx = skb_get_queue_mapping(skb);
@@@ -657,9 -681,11 +660,8 @@@ int netvsc_recv_callback(struct hv_devi
  
  	net = ((struct netvsc_device *)hv_get_drvdata(device_obj))->ndev;
  	if (!net || net->reg_state != NETREG_REGISTERED) {
- 		packet->status = NVSP_STAT_FAIL;
- 		return 0;
+ 		return NVSP_STAT_FAIL;
  	}
 -	net_device_ctx = netdev_priv(net);
 -	rx_stats = this_cpu_ptr(net_device_ctx->rx_stats);
  
  	/* Allocate a skb - TODO direct I/O to pages? */
  	skb = netdev_alloc_skb_ip_align(net, packet->total_data_buflen);
diff --cc drivers/net/hyperv/rndis_filter.c
index 4f78abd49222,28adf6acf481..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -364,9 -344,11 +364,9 @@@ static inline void *rndis_get_ppi(struc
  	return NULL;
  }
  
- static void rndis_filter_receive_data(struct rndis_device *dev,
+ static int rndis_filter_receive_data(struct rndis_device *dev,
  				   struct rndis_message *msg,
 -				   struct hv_netvsc_packet *pkt,
 -				   void **data,
 -				   struct vmbus_channel *channel)
 +				   struct hv_netvsc_packet *pkt)
  {
  	struct rndis_packet *rndis_pkt;
  	u32 data_offset;
@@@ -409,7 -391,8 +409,12 @@@
  	}
  
  	csum_info = rndis_get_ppi(rndis_pkt, TCPIP_CHKSUM_PKTINFO);
++<<<<<<< HEAD
 +	netvsc_recv_callback(dev->net_dev->dev, pkt, csum_info);
++=======
+ 	return netvsc_recv_callback(dev->net_dev->dev, pkt, data,
+ 				    csum_info, channel);
++>>>>>>> 10082f98878a (hv_netvsc: Eliminate status from struct hv_netvsc_packet)
  }
  
  int rndis_filter_receive(struct hv_device *dev,
@@@ -451,7 -437,8 +456,12 @@@
  	switch (rndis_msg->ndis_msg_type) {
  	case RNDIS_MSG_PACKET:
  		/* data msg */
++<<<<<<< HEAD
 +		rndis_filter_receive_data(rndis_dev, rndis_msg, pkt);
++=======
+ 		ret = rndis_filter_receive_data(rndis_dev, rndis_msg, pkt,
+ 						data, channel);
++>>>>>>> 10082f98878a (hv_netvsc: Eliminate status from struct hv_netvsc_packet)
  		break;
  
  	case RNDIS_MSG_INIT_C:
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/netvsc_drv.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
