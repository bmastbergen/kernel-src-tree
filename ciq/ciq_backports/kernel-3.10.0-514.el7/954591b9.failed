hv_netvsc: Fix dereference of nvdev before check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andrew Schwartzmeyer <andschwa@microsoft.com>
commit 954591b9f3b43e7015bdd83acaa317658a9b7048
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/954591b9.failed

Passes static analysis by Smatch.

	Signed-off-by: Andrew Schwartzmeyer <andschwa@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 954591b9f3b43e7015bdd83acaa317658a9b7048)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 56b76b7b9a27,2990024b90f9..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -728,6 -770,104 +728,107 @@@ static void netvsc_get_channels(struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int netvsc_set_channels(struct net_device *net,
+ 			       struct ethtool_channels *channels)
+ {
+ 	struct net_device_context *net_device_ctx = netdev_priv(net);
+ 	struct hv_device *dev = net_device_ctx->device_ctx;
+ 	struct netvsc_device *nvdev = hv_get_drvdata(dev);
+ 	struct netvsc_device_info device_info;
+ 	u32 num_chn;
+ 	u32 max_chn;
+ 	int ret = 0;
+ 	bool recovering = false;
+ 
+ 	if (!nvdev || nvdev->destroy)
+ 		return -ENODEV;
+ 
+ 	num_chn = nvdev->num_chn;
+ 	max_chn = min_t(u32, nvdev->max_chn, num_online_cpus());
+ 
+ 	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5) {
+ 		pr_info("vRSS unsupported before NVSP Version 5\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* We do not support rx, tx, or other */
+ 	if (!channels ||
+ 	    channels->rx_count ||
+ 	    channels->tx_count ||
+ 	    channels->other_count ||
+ 	    (channels->combined_count < 1))
+ 		return -EINVAL;
+ 
+ 	if (channels->combined_count > max_chn) {
+ 		pr_info("combined channels too high, using %d\n", max_chn);
+ 		channels->combined_count = max_chn;
+ 	}
+ 
+ 	ret = netvsc_close(net);
+ 	if (ret)
+ 		goto out;
+ 
+  do_set:
+ 	nvdev->start_remove = true;
+ 	rndis_filter_device_remove(dev);
+ 
+ 	nvdev->num_chn = channels->combined_count;
+ 
+ 	net_device_ctx->device_ctx = dev;
+ 	hv_set_drvdata(dev, net);
+ 
+ 	memset(&device_info, 0, sizeof(device_info));
+ 	device_info.num_chn = nvdev->num_chn; /* passed to RNDIS */
+ 	device_info.ring_size = ring_size;
+ 	device_info.max_num_vrss_chns = max_num_vrss_chns;
+ 
+ 	ret = rndis_filter_device_add(dev, &device_info);
+ 	if (ret) {
+ 		if (recovering) {
+ 			netdev_err(net, "unable to add netvsc device (ret %d)\n", ret);
+ 			return ret;
+ 		}
+ 		goto recover;
+ 	}
+ 
+ 	nvdev = hv_get_drvdata(dev);
+ 
+ 	ret = netif_set_real_num_tx_queues(net, nvdev->num_chn);
+ 	if (ret) {
+ 		if (recovering) {
+ 			netdev_err(net, "could not set tx queue count (ret %d)\n", ret);
+ 			return ret;
+ 		}
+ 		goto recover;
+ 	}
+ 
+ 	ret = netif_set_real_num_rx_queues(net, nvdev->num_chn);
+ 	if (ret) {
+ 		if (recovering) {
+ 			netdev_err(net, "could not set rx queue count (ret %d)\n", ret);
+ 			return ret;
+ 		}
+ 		goto recover;
+ 	}
+ 
+  out:
+ 	netvsc_open(net);
+ 
+ 	return ret;
+ 
+  recover:
+ 	/* If the above failed, we attempt to recover through the same
+ 	 * process but with the original number of channels.
+ 	 */
+ 	netdev_err(net, "could not set channels, recovering\n");
+ 	recovering = true;
+ 	channels->combined_count = num_chn;
+ 	goto do_set;
+ }
+ 
++>>>>>>> 954591b9f3b4 (hv_netvsc: Fix dereference of nvdev before check)
  static int netvsc_change_mtu(struct net_device *ndev, int mtu)
  {
  	struct net_device_context *ndevctx = netdev_priv(ndev);
* Unmerged path drivers/net/hyperv/netvsc_drv.c
