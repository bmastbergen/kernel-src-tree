x86/tsc: Enumerate BXT tsc_khz via CPUID

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] tsc: Enumerate BXT tsc_khz via CPUID (Prarit Bhargava) [1372759]
Rebuild_FUZZ: 94.74%
commit-author Len Brown <len.brown@intel.com>
commit ff4c86635ee12461fd3bd911d7d5253394da8f9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ff4c8663.failed

Hard code the BXT crystal clock (aka ART - Always Running Timer)
to 19.200 MHz, and use CPUID leaf 0x15 to determine the BXT TSC frequency.

Use tsc_khz to sanity check BXT cpu_khz,
which can be erroneous in some configurations.

(I simplified the original patch from Bin Gao.)

Original-From: Bin Gao <bin.gao@intel.com>
	Signed-off-by: Len Brown <len.brown@intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/bf4e7c175acd6d09719c47c319b10ff1f0627ff8.1466138954.git.len.brown@intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ff4c86635ee12461fd3bd911d7d5253394da8f9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/tsc.c
diff --cc arch/x86/kernel/tsc.c
index 934c769b779b,2a952fcb1516..000000000000
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@@ -434,6 -670,62 +434,65 @@@ success
   */
  unsigned long native_calibrate_tsc(void)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned int eax_denominator, ebx_numerator, ecx_hz, edx;
+ 	unsigned int crystal_khz;
+ 
+ 	if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)
+ 		return 0;
+ 
+ 	if (boot_cpu_data.cpuid_level < 0x15)
+ 		return 0;
+ 
+ 	eax_denominator = ebx_numerator = ecx_hz = edx = 0;
+ 
+ 	/* CPUID 15H TSC/Crystal ratio, plus optionally Crystal Hz */
+ 	cpuid(0x15, &eax_denominator, &ebx_numerator, &ecx_hz, &edx);
+ 
+ 	if (ebx_numerator == 0 || eax_denominator == 0)
+ 		return 0;
+ 
+ 	crystal_khz = ecx_hz / 1000;
+ 
+ 	if (crystal_khz == 0) {
+ 		switch (boot_cpu_data.x86_model) {
+ 		case 0x4E:	/* SKL */
+ 		case 0x5E:	/* SKL */
+ 			crystal_khz = 24000;	/* 24.0 MHz */
+ 			break;
+ 		case 0x5C:	/* BXT */
+ 			crystal_khz = 19200;	/* 19.2 MHz */
+ 			break;
+ 		}
+ 	}
+ 
+ 	return crystal_khz * ebx_numerator / eax_denominator;
+ }
+ 
+ static unsigned long cpu_khz_from_cpuid(void)
+ {
+ 	unsigned int eax_base_mhz, ebx_max_mhz, ecx_bus_mhz, edx;
+ 
+ 	if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)
+ 		return 0;
+ 
+ 	if (boot_cpu_data.cpuid_level < 0x16)
+ 		return 0;
+ 
+ 	eax_base_mhz = ebx_max_mhz = ecx_bus_mhz = edx = 0;
+ 
+ 	cpuid(0x16, &eax_base_mhz, &ebx_max_mhz, &ecx_bus_mhz, &edx);
+ 
+ 	return eax_base_mhz * 1000;
+ }
+ 
+ /**
+  * native_calibrate_cpu - calibrate the cpu on boot
+  */
+ unsigned long native_calibrate_cpu(void)
+ {
++>>>>>>> ff4c86635ee1 (x86/tsc: Enumerate BXT tsc_khz via CPUID)
  	u64 tsc1, tsc2, delta, ref1, ref2;
  	unsigned long tsc_pit_min = ULONG_MAX, tsc_ref_min = ULONG_MAX;
  	unsigned long flags, latch, ms, fast_calibrate;
@@@ -599,15 -892,19 +658,29 @@@ int recalibrate_cpu_khz(void
  #ifndef CONFIG_SMP
  	unsigned long cpu_khz_old = cpu_khz;
  
 -	if (!boot_cpu_has(X86_FEATURE_TSC))
 +	if (cpu_has_tsc) {
 +		tsc_khz = x86_platform.calibrate_tsc();
 +		cpu_khz = tsc_khz;
 +		cpu_data(0).loops_per_jiffy =
 +			cpufreq_scale(cpu_data(0).loops_per_jiffy,
 +					cpu_khz_old, cpu_khz);
 +		return 0;
 +	} else
  		return -ENODEV;
++<<<<<<< HEAD
++=======
+ 
+ 	cpu_khz = x86_platform.calibrate_cpu();
+ 	tsc_khz = x86_platform.calibrate_tsc();
+ 	if (tsc_khz == 0)
+ 		tsc_khz = cpu_khz;
+ 	else if (abs(cpu_khz - tsc_khz) * 10 > tsc_khz)
+ 		cpu_khz = tsc_khz;
+ 	cpu_data(0).loops_per_jiffy = cpufreq_scale(cpu_data(0).loops_per_jiffy,
+ 						    cpu_khz_old, cpu_khz);
+ 
+ 	return 0;
++>>>>>>> ff4c86635ee1 (x86/tsc: Enumerate BXT tsc_khz via CPUID)
  #else
  	return -ENODEV;
  #endif
@@@ -995,13 -1301,23 +1068,26 @@@ void __init tsc_init(void
  	u64 lpj;
  	int cpu;
  
 -	if (!boot_cpu_has(X86_FEATURE_TSC)) {
 -		setup_clear_cpu_cap(X86_FEATURE_TSC_DEADLINE_TIMER);
 +	x86_init.timers.tsc_pre_init();
 +
 +	if (!cpu_has_tsc)
  		return;
 -	}
  
 -	cpu_khz = x86_platform.calibrate_cpu();
  	tsc_khz = x86_platform.calibrate_tsc();
++<<<<<<< HEAD
 +	cpu_khz = tsc_khz;
++=======
+ 
+ 	/*
+ 	 * Trust non-zero tsc_khz as authorative,
+ 	 * and use it to sanity check cpu_khz,
+ 	 * which will be off if system timer is off.
+ 	 */
+ 	if (tsc_khz == 0)
+ 		tsc_khz = cpu_khz;
+ 	else if (abs(cpu_khz - tsc_khz) * 10 > tsc_khz)
+ 		cpu_khz = tsc_khz;
++>>>>>>> ff4c86635ee1 (x86/tsc: Enumerate BXT tsc_khz via CPUID)
  
  	if (!tsc_khz) {
  		mark_tsc_unstable("could not calculate TSC khz");
* Unmerged path arch/x86/kernel/tsc.c
