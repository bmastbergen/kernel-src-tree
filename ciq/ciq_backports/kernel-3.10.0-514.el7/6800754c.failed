mmc: Fix use of wrong device in mmc_gpiod_free_cd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] Fix use of wrong device in mmc_gpiod_free_cd() (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 94.85%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 6800754c3674fb36350b2df9c3f84676e7e7a8f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6800754c.failed

mmc_gpiod_free_cd() is paired with mmc_gpiod_request_cd()
and both must reference the same device which is the
actual host controller device not the mmc_host class
device.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 6800754c3674fb36350b2df9c3f84676e7e7a8f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/slot-gpio.c
diff --cc drivers/mmc/core/slot-gpio.c
index f33bbd48c2c0,38f76555d4bf..000000000000
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@@ -250,3 -273,125 +250,128 @@@ void mmc_gpio_free_cd(struct mmc_host *
  	devm_gpio_free(&host->class_dev, gpio);
  }
  EXPORT_SYMBOL(mmc_gpio_free_cd);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * mmc_gpiod_request_cd - request a gpio descriptor for card-detection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  *
+  * Use this function in place of mmc_gpio_request_cd() to use the GPIO
+  * descriptor API.  Note that it is paired with mmc_gpiod_free_cd() not
+  * mmc_gpio_free_cd().  Note also that it must be called prior to mmc_add_host()
+  * otherwise the caller must also call mmc_gpiod_request_cd_irq().
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->cd_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	ctx->override_cd_active_level = override_active_level;
+ 	ctx->cd_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_cd);
+ 
+ /**
+  * mmc_gpiod_request_ro - request a gpio descriptor for write protection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  *
+  * Use this function in place of mmc_gpio_request_ro() to use the GPIO
+  * descriptor API.  Note that it is paired with mmc_gpiod_free_ro() not
+  * mmc_gpio_free_ro().
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->ro_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	ctx->override_ro_active_level = override_active_level;
+ 	ctx->ro_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_ro);
+ 
+ /**
+  * mmc_gpiod_free_cd - free the card-detection gpio descriptor
+  * @host: mmc host
+  *
+  * It's provided only for cases that client drivers need to manually free
+  * up the card-detection gpio requested by mmc_gpiod_request_cd().
+  */
+ void mmc_gpiod_free_cd(struct mmc_host *host)
+ {
+ 	struct mmc_gpio *ctx = host->slot.handler_priv;
+ 
+ 	if (!ctx || !ctx->cd_gpio)
+ 		return;
+ 
+ 	if (host->slot.cd_irq >= 0) {
+ 		devm_free_irq(&host->class_dev, host->slot.cd_irq, host);
+ 		host->slot.cd_irq = -EINVAL;
+ 	}
+ 
+ 	devm_gpiod_put(host->parent, ctx->cd_gpio);
+ 
+ 	ctx->cd_gpio = NULL;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_free_cd);
++>>>>>>> 6800754c3674 (mmc: Fix use of wrong device in mmc_gpiod_free_cd())
* Unmerged path drivers/mmc/core/slot-gpio.c
