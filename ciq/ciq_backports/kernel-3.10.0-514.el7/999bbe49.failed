watchdog: use suspend/resume interface in fixup_ht_bug()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ulrich Obergfell <uobergfe@redhat.com>
commit 999bbe49ea0118b70ddf3f5d679f51dc7a97ae55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/999bbe49.failed

Remove watchdog_nmi_disable_all() and watchdog_nmi_enable_all() since
these functions are no longer needed.  If a subsystem has a need to
deactivate the watchdog temporarily, it should utilize the
watchdog_suspend() and watchdog_resume() functions.

[akpm@linux-foundation.org: fix build with CONFIG_LOCKUP_DETECTOR=m]
	Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
	Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
	Cc: Guenter Roeck <linux@roeck-us.net>
	Cc: Don Zickus <dzickus@redhat.com>
	Cc: Ulrich Obergfell <uobergfe@redhat.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Chris Metcalf <cmetcalf@ezchip.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Ingo Molnar <mingo@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 999bbe49ea0118b70ddf3f5d679f51dc7a97ae55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/nmi.h
#	kernel/watchdog.c
diff --cc include/linux/nmi.h
index 6fe7c9ae7224,e5afe8bae202..000000000000
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@@ -25,16 -25,9 +25,22 @@@ static inline void touch_nmi_watchdog(v
  #endif
  
  #if defined(CONFIG_HARDLOCKUP_DETECTOR)
++<<<<<<< HEAD
 +extern void watchdog_enable_hardlockup_detector(bool val);
 +extern bool watchdog_hardlockup_detector_is_enabled(void);
 +#else
 +static inline void watchdog_enable_hardlockup_detector(bool val)
 +{
 +}
 +static inline bool watchdog_hardlockup_detector_is_enabled(void)
 +{
 +	return true;
 +}
++=======
+ extern void hardlockup_detector_disable(void);
+ #else
+ static inline void hardlockup_detector_disable(void) {}
++>>>>>>> 999bbe49ea01 (watchdog: use suspend/resume interface in fixup_ht_bug())
  #endif
  
  /*
@@@ -82,8 -76,23 +88,28 @@@ extern int proc_soft_watchdog(struct ct
  			      void __user *, size_t *, loff_t *);
  extern int proc_watchdog_thresh(struct ctl_table *, int ,
  				void __user *, size_t *, loff_t *);
++<<<<<<< HEAD
 +extern int proc_dowatchdog(struct ctl_table *, int ,
 +			   void __user *, size_t *, loff_t *);
++=======
+ extern int proc_watchdog_cpumask(struct ctl_table *, int,
+ 				 void __user *, size_t *, loff_t *);
+ extern int watchdog_suspend(void);
+ extern void watchdog_resume(void);
+ #else
+ static inline int watchdog_suspend(void)
+ {
+ 	return 0;
+ }
+ 
+ static inline void watchdog_resume(void)
+ {
+ }
+ #endif
+ 
+ #ifdef CONFIG_HAVE_ACPI_APEI_NMI
+ #include <asm/nmi.h>
++>>>>>>> 999bbe49ea01 (watchdog: use suspend/resume interface in fixup_ht_bug())
  #endif
  
  #endif
diff --cc kernel/watchdog.c
index 22977eb33006,69666f4b8e8f..000000000000
--- a/kernel/watchdog.c
+++ b/kernel/watchdog.c
@@@ -622,41 -615,6 +622,44 @@@ static void watchdog_nmi_disable(unsign
  	}
  }
  
++<<<<<<< HEAD
 +void watchdog_nmi_enable_all(void)
 +{
 +	int cpu;
 +
 +	mutex_lock(&watchdog_proc_mutex);
 +
 +	if (!(watchdog_enabled & NMI_WATCHDOG_ENABLED))
 +		goto unlock;
 +
 +	get_online_cpus();
 +	for_each_online_cpu(cpu)
 +		watchdog_nmi_enable(cpu);
 +	put_online_cpus();
 +
 +unlock:
 +	mutex_unlock(&watchdog_proc_mutex);
 +}
 +
 +void watchdog_nmi_disable_all(void)
 +{
 +	int cpu;
 +
 +	mutex_lock(&watchdog_proc_mutex);
 +
 +	if (!watchdog_running)
 +		goto unlock;
 +
 +	get_online_cpus();
 +	for_each_online_cpu(cpu)
 +		watchdog_nmi_disable(cpu);
 +	put_online_cpus();
 +
 +unlock:
 +	mutex_unlock(&watchdog_proc_mutex);
 +}
++=======
++>>>>>>> 999bbe49ea01 (watchdog: use suspend/resume interface in fixup_ht_bug())
  #else
  static int watchdog_nmi_enable(unsigned int cpu) { return 0; }
  static void watchdog_nmi_disable(unsigned int cpu) { return; }
diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c
index d4cfd53179e2..56a699fcb649 100644
--- a/arch/x86/kernel/cpu/perf_event_intel.c
+++ b/arch/x86/kernel/cpu/perf_event_intel.c
@@ -3728,7 +3728,10 @@ static __init int fixup_ht_bug(void)
 		return 0;
 	}
 
-	watchdog_nmi_disable_all();
+	if (watchdog_suspend() != 0) {
+		pr_debug("failed to disable PMU erratum BJ122, BV98, HSD29 workaround\n");
+		return 0;
+	}
 
 	x86_pmu.flags &= ~(PMU_FL_EXCL_CNTRS | PMU_FL_EXCL_ENABLED);
 
@@ -3736,7 +3739,7 @@ static __init int fixup_ht_bug(void)
 	x86_pmu.commit_scheduling = NULL;
 	x86_pmu.stop_scheduling = NULL;
 
-	watchdog_nmi_enable_all();
+	watchdog_resume();
 
 	get_online_cpus();
 
* Unmerged path include/linux/nmi.h
* Unmerged path kernel/watchdog.c
