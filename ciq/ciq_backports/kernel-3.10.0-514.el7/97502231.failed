udp: ipv4: must add synchronization in udp_sk_rx_dst_set()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 975022310233fb0f0193873d79a7b8438070fa82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/97502231.failed

Unlike TCP, UDP input path does not hold the socket lock.

Before messing with sk->sk_rx_dst, we must use a spinlock, otherwise
multiple cpus could leak a refcount.

This patch also takes care of renewing a stale dst entry.
(When the sk->sk_rx_dst would not be used by IP early demux)

Fixes: 421b3885bf6d ("udp: ipv4: Add udp early demux")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Shawn Bohrer <sbohrer@rgmadvisors.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 975022310233fb0f0193873d79a7b8438070fa82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
diff --cc net/ipv4/udp.c
index 556580e2c4f8,62c19fdd102d..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -1630,6 -1599,23 +1630,26 @@@ static void flush_stack(struct sock **s
  		kfree_skb(skb1);
  }
  
++<<<<<<< HEAD
++=======
+ /* For TCP sockets, sk_rx_dst is protected by socket lock
+  * For UDP, we use sk_dst_lock to guard against concurrent changes.
+  */
+ static void udp_sk_rx_dst_set(struct sock *sk, struct dst_entry *dst)
+ {
+ 	struct dst_entry *old;
+ 
+ 	spin_lock(&sk->sk_dst_lock);
+ 	old = sk->sk_rx_dst;
+ 	if (likely(old != dst)) {
+ 		dst_hold(dst);
+ 		sk->sk_rx_dst = dst;
+ 		dst_release(old);
+ 	}
+ 	spin_unlock(&sk->sk_dst_lock);
+ }
+ 
++>>>>>>> 975022310233 (udp: ipv4: must add synchronization in udp_sk_rx_dst_set())
  /*
   *	Multicasts and broadcasts go to each listener.
   *
@@@ -1743,11 -1744,29 +1763,37 @@@ int __udp4_lib_rcv(struct sk_buff *skb
  	if (udp4_csum_init(skb, uh, proto))
  		goto csum_error;
  
++<<<<<<< HEAD
 +	if (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
 +		return __udp4_lib_mcast_deliver(net, skb, uh,
 +				saddr, daddr, udptable);
 +
 +	sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable);
++=======
+ 	sk = skb_steal_sock(skb);
+ 	if (sk) {
+ 		struct dst_entry *dst = skb_dst(skb);
+ 		int ret;
+ 
+ 		if (unlikely(sk->sk_rx_dst != dst))
+ 			udp_sk_rx_dst_set(sk, dst);
+ 
+ 		ret = udp_queue_rcv_skb(sk, skb);
+ 		sock_put(sk);
+ 		/* a return value > 0 means to resubmit the input, but
+ 		 * it wants the return to be -protocol, or 0
+ 		 */
+ 		if (ret > 0)
+ 			return -ret;
+ 		return 0;
+ 	} else {
+ 		if (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
+ 			return __udp4_lib_mcast_deliver(net, skb, uh,
+ 					saddr, daddr, udptable);
+ 
+ 		sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable);
+ 	}
++>>>>>>> 975022310233 (udp: ipv4: must add synchronization in udp_sk_rx_dst_set())
  
  	if (sk != NULL) {
  		int ret;
* Unmerged path net/ipv4/udp.c
