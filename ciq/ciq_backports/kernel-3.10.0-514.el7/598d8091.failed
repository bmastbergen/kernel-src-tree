mm: convert pr_warning to pr_warn

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] Convert pr_warning to pr_warn (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 93.55%
commit-author Joe Perches <joe@perches.com>
commit 598d80914e84fa79580850530f5d4a50a99bf4f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/598d8091.failed

There are a mixture of pr_warning and pr_warn uses in mm.  Use pr_warn
consistently.

Miscellanea:

 - Coalesce formats
 - Realign arguments

	Signed-off-by: Joe Perches <joe@perches.com>
	Acked-by: Tejun Heo <tj@kernel.org>	[percpu]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 598d80914e84fa79580850530f5d4a50a99bf4f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kmemleak.c
#	mm/percpu.c
diff --cc mm/kmemleak.c
index c8d7f3110fd0,a81cd76ea282..000000000000
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@@ -265,9 -276,9 +265,9 @@@ static void kmemleak_disable(void)
   * Print a warning and dump the stack trace.
   */
  #define kmemleak_warn(x...)	do {		\
- 	pr_warning(x);				\
+ 	pr_warn(x);				\
  	dump_stack();				\
 -	kmemleak_warning = 1;			\
 +	atomic_set(&kmemleak_warning, 1);	\
  } while (0)
  
  /*
@@@ -1769,9 -1873,9 +1769,15 @@@ void __init kmemleak_init(void
  	object_cache = KMEM_CACHE(kmemleak_object, SLAB_NOLEAKTRACE);
  	scan_area_cache = KMEM_CACHE(kmemleak_scan_area, SLAB_NOLEAKTRACE);
  
++<<<<<<< HEAD
 +	if (crt_early_log >= ARRAY_SIZE(early_log))
 +		pr_warning("Early log buffer exceeded (%d), please increase "
 +			   "DEBUG_KMEMLEAK_EARLY_LOG_SIZE\n", crt_early_log);
++=======
+ 	if (crt_early_log > ARRAY_SIZE(early_log))
+ 		pr_warn("Early log buffer exceeded (%d), please increase DEBUG_KMEMLEAK_EARLY_LOG_SIZE\n",
+ 			crt_early_log);
++>>>>>>> 598d80914e84 (mm: convert pr_warning to pr_warn)
  
  	/* the kernel is still in UP mode, so disabling the IRQs is enough */
  	local_irq_save(flags);
diff --cc mm/percpu.c
index 29e7e6e746eb,847814b15233..000000000000
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@@ -2018,10 -2015,9 +2018,16 @@@ int __init pcpu_embed_first_chunk(size_
  	max_distance += ai->unit_size;
  
  	/* warn if maximum distance is further than 75% of vmalloc space */
++<<<<<<< HEAD
 +	if (max_distance > (VMALLOC_END - VMALLOC_START) * 3 / 4) {
 +		pr_warning("PERCPU: max_distance=0x%zx too large for vmalloc "
 +			   "space 0x%lx\n", max_distance,
 +			   (unsigned long)(VMALLOC_END - VMALLOC_START));
++=======
+ 	if (max_distance > VMALLOC_TOTAL * 3 / 4) {
+ 		pr_warn("PERCPU: max_distance=0x%zx too large for vmalloc space 0x%lx\n",
+ 			max_distance, VMALLOC_TOTAL);
++>>>>>>> 598d80914e84 (mm: convert pr_warning to pr_warn)
  #ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK
  		/* and fail if we have fallback */
  		rc = -EINVAL;
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 71d89b84e581..666603e4c09f 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -2150,7 +2150,7 @@ void __init hugetlb_add_hstate(unsigned order)
 	unsigned long i;
 
 	if (size_to_hstate(PAGE_SIZE << order)) {
-		pr_warning("hugepagesz= specified twice, ignoring\n");
+		pr_warn("hugepagesz= specified twice, ignoring\n");
 		return;
 	}
 	BUG_ON(hugetlb_max_hstate >= HUGE_MAX_HSTATE);
@@ -2186,8 +2186,7 @@ static int __init hugetlb_nrpages_setup(char *s)
 		mhp = &parsed_hstate->max_huge_pages;
 
 	if (mhp == last_mhp) {
-		pr_warning("hugepages= specified twice without "
-			   "interleaving hugepagesz=, ignoring\n");
+		pr_warn("hugepages= specified twice without interleaving hugepagesz=, ignoring\n");
 		return 1;
 	}
 
* Unmerged path mm/kmemleak.c
* Unmerged path mm/percpu.c
