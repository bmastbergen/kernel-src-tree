net/mlx4_en: Use the new tx_copybreak to set inline threshold

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Use the new tx_copybreak to set inline threshold (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 96.61%
commit-author Eric Dumazet <edumazet@google.com>
commit 1556b8746e52501fdfaadd65837baaa63a9fa937
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1556b874.failed

Instead of setting inline threshold using module parameter only on
driver load, use set_tunable() to set it dynamically.
No need to store the threshold per ring, using instead the netdev global
priv->prof->inline_thold
Initial value still is set using the module parameter, therefore
backward compatability is kept.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Amir Vadai <amirv@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1556b8746e52501fdfaadd65837baaa63a9fa937)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx4/en_tx.c
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 4f071e60808e,ae83da9cd18a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -1834,112 -1267,48 +1834,157 @@@ static u32 mlx4_en_get_priv_flags(struc
  	return priv->pflags;
  }
  
++<<<<<<< HEAD
 +static int mlx4_en_get_module_info(struct net_device *dev,
 +				   struct ethtool_modinfo *modinfo)
 +{
 +	struct mlx4_en_priv *priv = netdev_priv(dev);
 +	struct mlx4_en_dev *mdev = priv->mdev;
 +	int ret;
 +	u8 data[4];
 +
 +	/* Read first 2 bytes to get Module & REV ID */
 +	ret = mlx4_get_module_info(mdev->dev, priv->port,
 +				   0/*offset*/, 2/*size*/, data);
 +	if (ret < 2)
 +		return -EIO;
 +
 +	switch (data[0] /* identifier */) {
 +	case MLX4_MODULE_ID_QSFP:
 +		modinfo->type = ETH_MODULE_SFF_8436;
 +		modinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;
 +		break;
 +	case MLX4_MODULE_ID_QSFP_PLUS:
 +		if (data[1] >= 0x3) { /* revision id */
 +			modinfo->type = ETH_MODULE_SFF_8636;
 +			modinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;
 +		} else {
 +			modinfo->type = ETH_MODULE_SFF_8436;
 +			modinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;
 +		}
 +		break;
 +	case MLX4_MODULE_ID_QSFP28:
 +		modinfo->type = ETH_MODULE_SFF_8636;
 +		modinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;
 +		break;
 +	case MLX4_MODULE_ID_SFP:
 +		modinfo->type = ETH_MODULE_SFF_8472;
 +		modinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;
 +		break;
 +	default:
 +		return -ENOSYS;
 +	}
 +
 +	return 0;
 +}
 +
 +static int mlx4_en_get_module_eeprom(struct net_device *dev,
 +				     struct ethtool_eeprom *ee,
 +				     u8 *data)
 +{
 +	struct mlx4_en_priv *priv = netdev_priv(dev);
 +	struct mlx4_en_dev *mdev = priv->mdev;
 +	int offset = ee->offset;
 +	int i = 0, ret;
 +
 +	if (ee->len == 0)
 +		return -EINVAL;
 +
 +	memset(data, 0, ee->len);
 +
 +	while (i < ee->len) {
 +		en_dbg(DRV, priv,
 +		       "mlx4_get_module_info i(%d) offset(%d) len(%d)\n",
 +		       i, offset, ee->len - i);
 +
 +		ret = mlx4_get_module_info(mdev->dev, priv->port,
 +					   offset, ee->len - i, data + i);
 +
 +		if (!ret) /* Done reading */
 +			return 0;
 +
 +		if (ret < 0) {
 +			en_err(priv,
 +			       "mlx4_get_module_info i(%d) offset(%d) bytes_to_read(%d) - FAILED (0x%x)\n",
 +			       i, offset, ee->len - i, ret);
 +			return 0;
 +		}
 +
 +		i += ret;
 +		offset += ret;
 +	}
 +	return 0;
 +}
 +
 +static int mlx4_en_set_phys_id(struct net_device *dev,
 +			       enum ethtool_phys_id_state state)
 +{
 +	int err;
 +	u16 beacon_duration;
 +	struct mlx4_en_priv *priv = netdev_priv(dev);
 +	struct mlx4_en_dev *mdev = priv->mdev;
 +
 +	if (!(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_PORT_BEACON))
 +		return -EOPNOTSUPP;
 +
 +	switch (state) {
 +	case ETHTOOL_ID_ACTIVE:
 +		beacon_duration = PORT_BEACON_MAX_LIMIT;
 +		break;
 +	case ETHTOOL_ID_INACTIVE:
 +		beacon_duration = 0;
 +		break;
 +	default:
 +		return -EOPNOTSUPP;
 +	}
 +
 +	err = mlx4_SET_PORT_BEACON(mdev->dev, priv->port, beacon_duration);
 +	return err;
 +}
++=======
+ static int mlx4_en_get_tunable(struct net_device *dev,
+ 			       const struct ethtool_tunable *tuna,
+ 			       void *data)
+ {
+ 	const struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	int ret = 0;
+ 
+ 	switch (tuna->id) {
+ 	case ETHTOOL_TX_COPYBREAK:
+ 		*(u32 *)data = priv->prof->inline_thold;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int mlx4_en_set_tunable(struct net_device *dev,
+ 			       const struct ethtool_tunable *tuna,
+ 			       const void *data)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	int val, ret = 0;
+ 
+ 	switch (tuna->id) {
+ 	case ETHTOOL_TX_COPYBREAK:
+ 		val = *(u32 *)data;
+ 		if (val < MIN_PKT_LEN || val > MAX_INLINE)
+ 			ret = -EINVAL;
+ 		else
+ 			priv->prof->inline_thold = val;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 1556b8746e52 (net/mlx4_en: Use the new tx_copybreak to set inline threshold)
  
  const struct ethtool_ops mlx4_en_ethtool_ops = {
  	.get_drvinfo = mlx4_en_get_drvinfo,
@@@ -1972,8 -1339,8 +2017,13 @@@
  	.get_ts_info = mlx4_en_get_ts_info,
  	.set_priv_flags = mlx4_en_set_priv_flags,
  	.get_priv_flags = mlx4_en_get_priv_flags,
++<<<<<<< HEAD
 +	.get_module_info = mlx4_en_get_module_info,
 +	.get_module_eeprom = mlx4_en_get_module_eeprom
++=======
+ 	.get_tunable		= mlx4_en_get_tunable,
+ 	.set_tunable		= mlx4_en_set_tunable,
++>>>>>>> 1556b8746e52 (net/mlx4_en: Use the new tx_copybreak to set inline threshold)
  };
  
  
diff --cc drivers/net/ethernet/mellanox/mlx4/en_tx.c
index 42578a9a06b2,92a7cf46d9af..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@@ -66,8 -66,6 +66,11 @@@ int mlx4_en_create_tx_ring(struct mlx4_
  	ring->size = size;
  	ring->size_mask = size - 1;
  	ring->stride = stride;
++<<<<<<< HEAD
 +	ring->inline_thold = priv->prof->inline_thold;
 +	ring->full_size = ring->size - HEADROOM - MAX_DESC_TXBBS;
++=======
++>>>>>>> 1556b8746e52 (net/mlx4_en: Use the new tx_copybreak to set inline threshold)
  
  	tmp = size * sizeof(struct mlx4_en_tx_info);
  	ring->tx_info = kmalloc_node(tmp, GFP_KERNEL | __GFP_NOWARN, node);
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_tx.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index f30ee995bbee..61f0fa3d0ea1 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@ -296,7 +296,6 @@ struct mlx4_en_tx_ring {
 	bool			bf_alloced;
 	struct netdev_queue	*tx_queue;
 	int			hwtstamp_tx_type;
-	int			inline_thold;
 } ____cacheline_aligned_in_smp;
 
 struct mlx4_en_rx_desc {
