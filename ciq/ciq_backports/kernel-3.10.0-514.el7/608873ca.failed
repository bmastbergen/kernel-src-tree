printk: release lockbuf_lock before calling console_trylock_for_printk()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jan Kara <jack@suse.cz>
commit 608873cacb9d0d2811586fcc79a38b64eabd6d32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/608873ca.failed

There's no reason to hold lockbuf_lock when entering
console_trylock_for_printk().

The first thing this function does is to call down_trylock(console_sem)
and if that fails it immediately unlocks lockbuf_lock.  So lockbuf_lock
isn't needed for that branch.  When down_trylock() succeeds, the rest of
console_trylock() is OK without lockbuf_lock (it is called without it
from other places), and the only remaining thing in
console_trylock_for_printk() is can_use_console() call.  For that call
console_sem is enough (it iterates all consoles and checks CON_ANYTIME
flag).

So we drop logbuf_lock before entering console_trylock_for_printk() which
simplifies the code.

[akpm@linux-foundation.org: fix have_callable_console() comment]
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 608873cacb9d0d2811586fcc79a38b64eabd6d32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/printk.c
diff --cc kernel/printk.c
index 6881a4f0352d,6e1b21a8a497..000000000000
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@@ -255,25 -249,10 +255,30 @@@ static char __log_buf[__LOG_BUF_LEN] __
  static char *log_buf = __log_buf;
  static u32 log_buf_len = __LOG_BUF_LEN;
  
++<<<<<<< HEAD:kernel/printk.c
 +/* cpu currently holding logbuf_lock */
 +static volatile unsigned int logbuf_cpu = UINT_MAX;
 +
 +/* Return log buffer address */
 +char *log_buf_addr_get(void)
++=======
+ /* human readable text of the record */
+ static char *log_text(const struct printk_log *msg)
++>>>>>>> 608873cacb9d (printk: release lockbuf_lock before calling console_trylock_for_printk()):kernel/printk/printk.c
 +{
 +	return log_buf;
 +}
 +
 +/* Return log buffer size */
 +u32 log_buf_len_get(void)
 +{
 +	return log_buf_len;
 +}
 +
 +/* human readable text of the record */
 +static char *log_text(const struct log *msg)
  {
 -	return (char *)msg + sizeof(struct printk_log);
 +	return (char *)msg + sizeof(struct log);
  }
  
  /* optional key/value pair dictionary attached to the record */
@@@ -1623,12 -1676,15 +1620,14 @@@ asmlinkage int vprintk_emit(int facilit
  			cont_flush(LOG_NEWLINE);
  		}
  
 -		if (stored)
 -			printed_len += text_len;
 -		else
 -			printed_len += log_store(facility, level, lflags, 0,
 -						 dict, dictlen, text, text_len);
 +		if (!stored)
 +			log_store(facility, level, lflags, 0,
 +				  dict, dictlen, text, text_len);
  	}
 +	printed_len += text_len;
  
+ 	logbuf_cpu = UINT_MAX;
+ 	raw_spin_unlock(&logbuf_lock);
  	/*
  	 * Try to acquire and then immediately release the console semaphore.
  	 * The release will print out buffers and wake up /dev/kmsg and syslog()
* Unmerged path kernel/printk.c
