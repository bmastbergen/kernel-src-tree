xfs: add configurable error support to metadata buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Carlos Maiolino <cmaiolino@redhat.com>
commit df3093907ccc718459c54c99da29dd774af41186
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/df309390.failed

With the error configuration handle for async metadata write errors
in place, we can now add initial support to the IO error processing
in xfs_buf_iodone_error().

Add an infrastructure function to look up the configuration handle,
and rearrange the error handling to prepare the way for different
error handling conigurations to be used.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Carlos Maiolino <cmaiolino@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit df3093907ccc718459c54c99da29dd774af41186)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf_item.c
#	fs/xfs/xfs_mount.h
#	fs/xfs/xfs_sysfs.c
diff --cc fs/xfs/xfs_buf_item.c
index 9099b323a893,b8d0cd4adb81..000000000000
--- a/fs/xfs/xfs_buf_item.c
+++ b/fs/xfs/xfs_buf_item.c
@@@ -1073,12 -1056,8 +1064,17 @@@ xfs_buf_iodone_callback_error
  	 * If we've already decided to shutdown the filesystem because of
  	 * I/O errors, there's no point in giving this a retry.
  	 */
++<<<<<<< HEAD
 +	if (XFS_FORCED_SHUTDOWN(mp)) {
 +		xfs_buf_stale(bp);
 +		XFS_BUF_DONE(bp);
 +		trace_xfs_buf_item_iodone(bp, _RET_IP_);
 +		goto do_callbacks;
 +	}
++=======
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		goto out_stale;
++>>>>>>> df3093907ccc (xfs: add configurable error support to metadata buffers)
  
  	if (bp->b_target != lasttarg ||
  	    time_after(jiffies, (lasttime + 5*HZ))) {
@@@ -1087,45 -1066,80 +1083,104 @@@
  	}
  	lasttarg = bp->b_target;
  
+ 	/* synchronous writes will have callers process the error */
+ 	if (!(bp->b_flags & XBF_ASYNC))
+ 		goto out_stale;
+ 
+ 	trace_xfs_buf_item_iodone_async(bp, _RET_IP_);
+ 	ASSERT(bp->b_iodone != NULL);
+ 
  	/*
  	 * If the write was asynchronous then no one will be looking for the
- 	 * error.  Clear the error state and write the buffer out again.
- 	 *
- 	 * XXX: This helps against transient write errors, but we need to find
- 	 * a way to shut the filesystem down if the writes keep failing.
- 	 *
- 	 * In practice we'll shut the filesystem down soon as non-transient
- 	 * errors tend to affect the whole device and a failing log write
- 	 * will make us give up.  But we really ought to do better here.
+ 	 * error.  If this is the first failure of this type, clear the error
+ 	 * state and write the buffer out again. This means we always retry an
+ 	 * async write failure at least once, but we also need to set the buffer
+ 	 * up to behave correctly now for repeated failures.
  	 */
++<<<<<<< HEAD
 +	if (XFS_BUF_ISASYNC(bp)) {
 +		ASSERT(bp->b_iodone != NULL);
 +
 +		trace_xfs_buf_item_iodone_async(bp, _RET_IP_);
 +
 +		xfs_buf_ioerror(bp, 0); /* errno of 0 unsets the flag */
 +
 +		if (!(bp->b_flags & (XBF_STALE|XBF_WRITE_FAIL))) {
 +			bp->b_flags |= XBF_WRITE | XBF_ASYNC |
 +				       XBF_DONE | XBF_WRITE_FAIL;
 +			xfs_buf_submit(bp);
 +		} else {
 +			xfs_buf_relse(bp);
 +		}
 +
 +		return;
++=======
+ 	if (!(bp->b_flags & (XBF_STALE|XBF_WRITE_FAIL)) ||
+ 	     bp->b_last_error != bp->b_error) {
+ 		bp->b_flags |= (XBF_WRITE | XBF_ASYNC |
+ 			        XBF_DONE | XBF_WRITE_FAIL);
+ 		bp->b_last_error = bp->b_error;
+ 		xfs_buf_ioerror(bp, 0);
+ 		xfs_buf_submit(bp);
+ 		return true;
++>>>>>>> df3093907ccc (xfs: add configurable error support to metadata buffers)
  	}
  
  	/*
- 	 * If the write of the buffer was synchronous, we want to make
- 	 * sure to return the error to the caller of xfs_bwrite().
+ 	 * Repeated failure on an async write. Take action according to the
+ 	 * error configuration we have been set up to use.
+ 	 */
+ 	cfg = xfs_error_get_cfg(mp, XFS_ERR_METADATA, bp->b_error);
+ 	if (!cfg->max_retries)
+ 		goto permanent_error;
+ 
+ 	/* still a transient error, higher layers will retry */
+ 	xfs_buf_ioerror(bp, 0);
+ 	xfs_buf_relse(bp);
+ 	return true;
+ 
+ 	/*
+ 	 * Permanent error - we need to trigger a shutdown if we haven't already
+ 	 * to indicate that inconsistency will result from this action.
  	 */
+ permanent_error:
+ 	xfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);
+ out_stale:
  	xfs_buf_stale(bp);
++<<<<<<< HEAD
 +	XFS_BUF_DONE(bp);
 +
++=======
+ 	bp->b_flags |= XBF_DONE;
++>>>>>>> df3093907ccc (xfs: add configurable error support to metadata buffers)
  	trace_xfs_buf_error_relse(bp, _RET_IP_);
+ 	return false;
+ }
+ 
+ /*
+  * This is the iodone() function for buffers which have had callbacks attached
+  * to them by xfs_buf_attach_iodone(). We need to iterate the items on the
+  * callback list, mark the buffer as having no more callbacks and then push the
+  * buffer through IO completion processing.
+  */
+ void
+ xfs_buf_iodone_callbacks(
+ 	struct xfs_buf		*bp)
+ {
+ 	/*
+ 	 * If there is an error, process it. Some errors require us
+ 	 * to run callbacks after failure processing is done so we
+ 	 * detect that and take appropriate action.
+ 	 */
+ 	if (bp->b_error && xfs_buf_iodone_callback_error(bp))
+ 		return;
+ 
+ 	/*
+ 	 * Successful IO or permanent error. Either way, we can clear the
+ 	 * retry state here in preparation for the next error that may occur.
+ 	 */
+ 	bp->b_last_error = 0;
  
- do_callbacks:
  	xfs_buf_do_callbacks(bp);
  	bp->b_fspriv = NULL;
  	bp->b_iodone = NULL;
diff --cc fs/xfs/xfs_mount.h
index fe5c55265429,0c5a97644d78..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -336,4 -384,10 +336,13 @@@ extern int	xfs_dev_is_read_only(struct 
  
  extern void	xfs_set_low_space_thresholds(struct xfs_mount *);
  
++<<<<<<< HEAD
++=======
+ int	xfs_zero_extent(struct xfs_inode *ip, xfs_fsblock_t start_fsb,
+ 			xfs_off_t count_fsb);
+ 
+ struct xfs_error_cfg * xfs_error_get_cfg(struct xfs_mount *mp,
+ 		int error_class, int error);
+ 
++>>>>>>> df3093907ccc (xfs: add configurable error support to metadata buffers)
  #endif	/* __XFS_MOUNT_H__ */
diff --cc fs/xfs/xfs_sysfs.c
index 641d625eb334,1cb5a85409af..000000000000
--- a/fs/xfs/xfs_sysfs.c
+++ b/fs/xfs/xfs_sysfs.c
@@@ -304,3 -363,104 +304,107 @@@ struct kobj_type xfs_log_ktype = 
  	.sysfs_ops = &xfs_sysfs_ops,
  	.default_attrs = xfs_log_attrs,
  };
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Metadata IO error configuration
+  *
+  * The sysfs structure here is:
+  *	...xfs/<dev>/error/<class>/<errno>/<error_attrs>
+  *
+  * where <class> allows us to discriminate between data IO and metadata IO,
+  * and any other future type of IO (e.g. special inode or directory error
+  * handling) we care to support.
+  */
+ static struct attribute *xfs_error_attrs[] = {
+ 	NULL,
+ };
+ 
+ static inline struct xfs_error_cfg *
+ to_error_cfg(struct kobject *kobject)
+ {
+ 	struct xfs_kobj *kobj = to_kobj(kobject);
+ 	return container_of(kobj, struct xfs_error_cfg, kobj);
+ }
+ 
+ struct kobj_type xfs_error_cfg_ktype = {
+ 	.release = xfs_sysfs_release,
+ 	.sysfs_ops = &xfs_sysfs_ops,
+ 	.default_attrs = xfs_error_attrs,
+ };
+ 
+ struct kobj_type xfs_error_ktype = {
+ 	.release = xfs_sysfs_release,
+ };
+ 
+ int
+ xfs_error_sysfs_init(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			error;
+ 
+ 	/* .../xfs/<dev>/error/ */
+ 	error = xfs_sysfs_init(&mp->m_error_kobj, &xfs_error_ktype,
+ 				&mp->m_kobj, "error");
+ 	if (error)
+ 		return error;
+ 
+ 	/* .../xfs/<dev>/error/metadata/ */
+ 	error = xfs_sysfs_init(&mp->m_error_meta_kobj, &xfs_error_ktype,
+ 				&mp->m_error_kobj, "metadata");
+ 	if (error)
+ 		goto out_error;
+ 
+ 	cfg = &mp->m_error_cfg[XFS_ERR_METADATA][XFS_ERR_DEFAULT];
+ 	error = xfs_sysfs_init(&cfg->kobj, &xfs_error_cfg_ktype,
+ 				&mp->m_error_meta_kobj, "default");
+ 	if (error)
+ 		goto out_error_meta;
+ 	cfg->max_retries = -1;
+ 
+ 	return 0;
+ 
+ out_error_meta:
+ 	xfs_sysfs_del(&mp->m_error_meta_kobj);
+ out_error:
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ 	return error;
+ }
+ 
+ void
+ xfs_error_sysfs_del(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			i, j;
+ 
+ 	for (i = 0; i < XFS_ERR_CLASS_MAX; i++) {
+ 		for (j = 0; j < XFS_ERR_ERRNO_MAX; j++) {
+ 			cfg = &mp->m_error_cfg[i][j];
+ 
+ 			xfs_sysfs_del(&cfg->kobj);
+ 		}
+ 	}
+ 	xfs_sysfs_del(&mp->m_error_meta_kobj);
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ }
+ 
+ struct xfs_error_cfg *
+ xfs_error_get_cfg(
+ 	struct xfs_mount	*mp,
+ 	int			error_class,
+ 	int			error)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 
+ 	switch (error) {
+ 	default:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_DEFAULT];
+ 		break;
+ 	}
+ 
+ 	return cfg;
+ }
++>>>>>>> df3093907ccc (xfs: add configurable error support to metadata buffers)
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index b5ec1b3719af..f4494dbd87b4 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -180,6 +180,7 @@ typedef struct xfs_buf {
 	unsigned int		b_page_count;	/* size of page array */
 	unsigned int		b_offset;	/* page offset in first page */
 	int			b_error;	/* error code on I/O */
+	int			b_last_error;	/* previous async I/O error */
 	const struct xfs_buf_ops	*b_ops;
 
 #ifdef XFS_BUF_LOCK_TRACKING
* Unmerged path fs/xfs/xfs_buf_item.c
* Unmerged path fs/xfs/xfs_mount.h
* Unmerged path fs/xfs/xfs_sysfs.c
diff --git a/fs/xfs/xfs_trace.h b/fs/xfs/xfs_trace.h
index dcf226ef842a..d1c8d56c3956 100644
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@ -364,7 +364,6 @@ DEFINE_BUF_EVENT(xfs_buf_delwri_split);
 DEFINE_BUF_EVENT(xfs_buf_get_uncached);
 DEFINE_BUF_EVENT(xfs_bdstrat_shut);
 DEFINE_BUF_EVENT(xfs_buf_item_relse);
-DEFINE_BUF_EVENT(xfs_buf_item_iodone);
 DEFINE_BUF_EVENT(xfs_buf_item_iodone_async);
 DEFINE_BUF_EVENT(xfs_buf_error_relse);
 DEFINE_BUF_EVENT(xfs_buf_wait_buftarg);
