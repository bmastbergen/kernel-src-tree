ipv6: Remove external dependency on rt6i_dst and rt6i_src

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit fd0273d7939f2ce3247f6aac5f6b9a0135d4cd39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fd0273d7.failed

This patch removes the assumptions that the returned rt is always
a RTF_CACHE entry with the rt6i_dst and rt6i_src containing the
destination and source address.  The dst and src can be recovered from
the calling site.

We may consider to rename (rt6i_dst, rt6i_src) to
(rt6i_key_dst, rt6i_key_src) later.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Reviewed-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Cc: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fd0273d7939f2ce3247f6aac5f6b9a0135d4cd39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ipv6.h
#	net/ipv6/icmp.c
#	net/ipv6/ip6_output.c
#	net/ipv6/output_core.c
#	net/sctp/ipv6.c
diff --cc include/net/ipv6.h
index 5dca98c3fc9f,b950a2000b7f..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -670,7 -671,10 +670,14 @@@ static inline int ipv6_addr_diff(const 
  	return __ipv6_addr_diff(a1, a2, sizeof(struct in6_addr));
  }
  
++<<<<<<< HEAD
 +void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt);
++=======
+ u32 ipv6_select_ident(struct net *net,
+ 		      const struct in6_addr *daddr,
+ 		      const struct in6_addr *saddr);
+ void ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb);
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  
  int ip6_dst_hoplimit(struct dst_entry *dst);
  
diff --cc net/ipv6/icmp.c
index 8a66e2366f49,24b359d1425b..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -197,10 -203,15 +197,22 @@@ static inline bool icmpv6_xrlim_allow(s
  		if (rt->rt6i_dst.plen < 128)
  			tmo >>= ((128 - rt->rt6i_dst.plen)>>5);
  
++<<<<<<< HEAD
 +		peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);
 +		res = inet_peer_xrlim_allow(peer, tmo);
 +		if (peer)
 +			inet_putpeer(peer);
++=======
+ 		if (icmp_global_allow()) {
+ 			struct inet_peer *peer;
+ 
+ 			peer = inet_getpeer_v6(net->ipv6.peers,
+ 					       &fl6->daddr, 1);
+ 			res = inet_peer_xrlim_allow(peer, tmo);
+ 			if (peer)
+ 				inet_putpeer(peer);
+ 		}
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  	}
  	dst_release(dst);
  	return res;
diff --cc net/ipv6/ip6_output.c
index 6e24dc6ba803,3097f2c5e890..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -564,6 -584,9 +564,12 @@@ int ip6_fragment(struct sock *sk, struc
  	}
  	mtu -= hlen + sizeof(struct frag_hdr);
  
++<<<<<<< HEAD
++=======
+ 	frag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,
+ 				    &ipv6_hdr(skb)->saddr);
+ 
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  	if (skb_has_frag_list(skb)) {
  		int first_len = skb_pagelen(skb);
  		struct sk_buff *frag2;
@@@ -1022,8 -1057,8 +1028,13 @@@ static inline int ip6_ufo_append_data(s
  			int getfrag(void *from, char *to, int offset, int len,
  			int odd, struct sk_buff *skb),
  			void *from, int length, int hh_len, int fragheaderlen,
++<<<<<<< HEAD
 +			int transhdrlen, int mtu,unsigned int flags,
 +			struct rt6_info *rt)
++=======
+ 			int transhdrlen, int mtu, unsigned int flags,
+ 			const struct flowi6 *fl6)
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  
  {
  	struct sk_buff *skb;
@@@ -1068,8 -1103,9 +1079,14 @@@
  	skb_shinfo(skb)->gso_size = (mtu - fragheaderlen -
  				     sizeof(struct frag_hdr)) & ~7;
  	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
++<<<<<<< HEAD
 +	ipv6_select_ident(&fhdr, rt);
 +	skb_shinfo(skb)->ip6_frag_id = fhdr.identification;
++=======
+ 	skb_shinfo(skb)->ip6_frag_id = ipv6_select_ident(sock_net(sk),
+ 							 &fl6->daddr,
+ 							 &fl6->saddr);
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  
  append:
  	return skb_append_datato_frags(sk, skb, getfrag, from,
@@@ -1287,10 -1326,11 +1304,10 @@@ emsgsize
  	if (((length > mtu) ||
  	     (skb && skb_is_gso(skb))) &&
  	    (sk->sk_protocol == IPPROTO_UDP) &&
 -	    (rt->dst.dev->features & NETIF_F_UFO) &&
 -	    (sk->sk_type == SOCK_DGRAM)) {
 +	    (rt->dst.dev->features & NETIF_F_UFO)) {
  		err = ip6_ufo_append_data(sk, queue, getfrag, from, length,
  					  hh_len, fragheaderlen,
- 					  transhdrlen, mtu, flags, rt);
+ 					  transhdrlen, mtu, flags, fl6);
  		if (err)
  			goto error;
  		return 0;
diff --cc net/ipv6/output_core.c
index f55ca250c2c9,055e85cb7b65..000000000000
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@@ -6,33 -6,72 +6,95 @@@
  #include <net/ipv6.h>
  #include <net/ip6_fib.h>
  #include <net/addrconf.h>
 -#include <net/secure_seq.h>
  
++<<<<<<< HEAD
 +void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)
++=======
+ static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,
+ 			       const struct in6_addr *dst,
+ 			       const struct in6_addr *src)
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  {
 -	u32 hash, id;
 -
 -	hash = __ipv6_addr_jhash(dst, hashrnd);
 -	hash = __ipv6_addr_jhash(src, hash);
 -	hash ^= net_hash_mix(net);
 +	static atomic_t ipv6_fragmentation_id;
 +	int old, new;
  
 +#if IS_ENABLED(CONFIG_IPV6)
 +	if (rt) {
 +		struct inet_peer *peer;
 +		struct net *net;
 +
++<<<<<<< HEAD
 +		net = dev_net(rt->dst.dev);
 +		peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);
 +		if (peer) {
 +			fhdr->identification = htonl(inet_getid(peer, 0));
 +			inet_putpeer(peer);
 +			return;
 +		}
 +	}
 +#endif
 +	do {
 +		old = atomic_read(&ipv6_fragmentation_id);
 +		new = old + 1;
 +		if (!new)
 +			new = 1;
 +	} while (atomic_cmpxchg(&ipv6_fragmentation_id, old, new) != old);
 +	fhdr->identification = htonl(new);
++=======
+ 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
+ 	 * set the hight order instead thus minimizing possible future
+ 	 * collisions.
+ 	 */
+ 	id = ip_idents_reserve(hash, 1);
+ 	if (unlikely(!id))
+ 		id = 1 << 31;
+ 
+ 	return id;
+ }
+ 
+ /* This function exists only for tap drivers that must support broken
+  * clients requesting UFO without specifying an IPv6 fragment ID.
+  *
+  * This is similar to ipv6_select_ident() but we use an independent hash
+  * seed to limit information leakage.
+  *
+  * The network header must be set before calling this.
+  */
+ void ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)
+ {
+ 	static u32 ip6_proxy_idents_hashrnd __read_mostly;
+ 	struct in6_addr buf[2];
+ 	struct in6_addr *addrs;
+ 	u32 id;
+ 
+ 	addrs = skb_header_pointer(skb,
+ 				   skb_network_offset(skb) +
+ 				   offsetof(struct ipv6hdr, saddr),
+ 				   sizeof(buf), buf);
+ 	if (!addrs)
+ 		return;
+ 
+ 	net_get_random_once(&ip6_proxy_idents_hashrnd,
+ 			    sizeof(ip6_proxy_idents_hashrnd));
+ 
+ 	id = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,
+ 				 &addrs[1], &addrs[0]);
+ 	skb_shinfo(skb)->ip6_frag_id = htonl(id);
+ }
+ EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);
+ 
+ u32 ipv6_select_ident(struct net *net,
+ 		      const struct in6_addr *daddr,
+ 		      const struct in6_addr *saddr)
+ {
+ 	static u32 ip6_idents_hashrnd __read_mostly;
+ 	u32 id;
+ 
+ 	net_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));
+ 
+ 	id = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);
+ 	return htonl(id);
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  }
  EXPORT_SYMBOL(ipv6_select_ident);
  
diff --cc net/sctp/ipv6.c
index 09aaba531950,17a0120ae5a5..000000000000
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@@ -339,13 -328,17 +339,20 @@@ static void sctp_v6_get_dst(struct sctp
  out:
  	if (!IS_ERR_OR_NULL(dst)) {
  		struct rt6_info *rt;
 -
  		rt = (struct rt6_info *)dst;
  		t->dst = dst;
++<<<<<<< HEAD
 +		SCTP_DEBUG_PRINTK("rt6_dst:%pI6 rt6_src:%pI6\n",
 +			&rt->rt6i_dst.addr, &fl6->saddr);
++=======
+ 		t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
+ 		pr_debug("rt6_dst:%pI6/%d rt6_src:%pI6\n",
+ 			 &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
+ 			 &fl6->saddr);
++>>>>>>> fd0273d7939f (ipv6: Remove external dependency on rt6i_dst and rt6i_src)
  	} else {
  		t->dst = NULL;
 -
 -		pr_debug("no route\n");
 +		SCTP_DEBUG_PRINTK("NO ROUTE\n");
  	}
  }
  
diff --git a/drivers/scsi/cxgbi/libcxgbi.c b/drivers/scsi/cxgbi/libcxgbi.c
index 0c235535fc76..5001dd27e972 100644
--- a/drivers/scsi/cxgbi/libcxgbi.c
+++ b/drivers/scsi/cxgbi/libcxgbi.c
@@ -728,7 +728,7 @@ static struct cxgbi_sock *cxgbi_check_route6(struct sockaddr *dst_addr)
 	}
 	ndev = n->dev;
 
-	if (ipv6_addr_is_multicast(&rt->rt6i_dst.addr)) {
+	if (ipv6_addr_is_multicast(&daddr6->sin6_addr)) {
 		pr_info("multi-cast route %pI6 port %u, dev %s.\n",
 			daddr6->sin6_addr.s6_addr,
 			ntohs(daddr6->sin6_port), ndev->name);
* Unmerged path include/net/ipv6.h
* Unmerged path net/ipv6/icmp.c
* Unmerged path net/ipv6/ip6_output.c
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index a9a67c3fc33d..3e147f40eef8 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1449,7 +1449,7 @@ void ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target)
 			  "Redirect: destination is not a neighbour\n");
 		goto release;
 	}
-	peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);
+	peer = inet_getpeer_v6(net->ipv6.peers, &ipv6_hdr(skb)->saddr, 1);
 	ret = inet_peer_xrlim_allow(peer, 1*HZ);
 	if (peer)
 		inet_putpeer(peer);
* Unmerged path net/ipv6/output_core.c
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index b1e56e7b4f4f..9bb6a16e0c74 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -277,7 +277,7 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
 	rt = (struct rt6_info *) dst;
 	if (tcp_death_row.sysctl_tw_recycle &&
 	    !tp->rx_opt.ts_recent_stamp &&
-	    ipv6_addr_equal(&rt->rt6i_dst.addr, &sk->sk_v6_daddr))
+	    ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr))
 		tcp_fetch_timewait_stamp(sk, dst);
 
 	icsk->icsk_ext_hdr_len = 0;
diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c
index 033f02180460..69d078e5ff90 100644
--- a/net/netfilter/ipvs/ip_vs_xmit.c
+++ b/net/netfilter/ipvs/ip_vs_xmit.c
@@ -748,7 +748,7 @@ ip_vs_nat_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,
 
 	/* From world but DNAT to loopback address? */
 	if (local && skb->dev && !(skb->dev->flags & IFF_LOOPBACK) &&
-	    ipv6_addr_type(&rt->rt6i_dst.addr) & IPV6_ADDR_LOOPBACK) {
+	    ipv6_addr_type(&cp->daddr.in6) & IPV6_ADDR_LOOPBACK) {
 		IP_VS_DBG_RL_PKT(1, AF_INET6, pp, skb, 0,
 				 "ip_vs_nat_xmit_v6(): "
 				 "stopping DNAT to loopback address");
@@ -1232,7 +1232,7 @@ ip_vs_icmp_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,
 
 	/* From world but DNAT to loopback address? */
 	if (local && skb->dev && !(skb->dev->flags & IFF_LOOPBACK) &&
-	    ipv6_addr_type(&rt->rt6i_dst.addr) & IPV6_ADDR_LOOPBACK) {
+	    ipv6_addr_type(&cp->daddr.in6) & IPV6_ADDR_LOOPBACK) {
 		IP_VS_DBG(1, "%s(): "
 			  "stopping DNAT to loopback %pI6\n",
 			  __func__, &cp->daddr.in6);
* Unmerged path net/sctp/ipv6.c
