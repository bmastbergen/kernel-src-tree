PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [pci] msi: Rename pci_msi_check_device() to pci_msi_supported() (Myron Stowe) [1325402]
Rebuild_FUZZ: 96.61%
commit-author Alexander Gordeev <agordeev@redhat.com>
commit a06cd74cefe754341f747ddc4cf7b0058fa9bff8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a06cd74c.failed

Rename pci_msi_check_device() to pci_msi_supported() for clarity.  Note
that pci_msi_supported() returns true if MSI/MSI-X is supported, so code
like:

  if (pci_msi_supported(...))

reads naturally.

[bhelgaas: changelog, split to separate patch, reverse sense]
	Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit a06cd74cefe754341f747ddc4cf7b0058fa9bff8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/msi.c
diff --cc drivers/pci/msi.c
index 35bd42459f55,5f1e5dc994cf..000000000000
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@@ -859,17 -802,18 +859,28 @@@ out_free
   *
   * Look at global flags, the device itself, and its parent buses
   * to determine if MSI/-X are supported for the device. If MSI/-X is
-  * supported return 0, else return an error code.
+  * supported return 1, else return 0.
   **/
++<<<<<<< HEAD
 +static int pci_msi_check_device(struct pci_dev *dev, int nvec, int type)
++=======
+ static int pci_msi_supported(struct pci_dev *dev, int nvec)
++>>>>>>> a06cd74cefe7 (PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported())
  {
  	struct pci_bus *bus;
 +	int ret;
  
  	/* MSI must be globally enabled and supported by the device */
++<<<<<<< HEAD
 +	if (!pci_msi_enable || !dev || dev->no_msi)
 +		return -EINVAL;
++=======
+ 	if (!pci_msi_enable)
+ 		return 0;
+ 
+ 	if (!dev || dev->no_msi || dev->current_state != PCI_D0)
+ 		return 0;
++>>>>>>> a06cd74cefe7 (PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported())
  
  	/*
  	 * You can't ask to have 0 or less MSIs configured.
@@@ -888,13 -832,9 +899,17 @@@
  	 */
  	for (bus = dev->bus; bus; bus = bus->parent)
  		if (bus->bus_flags & PCI_BUS_FLAGS_NO_MSI)
- 			return -EINVAL;
+ 			return 0;
  
++<<<<<<< HEAD
 +	ret = arch_msi_check_device(dev, nvec, type);
 +	if (ret)
 +		return ret;
 +
 +	return 0;
++=======
+ 	return 1;
++>>>>>>> a06cd74cefe7 (PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported())
  }
  
  /**
@@@ -1040,12 -936,11 +1055,17 @@@ int pci_enable_msix(struct pci_dev *dev
  	int status, nr_entries;
  	int i, j;
  
 -	if (!pci_msi_supported(dev, nvec))
++<<<<<<< HEAD
 +	if (!entries || !dev->msix_cap || dev->current_state != PCI_D0)
  		return -EINVAL;
  
 -	if (!entries)
 +	status = pci_msi_check_device(dev, nvec, PCI_CAP_ID_MSIX);
 +	if (status)
 +		return status;
++=======
++	if (!pci_msi_supported(dev, nvec))
+ 		return -EINVAL;
++>>>>>>> a06cd74cefe7 (PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported())
  
  	nr_entries = pci_msix_vec_count(dev);
  	if (nr_entries < 0)
@@@ -1153,7 -1048,7 +1173,11 @@@ int pci_enable_msi_range(struct pci_de
  	int nvec;
  	int rc;
  
++<<<<<<< HEAD
 +	if (dev->current_state != PCI_D0)
++=======
+ 	if (!pci_msi_supported(dev, minvec))
++>>>>>>> a06cd74cefe7 (PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported())
  		return -EINVAL;
  
  	WARN_ON(!!dev->msi_enabled);
* Unmerged path drivers/pci/msi.c
