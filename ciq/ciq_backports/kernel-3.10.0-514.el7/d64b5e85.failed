net: add netif_tx_napi_add()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] add netif_tx_napi_add() (Ivan Vecera) [1268334]
Rebuild_FUZZ: 90.20%
commit-author Eric Dumazet <edumazet@google.com>
commit d64b5e85bfe2fe4c790abcbd16d9ae32391ddd7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d64b5e85.failed

netif_tx_napi_add() is a variant of netif_napi_add()

It should be used by drivers that use a napi structure
to exclusively poll TX.

We do not want to add this kind of napi in napi_hash[] in following
patches, adding generic busy polling to all NAPI drivers.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d64b5e85bfe2fe4c790abcbd16d9ae32391ddd7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bcmsysport.c
#	drivers/net/ethernet/broadcom/genet/bcmgenet.c
#	drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
#	drivers/net/ethernet/freescale/gianfar.c
#	drivers/net/ethernet/rocker/rocker.c
#	drivers/net/ethernet/ti/cpsw.c
#	drivers/net/ethernet/ti/netcp_core.c
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
index edc120094c34,48a9c176e0d1..000000000000
--- a/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
+++ b/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
@@@ -1082,9 -1049,8 +1082,14 @@@ static int fs_enet_probe(struct platfor
  
  	ndev->netdev_ops = &fs_enet_netdev_ops;
  	ndev->watchdog_timeo = 2 * HZ;
++<<<<<<< HEAD
 +	if (fpi->use_napi)
 +		netif_napi_add(ndev, &fep->napi, fs_enet_rx_napi,
 +		               fpi->napi_weight);
++=======
+ 	netif_napi_add(ndev, &fep->napi, fs_enet_rx_napi, fpi->napi_weight);
+ 	netif_tx_napi_add(ndev, &fep->napi_tx, fs_enet_tx_napi, 2);
++>>>>>>> d64b5e85bfe2 (net: add netif_tx_napi_add())
  
  	ndev->ethtool_ops = &fs_ethtool_ops;
  
diff --cc drivers/net/ethernet/freescale/gianfar.c
index 2f6baa19a810,c8bc43e99a35..000000000000
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@@ -1089,11 -1305,78 +1089,84 @@@ static int gfar_probe(struct platform_d
  		priv->hash_regs[6] = &regs->gaddr6;
  		priv->hash_regs[7] = &regs->gaddr7;
  	}
 -}
  
++<<<<<<< HEAD
 +	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_PADDING)
 +		priv->padding = DEFAULT_PADDING;
 +	else
 +		priv->padding = 0;
++=======
+ /* Set up the ethernet device structure, private data,
+  * and anything else we need before we start
+  */
+ static int gfar_probe(struct platform_device *ofdev)
+ {
+ 	struct net_device *dev = NULL;
+ 	struct gfar_private *priv = NULL;
+ 	int err = 0, i;
+ 
+ 	err = gfar_of_init(ofdev, &dev);
+ 
+ 	if (err)
+ 		return err;
+ 
+ 	priv = netdev_priv(dev);
+ 	priv->ndev = dev;
+ 	priv->ofdev = ofdev;
+ 	priv->dev = &ofdev->dev;
+ 	SET_NETDEV_DEV(dev, &ofdev->dev);
+ 
+ 	INIT_WORK(&priv->reset_task, gfar_reset_task);
+ 
+ 	platform_set_drvdata(ofdev, priv);
+ 
+ 	gfar_detect_errata(priv);
+ 
+ 	/* Set the dev->base_addr to the gfar reg region */
+ 	dev->base_addr = (unsigned long) priv->gfargrp[0].regs;
+ 
+ 	/* Fill in the dev structure */
+ 	dev->watchdog_timeo = TX_TIMEOUT;
+ 	dev->mtu = 1500;
+ 	dev->netdev_ops = &gfar_netdev_ops;
+ 	dev->ethtool_ops = &gfar_ethtool_ops;
+ 
+ 	/* Register for napi ...We are registering NAPI for each grp */
+ 	for (i = 0; i < priv->num_grps; i++) {
+ 		if (priv->poll_mode == GFAR_SQ_POLLING) {
+ 			netif_napi_add(dev, &priv->gfargrp[i].napi_rx,
+ 				       gfar_poll_rx_sq, GFAR_DEV_WEIGHT);
+ 			netif_tx_napi_add(dev, &priv->gfargrp[i].napi_tx,
+ 				       gfar_poll_tx_sq, 2);
+ 		} else {
+ 			netif_napi_add(dev, &priv->gfargrp[i].napi_rx,
+ 				       gfar_poll_rx, GFAR_DEV_WEIGHT);
+ 			netif_tx_napi_add(dev, &priv->gfargrp[i].napi_tx,
+ 				       gfar_poll_tx, 2);
+ 		}
+ 	}
+ 
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_CSUM) {
+ 		dev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG |
+ 				   NETIF_F_RXCSUM;
+ 		dev->features |= NETIF_F_IP_CSUM | NETIF_F_SG |
+ 				 NETIF_F_RXCSUM | NETIF_F_HIGHDMA;
+ 	}
+ 
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_VLAN) {
+ 		dev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX |
+ 				    NETIF_F_HW_VLAN_CTAG_RX;
+ 		dev->features |= NETIF_F_HW_VLAN_CTAG_RX;
+ 	}
+ 
+ 	dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
+ 
+ 	gfar_init_addr_hash_table(priv);
+ 
+ 	/* Insert receive time stamps into padding alignment bytes */
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER)
+ 		priv->padding = 8;
++>>>>>>> d64b5e85bfe2 (net: add netif_tx_napi_add())
  
  	if (dev->features & NETIF_F_IP_CSUM ||
  	    priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER)
diff --cc drivers/net/ethernet/ti/cpsw.c
index d1a769f35f9d,15322c08de80..000000000000
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@@ -1875,8 -2467,9 +1875,14 @@@ static int cpsw_probe(struct platform_d
  	ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
  
  	ndev->netdev_ops = &cpsw_netdev_ops;
++<<<<<<< HEAD
 +	SET_ETHTOOL_OPS(ndev, &cpsw_ethtool_ops);
 +	netif_napi_add(ndev, &priv->napi, cpsw_poll, CPSW_POLL_WEIGHT);
++=======
+ 	ndev->ethtool_ops = &cpsw_ethtool_ops;
+ 	netif_napi_add(ndev, &priv->napi_rx, cpsw_rx_poll, CPSW_POLL_WEIGHT);
+ 	netif_tx_napi_add(ndev, &priv->napi_tx, cpsw_tx_poll, CPSW_POLL_WEIGHT);
++>>>>>>> d64b5e85bfe2 (net: add netif_tx_napi_add())
  
  	/* register the network device */
  	SET_NETDEV_DEV(ndev, &pdev->dev);
diff --cc include/linux/netdevice.h
index 3d20b7a47d76,838935d1cdbb..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -341,8 -326,8 +341,13 @@@ enum 
  	NAPI_STATE_SCHED,	/* Poll is scheduled */
  	NAPI_STATE_DISABLE,	/* Disable pending */
  	NAPI_STATE_NPSVC,	/* Netpoll - don't dequeue from poll_list */
++<<<<<<< HEAD
 +	NAPI_STATE_HASHED,	/* In NAPI hash */
 +	NAPI_STATE_EXT,		/* Extended napi_struct */
++=======
+ 	NAPI_STATE_HASHED,	/* In NAPI hash (busy polling possible) */
+ 	NAPI_STATE_NO_BUSY_POLL,/* Do not add in napi_hash, no busy polling */
++>>>>>>> d64b5e85bfe2 (net: add netif_tx_napi_add())
  };
  
  enum gro_result {
@@@ -1755,22 -1936,29 +1760,42 @@@ void __netif_napi_add(struct net_devic
   * netif_napi_add() must be used to initialize a napi context prior to calling
   * *any* of the other napi related functions.
   */
 +static inline void _netif_napi_add(struct net_device *dev,
 +				   struct napi_struct *napi,
 +				   int (*poll)(struct napi_struct *, int),
 +				   int weight)
 +{
 +	__netif_napi_add(dev, napi, poll, weight, sizeof(struct napi_struct));
 +}
 +
 +/* RHEL has netif_napi_add in KABI so we need to keep it for binary
 + * modules. Another reason is that older binary modules uses non-extended
 + * napi_struct. Newly compiled modules will use inlined function that uses
 + * current (extended) napi_struct. */
  void netif_napi_add(struct net_device *dev, struct napi_struct *napi,
  		    int (*poll)(struct napi_struct *, int), int weight);
 +#define netif_napi_add _netif_napi_add
  
+ /**
+  *	netif_tx_napi_add - initialize a napi context
+  *	@dev:  network device
+  *	@napi: napi context
+  *	@poll: polling function
+  *	@weight: default weight
+  *
+  * This variant of netif_napi_add() should be used from drivers using NAPI
+  * to exclusively poll a TX queue.
+  * This will avoid we add it into napi_hash[], thus polluting this hash table.
+  */
+ static inline void netif_tx_napi_add(struct net_device *dev,
+ 				     struct napi_struct *napi,
+ 				     int (*poll)(struct napi_struct *, int),
+ 				     int weight)
+ {
+ 	set_bit(NAPI_STATE_NO_BUSY_POLL, &napi->state);
+ 	netif_napi_add(dev, napi, poll, weight);
+ }
+ 
  /**
   *  netif_napi_del - remove a napi context
   *  @napi: napi context
diff --cc net/core/dev.c
index ab84e718fe49,ff58a8bc5e3c..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4349,25 -4737,23 +4349,31 @@@ EXPORT_SYMBOL(sk_busy_loop)
  
  void napi_hash_add(struct napi_struct *napi)
  {
++<<<<<<< HEAD
 +	if (!test_and_set_bit(NAPI_STATE_HASHED, &napi->state)) {
++=======
+ 	if (test_bit(NAPI_STATE_NO_BUSY_POLL, &napi->state) ||
+ 	    test_and_set_bit(NAPI_STATE_HASHED, &napi->state))
+ 		return;
++>>>>>>> d64b5e85bfe2 (net: add netif_tx_napi_add())
  
 -	spin_lock(&napi_hash_lock);
 +		spin_lock(&napi_hash_lock);
  
 -	/* 0..NR_CPUS+1 range is reserved for sender_cpu use */
 -	do {
 -		if (unlikely(++napi_gen_id < NR_CPUS + 1))
 -			napi_gen_id = NR_CPUS + 1;
 -	} while (napi_by_id(napi_gen_id));
 -	napi->napi_id = napi_gen_id;
 +		/* 0 is not a valid id, we also skip an id that is taken
 +		 * we expect both events to be extremely rare
 +		 */
 +		napi->napi_id = 0;
 +		while (!napi->napi_id) {
 +			napi->napi_id = ++napi_gen_id;
 +			if (napi_by_id(napi->napi_id))
 +				napi->napi_id = 0;
 +		}
  
 -	hlist_add_head_rcu(&napi->napi_hash_node,
 -			   &napi_hash[napi->napi_id % HASH_SIZE(napi_hash)]);
 +		hlist_add_head_rcu(&napi->napi_hash_node,
 +			&napi_hash[napi->napi_id % HASH_SIZE(napi_hash)]);
  
 -	spin_unlock(&napi_hash_lock);
 +		spin_unlock(&napi_hash_lock);
 +	}
  }
  EXPORT_SYMBOL_GPL(napi_hash_add);
  
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path drivers/net/ethernet/ti/netcp_core.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
* Unmerged path drivers/net/ethernet/freescale/gianfar.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_cq.c b/drivers/net/ethernet/mellanox/mlx4/en_cq.c
index 92329374a4c0..79fbb0108186 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_cq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_cq.c
@@ -160,8 +160,8 @@ int mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,
 	cq->mcq.event = mlx4_en_cq_event;
 
 	if (cq->is_tx) {
-		netif_napi_add(cq->dev, &cq->napi, mlx4_en_poll_tx_cq,
-			       NAPI_POLL_WEIGHT);
+		netif_tx_napi_add(cq->dev, &cq->napi, mlx4_en_poll_tx_cq,
+				  NAPI_POLL_WEIGHT);
 	} else {
 		netif_napi_add(cq->dev, &cq->napi, mlx4_en_poll_rx_cq, 64);
 		napi_hash_add(&cq->napi);
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
index 253c0c83918e..c6d0001567dc 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
@@ -1603,7 +1603,7 @@ int qlcnic_82xx_napi_add(struct qlcnic_adapter *adapter,
 	if (qlcnic_check_multi_tx(adapter) && !adapter->ahw->diag_test) {
 		for (ring = 0; ring < adapter->drv_tx_rings; ring++) {
 			tx_ring = &adapter->tx_ring[ring];
-			netif_napi_add(netdev, &tx_ring->napi, qlcnic_tx_poll,
+			netif_tx_napi_add(netdev, &tx_ring->napi, qlcnic_tx_poll,
 				       NAPI_POLL_WEIGHT);
 		}
 	}
@@ -2134,7 +2134,7 @@ int qlcnic_83xx_napi_add(struct qlcnic_adapter *adapter,
 	    !(adapter->flags & QLCNIC_TX_INTR_SHARED)) {
 		for (ring = 0; ring < adapter->drv_tx_rings; ring++) {
 			tx_ring = &adapter->tx_ring[ring];
-			netif_napi_add(netdev, &tx_ring->napi,
+			netif_tx_napi_add(netdev, &tx_ring->napi,
 				       qlcnic_83xx_msix_tx_poll,
 				       NAPI_POLL_WEIGHT);
 		}
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path drivers/net/ethernet/ti/cpsw.c
* Unmerged path drivers/net/ethernet/ti/netcp_core.c
diff --git a/drivers/net/wireless/ath/wil6210/netdev.c b/drivers/net/wireless/ath/wil6210/netdev.c
index 86741c6b8450..855d53071c3e 100644
--- a/drivers/net/wireless/ath/wil6210/netdev.c
+++ b/drivers/net/wireless/ath/wil6210/netdev.c
@@ -180,7 +180,7 @@ void *wil_if_alloc(struct device *dev, void __iomem *csr)
 
 	netif_napi_add(ndev, &wil->napi_rx, wil6210_netdev_poll_rx,
 		       WIL6210_NAPI_BUDGET);
-	netif_napi_add(ndev, &wil->napi_tx, wil6210_netdev_poll_tx,
+	netif_tx_napi_add(ndev, &wil->napi_tx, wil6210_netdev_poll_tx,
 		       WIL6210_NAPI_BUDGET);
 
 	netif_tx_stop_all_queues(ndev);
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
