can: add missing initialisations in CAN related skbuffs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Oliver Hartkopp <socketcan@hartkopp.net>
commit 969439016d2cf61fef53a973d7e6d2061c3793b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/96943901.failed

When accessing CAN network interfaces with AF_PACKET sockets e.g. by dhclient
this can lead to a skb_under_panic due to missing skb initialisations.

Add the missing initialisations at the CAN skbuff creation times on driver
level (rx path) and in the network layer (tx path).

	Reported-by: Austin Schuh <austin@peloton-tech.com>
	Reported-by: Daniel Steer <daniel.steer@mclaren.com>
	Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
	Cc: linux-stable <stable@vger.kernel.org>
	Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
(cherry picked from commit 969439016d2cf61fef53a973d7e6d2061c3793b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/can/dev.c
diff --cc drivers/net/can/dev.c
index 02930a57e002,b0f69248cb71..000000000000
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@@ -526,6 -593,34 +530,37 @@@ struct sk_buff *alloc_can_skb(struct ne
  }
  EXPORT_SYMBOL_GPL(alloc_can_skb);
  
++<<<<<<< HEAD
++=======
+ struct sk_buff *alloc_canfd_skb(struct net_device *dev,
+ 				struct canfd_frame **cfd)
+ {
+ 	struct sk_buff *skb;
+ 
+ 	skb = netdev_alloc_skb(dev, sizeof(struct can_skb_priv) +
+ 			       sizeof(struct canfd_frame));
+ 	if (unlikely(!skb))
+ 		return NULL;
+ 
+ 	skb->protocol = htons(ETH_P_CANFD);
+ 	skb->pkt_type = PACKET_BROADCAST;
+ 	skb->ip_summed = CHECKSUM_UNNECESSARY;
+ 
+ 	skb_reset_mac_header(skb);
+ 	skb_reset_network_header(skb);
+ 	skb_reset_transport_header(skb);
+ 
+ 	can_skb_reserve(skb);
+ 	can_skb_prv(skb)->ifindex = dev->ifindex;
+ 
+ 	*cfd = (struct canfd_frame *)skb_put(skb, sizeof(struct canfd_frame));
+ 	memset(*cfd, 0, sizeof(struct canfd_frame));
+ 
+ 	return skb;
+ }
+ EXPORT_SYMBOL_GPL(alloc_canfd_skb);
+ 
++>>>>>>> 969439016d2c (can: add missing initialisations in CAN related skbuffs)
  struct sk_buff *alloc_can_err_skb(struct net_device *dev, struct can_frame **cf)
  {
  	struct sk_buff *skb;
* Unmerged path drivers/net/can/dev.c
diff --git a/net/can/af_can.c b/net/can/af_can.c
index 55e18c10e4df..2e0af2a0016d 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -261,6 +261,9 @@ int can_send(struct sk_buff *skb, int loop)
 		goto inval_skb;
 	}
 
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	skb_reset_mac_header(skb);
 	skb_reset_network_header(skb);
 	skb_reset_transport_header(skb);
 
