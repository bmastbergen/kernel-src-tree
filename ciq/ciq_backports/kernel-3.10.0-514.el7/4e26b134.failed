serial: 8250_dw: clock rate handling for all ACPI platforms

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 4e26b134bd17234e373376b561d2fc5cba3fccb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4e26b134.failed

This replaces the Baytrail specific custom set_termios hook
with a more generic one where the clock framework is used to
set the rate. The method also doesn't need to be limited to
just Baytrail, so it's used with all ACPI platforms.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4e26b134bd17234e373376b561d2fc5cba3fccb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/serial/8250/8250_dw.c
diff --cc drivers/tty/serial/8250/8250_dw.c
index 19f1fa08014f,b8e4eb3e7cbe..000000000000
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@@ -54,12 -55,19 +54,21 @@@
  
  
  struct dw8250_data {
 -	u8			usr_reg;
 -	int			last_mcr;
 -	int			line;
 -	struct clk		*clk;
 -	struct uart_8250_dma	dma;
 +	int		last_lcr;
 +	int		last_mcr;
 +	int		line;
 +	struct clk	*clk;
  };
  
++<<<<<<< HEAD
++=======
+ #define BYT_PRV_CLK			0x800
+ #define BYT_PRV_CLK_EN			(1 << 0)
+ #define BYT_PRV_CLK_M_VAL_SHIFT		1
+ #define BYT_PRV_CLK_N_VAL_SHIFT		16
+ #define BYT_PRV_CLK_UPDATE		(1 << 31)
+ 
++>>>>>>> 4e26b134bd17 (serial: 8250_dw: clock rate handling for all ACPI platforms)
  static inline int dw8250_modify_msr(struct uart_port *p, int offset, int value)
  {
  	struct dw8250_data *d = p->private_data;
@@@ -143,76 -184,39 +152,106 @@@ dw8250_do_pm(struct uart_port *port, un
  		pm_runtime_put_sync_suspend(port->dev);
  }
  
++<<<<<<< HEAD
 +static int dw8250_probe_of(struct uart_port *p)
++=======
+ static void dw8250_set_termios(struct uart_port *p, struct ktermios *termios,
+ 			       struct ktermios *old)
+ {
+ 	unsigned int baud = tty_termios_baud_rate(termios);
+ 	struct dw8250_data *d = p->private_data;
+ 	unsigned int rate;
+ 	int ret;
+ 
+ 	if (IS_ERR(d->clk) || !old)
+ 		goto out;
+ 
+ 	/* Not requesting clock rates below 1.8432Mhz */
+ 	if (baud < 115200)
+ 		baud = 115200;
+ 
+ 	clk_disable_unprepare(d->clk);
+ 	rate = clk_round_rate(d->clk, baud * 16);
+ 	ret = clk_set_rate(d->clk, rate);
+ 	clk_prepare_enable(d->clk);
+ 
+ 	if (!ret)
+ 		p->uartclk = rate;
+ out:
+ 	serial8250_do_set_termios(p, termios, old);
+ }
+ 
+ static bool dw8250_dma_filter(struct dma_chan *chan, void *param)
++>>>>>>> 4e26b134bd17 (serial: 8250_dw: clock rate handling for all ACPI platforms)
  {
 -	struct dw8250_data *data = param;
 +	struct device_node	*np = p->dev->of_node;
 +	u32			val;
  
 -	return chan->chan_id == data->dma.tx_chan_id ||
 -	       chan->chan_id == data->dma.rx_chan_id;
 +	if (!of_property_read_u32(np, "reg-io-width", &val)) {
 +		switch (val) {
 +		case 1:
 +			break;
 +		case 4:
 +			p->iotype = UPIO_MEM32;
 +			p->serial_in = dw8250_serial_in32;
 +			p->serial_out = dw8250_serial_out32;
 +			break;
 +		default:
 +			dev_err(p->dev, "unsupported reg-io-width (%u)\n", val);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	if (!of_property_read_u32(np, "reg-shift", &val))
 +		p->regshift = val;
 +
 +	/* clock got configured through clk api, all done */
 +	if (p->uartclk)
 +		return 0;
 +
 +	/* try to find out clock frequency from DT as fallback */
 +	if (of_property_read_u32(np, "clock-frequency", &val)) {
 +		dev_err(p->dev, "clk or clock-frequency not defined\n");
 +		return -EINVAL;
 +	}
 +	p->uartclk = val;
 +
 +	return 0;
 +}
 +
 +#ifdef CONFIG_ACPI
 +static int dw8250_probe_acpi(struct uart_8250_port *up)
 +{
 +	const struct acpi_device_id *id;
 +	struct uart_port *p = &up->port;
 +
 +	id = acpi_match_device(p->dev->driver->acpi_match_table, p->dev);
 +	if (!id)
 +		return -ENODEV;
 +
 +	p->iotype = UPIO_MEM32;
 +	p->serial_in = dw8250_serial_in32;
 +	p->serial_out = dw8250_serial_out32;
 +	p->regshift = 2;
 +
 +	if (!p->uartclk)
 +		p->uartclk = (unsigned int)id->driver_data;
 +
 +	up->dma = devm_kzalloc(p->dev, sizeof(*up->dma), GFP_KERNEL);
 +	if (!up->dma)
 +		return -ENOMEM;
 +
 +	up->dma->rxconf.src_maxburst = p->fifosize / 4;
 +	up->dma->txconf.dst_maxburst = p->fifosize / 4;
 +
 +	return 0;
  }
 +#else
 +static inline int dw8250_probe_acpi(struct uart_8250_port *up)
 +{
 +	return -ENODEV;
 +}
 +#endif /* CONFIG_ACPI */
  
  static void dw8250_setup_port(struct uart_8250_port *up)
  {
@@@ -246,6 -250,83 +285,86 @@@
  		up->capabilities |= UART_CAP_AFE;
  }
  
++<<<<<<< HEAD
++=======
+ static int dw8250_probe_of(struct uart_port *p,
+ 			   struct dw8250_data *data)
+ {
+ 	struct device_node	*np = p->dev->of_node;
+ 	u32			val;
+ 	bool has_ucv = true;
+ 
+ 	if (of_device_is_compatible(np, "cavium,octeon-3860-uart")) {
+ #ifdef __BIG_ENDIAN
+ 		/*
+ 		 * Low order bits of these 64-bit registers, when
+ 		 * accessed as a byte, are 7 bytes further down in the
+ 		 * address space in big endian mode.
+ 		 */
+ 		p->membase += 7;
+ #endif
+ 		p->serial_out = dw8250_serial_out_rb;
+ 		p->flags = ASYNC_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;
+ 		p->type = PORT_OCTEON;
+ 		data->usr_reg = 0x27;
+ 		has_ucv = false;
+ 	} else if (!of_property_read_u32(np, "reg-io-width", &val)) {
+ 		switch (val) {
+ 		case 1:
+ 			break;
+ 		case 4:
+ 			p->iotype = UPIO_MEM32;
+ 			p->serial_in = dw8250_serial_in32;
+ 			p->serial_out = dw8250_serial_out32;
+ 			break;
+ 		default:
+ 			dev_err(p->dev, "unsupported reg-io-width (%u)\n", val);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	if (has_ucv)
+ 		dw8250_setup_port(container_of(p, struct uart_8250_port, port));
+ 
+ 	if (!of_property_read_u32(np, "reg-shift", &val))
+ 		p->regshift = val;
+ 
+ 	/* clock got configured through clk api, all done */
+ 	if (p->uartclk)
+ 		return 0;
+ 
+ 	/* try to find out clock frequency from DT as fallback */
+ 	if (of_property_read_u32(np, "clock-frequency", &val)) {
+ 		dev_err(p->dev, "clk or clock-frequency not defined\n");
+ 		return -EINVAL;
+ 	}
+ 	p->uartclk = val;
+ 
+ 	return 0;
+ }
+ 
+ static int dw8250_probe_acpi(struct uart_8250_port *up,
+ 			     struct dw8250_data *data)
+ {
+ 	struct uart_port *p = &up->port;
+ 
+ 	dw8250_setup_port(up);
+ 
+ 	p->iotype = UPIO_MEM32;
+ 	p->serial_in = dw8250_serial_in32;
+ 	p->serial_out = dw8250_serial_out32;
+ 	p->regshift = 2;
+ 
+ 	up->dma = &data->dma;
+ 
+ 	up->dma->rxconf.src_maxburst = p->fifosize / 4;
+ 	up->dma->txconf.dst_maxburst = p->fifosize / 4;
+ 
+ 	up->port.set_termios = dw8250_set_termios;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4e26b134bd17 (serial: 8250_dw: clock rate handling for all ACPI platforms)
  static int dw8250_probe(struct platform_device *pdev)
  {
  	struct uart_8250_port uart = {};
@@@ -387,6 -474,8 +506,11 @@@ MODULE_DEVICE_TABLE(of, dw8250_of_match
  static const struct acpi_device_id dw8250_acpi_match[] = {
  	{ "INT33C4", 0 },
  	{ "INT33C5", 0 },
++<<<<<<< HEAD
++=======
+ 	{ "INT3434", 0 },
+ 	{ "INT3435", 0 },
++>>>>>>> 4e26b134bd17 (serial: 8250_dw: clock rate handling for all ACPI platforms)
  	{ "80860F0A", 0 },
  	{ },
  };
* Unmerged path drivers/tty/serial/8250/8250_dw.c
