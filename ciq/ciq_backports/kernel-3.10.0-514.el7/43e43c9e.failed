dm mpath: fix infinite recursion in ioctl when no paths and !queue_if_no_path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Junichi Nomura <j-nomura@ce.jp.nec.com>
commit 43e43c9ea60a7a1831ec823773e924d2dadefd44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/43e43c9e.failed

In multipath_prepare_ioctl(),
  - pgpath is a path selected from available paths
  - m->queue_io is true if we cannot send a request immediately to
    paths, either because:
      * there is no available path
      * the path group needs activation (pg_init)
          - pg_init is not started
          - pg_init is still running
  - m->queue_if_no_path is true if the device is configured to queue
    I/O if there are no available paths

If !pgpath && !m->queue_if_no_path, the handler should return -EIO.
However in the course of refactoring the condition check has broken
and returns success in that case.  Since bdev points to the dm device
itself, dm_blk_ioctl() calls __blk_dev_driver_ioctl() for itself and
recurses until crash.

You could reproduce the problem like this:

  # dmsetup create mp --table '0 1024 multipath 0 0 0 0'
  # sg_inq /dev/mapper/mp
  <crash>
  [  172.648615] BUG: unable to handle kernel paging request at fffffffc81b10268
  [  172.662843] PGD 19dd067 PUD 0
  [  172.666269] Thread overran stack, or stack corrupted
  [  172.671808] Oops: 0000 [#1] SMP
  ...

Fix the condition check with some clarifications.

Fixes: e56f81e0b01e ("dm: refactor ioctl handling")
	Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Mike Snitzer <snitzer@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 43e43c9ea60a7a1831ec823773e924d2dadefd44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-mpath.c
diff --cc drivers/md/dm-mpath.c
index 84de222f462c,cfa29f574c2a..000000000000
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@@ -1548,46 -1533,38 +1548,72 @@@ out
  	return r;
  }
  
 -static int multipath_prepare_ioctl(struct dm_target *ti,
 -		struct block_device **bdev, fmode_t *mode)
 +static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
 +			   unsigned long arg)
  {
  	struct multipath *m = ti->private;
++<<<<<<< HEAD
 +	struct pgpath *pgpath;
 +	struct block_device *bdev;
 +	fmode_t mode;
  	unsigned long flags;
  	int r;
  
 +	bdev = NULL;
 +	mode = 0;
 +	r = 0;
 +
++=======
++	unsigned long flags;
++	int r;
++
++>>>>>>> 43e43c9ea60a (dm mpath: fix infinite recursion in ioctl when no paths and !queue_if_no_path)
  	spin_lock_irqsave(&m->lock, flags);
  
  	if (!m->current_pgpath)
  		__choose_pgpath(m, 0);
  
++<<<<<<< HEAD
 +	pgpath = m->current_pgpath;
 +
 +	if (pgpath) {
 +		bdev = pgpath->path.dev->bdev;
 +		mode = pgpath->path.dev->mode;
 +	}
 +
 +	if ((pgpath && m->queue_io) || (!pgpath && m->queue_if_no_path))
 +		r = -ENOTCONN;
 +	else if (!bdev)
 +		r = -EIO;
 +
++=======
+ 	if (m->current_pgpath) {
+ 		if (!m->queue_io) {
+ 			*bdev = m->current_pgpath->path.dev->bdev;
+ 			*mode = m->current_pgpath->path.dev->mode;
+ 			r = 0;
+ 		} else {
+ 			/* pg_init has not started or completed */
+ 			r = -ENOTCONN;
+ 		}
+ 	} else {
+ 		/* No path is available */
+ 		if (m->queue_if_no_path)
+ 			r = -ENOTCONN;
+ 		else
+ 			r = -EIO;
+ 	}
+ 
++>>>>>>> 43e43c9ea60a (dm mpath: fix infinite recursion in ioctl when no paths and !queue_if_no_path)
  	spin_unlock_irqrestore(&m->lock, flags);
  
 -	if (r == -ENOTCONN) {
 +	/*
 +	 * Only pass ioctls through if the device sizes match exactly.
 +	 */
 +	if (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
 +		r = scsi_verify_blk_ioctl(NULL, cmd);
 +
 +	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
  		spin_lock_irqsave(&m->lock, flags);
  		if (!m->current_pg) {
  			/* Path status changed, redo selection */
* Unmerged path drivers/md/dm-mpath.c
