Bluetooth: add LED trigger for indicating HCI is powered up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 6d5d2ee63cee7025badda3b74ae2ef7ab097acfa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6d5d2ee6.failed

Add support for LED triggers to the Bluetooth subsystem and add kernel
config symbol BT_LEDS for it.

For now one trigger for indicating "HCI is powered up" is supported.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 6d5d2ee63cee7025badda3b74ae2ef7ab097acfa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/Kconfig
#	net/bluetooth/Makefile
#	net/bluetooth/hci_core.c
diff --cc net/bluetooth/Kconfig
index d3f3f7b1d32c,06c31b9a68b0..000000000000
--- a/net/bluetooth/Kconfig
+++ b/net/bluetooth/Kconfig
@@@ -47,4 -53,64 +47,67 @@@ source "net/bluetooth/cmtp/Kconfig
  
  source "net/bluetooth/hidp/Kconfig"
  
++<<<<<<< HEAD
++=======
+ config BT_HS
+ 	bool "Bluetooth High Speed (HS) features"
+ 	depends on BT_BREDR
+ 	default y
+ 
+ config BT_LE
+ 	bool "Bluetooth Low Energy (LE) features"
+ 	depends on BT
+ 	default y
+ 
+ config BT_6LOWPAN
+ 	tristate "Bluetooth 6LoWPAN support"
+ 	depends on BT_LE && 6LOWPAN
+ 	help
+ 	  IPv6 compression over Bluetooth Low Energy.
+ 
+ config BT_LEDS
+ 	bool "Enable LED triggers"
+ 	depends on BT
+ 	depends on LEDS_CLASS
+ 	select LEDS_TRIGGERS
+ 	help
+ 	  This option selects a few LED triggers for different
+ 	  Bluetooth events.
+ 
+ config BT_SELFTEST
+ 	bool "Bluetooth self testing support"
+ 	depends on BT && DEBUG_KERNEL
+ 	help
+ 	  Run self tests when initializing the Bluetooth subsystem.  This
+ 	  is a developer option and can cause significant delay when booting
+ 	  the system.
+ 
+ 	  When the Bluetooth subsystem is built as module, then the test
+ 	  cases are run first thing at module load time.  When the Bluetooth
+ 	  subsystem is compiled into the kernel image, then the test cases
+ 	  are run late in the initcall hierarchy.
+ 
+ config BT_SELFTEST_ECDH
+ 	bool "ECDH test cases"
+ 	depends on BT_LE && BT_SELFTEST
+ 	help
+ 	  Run test cases for ECDH cryptographic functionality used by the
+ 	  Bluetooth Low Energy Secure Connections feature.
+ 
+ config BT_SELFTEST_SMP
+ 	bool "SMP test cases"
+ 	depends on BT_LE && BT_SELFTEST
+ 	help
+ 	  Run test cases for SMP cryptographic functionality, including both
+ 	  legacy SMP as well as the Secure Connections features.
+ 
+ config BT_DEBUGFS
+ 	bool "Export Bluetooth internals in debugfs"
+ 	depends on BT && DEBUG_FS
+ 	default y
+ 	help
+ 	  Provide extensive information about internal Bluetooth states
+ 	  in debugfs.
+ 
++>>>>>>> 6d5d2ee63cee (Bluetooth: add LED trigger for indicating HCI is powered up)
  source "drivers/bluetooth/Kconfig"
diff --cc net/bluetooth/Makefile
index dea6a287daca,b3ff12eb9b6d..000000000000
--- a/net/bluetooth/Makefile
+++ b/net/bluetooth/Makefile
@@@ -7,7 -7,18 +7,20 @@@ obj-$(CONFIG_BT_RFCOMM)	+= rfcomm
  obj-$(CONFIG_BT_BNEP)	+= bnep/
  obj-$(CONFIG_BT_CMTP)	+= cmtp/
  obj-$(CONFIG_BT_HIDP)	+= hidp/
 -obj-$(CONFIG_BT_6LOWPAN) += bluetooth_6lowpan.o
 -
 -bluetooth_6lowpan-y := 6lowpan.o
  
  bluetooth-y := af_bluetooth.o hci_core.o hci_conn.o hci_event.o mgmt.o \
++<<<<<<< HEAD
 +	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o sco.o lib.o \
 +	a2mp.o amp.o
++=======
+ 	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o lib.o \
+ 	ecc.o hci_request.o mgmt_util.o
+ 
+ bluetooth-$(CONFIG_BT_BREDR) += sco.o
+ bluetooth-$(CONFIG_BT_HS) += a2mp.o amp.o
+ bluetooth-$(CONFIG_BT_LEDS) += leds.o
+ bluetooth-$(CONFIG_BT_DEBUGFS) += hci_debugfs.o
+ bluetooth-$(CONFIG_BT_SELFTEST) += selftest.o
+ 
+ subdir-ccflags-y += -D__CHECK_ENDIAN__
++>>>>>>> 6d5d2ee63cee (Bluetooth: add LED trigger for indicating HCI is powered up)
diff --cc net/bluetooth/hci_core.c
index 7c88f5f83598,88f1ef3589d8..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -32,6 -31,16 +32,16 @@@
  
  #include <net/bluetooth/bluetooth.h>
  #include <net/bluetooth/hci_core.h>
++<<<<<<< HEAD
++=======
+ #include <net/bluetooth/l2cap.h>
+ #include <net/bluetooth/mgmt.h>
+ 
+ #include "hci_request.h"
+ #include "hci_debugfs.h"
+ #include "smp.h"
+ #include "leds.h"
++>>>>>>> 6d5d2ee63cee (Bluetooth: add LED trigger for indicating HCI is powered up)
  
  static void hci_rx_work(struct work_struct *work);
  static void hci_cmd_work(struct work_struct *work);
@@@ -1166,13 -1393,18 +1176,26 @@@ int hci_dev_open(__u16 dev
  
  	if (!ret) {
  		hci_dev_hold(hdev);
 -		hci_dev_set_flag(hdev, HCI_RPA_EXPIRED);
  		set_bit(HCI_UP, &hdev->flags);
++<<<<<<< HEAD
 +		hci_notify(hdev, HCI_DEV_UP);
 +		if (!test_bit(HCI_SETUP, &hdev->dev_flags) &&
 +		    mgmt_valid_hdev(hdev)) {
 +			hci_dev_lock(hdev);
 +			mgmt_powered(hdev, 1);
 +			hci_dev_unlock(hdev);
++=======
+ 		hci_sock_dev_event(hdev, HCI_DEV_UP);
+ 		hci_leds_update_powered(hdev, true);
+ 		if (!hci_dev_test_flag(hdev, HCI_SETUP) &&
+ 		    !hci_dev_test_flag(hdev, HCI_CONFIG) &&
+ 		    !hci_dev_test_flag(hdev, HCI_UNCONFIGURED) &&
+ 		    !hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&
+ 		    hci_dev_test_flag(hdev, HCI_MGMT) &&
+ 		    hdev->dev_type == HCI_BREDR) {
+ 			ret = __hci_req_hci_power_on(hdev);
+ 			mgmt_power_on(hdev, ret);
++>>>>>>> 6d5d2ee63cee (Bluetooth: add LED trigger for indicating HCI is powered up)
  		}
  	} else {
  		/* Init failed, cleanup */
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7cb6d360d147..777a466a2ea4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -25,6 +25,7 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
+#include <linux/leds.h>
 #include <net/bluetooth/hci.h>
 
 /* HCI priority */
@@ -290,6 +291,8 @@ struct hci_dev {
 	__u8			adv_data[HCI_MAX_AD_LENGTH];
 	__u8			adv_data_len;
 
+	struct led_trigger	*power_led;
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
* Unmerged path net/bluetooth/Kconfig
* Unmerged path net/bluetooth/Makefile
* Unmerged path net/bluetooth/hci_core.c
diff --git a/net/bluetooth/leds.c b/net/bluetooth/leds.c
new file mode 100644
index 000000000000..ded7c88eaccc
--- /dev/null
+++ b/net/bluetooth/leds.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2015, Heiner Kallweit <hkallweit1@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+
+#include "leds.h"
+
+struct hci_basic_led_trigger {
+	struct led_trigger	led_trigger;
+	struct hci_dev		*hdev;
+};
+
+#define to_hci_basic_led_trigger(arg) container_of(arg, \
+			struct hci_basic_led_trigger, led_trigger)
+
+void hci_leds_update_powered(struct hci_dev *hdev, bool enabled)
+{
+	if (hdev->power_led)
+		led_trigger_event(hdev->power_led,
+				  enabled ? LED_FULL : LED_OFF);
+}
+
+static void power_activate(struct led_classdev *led_cdev)
+{
+	struct hci_basic_led_trigger *htrig;
+	bool powered;
+
+	htrig = to_hci_basic_led_trigger(led_cdev->trigger);
+	powered = test_bit(HCI_UP, &htrig->hdev->flags);
+
+	led_trigger_event(led_cdev->trigger, powered ? LED_FULL : LED_OFF);
+}
+
+static struct led_trigger *led_allocate_basic(struct hci_dev *hdev,
+			void (*activate)(struct led_classdev *led_cdev),
+			const char *name)
+{
+	struct hci_basic_led_trigger *htrig;
+
+	htrig =	devm_kzalloc(&hdev->dev, sizeof(*htrig), GFP_KERNEL);
+	if (!htrig)
+		return NULL;
+
+	htrig->hdev = hdev;
+	htrig->led_trigger.activate = activate;
+	htrig->led_trigger.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
+						 "%s-%s", hdev->name,
+						 name);
+	if (!htrig->led_trigger.name)
+		goto err_alloc;
+
+	if (led_trigger_register(&htrig->led_trigger))
+		goto err_register;
+
+	return &htrig->led_trigger;
+
+err_register:
+	devm_kfree(&hdev->dev, (void *)htrig->led_trigger.name);
+err_alloc:
+	devm_kfree(&hdev->dev, htrig);
+	return NULL;
+}
+
+void hci_leds_init(struct hci_dev *hdev)
+{
+	/* initialize power_led */
+	hdev->power_led = led_allocate_basic(hdev, power_activate, "power");
+}
+
+void hci_leds_exit(struct hci_dev *hdev)
+{
+	if (hdev->power_led)
+		led_trigger_unregister(hdev->power_led);
+}
diff --git a/net/bluetooth/leds.h b/net/bluetooth/leds.h
new file mode 100644
index 000000000000..068261a4e12c
--- /dev/null
+++ b/net/bluetooth/leds.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2015, Heiner Kallweit <hkallweit1@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#if IS_ENABLED(CONFIG_BT_LEDS)
+void hci_leds_update_powered(struct hci_dev *hdev, bool enabled);
+void hci_leds_init(struct hci_dev *hdev);
+void hci_leds_exit(struct hci_dev *hdev);
+#else
+static inline void hci_leds_update_powered(struct hci_dev *hdev,
+					   bool enabled) {}
+static inline void hci_leds_init(struct hci_dev *hdev) {}
+static inline void hci_leds_exit(struct hci_dev *hdev) {}
+#endif
