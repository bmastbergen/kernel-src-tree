RDMA/iw_cxgb4: atomic find and reference for listening endpoints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hariprasad S <hariprasad@chelsio.com>
commit f86fac79afecb41682886785364b15cb13f22280
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f86fac79.failed

Add get_ep_from_stid() which will atomically find and reference the
endpoint struct if found. This avoids touch-after-free races between
threads destroying listening endpoints and the CPL processing thread
processing an incoming PASS_ACCEPT_REQ CPL.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit f86fac79afecb41682886785364b15cb13f22280)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index 59084dc17b06,4ee10547a4e4..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -306,6 -308,57 +306,60 @@@ static void *alloc_ep(int size, gfp_t g
  	return epc;
  }
  
++<<<<<<< HEAD
++=======
+ static void remove_ep_tid(struct c4iw_ep *ep)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&ep->com.dev->lock, flags);
+ 	_remove_handle(ep->com.dev, &ep->com.dev->hwtid_idr, ep->hwtid, 0);
+ 	spin_unlock_irqrestore(&ep->com.dev->lock, flags);
+ }
+ 
+ static void insert_ep_tid(struct c4iw_ep *ep)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&ep->com.dev->lock, flags);
+ 	_insert_handle(ep->com.dev, &ep->com.dev->hwtid_idr, ep, ep->hwtid, 0);
+ 	spin_unlock_irqrestore(&ep->com.dev->lock, flags);
+ }
+ 
+ /*
+  * Atomically lookup the ep ptr given the tid and grab a reference on the ep.
+  */
+ static struct c4iw_ep *get_ep_from_tid(struct c4iw_dev *dev, unsigned int tid)
+ {
+ 	struct c4iw_ep *ep;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&dev->lock, flags);
+ 	ep = idr_find(&dev->hwtid_idr, tid);
+ 	if (ep)
+ 		c4iw_get_ep(&ep->com);
+ 	spin_unlock_irqrestore(&dev->lock, flags);
+ 	return ep;
+ }
+ 
+ /*
+  * Atomically lookup the ep ptr given the stid and grab a reference on the ep.
+  */
+ static struct c4iw_listen_ep *get_ep_from_stid(struct c4iw_dev *dev,
+ 					       unsigned int stid)
+ {
+ 	struct c4iw_listen_ep *ep;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&dev->lock, flags);
+ 	ep = idr_find(&dev->stid_idr, stid);
+ 	if (ep)
+ 		c4iw_get_ep(&ep->com);
+ 	spin_unlock_irqrestore(&dev->lock, flags);
+ 	return ep;
+ }
+ 
++>>>>>>> f86fac79afec (RDMA/iw_cxgb4: atomic find and reference for listening endpoints)
  void _c4iw_free_ep(struct kref *kref)
  {
  	struct c4iw_ep *ep;
@@@ -2355,8 -2504,9 +2408,8 @@@ static int pass_accept_req(struct c4iw_
  	u16 peer_mss = ntohs(req->tcpopt.mss);
  	int iptype;
  	unsigned short hdrs;
 -	u8 tos = PASS_OPEN_TOS_G(ntohl(req->tos_stid));
  
- 	parent_ep = lookup_stid(t, stid);
+ 	parent_ep = (struct c4iw_ep *)get_ep_from_stid(dev, stid);
  	if (!parent_ep) {
  		PDBG("%s connect request on invalid stid %d\n", __func__, stid);
  		goto reject;
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
