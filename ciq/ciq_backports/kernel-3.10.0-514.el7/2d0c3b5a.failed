Drivers: hv: utils: Invoke the poll function after handshake

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] utils: Invoke the poll function after handshake (Vitaly Kuznetsov) [1074407 1309368]
Rebuild_FUZZ: 87.85%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 2d0c3b5ad739697a68dc8a444f5b9f4817cf8f8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2d0c3b5a.failed

When the handshake with daemon is complete, we should poll the channel since
during the handshake, we will not be processing any messages. This is a
potential bug if the host is waiting for a response from the guest.
I would like to thank Dexuan for pointing this out.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2d0c3b5ad739697a68dc8a444f5b9f4817cf8f8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/hv_kvp.c
#	drivers/hv/hv_snapshot.c
diff --cc drivers/hv/hv_kvp.c
index 0353aa1d6ef0,d4ab81bcd515..000000000000
--- a/drivers/hv/hv_kvp.c
+++ b/drivers/hv/hv_kvp.c
@@@ -156,20 -145,18 +156,32 @@@ static int kvp_handle_handshake(struct 
  		pr_info("KVP: incompatible daemon\n");
  		pr_info("KVP: KVP version: %d, Daemon version: %d\n",
  			KVP_OP_REGISTER1, msg->kvp_hdr.operation);
 -		return -EINVAL;
 +		ret = 0;
  	}
  
++<<<<<<< HEAD
 +	if (ret) {
 +		/*
 +		 * We have a compatible daemon; complete the handshake.
 +		 */
 +		pr_info("KVP: user-mode registering done.\n");
 +		kvp_register(dm_reg_value);
 +		kvp_transaction.active = false;
 +		if (kvp_transaction.kvp_context)
 +			poll_channel(kvp_transaction.kvp_context);
 +	}
 +	return ret;
++=======
+ 	/*
+ 	 * We have a compatible daemon; complete the handshake.
+ 	 */
+ 	pr_debug("KVP: userspace daemon ver. %d registered\n",
+ 		 KVP_OP_REGISTER);
+ 	kvp_register(dm_reg_value);
+ 	hv_poll_channel(kvp_transaction.recv_channel, kvp_poll_wrapper);
+ 
+ 	return 0;
++>>>>>>> 2d0c3b5ad739 (Drivers: hv: utils: Invoke the poll function after handshake)
  }
  
  
diff --cc drivers/hv/hv_snapshot.c
index 5ca7351b78df,67def4a831c8..000000000000
--- a/drivers/hv/hv_snapshot.c
+++ b/drivers/hv/hv_snapshot.c
@@@ -75,26 -92,62 +75,33 @@@ static void vss_timeout_func(struct wor
  	pr_warn("VSS: timeout waiting for daemon to reply\n");
  	vss_respond_to_host(HV_E_FAIL);
  
 -	hv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);
 +	hv_poll_channel(vss_transaction.vss_context,
 +			hv_vss_onchannelcallback);
  }
  
 -static int vss_handle_handshake(struct hv_vss_msg *vss_msg)
 +static void
 +vss_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)
  {
 -	u32 our_ver = VSS_OP_REGISTER1;
 -
 -	switch (vss_msg->vss_hdr.operation) {
 -	case VSS_OP_REGISTER:
 -		/* Daemon doesn't expect us to reply */
 -		dm_reg_value = VSS_OP_REGISTER;
 -		break;
 -	case VSS_OP_REGISTER1:
 -		/* Daemon expects us to reply with our own version*/
 -		if (hvutil_transport_send(hvt, &our_ver, sizeof(our_ver)))
 -			return -EFAULT;
 -		dm_reg_value = VSS_OP_REGISTER1;
 -		break;
 -	default:
 -		return -EINVAL;
 +	struct hv_vss_msg *vss_msg;
 +
 +	vss_msg = (struct hv_vss_msg *)msg->data;
 +
 +	if (vss_msg->vss_hdr.operation == VSS_OP_REGISTER) {
 +		pr_info("VSS daemon registered\n");
 +		vss_transaction.active = false;
  	}
++<<<<<<< HEAD
 +	if (cancel_delayed_work_sync(&vss_timeout_work))
 +		vss_respond_to_host(vss_msg->error);
++=======
+ 	hv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);
+ 	pr_debug("VSS: userspace daemon ver. %d registered\n", dm_reg_value);
+ 	return 0;
+ }
++>>>>>>> 2d0c3b5ad739 (Drivers: hv: utils: Invoke the poll function after handshake)
  
 -static int vss_on_msg(void *msg, int len)
 -{
 -	struct hv_vss_msg *vss_msg = (struct hv_vss_msg *)msg;
 -
 -	if (len != sizeof(*vss_msg))
 -		return -EINVAL;
 -
 -	if (vss_msg->vss_hdr.operation == VSS_OP_REGISTER ||
 -	    vss_msg->vss_hdr.operation == VSS_OP_REGISTER1) {
 -		/*
 -		 * Don't process registration messages if we're in the middle
 -		 * of a transaction processing.
 -		 */
 -		if (vss_transaction.state > HVUTIL_READY)
 -			return -EINVAL;
 -		return vss_handle_handshake(vss_msg);
 -	} else if (vss_transaction.state == HVUTIL_USERSPACE_REQ) {
 -		vss_transaction.state = HVUTIL_USERSPACE_RECV;
 -		if (cancel_delayed_work_sync(&vss_timeout_work)) {
 -			vss_respond_to_host(vss_msg->error);
 -			/* Transaction is finished, reset the state. */
 -			hv_poll_channel(vss_transaction.recv_channel,
 -					vss_poll_wrapper);
 -		}
 -	} else {
 -		/* This is a spurious call! */
 -		pr_warn("VSS: Transaction not active\n");
 -		return -EINVAL;
 -	}
 -	return 0;
 +	hv_poll_channel(vss_transaction.vss_context,
 +			hv_vss_onchannelcallback);
  }
  
  
* Unmerged path drivers/hv/hv_kvp.c
* Unmerged path drivers/hv/hv_snapshot.c
