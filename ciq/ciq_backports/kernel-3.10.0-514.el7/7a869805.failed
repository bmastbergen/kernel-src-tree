perf/x86/intel/rapl: Simplify quirk handling even more

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Borislav Petkov <bp@alien8.de>
commit 7a8698058ae493ae53b1a8a2fa23d2e37000d73e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7a869805.failed

Drop the quirk() function pointer in favor of a simple boolean which
says whether the quirk should be applied or not. Update comment while at
it.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <andi.kleen@intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Harish Chegondi <harish.chegondi@intel.com>
	Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: linux-tip-commits@vger.kernel.org
Link: http://lkml.kernel.org/r/20160308164041.GF16568@pd.tnic
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 7a8698058ae493ae53b1a8a2fa23d2e37000d73e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/perf_event_intel_rapl.c
diff --cc arch/x86/kernel/cpu/perf_event_intel_rapl.c
index c019c57572a7,b834a3f55a01..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel_rapl.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_rapl.c
@@@ -563,26 -534,19 +563,27 @@@ static void rapl_cpu_exit(int cpu
  
  static void rapl_cpu_init(int cpu)
  {
 -	struct rapl_pmu *pmu = cpu_to_rapl_pmu(cpu);
 -	int target;
 +	int i, phys_id = topology_physical_package_id(cpu);
  
 +	/* check if phys_is is already covered */
 +	for_each_cpu(i, &rapl_cpu_mask) {
 +		if (phys_id == topology_physical_package_id(i))
 +			return;
 +	}
 +	/* was not found, so add it */
 +	cpumask_set_cpu(cpu, &rapl_cpu_mask);
 +}
 +
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
 +static __init void rapl_hsw_server_quirk(void)
 +{
  	/*
 -	 * Check if there is an online cpu in the package which collects rapl
 -	 * events already.
 +	 * DRAM domain on HSW server has fixed energy unit which can be
 +	 * different than the unit from power unit MSR.
 +	 * "Intel Xeon Processor E5-1600 and E5-2600 v3 Product Families, V2
 +	 * of 2. Datasheet, September 2014, Reference Number: 330784-001 "
  	 */
 -	target = cpumask_any_and(&rapl_cpu_mask, topology_core_cpumask(cpu));
 -	if (target < nr_cpu_ids)
 -		return;
 -
 -	cpumask_set_cpu(cpu, &rapl_cpu_mask);
 -	pmu->cpu = cpu;
 +	rapl_hw_unit[RAPL_IDX_RAM_NRG_STAT] = 16;
  }
  
  static int rapl_cpu_prepare(int cpu)
@@@ -682,7 -592,7 +683,10 @@@ static int rapl_cpu_notifier(struct not
  	return NOTIFY_OK;
  }
  
 +static int rapl_check_hw_unit(void)
++=======
+ static int rapl_check_hw_unit(bool apply_quirk)
++>>>>>>> 7a8698058ae4 (perf/x86/intel/rapl: Simplify quirk handling even more):arch/x86/events/intel/rapl.c
  {
  	u64 msr_rapl_power_unit_bits;
  	int i;
@@@ -693,6 -603,27 +697,30 @@@
  	for (i = 0; i < NR_RAPL_DOMAINS; i++)
  		rapl_hw_unit[i] = (msr_rapl_power_unit_bits >> 8) & 0x1FULL;
  
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
++=======
+ 	/*
+ 	 * DRAM domain on HSW server and KNL has fixed energy unit which can be
+ 	 * different than the unit from power unit MSR. See
+ 	 * "Intel Xeon Processor E5-1600 and E5-2600 v3 Product Families, V2
+ 	 * of 2. Datasheet, September 2014, Reference Number: 330784-001 "
+ 	 */
+ 	if (apply_quirk)
+ 		rapl_hw_unit[RAPL_IDX_RAM_NRG_STAT] = 16;
+ 
+ 	/*
+ 	 * Calculate the timer rate:
+ 	 * Use reference of 200W for scaling the timeout to avoid counter
+ 	 * overflows. 200W = 200 Joules/sec
+ 	 * Divide interval by 2 to avoid lockstep (2 * 100)
+ 	 * if hw unit is 32, then we use 2 ms 1/200/2
+ 	 */
+ 	rapl_timer_ms = 2;
+ 	if (rapl_hw_unit[0] < 32) {
+ 		rapl_timer_ms = (1000 / (2 * 100));
+ 		rapl_timer_ms *= (1ULL << (32 - rapl_hw_unit[0] - 1));
+ 	}
++>>>>>>> 7a8698058ae4 (perf/x86/intel/rapl: Simplify quirk handling even more):arch/x86/events/intel/rapl.c
  	return 0;
  }
  
@@@ -703,18 -698,12 +731,23 @@@ static const struct x86_cpu_id rapl_cpu
  
  static int __init rapl_pmu_init(void)
  {
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
 +	struct rapl_pmu *pmu;
 +	int cpu, ret;
 +	struct x86_pmu_quirk *quirk;
 +	int i;
++=======
+ 	bool apply_quirk = false;
+ 	int ret;
++>>>>>>> 7a8698058ae4 (perf/x86/intel/rapl: Simplify quirk handling even more):arch/x86/events/intel/rapl.c
  
 +	/*
 +	 * check for Intel processor family 6
 +	 */
  	if (!x86_match_cpu(rapl_cpu_match))
 -		return -ENODEV;
 +		return 0;
  
 +	/* check supported CPU */
  	switch (boot_cpu_data.x86_model) {
  	case 42: /* Sandy Bridge */
  	case 58: /* Ivy Bridge */
@@@ -722,7 -711,7 +755,11 @@@
  		rapl_pmu_events_group.attrs = rapl_events_cln_attr;
  		break;
  	case 63: /* Haswell-Server */
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
 +		rapl_add_quirk(rapl_hsw_server_quirk);
++=======
+ 		apply_quirk = true;
++>>>>>>> 7a8698058ae4 (perf/x86/intel/rapl: Simplify quirk handling even more):arch/x86/events/intel/rapl.c
  		rapl_cntr_mask = RAPL_IDX_SRV;
  		rapl_pmu_events_group.attrs = rapl_events_srv_attr;
  		break;
@@@ -738,15 -727,19 +775,28 @@@
  		rapl_pmu_events_group.attrs = rapl_events_srv_attr;
  		break;
  	case 87: /* Knights Landing */
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
 +		rapl_add_quirk(rapl_hsw_server_quirk);
++=======
+ 		apply_quirk = true;
++>>>>>>> 7a8698058ae4 (perf/x86/intel/rapl: Simplify quirk handling even more):arch/x86/events/intel/rapl.c
  		rapl_cntr_mask = RAPL_IDX_KNL;
  		rapl_pmu_events_group.attrs = rapl_events_knl_attr;
  		break;
  	default:
 -		return -ENODEV;
 +		/* unsupported */
 +		return 0;
  	}
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
 +	ret = rapl_check_hw_unit();
++=======
+ 
+ 	ret = rapl_check_hw_unit(apply_quirk);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = init_rapl_pmus();
++>>>>>>> 7a8698058ae4 (perf/x86/intel/rapl: Simplify quirk handling even more):arch/x86/events/intel/rapl.c
  	if (ret)
  		return ret;
  
* Unmerged path arch/x86/kernel/cpu/perf_event_intel_rapl.c
