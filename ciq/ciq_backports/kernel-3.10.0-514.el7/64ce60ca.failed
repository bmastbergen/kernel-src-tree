hpsa: correct skipping masked peripherals

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Don Brace <don.brace@microsemi.com>
commit 64ce60cab24603ac0fcd59c9fbc3be78f4c4d229
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/64ce60ca.failed

The SA controller spins down RAID drive spares.

A REGNEWD event causes an inquiry to be sent to all physical
drives. This causes the SA controller to spin up the spare.

The controller suspends all I/O to a logical volume until
the spare is spun up. The spin-up can take over 50 seconds.

This can result in one or both of the following:
 - SML sends down aborts and resets to the logical volume
   and can cause the logical volume to be off-lined.
 - a negative impact on the logical volume's I/O performance
   each time a REGNEWD is triggered.

	Reviewed-by: Scott Teel <scott.teel@microsemi.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
	Signed-off-by: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 64ce60cab24603ac0fcd59c9fbc3be78f4c4d229)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index f29dd938faad,375a39632a7a..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -3723,7 -4054,123 +3723,127 @@@ static void hpsa_get_ioaccel_drive_info
  		dev->queue_depth = DRIVE_QUEUE_DEPTH; /* conservative */
  }
  
++<<<<<<< HEAD
 +static void hpsa_update_scsi_devices(struct ctlr_info *h, int hostno)
++=======
+ static void hpsa_get_path_info(struct hpsa_scsi_dev_t *this_device,
+ 	struct ReportExtendedLUNdata *rlep, int rle_index,
+ 	struct bmic_identify_physical_device *id_phys)
+ {
+ 	struct ext_report_lun_entry *rle = &rlep->LUN[rle_index];
+ 
+ 	if ((rle->device_flags & 0x08) && this_device->ioaccel_handle)
+ 		this_device->hba_ioaccel_enabled = 1;
+ 
+ 	memcpy(&this_device->active_path_index,
+ 		&id_phys->active_path_number,
+ 		sizeof(this_device->active_path_index));
+ 	memcpy(&this_device->path_map,
+ 		&id_phys->redundant_path_present_map,
+ 		sizeof(this_device->path_map));
+ 	memcpy(&this_device->box,
+ 		&id_phys->alternate_paths_phys_box_on_port,
+ 		sizeof(this_device->box));
+ 	memcpy(&this_device->phys_connector,
+ 		&id_phys->alternate_paths_phys_connector,
+ 		sizeof(this_device->phys_connector));
+ 	memcpy(&this_device->bay,
+ 		&id_phys->phys_bay_in_box,
+ 		sizeof(this_device->bay));
+ }
+ 
+ /* get number of local logical disks. */
+ static int hpsa_set_local_logical_count(struct ctlr_info *h,
+ 	struct bmic_identify_controller *id_ctlr,
+ 	u32 *nlocals)
+ {
+ 	int rc;
+ 
+ 	if (!id_ctlr) {
+ 		dev_warn(&h->pdev->dev, "%s: id_ctlr buffer is NULL.\n",
+ 			__func__);
+ 		return -ENOMEM;
+ 	}
+ 	memset(id_ctlr, 0, sizeof(*id_ctlr));
+ 	rc = hpsa_bmic_id_controller(h, id_ctlr, sizeof(*id_ctlr));
+ 	if (!rc)
+ 		if (id_ctlr->configured_logical_drive_count < 256)
+ 			*nlocals = id_ctlr->configured_logical_drive_count;
+ 		else
+ 			*nlocals = le16_to_cpu(
+ 					id_ctlr->extended_logical_unit_count);
+ 	else
+ 		*nlocals = -1;
+ 	return rc;
+ }
+ 
+ static bool hpsa_is_disk_spare(struct ctlr_info *h, u8 *lunaddrbytes)
+ {
+ 	struct bmic_identify_physical_device *id_phys;
+ 	bool is_spare = false;
+ 	int rc;
+ 
+ 	id_phys = kzalloc(sizeof(*id_phys), GFP_KERNEL);
+ 	if (!id_phys)
+ 		return false;
+ 
+ 	rc = hpsa_bmic_id_physical_device(h,
+ 					lunaddrbytes,
+ 					GET_BMIC_DRIVE_NUMBER(lunaddrbytes),
+ 					id_phys, sizeof(*id_phys));
+ 	if (rc == 0)
+ 		is_spare = (id_phys->more_flags >> 6) & 0x01;
+ 
+ 	kfree(id_phys);
+ 	return is_spare;
+ }
+ 
+ #define RPL_DEV_FLAG_NON_DISK                           0x1
+ #define RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED  0x2
+ #define RPL_DEV_FLAG_UNCONFIG_DISK                      0x4
+ 
+ #define BMIC_DEVICE_TYPE_ENCLOSURE  6
+ 
+ static bool hpsa_skip_device(struct ctlr_info *h, u8 *lunaddrbytes,
+ 				struct ext_report_lun_entry *rle)
+ {
+ 	u8 device_flags;
+ 	u8 device_type;
+ 
+ 	if (!MASKED_DEVICE(lunaddrbytes))
+ 		return false;
+ 
+ 	device_flags = rle->device_flags;
+ 	device_type = rle->device_type;
+ 
+ 	if (device_flags & RPL_DEV_FLAG_NON_DISK) {
+ 		if (device_type == BMIC_DEVICE_TYPE_ENCLOSURE)
+ 			return false;
+ 		return true;
+ 	}
+ 
+ 	if (!(device_flags & RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED))
+ 		return false;
+ 
+ 	if (device_flags & RPL_DEV_FLAG_UNCONFIG_DISK)
+ 		return false;
+ 
+ 	/*
+ 	 * Spares may be spun down, we do not want to
+ 	 * do an Inquiry to a RAID set spare drive as
+ 	 * that would have them spun up, that is a
+ 	 * performance hit because I/O to the RAID device
+ 	 * stops while the spin up occurs which can take
+ 	 * over 50 seconds.
+ 	 */
+ 	if (hpsa_is_disk_spare(h, lunaddrbytes))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static void hpsa_update_scsi_devices(struct ctlr_info *h)
++>>>>>>> 64ce60cab246 (hpsa: correct skipping masked peripherals)
  {
  	/* the idea here is we could get notified
  	 * that some devices have changed, so we do a report
@@@ -3809,21 -4260,46 +3929,41 @@@
  	n_ext_target_devs = 0;
  	for (i = 0; i < nphysicals + nlogicals + 1; i++) {
  		u8 *lunaddrbytes, is_OBDR = 0;
++<<<<<<< HEAD
++=======
+ 		int rc = 0;
+ 		int phys_dev_index = i - (raid_ctlr_position == 0);
+ 		bool skip_device = false;
+ 
+ 		physical_device = i < nphysicals + (raid_ctlr_position == 0);
++>>>>>>> 64ce60cab246 (hpsa: correct skipping masked peripherals)
  
  		/* Figure out where the LUN ID info is coming from */
  		lunaddrbytes = figure_lunaddrbytes(h, raid_ctlr_position,
  			i, nphysicals, nlogicals, physdev_list, logdev_list);
  
++<<<<<<< HEAD
 +		/* skip masked non-disk devices */
 +		if (MASKED_DEVICE(lunaddrbytes))
 +			if (i < nphysicals + (raid_ctlr_position == 0) &&
 +				NON_DISK_PHYS_DEV(lunaddrbytes))
 +				continue;
++=======
+ 		/*
+ 		 * Skip over some devices such as a spare.
+ 		 */
+ 		if (!tmpdevice->external && physical_device) {
+ 			skip_device = hpsa_skip_device(h, lunaddrbytes,
+ 					&physdev_list->LUN[phys_dev_index]);
+ 			if (skip_device)
+ 				continue;
+ 		}
++>>>>>>> 64ce60cab246 (hpsa: correct skipping masked peripherals)
  
  		/* Get device type, vendor, model, device id */
 -		rc = hpsa_update_device_info(h, lunaddrbytes, tmpdevice,
 -							&is_OBDR);
 -		if (rc == -ENOMEM) {
 -			dev_warn(&h->pdev->dev,
 -				"Out of memory, rescan deferred.\n");
 -			h->drv_req_rescan = 1;
 -			goto out;
 -		}
 -		if (rc) {
 -			dev_warn(&h->pdev->dev,
 -				"Inquiry failed, skipping device.\n");
 -			continue;
 -		}
 -
 -		/* Determine if this is a lun from an external target array */
 -		tmpdevice->external =
 -			figure_external_status(h, raid_ctlr_position, i,
 -						nphysicals, nlocal_logicals);
 -
 +		if (hpsa_update_device_info(h, lunaddrbytes, tmpdevice,
 +							&is_OBDR))
 +			continue; /* skip it if we can't talk to it. */
  		figure_bus_target_lun(h, lunaddrbytes, tmpdevice);
  		hpsa_update_device_supports_aborts(h, tmpdevice, lunaddrbytes);
  		this_device = currentsd[ncurrent];
* Unmerged path drivers/scsi/hpsa.c
