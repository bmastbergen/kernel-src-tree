mmc: core: Let mmc_send_tuning() to take struct mmc_host* as parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit fe5afb13d46e76b07ab7e732f2b694dcafef4d9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fe5afb13.failed

To be able to use mmc_send_tuning() prior the struct mmc_card has been
allocated, let's convert it to take the struct mmc_host* as parameter
instead.

	Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Acked-by: Dong Aisheng <b29396@freescale.com>
	Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
(cherry picked from commit fe5afb13d46e76b07ab7e732f2b694dcafef4d9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc_ops.c
#	include/linux/mmc/core.h
diff --cc drivers/mmc/core/mmc_ops.c
index 7d8324d583f4,3b044c5b029c..000000000000
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@@ -524,6 -547,75 +524,78 @@@ int mmc_switch(struct mmc_card *card, u
  }
  EXPORT_SYMBOL_GPL(mmc_switch);
  
++<<<<<<< HEAD
++=======
+ int mmc_send_tuning(struct mmc_host *host)
+ {
+ 	struct mmc_request mrq = {NULL};
+ 	struct mmc_command cmd = {0};
+ 	struct mmc_data data = {0};
+ 	struct scatterlist sg;
+ 	struct mmc_ios *ios = &host->ios;
+ 	const u8 *tuning_block_pattern;
+ 	int size, err = 0;
+ 	u8 *data_buf;
+ 	u32 opcode;
+ 
+ 	if (ios->bus_width == MMC_BUS_WIDTH_8) {
+ 		tuning_block_pattern = tuning_blk_pattern_8bit;
+ 		size = sizeof(tuning_blk_pattern_8bit);
+ 		opcode = MMC_SEND_TUNING_BLOCK_HS200;
+ 	} else if (ios->bus_width == MMC_BUS_WIDTH_4) {
+ 		tuning_block_pattern = tuning_blk_pattern_4bit;
+ 		size = sizeof(tuning_blk_pattern_4bit);
+ 		opcode = MMC_SEND_TUNING_BLOCK;
+ 	} else
+ 		return -EINVAL;
+ 
+ 	data_buf = kzalloc(size, GFP_KERNEL);
+ 	if (!data_buf)
+ 		return -ENOMEM;
+ 
+ 	mrq.cmd = &cmd;
+ 	mrq.data = &data;
+ 
+ 	cmd.opcode = opcode;
+ 	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+ 
+ 	data.blksz = size;
+ 	data.blocks = 1;
+ 	data.flags = MMC_DATA_READ;
+ 
+ 	/*
+ 	 * According to the tuning specs, Tuning process
+ 	 * is normally shorter 40 executions of CMD19,
+ 	 * and timeout value should be shorter than 150 ms
+ 	 */
+ 	data.timeout_ns = 150 * NSEC_PER_MSEC;
+ 
+ 	data.sg = &sg;
+ 	data.sg_len = 1;
+ 	sg_init_one(&sg, data_buf, size);
+ 
+ 	mmc_wait_for_req(host, &mrq);
+ 
+ 	if (cmd.error) {
+ 		err = cmd.error;
+ 		goto out;
+ 	}
+ 
+ 	if (data.error) {
+ 		err = data.error;
+ 		goto out;
+ 	}
+ 
+ 	if (memcmp(data_buf, tuning_block_pattern, size))
+ 		err = -EIO;
+ 
+ out:
+ 	kfree(data_buf);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mmc_send_tuning);
+ 
++>>>>>>> fe5afb13d46e (mmc: core: Let mmc_send_tuning() to take struct mmc_host* as parameter)
  static int
  mmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,
  		  u8 len)
diff --cc include/linux/mmc/core.h
index f206e29f94d7,cb2b0400d284..000000000000
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@@ -154,7 -154,8 +154,12 @@@ extern void mmc_start_bkops(struct mmc_
  extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool,
  			bool, bool);
  extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
++<<<<<<< HEAD
 +extern int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
++=======
+ extern int mmc_send_tuning(struct mmc_host *host);
+ extern int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd);
++>>>>>>> fe5afb13d46e (mmc: core: Let mmc_send_tuning() to take struct mmc_host* as parameter)
  
  #define MMC_ERASE_ARG		0x00000000
  #define MMC_SECURE_ERASE_ARG	0x80000000
* Unmerged path drivers/mmc/core/mmc_ops.c
* Unmerged path include/linux/mmc/core.h
