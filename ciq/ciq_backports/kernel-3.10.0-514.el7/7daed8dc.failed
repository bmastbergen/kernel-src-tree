r8152: fix wakeup settings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author hayeswang <hayeswang@realtek.com>
commit 7daed8dc2a4b48c5a7ea5b3243d01837ec1aed0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7daed8dc.failed

Avoid the driver to enable WOL if the device doesn't support it.

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7daed8dc2a4b48c5a7ea5b3243d01837ec1aed0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index e3d600def538,d537c303dfd8..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -2200,6 -2338,53 +2200,56 @@@ static void __rtl_set_wol(struct r8152 
  		device_set_wakeup_enable(&tp->udev->dev, false);
  }
  
++<<<<<<< HEAD
++=======
+ static void r8153_u1u2en(struct r8152 *tp, bool enable)
+ {
+ 	u8 u1u2[8];
+ 
+ 	if (enable)
+ 		memset(u1u2, 0xff, sizeof(u1u2));
+ 	else
+ 		memset(u1u2, 0x00, sizeof(u1u2));
+ 
+ 	usb_ocp_write(tp, USB_TOLERANCE, BYTE_EN_SIX_BYTES, sizeof(u1u2), u1u2);
+ }
+ 
+ static void r8153_u2p3en(struct r8152 *tp, bool enable)
+ {
+ 	u32 ocp_data;
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL);
+ 	if (enable && tp->version != RTL_VER_03 && tp->version != RTL_VER_04)
+ 		ocp_data |= U2P3_ENABLE;
+ 	else
+ 		ocp_data &= ~U2P3_ENABLE;
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL, ocp_data);
+ }
+ 
+ static void r8153_power_cut_en(struct r8152 *tp, bool enable)
+ {
+ 	u32 ocp_data;
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_POWER_CUT);
+ 	if (enable)
+ 		ocp_data |= PWR_EN | PHASE2_EN;
+ 	else
+ 		ocp_data &= ~(PWR_EN | PHASE2_EN);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
+ 	ocp_data &= ~PCUT_STATUS;
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
+ }
+ 
+ static bool rtl_can_wakeup(struct r8152 *tp)
+ {
+ 	struct usb_device *udev = tp->udev;
+ 
+ 	return (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP);
+ }
+ 
++>>>>>>> 7daed8dc2a4b (r8152: fix wakeup settings)
  static void rtl_runtime_suspend_enable(struct r8152 *tp, bool enable)
  {
  	if (enable) {
@@@ -3243,8 -3424,15 +3293,20 @@@ static void rtl8152_get_wol(struct net_
  	if (usb_autopm_get_interface(tp->intf) < 0)
  		return;
  
++<<<<<<< HEAD
 +	wol->supported = WAKE_ANY;
 +	wol->wolopts = __rtl_get_wol(tp);
++=======
+ 	if (!rtl_can_wakeup(tp)) {
+ 		wol->supported = 0;
+ 		wol->wolopts = 0;
+ 	} else {
+ 		mutex_lock(&tp->control);
+ 		wol->supported = WAKE_ANY;
+ 		wol->wolopts = __rtl_get_wol(tp);
+ 		mutex_unlock(&tp->control);
+ 	}
++>>>>>>> 7daed8dc2a4b (r8152: fix wakeup settings)
  
  	usb_autopm_put_interface(tp->intf);
  }
* Unmerged path drivers/net/usb/r8152.c
