qla2xxx: prevent board_disable from running during EEH

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thadeu Lima de Souza Cascardo <cascardo@linux.vnet.ibm.com>
commit a30c2a3bf8571c6748dd16edc10b32d45ed71a72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a30c2a3b.failed

Commit f3ddac1918fe963bcbf8d407a3a3c0881b47248b ("[SCSI] qla2xxx:
Disable adapter when we encounter a PCI disconnect.") has introduced a
code that disables the board, releasing some resources, when reading
0xffffffff.

In case this happens when there is an EEH, this read will trigger EEH
detection and set PCI channel offline. EEH will be able to recover the
card from this state by doing a reset, so it's a better option than
simply disabling the card.

Since eeh_check_failure will mark the channel as offline before
returning the read value, in case there really was an EEH, we can simply
check for pci_channel_offline, preventing the board_disable code from
running if it's true.

Without this patch, EEH code will try to access those same resources
that board_disable will try to free. This race can cause EEH recovery to
fail.

[  504.370577] EEH: Notify device driver to resume
[  504.370580] qla2xxx [0001:07:00.0]-9002:2: The device failed to resume I/O from slot/link_reset.

	Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@linux.vnet.ibm.com>
	Acked-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit a30c2a3bf8571c6748dd16edc10b32d45ed71a72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_isr.c
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index adcba60f18f4,dcfa4655ce43..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -110,6 -112,32 +110,35 @@@ qla2100_intr_handler(int irq, void *dev
  	return (IRQ_HANDLED);
  }
  
++<<<<<<< HEAD
++=======
+ bool
+ qla2x00_check_reg32_for_disconnect(scsi_qla_host_t *vha, uint32_t reg)
+ {
+ 	/* Check for PCI disconnection */
+ 	if (reg == 0xffffffff && !pci_channel_offline(vha->hw->pdev)) {
+ 		if (!test_and_set_bit(PFLG_DISCONNECTED, &vha->pci_flags) &&
+ 		    !test_bit(PFLG_DRIVER_REMOVING, &vha->pci_flags) &&
+ 		    !test_bit(PFLG_DRIVER_PROBING, &vha->pci_flags)) {
+ 			/*
+ 			 * Schedule this (only once) on the default system
+ 			 * workqueue so that all the adapter workqueues and the
+ 			 * DPC thread can be shutdown cleanly.
+ 			 */
+ 			schedule_work(&vha->hw->board_disable);
+ 		}
+ 		return true;
+ 	} else
+ 		return false;
+ }
+ 
+ bool
+ qla2x00_check_reg16_for_disconnect(scsi_qla_host_t *vha, uint16_t reg)
+ {
+ 	return qla2x00_check_reg32_for_disconnect(vha, 0xffff0000 | reg);
+ }
+ 
++>>>>>>> a30c2a3bf857 (qla2xxx: prevent board_disable from running during EEH)
  /**
   * qla2300_intr_handler() - Process interrupts for the ISP23xx and ISP63xx.
   * @irq:
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
