RDMA/ocrdma: Remove old FRWR API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 191cfed565c0435aeced5f11f6cf9b03ec380d5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/191cfed5.failed

No ULP uses it anymore, go ahead and remove it.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 191cfed565c0435aeced5f11f6cf9b03ec380d5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
index c6b6f56ab788,583001bcfb8f..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
@@@ -2133,40 -2133,6 +2133,43 @@@ static void ocrdma_build_read(struct oc
  	ext_rw->len = hdr->total_len;
  }
  
++<<<<<<< HEAD
 +static void build_frmr_pbes(struct ib_send_wr *wr, struct ocrdma_pbl *pbl_tbl,
 +			    struct ocrdma_hw_mr *hwmr)
 +{
 +	int i;
 +	u64 buf_addr = 0;
 +	int num_pbes;
 +	struct ocrdma_pbe *pbe;
 +
 +	pbe = (struct ocrdma_pbe *)pbl_tbl->va;
 +	num_pbes = 0;
 +
 +	/* go through the OS phy regions & fill hw pbe entries into pbls. */
 +	for (i = 0; i < wr->wr.fast_reg.page_list_len; i++) {
 +		/* number of pbes can be more for one OS buf, when
 +		 * buffers are of different sizes.
 +		 * split the ib_buf to one or more pbes.
 +		 */
 +		buf_addr = wr->wr.fast_reg.page_list->page_list[i];
 +		pbe->pa_lo = cpu_to_le32((u32) (buf_addr & PAGE_MASK));
 +		pbe->pa_hi = cpu_to_le32((u32) upper_32_bits(buf_addr));
 +		num_pbes += 1;
 +		pbe++;
 +
 +		/* if the pbl is full storing the pbes,
 +		 * move to next pbl.
 +		*/
 +		if (num_pbes == (hwmr->pbl_size/sizeof(u64))) {
 +			pbl_tbl++;
 +			pbe = (struct ocrdma_pbe *)pbl_tbl->va;
 +		}
 +	}
 +	return;
 +}
 +
++=======
++>>>>>>> 191cfed565c0 (RDMA/ocrdma: Remove old FRWR API)
  static int get_encoded_page_size(int pg_sz)
  {
  	/* Max size is 256M 4096 << 16 */
@@@ -2233,50 -2199,6 +2236,53 @@@ static int ocrdma_build_reg(struct ocrd
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int ocrdma_build_fr(struct ocrdma_qp *qp, struct ocrdma_hdr_wqe *hdr,
 +			   struct ib_send_wr *wr)
 +{
 +	u64 fbo;
 +	struct ocrdma_ewqe_fr *fast_reg = (struct ocrdma_ewqe_fr *)(hdr + 1);
 +	struct ocrdma_mr *mr;
 +	struct ocrdma_dev *dev = get_ocrdma_dev(qp->ibqp.device);
 +	u32 wqe_size = sizeof(*fast_reg) + sizeof(*hdr);
 +
 +	wqe_size = roundup(wqe_size, OCRDMA_WQE_ALIGN_BYTES);
 +
 +	if (wr->wr.fast_reg.page_list_len > dev->attr.max_pages_per_frmr)
 +		return -EINVAL;
 +
 +	hdr->cw |= (OCRDMA_FR_MR << OCRDMA_WQE_OPCODE_SHIFT);
 +	hdr->cw |= ((wqe_size / OCRDMA_WQE_STRIDE) << OCRDMA_WQE_SIZE_SHIFT);
 +
 +	if (wr->wr.fast_reg.page_list_len == 0)
 +		BUG();
 +	if (wr->wr.fast_reg.access_flags & IB_ACCESS_LOCAL_WRITE)
 +		hdr->rsvd_lkey_flags |= OCRDMA_LKEY_FLAG_LOCAL_WR;
 +	if (wr->wr.fast_reg.access_flags & IB_ACCESS_REMOTE_WRITE)
 +		hdr->rsvd_lkey_flags |= OCRDMA_LKEY_FLAG_REMOTE_WR;
 +	if (wr->wr.fast_reg.access_flags & IB_ACCESS_REMOTE_READ)
 +		hdr->rsvd_lkey_flags |= OCRDMA_LKEY_FLAG_REMOTE_RD;
 +	hdr->lkey = wr->wr.fast_reg.rkey;
 +	hdr->total_len = wr->wr.fast_reg.length;
 +
 +	fbo = wr->wr.fast_reg.iova_start -
 +	    (wr->wr.fast_reg.page_list->page_list[0] & PAGE_MASK);
 +
 +	fast_reg->va_hi = upper_32_bits(wr->wr.fast_reg.iova_start);
 +	fast_reg->va_lo = (u32) (wr->wr.fast_reg.iova_start & 0xffffffff);
 +	fast_reg->fbo_hi = upper_32_bits(fbo);
 +	fast_reg->fbo_lo = (u32) fbo & 0xffffffff;
 +	fast_reg->num_sges = wr->wr.fast_reg.page_list_len;
 +	fast_reg->size_sge =
 +		get_encoded_page_size(1 << wr->wr.fast_reg.page_shift);
 +	mr = (struct ocrdma_mr *) (unsigned long)
 +		dev->stag_arr[(hdr->lkey >> 8) & (OCRDMA_MAX_STAG - 1)];
 +	build_frmr_pbes(wr, mr->hwmr.pbl_table, &mr->hwmr);
 +	return 0;
 +}
 +
++=======
++>>>>>>> 191cfed565c0 (RDMA/ocrdma: Remove old FRWR API)
  static void ocrdma_ring_sq_db(struct ocrdma_qp *qp)
  {
  	u32 val = qp->sq.dbid | (1 << OCRDMA_DB_SQ_SHIFT);
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_main.c b/drivers/infiniband/hw/ocrdma/ocrdma_main.c
index 19a5ccd6e5fc..62b7009daa6c 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_main.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_main.c
@@ -181,8 +181,6 @@ static int ocrdma_register_device(struct ocrdma_dev *dev)
 
 	dev->ibdev.alloc_mr = ocrdma_alloc_mr;
 	dev->ibdev.map_mr_sg = ocrdma_map_mr_sg;
-	dev->ibdev.alloc_fast_reg_page_list = ocrdma_alloc_frmr_page_list;
-	dev->ibdev.free_fast_reg_page_list = ocrdma_free_frmr_page_list;
 
 	/* mandatory to support user space verbs consumer. */
 	dev->ibdev.alloc_ucontext = ocrdma_alloc_ucontext;
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.h b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
index 1b2d3ac10203..a2f3b4dc20b0 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
@@ -128,9 +128,5 @@ struct ib_mr *ocrdma_alloc_mr(struct ib_pd *pd,
 int ocrdma_map_mr_sg(struct ib_mr *ibmr,
 		     struct scatterlist *sg,
 		     int sg_nents);
-struct ib_fast_reg_page_list *ocrdma_alloc_frmr_page_list(struct ib_device
-							*ibdev,
-							int page_list_len);
-void ocrdma_free_frmr_page_list(struct ib_fast_reg_page_list *page_list);
 
 #endif				/* __OCRDMA_VERBS_H__ */
