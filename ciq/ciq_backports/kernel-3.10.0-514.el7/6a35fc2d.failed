cpufreq: intel_pstate: get P1 from TAR when available

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: get P1 from TAR when available (Prarit Bhargava) [1283337]
Rebuild_FUZZ: 90.72%
commit-author Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
commit 6a35fc2d6c22bafe45117cdc5d8cee332244edbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6a35fc2d.failed

After Ivybridge, the max non turbo ratio obtained from platform info msr
is not always guaranteed P1 on client platforms. The max non turbo
activation ratio (TAR), determines the max for the current level of TDP.
The ratio in platform info is physical max. The TAR MSR can be locked,
so updating this value is not possible on all platforms.
This change gets this ratio from MSR TURBO_ACTIVATION_RATIO if
available,
but also do some sanity checking to make sure that this value is
correct.
The sanity check involves reading the TDP ratio for the current tdp
control value when platform has configurable TDP present and matching
TAC
with this.

	Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Acked-by: Kristen Carlson Accardi <kristen@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6a35fc2d6c22bafe45117cdc5d8cee332244edbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/uapi/asm/msr-index.h
diff --cc arch/x86/include/uapi/asm/msr-index.h
index 312bbffd9ada,9f3905697f12..000000000000
--- a/arch/x86/include/uapi/asm/msr-index.h
+++ b/arch/x86/include/uapi/asm/msr-index.h
@@@ -167,6 -199,20 +167,23 @@@
  
  #define MSR_CORE_C1_RES			0x00000660
  
++<<<<<<< HEAD:arch/x86/include/uapi/asm/msr-index.h
++=======
+ #define MSR_CC6_DEMOTION_POLICY_CONFIG	0x00000668
+ #define MSR_MC6_DEMOTION_POLICY_CONFIG	0x00000669
+ 
+ #define MSR_CORE_PERF_LIMIT_REASONS	0x00000690
+ #define MSR_GFX_PERF_LIMIT_REASONS	0x000006B0
+ #define MSR_RING_PERF_LIMIT_REASONS	0x000006B1
+ 
+ /* Config TDP MSRs */
+ #define MSR_CONFIG_TDP_NOMINAL		0x00000648
+ #define MSR_CONFIG_TDP_LEVEL1		0x00000649
+ #define MSR_CONFIG_TDP_LEVEL2		0x0000064A
+ #define MSR_CONFIG_TDP_CONTROL		0x0000064B
+ #define MSR_TURBO_ACTIVATION_RATIO	0x0000064C
+ 
++>>>>>>> 6a35fc2d6c22 (cpufreq: intel_pstate: get P1 from TAR when available):arch/x86/include/asm/msr-index.h
  /* Hardware P state interface */
  #define MSR_PPERF			0x0000064e
  #define MSR_PERF_LIMIT_REASONS		0x0000064f
* Unmerged path arch/x86/include/uapi/asm/msr-index.h
diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c
index 07d88cb77cb6..7eb18decdf7c 100644
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@ -41,7 +41,6 @@
 #define int_tofp(X) ((int64_t)(X) << FRAC_BITS)
 #define fp_toint(X) ((X) >> FRAC_BITS)
 
-
 static inline int32_t mul_fp(int32_t x, int32_t y)
 {
 	return ((int64_t)x * (int64_t)y) >> FRAC_BITS;
@@ -592,10 +591,42 @@ static int core_get_max_pstate_physical(void)
 
 static int core_get_max_pstate(void)
 {
-	u64 value;
+	u64 tar;
+	u64 plat_info;
+	int max_pstate;
+	int err;
+
+	rdmsrl(MSR_PLATFORM_INFO, plat_info);
+	max_pstate = (plat_info >> 8) & 0xFF;
+
+	err = rdmsrl_safe(MSR_TURBO_ACTIVATION_RATIO, &tar);
+	if (!err) {
+		/* Do some sanity checking for safety */
+		if (plat_info & 0x600000000) {
+			u64 tdp_ctrl;
+			u64 tdp_ratio;
+			int tdp_msr;
+
+			err = rdmsrl_safe(MSR_CONFIG_TDP_CONTROL, &tdp_ctrl);
+			if (err)
+				goto skip_tar;
+
+			tdp_msr = MSR_CONFIG_TDP_NOMINAL + tdp_ctrl;
+			err = rdmsrl_safe(tdp_msr, &tdp_ratio);
+			if (err)
+				goto skip_tar;
+
+			if (tdp_ratio - 1 == tar) {
+				max_pstate = tar;
+				pr_debug("max_pstate=TAC %x\n", max_pstate);
+			} else {
+				goto skip_tar;
+			}
+		}
+	}
 
-	rdmsrl(MSR_PLATFORM_INFO, value);
-	return (value >> 8) & 0xFF;
+skip_tar:
+	return max_pstate;
 }
 
 static int core_get_turbo_pstate(void)
