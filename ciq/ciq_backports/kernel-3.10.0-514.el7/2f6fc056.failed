nfsd: fix deadlock secinfo+readdir compound

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author J. Bruce Fields <bfields@redhat.com>
commit 2f6fc056e899bd0144a08da5cacaecbe8997cd74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2f6fc056.failed

nfsd_lookup_dentry exits with the parent filehandle locked.  fh_put also
unlocks if necessary (nfsd filehandle locking is probably too lenient),
so it gets unlocked eventually, but if the following op in the compound
needs to lock it again, we can deadlock.

A fuzzer ran into this; normal clients don't send a secinfo followed by
a readdir in the same compound.

	Cc: stable@vger.kernel.org
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 2f6fc056e899bd0144a08da5cacaecbe8997cd74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4proc.c
diff --cc fs/nfsd/nfs4proc.c
index f3b3a27d9ad7,40b912407d51..000000000000
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@@ -876,7 -876,8 +876,12 @@@ nfsd4_secinfo(struct svc_rqst *rqstp, s
  				    &exp, &dentry);
  	if (err)
  		return err;
++<<<<<<< HEAD
 +	if (dentry->d_inode == NULL) {
++=======
+ 	fh_unlock(&cstate->current_fh);
+ 	if (d_really_is_negative(dentry)) {
++>>>>>>> 2f6fc056e899 (nfsd: fix deadlock secinfo+readdir compound)
  		exp_put(exp);
  		err = nfserr_noent;
  	} else
* Unmerged path fs/nfsd/nfs4proc.c
