tcp: enable per-socket rate limiting of all 'challenge acks'

jira LE-1907
cve CVE-2016-5696
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Baron <jbaron@akamai.com>
commit 083ae308280d13d187512b9babe3454342a7987e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/083ae308.failed

The per-socket rate limit for 'challenge acks' was introduced in the
context of limiting ack loops:

commit f2b2c582e824 ("tcp: mitigate ACK loops for connections as tcp_sock")

And I think it can be extended to rate limit all 'challenge acks' on a
per-socket basis.

Since we have the global tcp_challenge_ack_limit, this patch allows for
tcp_challenge_ack_limit to be set to a large value and effectively rely on
the per-socket limit, or set tcp_challenge_ack_limit to a lower value and
still prevents a single connections from consuming the entire challenge ack
quota.

It further moves in the direction of eliminating the global limit at some
point, as Eric Dumazet has suggested. This a follow-up to:
Subject: tcp: make challenge acks less predictable

	Cc: Eric Dumazet <edumazet@google.com>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: Neal Cardwell <ncardwell@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Cc: Yue Cao <ycao009@ucr.edu>
	Signed-off-by: Jason Baron <jbaron@akamai.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 083ae308280d13d187512b9babe3454342a7987e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 0b920619f257,42bf89aaf6a5..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -3317,21 -3451,9 +3334,25 @@@ bool tcp_oow_rate_limited(struct net *n
  	/* Data packets without SYNs are not likely part of an ACK loop. */
  	if ((TCP_SKB_CB(skb)->seq != TCP_SKB_CB(skb)->end_seq) &&
  	    !tcp_hdr(skb)->syn)
- 		goto not_rate_limited;
+ 		return false;
  
++<<<<<<< HEAD
 +	if (*last_oow_ack_time) {
 +		s32 elapsed = (s32)(tcp_time_stamp - *last_oow_ack_time);
 +
 +		if (0 <= elapsed && elapsed < sysctl_tcp_invalid_ratelimit) {
 +			NET_INC_STATS_BH(net, mib_idx);
 +			return true;	/* rate-limited: don't send yet! */
 +		}
 +	}
 +
 +	*last_oow_ack_time = tcp_time_stamp;
 +
 +not_rate_limited:
 +	return false;	/* not rate-limited: go ahead, send dupack now! */
++=======
+ 	return __tcp_oow_rate_limited(net, mib_idx, last_oow_ack_time);
++>>>>>>> 083ae308280d (tcp: enable per-socket rate limiting of all 'challenge acks')
  }
  
  /* RFC 5961 7 [ACK Throttling] */
@@@ -3341,22 -3463,27 +3362,22 @@@ static void tcp_send_challenge_ack(stru
  	static u32 challenge_timestamp;
  	static unsigned int challenge_count;
  	struct tcp_sock *tp = tcp_sk(sk);
 -	u32 count, now;
 +	u32 now;
  
  	/* First check our per-socket dupack rate limit. */
- 	if (tcp_oow_rate_limited(sock_net(sk), skb,
- 				 LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
- 				 &tp->last_oow_ack_time))
+ 	if (__tcp_oow_rate_limited(sock_net(sk),
+ 				   LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
+ 				   &tp->last_oow_ack_time))
  		return;
  
 -	/* Then check host-wide RFC 5961 rate limit. */
 +	/* Then check the check host-wide RFC 5961 rate limit. */
  	now = jiffies / HZ;
  	if (now != challenge_timestamp) {
 -		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;
 -
  		challenge_timestamp = now;
 -		WRITE_ONCE(challenge_count, half +
 -			   prandom_u32_max(sysctl_tcp_challenge_ack_limit));
 +		challenge_count = 0;
  	}
 -	count = READ_ONCE(challenge_count);
 -	if (count > 0) {
 -		WRITE_ONCE(challenge_count, count - 1);
 -		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 +	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
 +		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
  		tcp_send_ack(sk);
  	}
  }
* Unmerged path net/ipv4/tcp_input.c
