perf hists: Add level field to struct perf_hpp_fmt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 4b633eba14627bcb1ef5c7a498e7dc308cd6a5d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4b633eba.failed

The level field is to distinguish levels in the hierarchy mode.
Currently each column (perf_hpp_fmt) has a different level.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1457103582-28396-2-git-send-email-namhyung@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 4b633eba14627bcb1ef5c7a498e7dc308cd6a5d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/sort.c
diff --cc tools/perf/util/sort.c
index 8f36c1d6fd38,ab6eb7ca8c60..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1448,8 -1483,68 +1448,8 @@@ static int64_t __sort__hpp_sort(struct 
  	return sort_fn(a, b);
  }
  
 -bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
 -{
 -	return format->header == __sort__hpp_header;
 -}
 -
 -bool perf_hpp__is_trace_entry(struct perf_hpp_fmt *fmt)
 -{
 -	struct hpp_sort_entry *hse;
 -
 -	if (!perf_hpp__is_sort_entry(fmt))
 -		return false;
 -
 -	hse = container_of(fmt, struct hpp_sort_entry, hpp);
 -	return hse->se == &sort_trace;
 -}
 -
 -bool perf_hpp__is_srcline_entry(struct perf_hpp_fmt *fmt)
 -{
 -	struct hpp_sort_entry *hse;
 -
 -	if (!perf_hpp__is_sort_entry(fmt))
 -		return false;
 -
 -	hse = container_of(fmt, struct hpp_sort_entry, hpp);
 -	return hse->se == &sort_srcline;
 -}
 -
 -bool perf_hpp__is_srcfile_entry(struct perf_hpp_fmt *fmt)
 -{
 -	struct hpp_sort_entry *hse;
 -
 -	if (!perf_hpp__is_sort_entry(fmt))
 -		return false;
 -
 -	hse = container_of(fmt, struct hpp_sort_entry, hpp);
 -	return hse->se == &sort_srcfile;
 -}
 -
 -static bool __sort__hpp_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
 -{
 -	struct hpp_sort_entry *hse_a;
 -	struct hpp_sort_entry *hse_b;
 -
 -	if (!perf_hpp__is_sort_entry(a) || !perf_hpp__is_sort_entry(b))
 -		return false;
 -
 -	hse_a = container_of(a, struct hpp_sort_entry, hpp);
 -	hse_b = container_of(b, struct hpp_sort_entry, hpp);
 -
 -	return hse_a->se == hse_b->se;
 -}
 -
 -static void hse_free(struct perf_hpp_fmt *fmt)
 -{
 -	struct hpp_sort_entry *hse;
 -
 -	hse = container_of(fmt, struct hpp_sort_entry, hpp);
 -	free(hse);
 -}
 -
  static struct hpp_sort_entry *
- __sort_dimension__alloc_hpp(struct sort_dimension *sd)
+ __sort_dimension__alloc_hpp(struct sort_dimension *sd, int level)
  {
  	struct hpp_sort_entry *hse;
  
@@@ -1479,14 -1577,46 +1480,50 @@@
  	return hse;
  }
  
 -static void hpp_free(struct perf_hpp_fmt *fmt)
 +bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
  {
++<<<<<<< HEAD
 +	return format->header == __sort__hpp_header;
++=======
+ 	free(fmt);
  }
  
- static int __sort_dimension__add_hpp_sort(struct sort_dimension *sd)
+ static struct perf_hpp_fmt *__hpp_dimension__alloc_hpp(struct hpp_dimension *hd,
+ 						       int level)
  {
- 	struct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd);
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	fmt = memdup(hd->fmt, sizeof(*fmt));
+ 	if (fmt) {
+ 		INIT_LIST_HEAD(&fmt->list);
+ 		INIT_LIST_HEAD(&fmt->sort_list);
+ 		fmt->free = hpp_free;
+ 		fmt->level = level;
+ 	}
+ 
+ 	return fmt;
+ }
+ 
+ int hist_entry__filter(struct hist_entry *he, int type, const void *arg)
+ {
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hpp_sort_entry *hse;
+ 
+ 	fmt = he->fmt;
+ 	if (fmt == NULL || !perf_hpp__is_sort_entry(fmt))
+ 		return -1;
+ 
+ 	hse = container_of(fmt, struct hpp_sort_entry, hpp);
+ 	if (hse->se->se_filter == NULL)
+ 		return -1;
+ 
+ 	return hse->se->se_filter(he, type, arg);
++>>>>>>> 4b633eba1462 (perf hists: Add level field to struct perf_hpp_fmt)
+ }
+ 
+ static int __sort_dimension__add_hpp_sort(struct sort_dimension *sd, int level)
+ {
+ 	struct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd, level);
  
  	if (hse == NULL)
  		return -1;
@@@ -1495,9 -1625,10 +1532,9 @@@
  	return 0;
  }
  
 -static int __sort_dimension__add_hpp_output(struct perf_hpp_list *list,
 -					    struct sort_dimension *sd)
 +static int __sort_dimension__add_hpp_output(struct sort_dimension *sd)
  {
- 	struct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd);
+ 	struct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd, 0);
  
  	if (hse == NULL)
  		return -1;
@@@ -1713,8 -1843,36 +1750,9 @@@ static int64_t __sort__hde_cmp(struct p
  	return memcmp(a->raw_data + offset, b->raw_data + offset, size);
  }
  
 -bool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *fmt)
 -{
 -	return fmt->cmp == __sort__hde_cmp;
 -}
 -
 -static bool __sort__hde_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
 -{
 -	struct hpp_dynamic_entry *hde_a;
 -	struct hpp_dynamic_entry *hde_b;
 -
 -	if (!perf_hpp__is_dynamic_entry(a) || !perf_hpp__is_dynamic_entry(b))
 -		return false;
 -
 -	hde_a = container_of(a, struct hpp_dynamic_entry, hpp);
 -	hde_b = container_of(b, struct hpp_dynamic_entry, hpp);
 -
 -	return hde_a->field == hde_b->field;
 -}
 -
 -static void hde_free(struct perf_hpp_fmt *fmt)
 -{
 -	struct hpp_dynamic_entry *hde;
 -
 -	hde = container_of(fmt, struct hpp_dynamic_entry, hpp);
 -	free(hde);
 -}
 -
  static struct hpp_dynamic_entry *
- __alloc_dynamic_entry(struct perf_evsel *evsel, struct format_field *field)
+ __alloc_dynamic_entry(struct perf_evsel *evsel, struct format_field *field,
+ 		      int level)
  {
  	struct hpp_dynamic_entry *hde;
  
@@@ -1747,12 -1908,153 +1786,157 @@@
  	return hde;
  }
  
++<<<<<<< HEAD
 +static int add_dynamic_entry(struct perf_evlist *evlist, const char *tok)
++=======
+ static int parse_field_name(char *str, char **event, char **field, char **opt)
+ {
+ 	char *event_name, *field_name, *opt_name;
+ 
+ 	event_name = str;
+ 	field_name = strchr(str, '.');
+ 
+ 	if (field_name) {
+ 		*field_name++ = '\0';
+ 	} else {
+ 		event_name = NULL;
+ 		field_name = str;
+ 	}
+ 
+ 	opt_name = strchr(field_name, '/');
+ 	if (opt_name)
+ 		*opt_name++ = '\0';
+ 
+ 	*event = event_name;
+ 	*field = field_name;
+ 	*opt   = opt_name;
+ 
+ 	return 0;
+ }
+ 
+ /* find match evsel using a given event name.  The event name can be:
+  *   1. '%' + event index (e.g. '%1' for first event)
+  *   2. full event name (e.g. sched:sched_switch)
+  *   3. partial event name (should not contain ':')
+  */
+ static struct perf_evsel *find_evsel(struct perf_evlist *evlist, char *event_name)
+ {
+ 	struct perf_evsel *evsel = NULL;
+ 	struct perf_evsel *pos;
+ 	bool full_name;
+ 
+ 	/* case 1 */
+ 	if (event_name[0] == '%') {
+ 		int nr = strtol(event_name+1, NULL, 0);
+ 
+ 		if (nr > evlist->nr_entries)
+ 			return NULL;
+ 
+ 		evsel = perf_evlist__first(evlist);
+ 		while (--nr > 0)
+ 			evsel = perf_evsel__next(evsel);
+ 
+ 		return evsel;
+ 	}
+ 
+ 	full_name = !!strchr(event_name, ':');
+ 	evlist__for_each(evlist, pos) {
+ 		/* case 2 */
+ 		if (full_name && !strcmp(pos->name, event_name))
+ 			return pos;
+ 		/* case 3 */
+ 		if (!full_name && strstr(pos->name, event_name)) {
+ 			if (evsel) {
+ 				pr_debug("'%s' event is ambiguous: it can be %s or %s\n",
+ 					 event_name, evsel->name, pos->name);
+ 				return NULL;
+ 			}
+ 			evsel = pos;
+ 		}
+ 	}
+ 
+ 	return evsel;
+ }
+ 
+ static int __dynamic_dimension__add(struct perf_evsel *evsel,
+ 				    struct format_field *field,
+ 				    bool raw_trace, int level)
+ {
+ 	struct hpp_dynamic_entry *hde;
+ 
+ 	hde = __alloc_dynamic_entry(evsel, field, level);
+ 	if (hde == NULL)
+ 		return -ENOMEM;
+ 
+ 	hde->raw_trace = raw_trace;
+ 
+ 	perf_hpp__register_sort_field(&hde->hpp);
+ 	return 0;
+ }
+ 
+ static int add_evsel_fields(struct perf_evsel *evsel, bool raw_trace, int level)
+ {
+ 	int ret;
+ 	struct format_field *field;
+ 
+ 	field = evsel->tp_format->format.fields;
+ 	while (field) {
+ 		ret = __dynamic_dimension__add(evsel, field, raw_trace, level);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		field = field->next;
+ 	}
+ 	return 0;
+ }
+ 
+ static int add_all_dynamic_fields(struct perf_evlist *evlist, bool raw_trace,
+ 				  int level)
+ {
+ 	int ret;
+ 	struct perf_evsel *evsel;
+ 
+ 	evlist__for_each(evlist, evsel) {
+ 		if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
+ 			continue;
+ 
+ 		ret = add_evsel_fields(evsel, raw_trace, level);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 	return 0;
+ }
+ 
+ static int add_all_matching_fields(struct perf_evlist *evlist,
+ 				   char *field_name, bool raw_trace, int level)
+ {
+ 	int ret = -ESRCH;
+ 	struct perf_evsel *evsel;
+ 	struct format_field *field;
+ 
+ 	evlist__for_each(evlist, evsel) {
+ 		if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
+ 			continue;
+ 
+ 		field = pevent_find_any_field(evsel->tp_format, field_name);
+ 		if (field == NULL)
+ 			continue;
+ 
+ 		ret = __dynamic_dimension__add(evsel, field, raw_trace, level);
+ 		if (ret < 0)
+ 			break;
+ 	}
+ 	return ret;
+ }
+ 
+ static int add_dynamic_entry(struct perf_evlist *evlist, const char *tok,
+ 			     int level)
++>>>>>>> 4b633eba1462 (perf hists: Add level field to struct perf_hpp_fmt)
  {
 -	char *str, *event_name, *field_name, *opt_name;
 -	struct perf_evsel *evsel;
 +	char *str, *event_name, *field_name;
 +	struct perf_evsel *evsel, *pos;
  	struct format_field *field;
 -	bool raw_trace = symbol_conf.raw_trace;
 +	struct hpp_dynamic_entry *hde;
  	int ret = 0;
  
  	if (evlist == NULL)
@@@ -1768,16 -2068,27 +1952,30 @@@
  		ret = -EINVAL;
  		goto out;
  	}
 +	*field_name++ = '\0';
  
 -	if (opt_name) {
 -		if (strcmp(opt_name, "raw")) {
 -			pr_debug("unsupported field option %s\n", opt_name);
 -			ret = -EINVAL;
 -			goto out;
 +	evsel = NULL;
 +	evlist__for_each(evlist, pos) {
 +		if (!strcmp(pos->name, event_name)) {
 +			evsel = pos;
 +			break;
  		}
 -		raw_trace = true;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (!strcmp(field_name, "trace_fields")) {
+ 		ret = add_all_dynamic_fields(evlist, raw_trace, level);
+ 		goto out;
+ 	}
+ 
+ 	if (event_name == NULL) {
+ 		ret = add_all_matching_fields(evlist, field_name, raw_trace, level);
+ 		goto out;
+ 	}
+ 
+ 	evsel = find_evsel(evlist, event_name);
++>>>>>>> 4b633eba1462 (perf hists: Add level field to struct perf_hpp_fmt)
  	if (evsel == NULL) {
  		pr_debug("Cannot find event: %s\n", event_name);
  		ret = -ENOENT;
@@@ -1790,22 -2101,19 +1988,36 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	field = pevent_find_any_field(evsel->tp_format, field_name);
 +	if (field == NULL) {
 +		pr_debug("Cannot find event field for %s.%s\n",
 +		       event_name, field_name);
 +		ret = -ENOENT;
 +		goto out;
++=======
+ 	if (!strcmp(field_name, "*")) {
+ 		ret = add_evsel_fields(evsel, raw_trace, level);
+ 	} else {
+ 		field = pevent_find_any_field(evsel->tp_format, field_name);
+ 		if (field == NULL) {
+ 			pr_debug("Cannot find event field for %s.%s\n",
+ 				 event_name, field_name);
+ 			return -ENOENT;
+ 		}
+ 
+ 		ret = __dynamic_dimension__add(evsel, field, raw_trace, level);
++>>>>>>> 4b633eba1462 (perf hists: Add level field to struct perf_hpp_fmt)
 +	}
 +
 +	hde = __alloc_dynamic_entry(evsel, field);
 +	if (hde == NULL) {
 +		ret = -ENOMEM;
 +		goto out;
  	}
  
 +	perf_hpp__register_sort_field(&hde->hpp);
 +
  out:
  	free(str);
  	return ret;
@@@ -1827,13 -2135,19 +2039,25 @@@ static int __sort_dimension__add(struc
  	return 0;
  }
  
- static int __hpp_dimension__add(struct hpp_dimension *hd)
+ static int __hpp_dimension__add(struct hpp_dimension *hd, int level)
  {
 -	struct perf_hpp_fmt *fmt;
 +	if (!hd->taken) {
 +		hd->taken = 1;
  
++<<<<<<< HEAD
 +		perf_hpp__register_sort_field(hd->fmt);
 +	}
++=======
+ 	if (hd->taken)
+ 		return 0;
+ 
+ 	fmt = __hpp_dimension__alloc_hpp(hd, level);
+ 	if (!fmt)
+ 		return -1;
+ 
+ 	hd->taken = 1;
+ 	perf_hpp__register_sort_field(fmt);
++>>>>>>> 4b633eba1462 (perf hists: Add level field to struct perf_hpp_fmt)
  	return 0;
  }
  
@@@ -1849,24 -2164,31 +2073,36 @@@ static int __sort_dimension__add_output
  	return 0;
  }
  
 -static int __hpp_dimension__add_output(struct perf_hpp_list *list,
 -				       struct hpp_dimension *hd)
 +static int __hpp_dimension__add_output(struct hpp_dimension *hd)
  {
 -	struct perf_hpp_fmt *fmt;
 +	if (!hd->taken) {
 +		hd->taken = 1;
  
++<<<<<<< HEAD
 +		perf_hpp__column_register(hd->fmt);
 +	}
++=======
+ 	if (hd->taken)
+ 		return 0;
+ 
+ 	fmt = __hpp_dimension__alloc_hpp(hd, 0);
+ 	if (!fmt)
+ 		return -1;
+ 
+ 	hd->taken = 1;
+ 	perf_hpp_list__column_register(list, fmt);
++>>>>>>> 4b633eba1462 (perf hists: Add level field to struct perf_hpp_fmt)
  	return 0;
  }
  
  int hpp_dimension__add_output(unsigned col)
  {
  	BUG_ON(col >= PERF_HPP__MAX_INDEX);
 -	return __hpp_dimension__add_output(&perf_hpp_list, &hpp_sort_dimensions[col]);
 +	return __hpp_dimension__add_output(&hpp_sort_dimensions[col]);
  }
  
- static int sort_dimension__add(const char *tok,
- 			       struct perf_evlist *evlist __maybe_unused)
+ static int sort_dimension__add(const char *tok, struct perf_evlist *evlist,
+ 			       int level)
  {
  	unsigned int i;
  
@@@ -1899,9 -2221,13 +2135,9 @@@
  
  		} else if (sd->entry == &sort_dso) {
  			sort__has_dso = 1;
 -		} else if (sd->entry == &sort_socket) {
 -			sort__has_socket = 1;
 -		} else if (sd->entry == &sort_thread) {
 -			sort__has_thread = 1;
  		}
  
- 		return __sort_dimension__add(sd);
+ 		return __sort_dimension__add(sd, level);
  	}
  
  	for (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++) {
diff --git a/tools/perf/util/hist.h b/tools/perf/util/hist.h
index 1d52912874e9..1ca4f2c439ba 100644
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@ -216,6 +216,7 @@ struct perf_hpp_fmt {
 	int len;
 	int user_len;
 	int idx;
+	int level;
 };
 
 struct perf_hpp_list {
* Unmerged path tools/perf/util/sort.c
