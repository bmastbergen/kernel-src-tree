megaraid_sas: Dual queue depth support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sumit Saxena <sumit.saxena@avagotech.com>
commit 308ec459bc1975d9856cfeb3d1cd6461794a3976
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/308ec459.failed

1. For iMR controllers, firmware will report two queue depths:

   - Controller-wide queue depth
   - LDIO queue depth (240)

Controller-wide queue depth will be greater among the two. Using this
new feature, iMR can provide larger Queue depth(QD) for JBOD and limited
QD for Virtual Disk(VD).

2. megaraid_sas driver will throttle read/write LDIOs based on "LDIO
Queue Depth".

3. Dual queue depth can be enabled/disabled via module parameter. It is
enabled by default if the firmware supports it. Only specific firmware
builds will enable the feature.

4. Added sysfs parameter "ldio_outstanding" which permits querying the
number of outstanding LDIO requests at runtime.

	Signed-off-by: Sumit Saxena <sumit.saxena@avagotech.com>
	Signed-off-by: Kashyap Desai <kashyap.desai@avagotech.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 308ec459bc1975d9856cfeb3d1cd6461794a3976)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas.h
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas.h
index d4c399b43165,2a2f49134491..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@@ -1091,6 -1348,17 +1091,20 @@@ enum MR_SCSI_CMD_TYPE 
  	NON_READ_WRITE_SYSPDIO = 3,
  };
  
++<<<<<<< HEAD
++=======
+ enum DCMD_TIMEOUT_ACTION {
+ 	INITIATE_OCR = 0,
+ 	KILL_ADAPTER = 1,
+ 	IGNORE_TIMEOUT = 2,
+ };
+ 
+ enum FW_BOOT_CONTEXT {
+ 	PROBE_CONTEXT = 0,
+ 	OCR_CONTEXT = 1,
+ };
+ 
++>>>>>>> 308ec459bc19 (megaraid_sas: Dual queue depth support)
  /* Frame Type */
  #define IO_FRAME				0
  #define PTHRU_FRAME				1
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index b60f8ef53c66,961c024d11ca..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -92,6 -92,14 +92,17 @@@ int smp_affinity_enable = 1
  module_param(smp_affinity_enable, int, S_IRUGO);
  MODULE_PARM_DESC(smp_affinity_enable, "SMP affinity feature enable/disbale Default: enable(1)");
  
++<<<<<<< HEAD
++=======
+ int rdpq_enable = 1;
+ module_param(rdpq_enable, int, S_IRUGO);
+ MODULE_PARM_DESC(rdpq_enable, " Allocate reply queue in chunks for large queue depth enable/disable Default: disable(0)");
+ 
+ unsigned int dual_qdepth_disable;
+ module_param(dual_qdepth_disable, int, S_IRUGO);
+ MODULE_PARM_DESC(dual_qdepth_disable, "Disable dual queue depth feature. Default: 0");
+ 
++>>>>>>> 308ec459bc19 (megaraid_sas: Dual queue depth support)
  MODULE_LICENSE("GPL");
  MODULE_VERSION(MEGASAS_VERSION);
  MODULE_AUTHOR("megaraidlinux.pdl@avagotech.com");
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index a09ae37a613c,6b8547cf9de4..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -92,6 -92,9 +92,12 @@@ void megasas_start_timer(struct megasas
  			 void *fn, unsigned long interval);
  extern struct megasas_mgmt_info megasas_mgmt_info;
  extern int resetwaittime;
++<<<<<<< HEAD
++=======
+ extern unsigned int dual_qdepth_disable;
+ static void megasas_free_rdpq_fusion(struct megasas_instance *instance);
+ static void megasas_free_reply_fusion(struct megasas_instance *instance);
++>>>>>>> 308ec459bc19 (megaraid_sas: Dual queue depth support)
  
  
  
@@@ -205,54 -208,67 +211,115 @@@ megasas_fire_cmd_fusion(struct megasas_
  #endif
  }
  
 +
 +/**
 + * megasas_teardown_frame_pool_fusion -	Destroy the cmd frame DMA pool
 + * @instance:				Adapter soft state
 + */
 +static void megasas_teardown_frame_pool_fusion(
 +	struct megasas_instance *instance)
 +{
 +	int i;
 +	struct fusion_context *fusion = instance->ctrl_context;
 +
 +	u16 max_cmd = instance->max_fw_cmds;
 +
 +	struct megasas_cmd_fusion *cmd;
 +
 +	if (!fusion->sg_dma_pool || !fusion->sense_dma_pool) {
 +		printk(KERN_ERR "megasas: dma pool is null. SG Pool %p, "
 +		       "sense pool : %p\n", fusion->sg_dma_pool,
 +		       fusion->sense_dma_pool);
 +		return;
 +	}
 +
 +	/*
 +	 * Return all frames to pool
 +	 */
 +	for (i = 0; i < max_cmd; i++) {
 +
 +		cmd = fusion->cmd_list[i];
 +
 +		if (cmd->sg_frame)
 +			pci_pool_free(fusion->sg_dma_pool, cmd->sg_frame,
 +				      cmd->sg_frame_phys_addr);
 +
 +		if (cmd->sense)
 +			pci_pool_free(fusion->sense_dma_pool, cmd->sense,
 +				      cmd->sense_phys_addr);
 +	}
 +
 +	/*
 +	 * Now destroy the pool itself
 +	 */
 +	pci_pool_destroy(fusion->sg_dma_pool);
 +	pci_pool_destroy(fusion->sense_dma_pool);
 +
 +	fusion->sg_dma_pool = NULL;
 +	fusion->sense_dma_pool = NULL;
 +}
 +
+ /**
+  * megasas_fusion_update_can_queue -	Do all Adapter Queue depth related calculations here
+  * @instance:							Adapter soft state
+  * fw_boot_context:						Whether this function called during probe or after OCR
+  *
+  * This function is only for fusion controllers.
+  * Update host can queue, if firmware downgrade max supported firmware commands.
+  * Firmware upgrade case will be skiped because underlying firmware has
+  * more resource than exposed to the OS.
+  *
+  */
+ static void
+ megasas_fusion_update_can_queue(struct megasas_instance *instance, int fw_boot_context)
+ {
+ 	u16 cur_max_fw_cmds = 0;
+ 	u16 ldio_threshold = 0;
+ 	struct megasas_register_set __iomem *reg_set;
+ 
+ 	reg_set = instance->reg_set;
+ 
+ 	cur_max_fw_cmds = readl(&instance->reg_set->outbound_scratch_pad_3) & 0x00FFFF;
+ 
+ 	if (dual_qdepth_disable || !cur_max_fw_cmds)
+ 		cur_max_fw_cmds = instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;
+ 	else
+ 		ldio_threshold =
+ 			(instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF) - MEGASAS_FUSION_IOCTL_CMDS;
+ 
+ 	dev_info(&instance->pdev->dev,
+ 			"Current firmware maximum commands: %d\t LDIO threshold: %d\n",
+ 			cur_max_fw_cmds, ldio_threshold);
+ 
+ 	if (fw_boot_context == OCR_CONTEXT) {
+ 		cur_max_fw_cmds = cur_max_fw_cmds - 1;
+ 		if (cur_max_fw_cmds <= instance->max_fw_cmds) {
+ 			instance->cur_can_queue =
+ 				cur_max_fw_cmds - (MEGASAS_FUSION_INTERNAL_CMDS +
+ 						MEGASAS_FUSION_IOCTL_CMDS);
+ 			instance->host->can_queue = instance->cur_can_queue;
+ 			instance->ldio_threshold = ldio_threshold;
+ 		}
+ 	} else {
+ 		instance->max_fw_cmds = cur_max_fw_cmds;
+ 		instance->ldio_threshold = ldio_threshold;
+ 
+ 		if (!instance->is_rdpq)
+ 			instance->max_fw_cmds = min_t(u16, instance->max_fw_cmds, 1024);
+ 
+ 		/*
+ 		* Reduce the max supported cmds by 1. This is to ensure that the
+ 		* reply_q_sz (1 more than the max cmd that driver may send)
+ 		* does not exceed max cmds that the FW can support
+ 		*/
+ 		instance->max_fw_cmds = instance->max_fw_cmds-1;
+ 
+ 		instance->max_scsi_cmds = instance->max_fw_cmds -
+ 				(MEGASAS_FUSION_INTERNAL_CMDS +
+ 				MEGASAS_FUSION_IOCTL_CMDS);
+ 		instance->cur_can_queue = instance->max_scsi_cmds;
+ 	}
+ }
  /**
   * megasas_free_cmds_fusion -	Free all the cmds in the free cmd pool
   * @instance:		Adapter soft state
@@@ -668,6 -799,10 +735,13 @@@ megasas_ioc_init_fusion(struct megasas_
  	if (instance->max_chain_frame_sz > MEGASAS_CHAIN_FRAME_SZ_MIN)
  		drv_ops->mfi_capabilities.support_ext_io_size = 1;
  
++<<<<<<< HEAD
++=======
+ 	drv_ops->mfi_capabilities.support_fp_rlbypass = 1;
+ 	if (!dual_qdepth_disable)
+ 		drv_ops->mfi_capabilities.support_ext_queue_depth = 1;
+ 
++>>>>>>> 308ec459bc19 (megaraid_sas: Dual queue depth support)
  	/* Convert capability to LE32 */
  	cpu_to_le32s((u32 *)&init_frame->driver_operations.mfi_capabilities);
  
@@@ -1076,12 -1217,7 +1150,16 @@@ megasas_init_adapter_fusion(struct mega
  
  	reg_set = instance->reg_set;
  
++<<<<<<< HEAD
 +	/*
 +	 * Get various operational parameters from status register
 +	 */
 +	instance->max_fw_cmds =
 +		instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;
 +	instance->max_fw_cmds = min(instance->max_fw_cmds, (u16)1008);
++=======
+ 	megasas_fusion_update_can_queue(instance, PROBE_CONTEXT);
++>>>>>>> 308ec459bc19 (megaraid_sas: Dual queue depth support)
  
  	/*
  	 * Reduce the max supported cmds by 1. This is to ensure that the
@@@ -2926,8 -3527,10 +3016,10 @@@ int megasas_reset_fusion(struct Scsi_Ho
  			}
  
  			megasas_reset_reply_desc(instance);
+ 			megasas_fusion_update_can_queue(instance, OCR_CONTEXT);
+ 
  			if (megasas_ioc_init_fusion(instance)) {
 -				dev_warn(&instance->pdev->dev,
 +				printk(KERN_WARNING "megaraid_sas: "
  				       "megasas_ioc_init_fusion() failed!"
  				       " for scsi%d\n",
  				       instance->host->host_no);
* Unmerged path drivers/scsi/megaraid/megaraid_sas.h
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
