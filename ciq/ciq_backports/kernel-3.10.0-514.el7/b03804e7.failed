net: Check CHANGEUPPER notifier return value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] Check CHANGEUPPER notifier return value (Ivan Vecera) [1268334]
Rebuild_FUZZ: 93.98%
commit-author Ido Schimmel <idosch@mellanox.com>
commit b03804e7c3ad41c265c0ca21ddb306b252b4f99f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b03804e7.failed

switchdev drivers reflect the newly requested topology to hardware when
CHANGEUPPER is received, after software links were already formed.
However, the operation can fail and user will not be notified, as the
return value of the notifier is not checked.

Add this check and rollback software links if necessary.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b03804e7c3ad41c265c0ca21ddb306b252b4f99f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index ce5758e98847,939cd1b1da15..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4731,22 -5442,98 +4731,64 @@@ static int __netdev_upper_dev_link(stru
  	if (master && netdev_master_upper_dev_get(dev))
  		return -EBUSY;
  
 -	changeupper_info.upper_dev = upper_dev;
 -	changeupper_info.master = master;
 -	changeupper_info.linking = true;
 +	upper = kmalloc(sizeof(*upper), GFP_KERNEL);
 +	if (!upper)
 +		return -ENOMEM;
  
 -	ret = call_netdevice_notifiers_info(NETDEV_PRECHANGEUPPER, dev,
 -					    &changeupper_info.info);
 -	ret = notifier_to_errno(ret);
 -	if (ret)
 -		return ret;
 +	upper->dev = upper_dev;
 +	upper->master = master;
 +	INIT_LIST_HEAD(&upper->search_list);
  
 -	ret = __netdev_adjacent_dev_link_neighbour(dev, upper_dev, private,
 -						   master);
 -	if (ret)
 -		return ret;
 +	/* Ensure that master upper link is always the first item in list. */
 +	if (master)
 +		list_add_rcu(&upper->list, &dev->upper_dev_list);
 +	else
 +		list_add_tail_rcu(&upper->list, &dev->upper_dev_list);
 +	dev_hold(upper_dev);
  
++<<<<<<< HEAD
++=======
+ 	/* Now that we linked these devs, make all the upper_dev's
+ 	 * all_adj_list.upper visible to every dev's all_adj_list.lower an
+ 	 * versa, and don't forget the devices itself. All of these
+ 	 * links are non-neighbours.
+ 	 */
+ 	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
+ 		list_for_each_entry(j, &upper_dev->all_adj_list.upper, list) {
+ 			pr_debug("Interlinking %s with %s, non-neighbour\n",
+ 				 i->dev->name, j->dev->name);
+ 			ret = __netdev_adjacent_dev_link(i->dev, j->dev);
+ 			if (ret)
+ 				goto rollback_mesh;
+ 		}
+ 	}
+ 
+ 	/* add dev to every upper_dev's upper device */
+ 	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list) {
+ 		pr_debug("linking %s's upper device %s with %s\n",
+ 			 upper_dev->name, i->dev->name, dev->name);
+ 		ret = __netdev_adjacent_dev_link(dev, i->dev);
+ 		if (ret)
+ 			goto rollback_upper_mesh;
+ 	}
+ 
+ 	/* add upper_dev to every dev's lower device */
+ 	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
+ 		pr_debug("linking %s's lower device %s with %s\n", dev->name,
+ 			 i->dev->name, upper_dev->name);
+ 		ret = __netdev_adjacent_dev_link(i->dev, upper_dev);
+ 		if (ret)
+ 			goto rollback_lower_mesh;
+ 	}
+ 
+ 	ret = call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
+ 					    &changeupper_info.info);
+ 	ret = notifier_to_errno(ret);
+ 	if (ret)
+ 		goto rollback_lower_mesh;
+ 
++>>>>>>> b03804e7c3ad (net: Check CHANGEUPPER notifier return value)
  	return 0;
 -
 -rollback_lower_mesh:
 -	to_i = i;
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		if (i == to_i)
 -			break;
 -		__netdev_adjacent_dev_unlink(i->dev, upper_dev);
 -	}
 -
 -	i = NULL;
 -
 -rollback_upper_mesh:
 -	to_i = i;
 -	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list) {
 -		if (i == to_i)
 -			break;
 -		__netdev_adjacent_dev_unlink(dev, i->dev);
 -	}
 -
 -	i = j = NULL;
 -
 -rollback_mesh:
 -	to_i = i;
 -	to_j = j;
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		list_for_each_entry(j, &upper_dev->all_adj_list.upper, list) {
 -			if (i == to_i && j == to_j)
 -				break;
 -			__netdev_adjacent_dev_unlink(i->dev, j->dev);
 -		}
 -		if (i == to_i)
 -			break;
 -	}
 -
 -	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
 -
 -	return ret;
  }
  
  /**
* Unmerged path net/core/dev.c
