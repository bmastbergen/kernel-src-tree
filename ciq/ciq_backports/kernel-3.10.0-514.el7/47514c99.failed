efi: Pass correct file handle to efi_file_{read,close}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [firmware] efi: Pass correct file handle to efi_file_{read, close} (Lenny Szubowicz) [1310154]
Rebuild_FUZZ: 99.08%
commit-author Matt Fleming <matt.fleming@intel.com>
commit 47514c996fac5e6f13ef3a4c5e23f1c5cffabb7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/47514c99.failed

We're currently passing the file handle for the root file system to
efi_file_read() and efi_file_close(), instead of the file handle for the
file we wish to read/close.

While this has worked up until now, it seems that it has only been by
pure luck. Olivier explains,

 "The issue is the UEFI Fat driver might return the same function for
  'fh->read()' and 'h->read()'. While in our case it does not work with
  a different implementation of EFI_SIMPLE_FILE_SYSTEM_PROTOCOL. In our
  case, we return a different pointer when reading a directory and
  reading a file."

Fixing this actually clears up the two functions because we can drop one
of the arguments, and instead only pass a file 'handle' argument.

	Reported-by: Olivier Martin <olivier.martin@arm.com>
	Reviewed-by: Olivier Martin <olivier.martin@arm.com>
	Reviewed-by: Mark Rutland <mark.rutland@arm.com>
	Cc: Leif Lindholm <leif.lindholm@linaro.org>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 47514c996fac5e6f13ef3a4c5e23f1c5cffabb7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
#	drivers/firmware/efi/efi-stub-helper.c
diff --cc arch/x86/boot/compressed/eboot.c
index a1ae20b40077,4703a6c4b8e3..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -20,6 -19,270 +20,273 @@@
  
  static efi_system_table_t *sys_table;
  
++<<<<<<< HEAD
++=======
+ static struct efi_config *efi_early;
+ 
+ #define efi_call_early(f, ...)						\
+ 	efi_early->call(efi_early->f, __VA_ARGS__);
+ 
+ #define BOOT_SERVICES(bits)						\
+ static void setup_boot_services##bits(struct efi_config *c)		\
+ {									\
+ 	efi_system_table_##bits##_t *table;				\
+ 	efi_boot_services_##bits##_t *bt;				\
+ 									\
+ 	table = (typeof(table))sys_table;				\
+ 									\
+ 	c->text_output = table->con_out;				\
+ 									\
+ 	bt = (typeof(bt))(unsigned long)(table->boottime);		\
+ 									\
+ 	c->allocate_pool = bt->allocate_pool;				\
+ 	c->allocate_pages = bt->allocate_pages;				\
+ 	c->get_memory_map = bt->get_memory_map;				\
+ 	c->free_pool = bt->free_pool;					\
+ 	c->free_pages = bt->free_pages;					\
+ 	c->locate_handle = bt->locate_handle;				\
+ 	c->handle_protocol = bt->handle_protocol;			\
+ 	c->exit_boot_services = bt->exit_boot_services;			\
+ }
+ BOOT_SERVICES(32);
+ BOOT_SERVICES(64);
+ 
+ static void efi_printk(efi_system_table_t *, char *);
+ static void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
+ 
+ static efi_status_t
+ __file_size32(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_32_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u32 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_call_early(free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_call_early(free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t
+ __file_size64(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_64_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u64 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_call_early(free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_call_early(free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ static efi_status_t
+ efi_file_size(efi_system_table_t *sys_table, void *__fh,
+ 	      efi_char16_t *filename_16, void **handle, u64 *file_sz)
+ {
+ 	if (efi_early->is64)
+ 		return __file_size64(__fh, filename_16, handle, file_sz);
+ 
+ 	return __file_size32(__fh, filename_16, handle, file_sz);
+ }
+ 
+ static inline efi_status_t
+ efi_file_read(void *handle, unsigned long *size, void *addr)
+ {
+ 	unsigned long func;
+ 
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = handle;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	} else {
+ 		efi_file_handle_32_t *fh = handle;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	}
+ }
+ 
+ static inline efi_status_t efi_file_close(void *handle)
+ {
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = handle;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	} else {
+ 		efi_file_handle_32_t *fh = handle;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	}
+ }
+ 
+ static inline efi_status_t __open_volume32(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_32_t *image = __image;
+ 	efi_file_handle_32_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t __open_volume64(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_64_t *image = __image;
+ 	efi_file_handle_64_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t
+ efi_open_volume(efi_system_table_t *sys_table, void *__image, void **__fh)
+ {
+ 	if (efi_early->is64)
+ 		return __open_volume64(__image, __fh);
+ 
+ 	return __open_volume32(__image, __fh);
+ }
+ 
+ static void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
+ {
+ 	unsigned long output_string;
+ 	size_t offset;
+ 
+ 	if (efi_early->is64) {
+ 		struct efi_simple_text_output_protocol_64 *out;
+ 		u64 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u64 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	} else {
+ 		struct efi_simple_text_output_protocol_32 *out;
+ 		u32 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u32 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	}
+ }
++>>>>>>> 47514c996fac (efi: Pass correct file handle to efi_file_{read,close})
  
  #include "../../../../drivers/firmware/efi/efi-stub-helper.c"
  
diff --cc drivers/firmware/efi/efi-stub-helper.c
index f243c3499856,2c41eaece2c1..000000000000
--- a/drivers/firmware/efi/efi-stub-helper.c
+++ b/drivers/firmware/efi/efi-stub-helper.c
@@@ -441,18 -396,19 +441,29 @@@ grow
  					chunksize = EFI_READ_CHUNK_SIZE;
  				else
  					chunksize = size;
++<<<<<<< HEAD
 +				status = efi_call_phys3(fh->read,
 +							initrds[j].handle,
 +							&chunksize, addr);
++=======
+ 
+ 				status = efi_file_read(files[j].handle,
+ 						       &chunksize,
+ 						       (void *)addr);
++>>>>>>> 47514c996fac (efi: Pass correct file handle to efi_file_{read,close})
  				if (status != EFI_SUCCESS) {
 -					efi_printk(sys_table_arg, "Failed to read file\n");
 -					goto free_file_total;
 +					efi_printk(sys_table_arg, "Failed to read initrd\n");
 +					goto free_initrd_total;
  				}
  				addr += chunksize;
  				size -= chunksize;
  			}
  
++<<<<<<< HEAD
 +			efi_call_phys1(fh->close, initrds[j].handle);
++=======
+ 			efi_file_close(files[j].handle);
++>>>>>>> 47514c996fac (efi: Pass correct file handle to efi_file_{read,close})
  		}
  
  	}
@@@ -469,12 -425,12 +480,18 @@@ free_initrd_total
  
  close_handles:
  	for (k = j; k < i; k++)
++<<<<<<< HEAD
 +		efi_call_phys1(fh->close, initrds[k].handle);
 +free_initrds:
 +	efi_call_phys1(sys_table_arg->boottime->free_pool, initrds);
++=======
+ 		efi_file_close(files[k].handle);
+ free_files:
+ 	efi_call_early(free_pool, files);
++>>>>>>> 47514c996fac (efi: Pass correct file handle to efi_file_{read,close})
  fail:
 -	*load_addr = 0;
 -	*load_size = 0;
 +	hdr->ramdisk_image = 0;
 +	hdr->ramdisk_size = 0;
  
  	return status;
  }
* Unmerged path arch/x86/boot/compressed/eboot.c
* Unmerged path drivers/firmware/efi/efi-stub-helper.c
