IB/core: Change per-entry lock in RoCE GID table to one lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matan Barak <matanb@mellanox.com>
commit 9c584f04959620e587b3b3d358076dab48a8893c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9c584f04.failed

Previously, IB GID cached used a lock per entry. This could result
in spending a lot of CPU cycles for locking and unlocking just
in order to find a GID. Changing this in favor of one lock per
a GID table.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Reviewed-by: Haggai Eran <haggaie@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9c584f04959620e587b3b3d358076dab48a8893c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cache.c
diff --cc drivers/infiniband/core/cache.c
index 77177fb6d68f,83aee7c55cb3..000000000000
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@@ -443,8 -453,84 +453,87 @@@ int ib_cache_gid_find_by_port(struct ib
  		return 0;
  	}
  
+ 	read_unlock_irqrestore(&table->rwlock, flags);
  	return -ENOENT;
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL(ib_find_cached_gid_by_port);
+ 
+ /**
+  * ib_find_gid_by_filter - Returns the GID table index where a specified
+  * GID value occurs
+  * @device: The device to query.
+  * @gid: The GID value to search for.
+  * @port_num: The port number of the device where the GID value could be
+  *   searched.
+  * @filter: The filter function is executed on any matching GID in the table.
+  *   If the filter function returns true, the corresponding index is returned,
+  *   otherwise, we continue searching the GID table. It's guaranteed that
+  *   while filter is executed, ndev field is valid and the structure won't
+  *   change. filter is executed in an atomic context. filter must not be NULL.
+  * @index: The index into the cached GID table where the GID was found.  This
+  *   parameter may be NULL.
+  *
+  * ib_cache_gid_find_by_filter() searches for the specified GID value
+  * of which the filter function returns true in the port's GID table.
+  * This function is only supported on RoCE ports.
+  *
+  */
+ static int ib_cache_gid_find_by_filter(struct ib_device *ib_dev,
+ 				       const union ib_gid *gid,
+ 				       u8 port,
+ 				       bool (*filter)(const union ib_gid *,
+ 						      const struct ib_gid_attr *,
+ 						      void *),
+ 				       void *context,
+ 				       u16 *index)
+ {
+ 	struct ib_gid_table **ports_table = ib_dev->cache.gid_cache;
+ 	struct ib_gid_table *table;
+ 	unsigned int i;
+ 	unsigned long flags;
+ 	bool found = false;
+ 
+ 	if (!ports_table)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (port < rdma_start_port(ib_dev) ||
+ 	    port > rdma_end_port(ib_dev) ||
+ 	    !rdma_protocol_roce(ib_dev, port))
+ 		return -EPROTONOSUPPORT;
+ 
+ 	table = ports_table[port - rdma_start_port(ib_dev)];
+ 
+ 	read_lock_irqsave(&table->rwlock, flags);
+ 	for (i = 0; i < table->sz; i++) {
+ 		struct ib_gid_attr attr;
+ 
+ 		if (table->data_vec[i].props & GID_TABLE_ENTRY_INVALID)
+ 			goto next;
+ 
+ 		if (memcmp(gid, &table->data_vec[i].gid, sizeof(*gid)))
+ 			goto next;
+ 
+ 		memcpy(&attr, &table->data_vec[i].attr, sizeof(attr));
+ 
+ 		if (filter(gid, &attr, context))
+ 			found = true;
+ 
+ next:
+ 		if (found)
+ 			break;
+ 	}
+ 	read_unlock_irqrestore(&table->rwlock, flags);
+ 
+ 	if (!found)
+ 		return -ENOENT;
+ 
+ 	if (index)
+ 		*index = i;
+ 	return 0;
+ }
++>>>>>>> 9c584f049596 (IB/core: Change per-entry lock in RoCE GID table to one lock)
  
  static struct ib_gid_table *alloc_gid_table(int sz)
  {
@@@ -656,12 -756,22 +759,25 @@@ static int gid_table_setup_one(struct i
  int ib_get_cached_gid(struct ib_device *device,
  		      u8                port_num,
  		      int               index,
 -		      union ib_gid     *gid,
 -		      struct ib_gid_attr *gid_attr)
 +		      union ib_gid     *gid)
  {
+ 	int res;
+ 	unsigned long flags;
+ 	struct ib_gid_table **ports_table = device->cache.gid_cache;
+ 	struct ib_gid_table *table = ports_table[port_num - rdma_start_port(device)];
+ 
  	if (port_num < rdma_start_port(device) || port_num > rdma_end_port(device))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	return __ib_cache_gid_get(device, port_num, index, gid, NULL);
++=======
+ 	read_lock_irqsave(&table->rwlock, flags);
+ 	res = __ib_cache_gid_get(device, port_num, index, gid, gid_attr);
+ 	read_unlock_irqrestore(&table->rwlock, flags);
+ 
+ 	return res;
++>>>>>>> 9c584f049596 (IB/core: Change per-entry lock in RoCE GID table to one lock)
  }
  EXPORT_SYMBOL(ib_get_cached_gid);
  
* Unmerged path drivers/infiniband/core/cache.c
