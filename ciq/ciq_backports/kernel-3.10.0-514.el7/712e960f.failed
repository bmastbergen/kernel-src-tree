ACPI / PM: Attach ACPI power domain only once

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 712e960f0ee9337f3473ba3de2bcfc7e87b7c5a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/712e960f.failed

Some devices, like MFD subdevices, share a single ACPI companion device so
that they are able to access their resources and children. However,
currently all these subdevices are attached to the ACPI power domain and
this might cause that the power methods for the companion device get called
more than once.

In order to solve this we attach the ACPI power domain only to the first
physical device that is bound to the ACPI companion device. In case of MFD
devices, this is the parent MFD device itself.

	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Lee Jones <lee.jones@linaro.org>
(cherry picked from commit 712e960f0ee9337f3473ba3de2bcfc7e87b7c5a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/device_pm.c
#	drivers/acpi/internal.h
#	drivers/acpi/scan.c
diff --cc drivers/acpi/device_pm.c
index bce55ef59dce,08dc3ec7e892..000000000000
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@@ -999,7 -1123,15 +999,19 @@@ int acpi_dev_pm_attach(struct device *d
  	if (dev->pm_domain)
  		return -EEXIST;
  
++<<<<<<< HEAD
 +	acpi_add_pm_notifier(adev, acpi_wakeup_device, dev);
++=======
+ 	/*
+ 	 * Only attach the power domain to the first device if the
+ 	 * companion is shared by multiple. This is to prevent doing power
+ 	 * management twice.
+ 	 */
+ 	if (!acpi_device_is_first_physical_node(adev, dev))
+ 		return -EBUSY;
+ 
+ 	acpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);
++>>>>>>> 712e960f0ee9 (ACPI / PM: Attach ACPI power domain only once)
  	dev->pm_domain = &acpi_general_pm_domain;
  	if (power_on) {
  		acpi_dev_pm_full_power(adev);
diff --cc drivers/acpi/internal.h
index 0f5eb460f227,f6aefe984941..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -92,10 -95,10 +92,16 @@@ void acpi_init_device_object(struct acp
  			     int type, unsigned long long sta);
  void acpi_device_add_finalize(struct acpi_device *device);
  void acpi_free_pnp_ids(struct acpi_device_pnp *pnp);
 +int acpi_bind_one(struct device *dev, struct acpi_device *adev);
 +int acpi_unbind_one(struct device *dev);
  bool acpi_device_is_present(struct acpi_device *adev);
++<<<<<<< HEAD
 +bool acpi_device_is_battery(acpi_handle handle);
++=======
+ bool acpi_device_is_battery(struct acpi_device *adev);
+ bool acpi_device_is_first_physical_node(struct acpi_device *adev,
+ 					const struct device *dev);
++>>>>>>> 712e960f0ee9 (ACPI / PM: Attach ACPI power domain only once)
  
  /* --------------------------------------------------------------------------
                                    Power Resource
diff --cc drivers/acpi/scan.c
index a53f9f1ef42f,89ff6d2eef8a..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -138,17 -172,218 +138,229 @@@ static int create_modalias(struct acpi_
  	return len;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * create_of_modalias - Creates DT compatible string for modalias and uevent
+  * @acpi_dev: ACPI device object.
+  * @modalias: Buffer to print into.
+  * @size: Size of the buffer.
+  *
+  * Expose DT compatible modalias as of:NnameTCcompatible.  This function should
+  * only be called for devices having ACPI_DT_NAMESPACE_HID in their list of
+  * ACPI/PNP IDs.
+  */
+ static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
+ 			      int size)
+ {
+ 	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+ 	const union acpi_object *of_compatible, *obj;
+ 	int len, count;
+ 	int i, nval;
+ 	char *c;
+ 
+ 	acpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);
+ 	/* DT strings are all in lower case */
+ 	for (c = buf.pointer; *c != '\0'; c++)
+ 		*c = tolower(*c);
+ 
+ 	len = snprintf(modalias, size, "of:N%sT", (char *)buf.pointer);
+ 	ACPI_FREE(buf.pointer);
+ 
+ 	if (len <= 0)
+ 		return len;
+ 
+ 	of_compatible = acpi_dev->data.of_compatible;
+ 	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+ 		nval = of_compatible->package.count;
+ 		obj = of_compatible->package.elements;
+ 	} else { /* Must be ACPI_TYPE_STRING. */
+ 		nval = 1;
+ 		obj = of_compatible;
+ 	}
+ 	for (i = 0; i < nval; i++, obj++) {
+ 		count = snprintf(&modalias[len], size, "C%s",
+ 				 obj->string.pointer);
+ 		if (count < 0)
+ 			return -EINVAL;
+ 
+ 		if (count >= size)
+ 			return -ENOMEM;
+ 
+ 		len += count;
+ 		size -= count;
+ 	}
+ 	modalias[len] = '\0';
+ 	return len;
+ }
+ 
+ /**
+  * acpi_device_is_first_physical_node - Is given dev first physical node
+  * @adev: ACPI companion device
+  * @dev: Physical device to check
+  *
+  * Function checks if given @dev is the first physical devices attached to
+  * the ACPI companion device. This distinction is needed in some cases
+  * where the same companion device is shared between many physical devices.
+  *
+  * Note that the caller have to provide valid @adev pointer.
+  */
+ bool acpi_device_is_first_physical_node(struct acpi_device *adev,
+ 					const struct device *dev)
+ {
+ 	bool ret = false;
+ 
+ 	mutex_lock(&adev->physical_node_lock);
+ 	if (!list_empty(&adev->physical_node_list)) {
+ 		const struct acpi_device_physical_node *node;
+ 
+ 		node = list_first_entry(&adev->physical_node_list,
+ 					struct acpi_device_physical_node, node);
+ 		ret = node->dev == dev;
+ 	}
+ 	mutex_unlock(&adev->physical_node_lock);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * acpi_companion_match() - Can we match via ACPI companion device
+  * @dev: Device in question
+  *
+  * Check if the given device has an ACPI companion and if that companion has
+  * a valid list of PNP IDs, and if the device is the first (primary) physical
+  * device associated with it.  Return the companion pointer if that's the case
+  * or NULL otherwise.
+  *
+  * If multiple physical devices are attached to a single ACPI companion, we need
+  * to be careful.  The usage scenario for this kind of relationship is that all
+  * of the physical devices in question use resources provided by the ACPI
+  * companion.  A typical case is an MFD device where all the sub-devices share
+  * the parent's ACPI companion.  In such cases we can only allow the primary
+  * (first) physical device to be matched with the help of the companion's PNP
+  * IDs.
+  *
+  * Additional physical devices sharing the ACPI companion can still use
+  * resources available from it but they will be matched normally using functions
+  * provided by their bus types (and analogously for their modalias).
+  */
+ static struct acpi_device *acpi_companion_match(const struct device *dev)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	adev = ACPI_COMPANION(dev);
+ 	if (!adev)
+ 		return NULL;
+ 
+ 	if (list_empty(&adev->pnp.ids))
+ 		return NULL;
+ 
+ 	return acpi_device_is_first_physical_node(adev, dev) ? adev : NULL;
+ }
+ 
+ static int __acpi_device_uevent_modalias(struct acpi_device *adev,
+ 					 struct kobj_uevent_env *env)
+ {
+ 	int len;
+ 
+ 	if (!adev)
+ 		return -ENODEV;
+ 
+ 	if (list_empty(&adev->pnp.ids))
+ 		return 0;
+ 
+ 	if (add_uevent_var(env, "MODALIAS="))
+ 		return -ENOMEM;
+ 
+ 	len = create_pnp_modalias(adev, &env->buf[env->buflen - 1],
+ 				  sizeof(env->buf) - env->buflen);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	env->buflen += len;
+ 	if (!adev->data.of_compatible)
+ 		return 0;
+ 
+ 	if (len > 0 && add_uevent_var(env, "MODALIAS="))
+ 		return -ENOMEM;
+ 
+ 	len = create_of_modalias(adev, &env->buf[env->buflen - 1],
+ 				 sizeof(env->buf) - env->buflen);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	env->buflen += len;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Creates uevent modalias field for ACPI enumerated devices.
+  * Because the other buses does not support ACPI HIDs & CIDs.
+  * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+  * "acpi:IBM0001:ACPI0001"
+  */
+ int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	return __acpi_device_uevent_modalias(acpi_companion_match(dev), env);
+ }
+ EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
+ 
+ static int __acpi_device_modalias(struct acpi_device *adev, char *buf, int size)
+ {
+ 	int len, count;
+ 
+ 	if (!adev)
+ 		return -ENODEV;
+ 
+ 	if (list_empty(&adev->pnp.ids))
+ 		return 0;
+ 
+ 	len = create_pnp_modalias(adev, buf, size - 1);
+ 	if (len < 0) {
+ 		return len;
+ 	} else if (len > 0) {
+ 		buf[len++] = '\n';
+ 		size -= len;
+ 	}
+ 	if (!adev->data.of_compatible)
+ 		return len;
+ 
+ 	count = create_of_modalias(adev, buf + len, size - 1);
+ 	if (count < 0) {
+ 		return count;
+ 	} else if (count > 0) {
+ 		len += count;
+ 		buf[len++] = '\n';
+ 	}
+ 
+ 	return len;
+ }
+ 
+ /*
+  * Creates modalias sysfs attribute for ACPI enumerated devices.
+  * Because the other buses does not support ACPI HIDs & CIDs.
+  * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+  * "acpi:IBM0001:ACPI0001"
+  */
+ int acpi_device_modalias(struct device *dev, char *buf, int size)
+ {
+ 	return __acpi_device_modalias(acpi_companion_match(dev), buf, size);
+ }
+ EXPORT_SYMBOL_GPL(acpi_device_modalias);
+ 
++>>>>>>> 712e960f0ee9 (ACPI / PM: Attach ACPI power domain only once)
  static ssize_t
  acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf) {
 -	return __acpi_device_modalias(to_acpi_device(dev), buf, 1024);
 +	struct acpi_device *acpi_dev = to_acpi_device(dev);
 +	int len;
 +
 +	/* Device has no HID and no CID or string is >1024 */
 +	len = create_modalias(acpi_dev, buf, 1024);
 +	if (len <= 0)
 +		return 0;
 +	buf[len++] = '\n';
 +	return len;
  }
  static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
  
* Unmerged path drivers/acpi/device_pm.c
* Unmerged path drivers/acpi/internal.h
* Unmerged path drivers/acpi/scan.c
