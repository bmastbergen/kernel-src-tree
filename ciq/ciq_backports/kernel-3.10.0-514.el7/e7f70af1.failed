vxlan: support setting IPv6 flow label

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit e7f70af111f086a20800ad2e17f544b2e3e0f375
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e7f70af1.failed

This work adds support for setting the IPv6 flow label for vxlan per
device and through collect metadata (ip_tunnel_key) frontends. The
vxlan dst cache does not need any special considerations here, for
the cases where caches can be used, the label is static per cache.

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e7f70af111f086a20800ad2e17f544b2e3e0f375)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/vxlan.h
#	include/uapi/linux/if_link.h
diff --cc drivers/net/vxlan.c
index 000e4c57a81e,8eda76f9e474..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1816,12 -1749,87 +1816,94 @@@ int vxlan_xmit_skb(struct rtable *rt, s
  		vxlan_build_gbp_hdr(vxh, vxflags, md);
  
  	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
 -	return 0;
 +
 +	return udp_tunnel_xmit_skb(rt, sk, skb, src, dst, tos,
 +				   ttl, df, src_port, dst_port, xnet,
 +				   !(vxflags & VXLAN_F_UDP_CSUM));
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
++=======
+ 
+ static struct rtable *vxlan_get_route(struct vxlan_dev *vxlan,
+ 				      struct sk_buff *skb, int oif, u8 tos,
+ 				      __be32 daddr, __be32 *saddr,
+ 				      struct dst_cache *dst_cache,
+ 				      const struct ip_tunnel_info *info)
+ {
+ 	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
+ 	struct rtable *rt = NULL;
+ 	struct flowi4 fl4;
+ 
+ 	if (tos && !info)
+ 		use_cache = false;
+ 	if (use_cache) {
+ 		rt = dst_cache_get_ip4(dst_cache, saddr);
+ 		if (rt)
+ 			return rt;
+ 	}
+ 
+ 	memset(&fl4, 0, sizeof(fl4));
+ 	fl4.flowi4_oif = oif;
+ 	fl4.flowi4_tos = RT_TOS(tos);
+ 	fl4.flowi4_mark = skb->mark;
+ 	fl4.flowi4_proto = IPPROTO_UDP;
+ 	fl4.daddr = daddr;
+ 	fl4.saddr = vxlan->cfg.saddr.sin.sin_addr.s_addr;
+ 
+ 	rt = ip_route_output_key(vxlan->net, &fl4);
+ 	if (!IS_ERR(rt)) {
+ 		*saddr = fl4.saddr;
+ 		if (use_cache)
+ 			dst_cache_set_ip4(dst_cache, &rt->dst, fl4.saddr);
+ 	}
+ 	return rt;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,
+ 					  struct sk_buff *skb, int oif, u8 tos,
+ 					  __be32 label,
+ 					  const struct in6_addr *daddr,
+ 					  struct in6_addr *saddr,
+ 					  struct dst_cache *dst_cache,
+ 					  const struct ip_tunnel_info *info)
+ {
+ 	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
+ 	struct dst_entry *ndst;
+ 	struct flowi6 fl6;
+ 	int err;
+ 
+ 	if (tos && !info)
+ 		use_cache = false;
+ 	if (use_cache) {
+ 		ndst = dst_cache_get_ip6(dst_cache, saddr);
+ 		if (ndst)
+ 			return ndst;
+ 	}
+ 
+ 	memset(&fl6, 0, sizeof(fl6));
+ 	fl6.flowi6_oif = oif;
+ 	fl6.flowi6_tos = RT_TOS(tos);
+ 	fl6.daddr = *daddr;
+ 	fl6.saddr = vxlan->cfg.saddr.sin6.sin6_addr;
+ 	fl6.flowlabel = label;
+ 	fl6.flowi6_mark = skb->mark;
+ 	fl6.flowi6_proto = IPPROTO_UDP;
+ 
+ 	err = ipv6_stub->ipv6_dst_lookup(vxlan->net,
+ 					 vxlan->vn6_sock->sock->sk,
+ 					 &ndst, &fl6);
+ 	if (err < 0)
+ 		return ERR_PTR(err);
+ 
+ 	*saddr = fl6.saddr;
+ 	if (use_cache)
+ 		dst_cache_set_ip6(dst_cache, ndst, saddr);
+ 	return ndst;
+ }
+ #endif
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  
  /* Bypass encapsulation if the destination is local */
  static void vxlan_encap_bypass(struct sk_buff *skb, struct vxlan_dev *src_vxlan,
@@@ -1871,15 -1879,18 +1953,19 @@@
  static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
  			   struct vxlan_rdst *rdst, bool did_rsc)
  {
 -	struct dst_cache *dst_cache;
 -	struct ip_tunnel_info *info;
  	struct vxlan_dev *vxlan = netdev_priv(dev);
 -	struct sock *sk;
 +	struct sock *sk = vxlan->vn_sock->sock->sk;
  	struct rtable *rt = NULL;
  	const struct iphdr *old_iph;
 +	struct flowi4 fl4;
  	union vxlan_addr *dst;
 -	union vxlan_addr remote_ip;
 -	struct vxlan_metadata _md;
 -	struct vxlan_metadata *md = &_md;
 +	struct vxlan_metadata md;
  	__be16 src_port = 0, dst_port;
++<<<<<<< HEAD
 +	u32 vni;
++=======
+ 	__be32 vni, label;
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  	__be16 df = 0;
  	__u8 tos, ttl;
  	int err;
@@@ -1907,19 -1941,33 +1993,37 @@@
  	if (tos == 1)
  		tos = ip_tunnel_get_dsfield(old_iph, skb);
  
++<<<<<<< HEAD
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->port_min,
 +				     vxlan->port_max, true);
++=======
+ 	label = vxlan->cfg.label;
+ 	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				     vxlan->cfg.port_max, true);
+ 
+ 	if (info) {
+ 		ttl = info->key.ttl;
+ 		tos = info->key.tos;
+ 		label = info->key.label;
+ 		udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);
+ 
+ 		if (info->options_len)
+ 			md = ip_tunnel_info_opts(info);
+ 	} else {
+ 		md->gbp = skb->mark;
+ 	}
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  
  	if (dst->sa.sa_family == AF_INET) {
 -		__be32 saddr;
 -
 -		if (!vxlan->vn4_sock)
 -			goto drop;
 -		sk = vxlan->vn4_sock->sock->sk;
 -
 -		rt = vxlan_get_route(vxlan, skb,
 -				     rdst ? rdst->remote_ifindex : 0, tos,
 -				     dst->sin.sin_addr.s_addr, &saddr,
 -				     dst_cache, info);
 +		memset(&fl4, 0, sizeof(fl4));
 +		fl4.flowi4_oif = rdst->remote_ifindex;
 +		fl4.flowi4_tos = RT_TOS(tos);
 +		fl4.flowi4_mark = skb->mark;
 +		fl4.flowi4_proto = IPPROTO_UDP;
 +		fl4.daddr = dst->sin.sin_addr.s_addr;
 +		fl4.saddr = vxlan->saddr.sin.sin_addr.s_addr;
 +
 +		rt = ip_route_output_key(vxlan->net, &fl4);
  		if (IS_ERR(rt)) {
  			netdev_dbg(dev, "no route to %pI4\n",
  				   &dst->sin.sin_addr.s_addr);
@@@ -1969,17 -2015,18 +2073,25 @@@
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
  		struct dst_entry *ndst;
 -		struct in6_addr saddr;
 +		struct flowi6 fl6;
  		u32 rt6i_flags;
  
 -		if (!vxlan->vn6_sock)
 -			goto drop;
 -		sk = vxlan->vn6_sock->sock->sk;
 +		memset(&fl6, 0, sizeof(fl6));
 +		fl6.flowi6_oif = rdst->remote_ifindex;
 +		fl6.daddr = dst->sin6.sin6_addr;
 +		fl6.saddr = vxlan->saddr.sin6.sin6_addr;
 +		fl6.flowi6_mark = skb->mark;
 +		fl6.flowi6_proto = IPPROTO_UDP;
  
++<<<<<<< HEAD
 +		if (ipv6_stub->ipv6_dst_lookup(sk, &ndst, &fl6)) {
++=======
+ 		ndst = vxlan6_get_route(vxlan, skb,
+ 					rdst ? rdst->remote_ifindex : 0, tos,
+ 					label, &dst->sin6.sin6_addr, &saddr,
+ 					dst_cache, info);
+ 		if (IS_ERR(ndst)) {
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  			netdev_dbg(dev, "no route to %pI6\n",
  				   &dst->sin6.sin6_addr);
  			dev->stats.tx_carrier_errors++;
@@@ -2010,14 -2057,21 +2122,27 @@@
  			return;
  		}
  
 -		if (!info)
 -			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);
 -
 -		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
++<<<<<<< HEAD
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &fl6.saddr, &fl6.daddr,
 +				      0, ttl, src_port, dst_port, &md,
 +				      !net_eq(vxlan->net, dev_net(vxlan->dev)),
 +				      vxlan->flags);
++=======
+ 		skb_scrub_packet(skb, xnet);
+ 		err = vxlan_build_skb(skb, ndst, sizeof(struct ipv6hdr),
+ 				      vni, md, flags, udp_sum);
+ 		if (err < 0) {
+ 			dst_release(ndst);
+ 			return;
+ 		}
+ 		udp_tunnel6_xmit_skb(ndst, sk, skb, dev,
+ 				     &saddr, &dst->sin6.sin6_addr, tos, ttl,
+ 				     label, src_port, dst_port, !udp_sum);
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  #endif
  	}
  
@@@ -2304,6 -2366,48 +2429,51 @@@ static int vxlan_change_mtu(struct net_
  	return __vxlan_change_mtu(dev, lowerdev, dst, new_mtu, true);
  }
  
++<<<<<<< HEAD
++=======
+ static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	__be16 sport, dport;
+ 
+ 	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				  vxlan->cfg.port_max, true);
+ 	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		struct rtable *rt;
+ 
+ 		if (!vxlan->vn4_sock)
+ 			return -EINVAL;
+ 		rt = vxlan_get_route(vxlan, skb, 0, info->key.tos,
+ 				     info->key.u.ipv4.dst,
+ 				     &info->key.u.ipv4.src, NULL, info);
+ 		if (IS_ERR(rt))
+ 			return PTR_ERR(rt);
+ 		ip_rt_put(rt);
+ 	} else {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		struct dst_entry *ndst;
+ 
+ 		if (!vxlan->vn6_sock)
+ 			return -EINVAL;
+ 		ndst = vxlan6_get_route(vxlan, skb, 0, info->key.tos,
+ 					info->key.label, &info->key.u.ipv6.dst,
+ 					&info->key.u.ipv6.src, NULL, info);
+ 		if (IS_ERR(ndst))
+ 			return PTR_ERR(ndst);
+ 		dst_release(ndst);
+ #else /* !CONFIG_IPV6 */
+ 		return -EPFNOSUPPORT;
+ #endif
+ 	}
+ 	info->key.tp_src = sport;
+ 	info->key.tp_dst = dport;
+ 	return 0;
+ }
+ 
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  static const struct net_device_ops vxlan_netdev_ops = {
  	.ndo_init		= vxlan_init,
  	.ndo_uninit		= vxlan_uninit,
@@@ -2579,59 -2680,78 +2750,70 @@@ struct vxlan_sock *vxlan_sock_add(struc
  		}
  		spin_unlock(&vn->sock_lock);
  	}
 -	if (!vs)
 -		vs = vxlan_socket_create(vxlan->net, ipv6,
 -					 vxlan->cfg.dst_port, vxlan->flags);
 -	if (IS_ERR(vs))
 -		return PTR_ERR(vs);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	if (ipv6)
 -		vxlan->vn6_sock = vs;
 -	else
 -#endif
 -		vxlan->vn4_sock = vs;
 -	vxlan_vs_add_dev(vs, vxlan);
 -	return 0;
 -}
  
 -static int vxlan_sock_add(struct vxlan_dev *vxlan)
 -{
 -	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
 -	bool metadata = vxlan->flags & VXLAN_F_COLLECT_METADATA;
 -	int ret = 0;
 -
 -	vxlan->vn4_sock = NULL;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	vxlan->vn6_sock = NULL;
 -	if (ipv6 || metadata)
 -		ret = __vxlan_sock_add(vxlan, true);
 -#endif
 -	if (!ret && (!ipv6 || metadata))
 -		ret = __vxlan_sock_add(vxlan, false);
 -	if (ret < 0)
 -		vxlan_sock_release(vxlan);
 -	return ret;
 +	return vxlan_socket_create(net, port, rcv, data, flags);
  }
 +EXPORT_SYMBOL_GPL(vxlan_sock_add);
  
 -static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,
 -			       struct vxlan_config *conf)
 +static int vxlan_newlink(struct net *src_net, struct net_device *dev,
 +			 struct nlattr *tb[], struct nlattr *data[])
  {
  	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
 -	struct vxlan_dev *vxlan = netdev_priv(dev), *tmp;
 +	struct vxlan_dev *vxlan = netdev_priv(dev);
  	struct vxlan_rdst *dst = &vxlan->default_dst;
 -	unsigned short needed_headroom = ETH_HLEN;
 +	__u32 vni;
  	int err;
  	bool use_ipv6 = false;
 -	__be16 default_port = vxlan->cfg.dst_port;
 -	struct net_device *lowerdev = NULL;
  
 -	vxlan->net = src_net;
 +	if (!data[IFLA_VXLAN_ID])
 +		return -EINVAL;
  
 -	dst->remote_vni = conf->vni;
 +	vxlan->net = src_net;
  
 -	memcpy(&dst->remote_ip, &conf->remote_ip, sizeof(conf->remote_ip));
 +	vni = nla_get_u32(data[IFLA_VXLAN_ID]);
 +	dst->remote_vni = vni;
  
  	/* Unless IPv6 is explicitly requested, assume IPv4 */
 -	if (!dst->remote_ip.sa.sa_family)
 -		dst->remote_ip.sa.sa_family = AF_INET;
 +	dst->remote_ip.sa.sa_family = AF_INET;
 +	if (data[IFLA_VXLAN_GROUP]) {
 +		dst->remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);
 +	} else if (data[IFLA_VXLAN_GROUP6]) {
 +		if (!IS_ENABLED(CONFIG_IPV6))
 +			return -EPFNOSUPPORT;
  
 -	if (dst->remote_ip.sa.sa_family == AF_INET6 ||
 -	    vxlan->cfg.saddr.sa.sa_family == AF_INET6) {
 +		dst->remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);
 +		dst->remote_ip.sa.sa_family = AF_INET6;
 +		use_ipv6 = true;
 +	}
 +
++<<<<<<< HEAD
 +	if (data[IFLA_VXLAN_LOCAL]) {
 +		vxlan->saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);
 +		vxlan->saddr.sa.sa_family = AF_INET;
 +	} else if (data[IFLA_VXLAN_LOCAL6]) {
  		if (!IS_ENABLED(CONFIG_IPV6))
  			return -EPFNOSUPPORT;
 +
 +		/* TODO: respect scope id */
 +		vxlan->saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);
 +		vxlan->saddr.sa.sa_family = AF_INET6;
  		use_ipv6 = true;
 -		vxlan->flags |= VXLAN_F_IPV6;
  	}
  
 +	if (data[IFLA_VXLAN_LINK] &&
 +	    (dst->remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]))) {
 +		struct net_device *lowerdev
 +			 = __dev_get_by_index(src_net, dst->remote_ifindex);
++=======
+ 	if (conf->label && !use_ipv6) {
+ 		pr_info("label only supported in use with IPv6\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (conf->remote_ifindex) {
+ 		lowerdev = __dev_get_by_index(src_net, conf->remote_ifindex);
+ 		dst->remote_ifindex = conf->remote_ifindex;
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  
  		if (!lowerdev) {
  			pr_info("ifindex %d does not exist\n", dst->remote_ifindex);
@@@ -2758,6 -2831,155 +2940,158 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct net_device *vxlan_dev_create(struct net *net, const char *name,
+ 				    u8 name_assign_type, struct vxlan_config *conf)
+ {
+ 	struct nlattr *tb[IFLA_MAX+1];
+ 	struct net_device *dev;
+ 	int err;
+ 
+ 	memset(&tb, 0, sizeof(tb));
+ 
+ 	dev = rtnl_create_link(net, name, name_assign_type,
+ 			       &vxlan_link_ops, tb);
+ 	if (IS_ERR(dev))
+ 		return dev;
+ 
+ 	err = vxlan_dev_configure(net, dev, conf);
+ 	if (err < 0) {
+ 		free_netdev(dev);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return dev;
+ }
+ EXPORT_SYMBOL_GPL(vxlan_dev_create);
+ 
+ static int vxlan_newlink(struct net *src_net, struct net_device *dev,
+ 			 struct nlattr *tb[], struct nlattr *data[])
+ {
+ 	struct vxlan_config conf;
+ 	int err;
+ 
+ 	memset(&conf, 0, sizeof(conf));
+ 
+ 	if (data[IFLA_VXLAN_ID])
+ 		conf.vni = cpu_to_be32(nla_get_u32(data[IFLA_VXLAN_ID]));
+ 
+ 	if (data[IFLA_VXLAN_GROUP]) {
+ 		conf.remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);
+ 	} else if (data[IFLA_VXLAN_GROUP6]) {
+ 		if (!IS_ENABLED(CONFIG_IPV6))
+ 			return -EPFNOSUPPORT;
+ 
+ 		conf.remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);
+ 		conf.remote_ip.sa.sa_family = AF_INET6;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_LOCAL]) {
+ 		conf.saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);
+ 		conf.saddr.sa.sa_family = AF_INET;
+ 	} else if (data[IFLA_VXLAN_LOCAL6]) {
+ 		if (!IS_ENABLED(CONFIG_IPV6))
+ 			return -EPFNOSUPPORT;
+ 
+ 		/* TODO: respect scope id */
+ 		conf.saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);
+ 		conf.saddr.sa.sa_family = AF_INET6;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_LINK])
+ 		conf.remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]);
+ 
+ 	if (data[IFLA_VXLAN_TOS])
+ 		conf.tos  = nla_get_u8(data[IFLA_VXLAN_TOS]);
+ 
+ 	if (data[IFLA_VXLAN_TTL])
+ 		conf.ttl = nla_get_u8(data[IFLA_VXLAN_TTL]);
+ 
+ 	if (data[IFLA_VXLAN_LABEL])
+ 		conf.label = nla_get_be32(data[IFLA_VXLAN_LABEL]) &
+ 			     IPV6_FLOWLABEL_MASK;
+ 
+ 	if (!data[IFLA_VXLAN_LEARNING] || nla_get_u8(data[IFLA_VXLAN_LEARNING]))
+ 		conf.flags |= VXLAN_F_LEARN;
+ 
+ 	if (data[IFLA_VXLAN_AGEING])
+ 		conf.age_interval = nla_get_u32(data[IFLA_VXLAN_AGEING]);
+ 
+ 	if (data[IFLA_VXLAN_PROXY] && nla_get_u8(data[IFLA_VXLAN_PROXY]))
+ 		conf.flags |= VXLAN_F_PROXY;
+ 
+ 	if (data[IFLA_VXLAN_RSC] && nla_get_u8(data[IFLA_VXLAN_RSC]))
+ 		conf.flags |= VXLAN_F_RSC;
+ 
+ 	if (data[IFLA_VXLAN_L2MISS] && nla_get_u8(data[IFLA_VXLAN_L2MISS]))
+ 		conf.flags |= VXLAN_F_L2MISS;
+ 
+ 	if (data[IFLA_VXLAN_L3MISS] && nla_get_u8(data[IFLA_VXLAN_L3MISS]))
+ 		conf.flags |= VXLAN_F_L3MISS;
+ 
+ 	if (data[IFLA_VXLAN_LIMIT])
+ 		conf.addrmax = nla_get_u32(data[IFLA_VXLAN_LIMIT]);
+ 
+ 	if (data[IFLA_VXLAN_COLLECT_METADATA] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_COLLECT_METADATA]))
+ 		conf.flags |= VXLAN_F_COLLECT_METADATA;
+ 
+ 	if (data[IFLA_VXLAN_PORT_RANGE]) {
+ 		const struct ifla_vxlan_port_range *p
+ 			= nla_data(data[IFLA_VXLAN_PORT_RANGE]);
+ 		conf.port_min = ntohs(p->low);
+ 		conf.port_max = ntohs(p->high);
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_PORT])
+ 		conf.dst_port = nla_get_be16(data[IFLA_VXLAN_PORT]);
+ 
+ 	if (data[IFLA_VXLAN_UDP_CSUM] &&
+ 	    !nla_get_u8(data[IFLA_VXLAN_UDP_CSUM]))
+ 		conf.flags |= VXLAN_F_UDP_ZERO_CSUM_TX;
+ 
+ 	if (data[IFLA_VXLAN_UDP_ZERO_CSUM6_TX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_UDP_ZERO_CSUM6_TX]))
+ 		conf.flags |= VXLAN_F_UDP_ZERO_CSUM6_TX;
+ 
+ 	if (data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX]))
+ 		conf.flags |= VXLAN_F_UDP_ZERO_CSUM6_RX;
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_TX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_REMCSUM_TX]))
+ 		conf.flags |= VXLAN_F_REMCSUM_TX;
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_RX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_REMCSUM_RX]))
+ 		conf.flags |= VXLAN_F_REMCSUM_RX;
+ 
+ 	if (data[IFLA_VXLAN_GBP])
+ 		conf.flags |= VXLAN_F_GBP;
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_NOPARTIAL])
+ 		conf.flags |= VXLAN_F_REMCSUM_NOPARTIAL;
+ 
+ 	err = vxlan_dev_configure(src_net, dev, &conf);
+ 	switch (err) {
+ 	case -ENODEV:
+ 		pr_info("ifindex %d does not exist\n", conf.remote_ifindex);
+ 		break;
+ 
+ 	case -EPERM:
+ 		pr_info("IPv6 is disabled via sysctl\n");
+ 		break;
+ 
+ 	case -EEXIST:
+ 		pr_info("duplicate VNI %u\n", be32_to_cpu(conf.vni));
+ 		break;
+ 	}
+ 
+ 	return err;
+ }
+ 
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  static void vxlan_dellink(struct net_device *dev, struct list_head *head)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
@@@ -2841,8 -3066,9 +3176,14 @@@ static int vxlan_fill_info(struct sk_bu
  		}
  	}
  
++<<<<<<< HEAD
 +	if (nla_put_u8(skb, IFLA_VXLAN_TTL, vxlan->ttl) ||
 +	    nla_put_u8(skb, IFLA_VXLAN_TOS, vxlan->tos) ||
++=======
+ 	if (nla_put_u8(skb, IFLA_VXLAN_TTL, vxlan->cfg.ttl) ||
+ 	    nla_put_u8(skb, IFLA_VXLAN_TOS, vxlan->cfg.tos) ||
+ 	    nla_put_be32(skb, IFLA_VXLAN_LABEL, vxlan->cfg.label) ||
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  	    nla_put_u8(skb, IFLA_VXLAN_LEARNING,
  			!!(vxlan->flags & VXLAN_F_LEARN)) ||
  	    nla_put_u8(skb, IFLA_VXLAN_PROXY,
diff --cc include/net/vxlan.h
index b3828bd87f8a,a763c96ecde4..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -114,6 -135,63 +114,66 @@@ struct vxlan_sock 
  	u32		  flags;
  };
  
++<<<<<<< HEAD
++=======
+ union vxlan_addr {
+ 	struct sockaddr_in sin;
+ 	struct sockaddr_in6 sin6;
+ 	struct sockaddr sa;
+ };
+ 
+ struct vxlan_rdst {
+ 	union vxlan_addr	 remote_ip;
+ 	__be16			 remote_port;
+ 	__be32			 remote_vni;
+ 	u32			 remote_ifindex;
+ 	struct list_head	 list;
+ 	struct rcu_head		 rcu;
+ 	struct dst_cache	 dst_cache;
+ };
+ 
+ struct vxlan_config {
+ 	union vxlan_addr	remote_ip;
+ 	union vxlan_addr	saddr;
+ 	__be32			vni;
+ 	int			remote_ifindex;
+ 	int			mtu;
+ 	__be16			dst_port;
+ 	u16			port_min;
+ 	u16			port_max;
+ 	u8			tos;
+ 	u8			ttl;
+ 	__be32			label;
+ 	u32			flags;
+ 	unsigned long		age_interval;
+ 	unsigned int		addrmax;
+ 	bool			no_share;
+ };
+ 
+ /* Pseudo network device */
+ struct vxlan_dev {
+ 	struct hlist_node hlist;	/* vni hash table */
+ 	struct list_head  next;		/* vxlan's per namespace list */
+ 	struct vxlan_sock *vn4_sock;	/* listening socket for IPv4 */
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct vxlan_sock *vn6_sock;	/* listening socket for IPv6 */
+ #endif
+ 	struct net_device *dev;
+ 	struct net	  *net;		/* netns for packet i/o */
+ 	struct vxlan_rdst default_dst;	/* default destination */
+ 	u32		  flags;	/* VXLAN_F_* in vxlan.h */
+ 
+ 	struct timer_list age_timer;
+ 	spinlock_t	  hash_lock;
+ 	unsigned int	  addrcnt;
+ 	struct gro_cells  gro_cells;
+ 
+ 	struct vxlan_config	cfg;
+ 
+ 	struct hlist_head fdb_head[FDB_HASH_SIZE];
+ };
+ 
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  #define VXLAN_F_LEARN			0x01
  #define VXLAN_F_PROXY			0x02
  #define VXLAN_F_RSC			0x04
diff --cc include/uapi/linux/if_link.h
index 719f99b573ac,6bebc975031d..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -337,6 -455,8 +337,11 @@@ enum 
  	IFLA_VXLAN_REMCSUM_RX,
  	IFLA_VXLAN_GBP,
  	IFLA_VXLAN_REMCSUM_NOPARTIAL,
++<<<<<<< HEAD
++=======
+ 	IFLA_VXLAN_COLLECT_METADATA,
+ 	IFLA_VXLAN_LABEL,
++>>>>>>> e7f70af111f0 (vxlan: support setting IPv6 flow label)
  	__IFLA_VXLAN_MAX
  };
  #define IFLA_VXLAN_MAX	(__IFLA_VXLAN_MAX - 1)
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/vxlan.h
* Unmerged path include/uapi/linux/if_link.h
