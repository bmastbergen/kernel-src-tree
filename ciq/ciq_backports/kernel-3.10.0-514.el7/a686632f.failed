ALSA: hda - Split out Intel-specific codes from patch_generic_hdmi()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit a686632fd9a857776798f3479e2b58b07d938076
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a686632f.failed

We have too many Intel-specific codes in patch_hdmi_generic() despite
its function name.  And this makes it difficult to adjust per chipset,
e.g. for allowing the audio notifier on an old chipset, one would need
to add an explicit if() check.

This patch attempts some code refactoring and cleanups in this regard;
the Intel-specific codes are moved out of patch_generic_hdmi() into
the new functions, patch_i915_hsw_hdmi() and patch_i915_byt_hdmi(),
depending on the chipset.  The other old Intel chipsets keep using
patch_generic_hdmi() without Intel hacks.  The existing
patch_generic_hdmi() is also split to a few components so that they
can be called from the Intel codec parsers.

There are still many is_haswell*() and is_valleyview*() macro usages
in the code.  They will be cleaned up later.  For the time being, only
the entry are concerned.

Along with this change, the i915_bound flag and the on-demand i915
component binding have been removed as a cleanup, since there is no
user at this moment.  This will be added back later once when Cougar
Point and else start using the i915 eld notifier.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a686632fd9a857776798f3479e2b58b07d938076)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_hdmi.c
diff --cc sound/pci/hda/patch_hdmi.c
index 07dadb7c58be,48c63fea7018..000000000000
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@@ -2235,92 -2290,96 +2291,129 @@@ static void intel_pin_eld_notify(void *
  	check_presence_and_report(codec, pin_nid);
  }
  
- static int patch_generic_hdmi(struct hda_codec *codec)
+ /* register i915 component pin_eld_notify callback */
+ static void register_i915_notifier(struct hda_codec *codec)
+ {
+ 	struct hdmi_spec *spec = codec->spec;
+ 
+ 	spec->use_acomp_notifier = true;
+ 	spec->i915_audio_ops.audio_ptr = codec;
+ 	/* intel_audio_codec_enable() or intel_audio_codec_disable()
+ 	 * will call pin_eld_notify with using audio_ptr pointer
+ 	 * We need make sure audio_ptr is really setup
+ 	 */
+ 	wmb();
+ 	spec->i915_audio_ops.pin_eld_notify = intel_pin_eld_notify;
+ 	snd_hdac_i915_register_notifier(&spec->i915_audio_ops);
+ }
+ 
+ /* Intel Haswell and onwards; audio component with eld notifier */
+ static int patch_i915_hsw_hdmi(struct hda_codec *codec)
  {
  	struct hdmi_spec *spec;
+ 	int err;
  
- 	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
- 	if (spec == NULL)
- 		return -ENOMEM;
+ 	/* HSW+ requires i915 binding */
+ 	if (!codec->bus->core.audio_component) {
+ 		codec_info(codec, "No i915 binding for Intel HDMI/DP codec\n");
+ 		return -ENODEV;
+ 	}
  
- 	spec->ops = generic_standard_hdmi_ops;
- 	mutex_init(&spec->pcm_lock);
- 	snd_hdac_register_chmap_ops(&codec->core, &spec->chmap);
+ 	err = alloc_generic_hdmi(codec);
+ 	if (err < 0)
+ 		return err;
+ 	spec = codec->spec;
  
- 	spec->chmap.ops.get_chmap = hdmi_get_chmap;
- 	spec->chmap.ops.set_chmap = hdmi_set_chmap;
- 	spec->chmap.ops.is_pcm_attached = is_hdmi_pcm_attached;
+ 	intel_haswell_enable_all_pins(codec, true);
+ 	intel_haswell_fixup_enable_dp12(codec);
  
- 	codec->spec = spec;
- 	hdmi_array_init(spec, 4);
+ 	/* For Haswell/Broadwell, the controller is also in the power well and
+ 	 * can cover the codec power request, and so need not set this flag.
+ 	 */
+ 	if (!is_haswell(codec) && !is_broadwell(codec))
+ 		codec->core.link_power_control = 1;
  
- #ifdef CONFIG_SND_HDA_I915
- 	/* Try to bind with i915 for Intel HSW+ codecs (if not done yet) */
- 	if ((codec->core.vendor_id >> 16) == 0x8086 &&
- 	    is_haswell_plus(codec)) {
- #if 0
- 		/* on-demand binding leads to an unbalanced refcount when
- 		 * both i915 and hda drivers are probed concurrently;
- 		 * disabled temporarily for now
- 		 */
- 		if (!codec->bus->core.audio_component)
- 			if (!snd_hdac_i915_init(&codec->bus->core))
- 				spec->i915_bound = true;
- #endif
- 		/* use i915 audio component notifier for hotplug */
- 		if (codec->bus->core.audio_component)
- 			spec->use_acomp_notifier = true;
+ 	codec->patch_ops.set_power_state = haswell_set_power_state;
+ 	codec->dp_mst = true;
+ 	codec->depop_delay = 0;
+ 	codec->auto_runtime_pm = 1;
+ 
+ 	err = hdmi_parse_codec(codec);
+ 	if (err < 0) {
+ 		generic_spec_free(codec);
+ 		return err;
  	}
- #endif
  
- 	if (is_haswell_plus(codec)) {
- 		intel_haswell_enable_all_pins(codec, true);
- 		intel_haswell_fixup_enable_dp12(codec);
+ 	generic_hdmi_init_per_pins(codec);
+ 	register_i915_notifier(codec);
+ 	return 0;
+ }
+ 
+ /* Intel Baytrail and Braswell; without get_eld notifier */
+ static int patch_i915_byt_hdmi(struct hda_codec *codec)
+ {
+ 	struct hdmi_spec *spec;
+ 	int err;
+ 
+ 	/* requires i915 binding */
+ 	if (!codec->bus->core.audio_component) {
+ 		codec_info(codec, "No i915 binding for Intel HDMI/DP codec\n");
+ 		return -ENODEV;
  	}
  
+ 	err = alloc_generic_hdmi(codec);
+ 	if (err < 0)
+ 		return err;
+ 	spec = codec->spec;
+ 
  	/* For Valleyview/Cherryview, only the display codec is in the display
  	 * power well and can use link_power ops to request/release the power.
- 	 * For Haswell/Broadwell, the controller is also in the power well and
- 	 * can cover the codec power request, and so need not set this flag.
- 	 * For previous platforms, there is no such power well feature.
  	 */
- 	if (is_valleyview_plus(codec) || is_skylake(codec) ||
- 			is_broxton(codec))
- 		codec->core.link_power_control = 1;
+ 	codec->core.link_power_control = 1;
  
++<<<<<<< HEAD
 +	if (codec_has_acomp(codec)) {
 +		codec->depop_delay = 0;
 +		spec->i915_audio_ops.audio_ptr = codec;
 +		/* intel_audio_codec_enable() or intel_audio_codec_disable()
 +		 * will call pin_eld_notify with using audio_ptr pointer
 +		 * We need make sure audio_ptr is really setup
 +		 */
 +		wmb();
 +		spec->i915_audio_ops.pin_eld_notify = intel_pin_eld_notify;
 +		snd_hdac_i915_register_notifier(&spec->i915_audio_ops);
 +	}
 +
 +	if (hdmi_parse_codec(codec) < 0) {
 +		if (spec->i915_bound)
 +			snd_hdac_i915_exit(&codec->bus->core);
 +		codec->spec = NULL;
 +		kfree(spec);
 +		return -EINVAL;
 +	}
 +	codec->patch_ops = generic_hdmi_patch_ops;
 +	if (is_haswell_plus(codec)) {
 +		codec->patch_ops.set_power_state = haswell_set_power_state;
 +		codec->dp_mst = true;
 +	}
++=======
+ 	codec->depop_delay = 0;
+ 	codec->auto_runtime_pm = 1;
++>>>>>>> a686632fd9a8 (ALSA: hda - Split out Intel-specific codes from patch_generic_hdmi())
  
- 	/* Enable runtime pm for HDMI audio codec of HSW/BDW/SKL/BYT/BSW */
- 	if (is_haswell_plus(codec) || is_valleyview_plus(codec))
- 		codec->auto_runtime_pm = 1;
+ 	err = hdmi_parse_codec(codec);
+ 	if (err < 0) {
+ 		generic_spec_free(codec);
+ 		return err;
+ 	}
  
  	generic_hdmi_init_per_pins(codec);
++<<<<<<< HEAD
 +
 +
 +	WARN_ON(spec->dyn_pcm_assign && !codec_has_acomp(codec));
++=======
++>>>>>>> a686632fd9a8 (ALSA: hda - Split out Intel-specific codes from patch_generic_hdmi())
  	return 0;
  }
  
* Unmerged path sound/pci/hda/patch_hdmi.c
