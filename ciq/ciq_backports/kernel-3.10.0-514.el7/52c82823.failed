qla2xxx: Remove set-but-not-used variables

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 52c82823cc686d4faf9e9bc4feec4bf48c36fded
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/52c82823.failed

Detected these variables by building with W=1.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Acked-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 52c82823cc686d4faf9e9bc4feec4bf48c36fded)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index c32faba9b0e7,e95162e1fcb7..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -325,10 -325,8 +325,9 @@@ qla2x00_start_scsi(srb_t *sp
  	struct qla_hw_data *ha;
  	struct req_que *req;
  	struct rsp_que *rsp;
 +	char		tag[2];
  
  	/* Setup device pointers. */
- 	ret = 0;
  	vha = sp->fcport->vha;
  	ha = vha->hw;
  	reg = &ha->iobase->isp;
@@@ -953,16 -929,27 +950,40 @@@ qla24xx_walk_and_build_sglist_no_difb(s
  	struct qla2_sgx sgx;
  	dma_addr_t	sle_dma;
  	uint32_t	sle_dma_len, tot_prot_dma_len = 0;
++<<<<<<< HEAD
 +	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
 +
 +	prot_int = cmd->device->sector_size;
 +
 +	memset(&sgx, 0, sizeof(struct qla2_sgx));
 +	sgx.tot_bytes = scsi_bufflen(cmd);
 +	sgx.cur_sg = scsi_sglist(cmd);
 +	sgx.sp = sp;
 +
 +	sg_prot = scsi_prot_sglist(cmd);
++=======
+ 	struct scsi_cmnd *cmd;
+ 
+ 	memset(&sgx, 0, sizeof(struct qla2_sgx));
+ 	if (sp) {
+ 		cmd = GET_CMD_SP(sp);
+ 		prot_int = cmd->device->sector_size;
+ 
+ 		sgx.tot_bytes = scsi_bufflen(cmd);
+ 		sgx.cur_sg = scsi_sglist(cmd);
+ 		sgx.sp = sp;
+ 
+ 		sg_prot = scsi_prot_sglist(cmd);
+ 	} else if (tc) {
+ 		prot_int      = tc->blk_sz;
+ 		sgx.tot_bytes = tc->bufflen;
+ 		sgx.cur_sg    = tc->sg;
+ 		sg_prot	      = tc->prot_sg;
+ 	} else {
+ 		BUG();
+ 		return 1;
+ 	}
++>>>>>>> 52c82823cc68 (qla2xxx: Remove set-but-not-used variables)
  
  	while (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {
  
@@@ -1045,9 -1040,20 +1066,26 @@@ qla24xx_walk_and_build_sglist(struct ql
  	uint32_t *cur_dsd = dsd;
  	int	i;
  	uint16_t	used_dsds = tot_dsds;
++<<<<<<< HEAD
 +	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
 +
 +	scsi_for_each_sg(cmd, sg, tot_dsds, i) {
++=======
+ 	struct scsi_cmnd *cmd;
+ 
+ 	if (sp) {
+ 		cmd = GET_CMD_SP(sp);
+ 		sgl = scsi_sglist(cmd);
+ 	} else if (tc) {
+ 		sgl = tc->sg;
+ 	} else {
+ 		BUG();
+ 		return 1;
+ 	}
+ 
+ 
+ 	for_each_sg(sgl, sg, tot_dsds, i) {
++>>>>>>> 52c82823cc68 (qla2xxx: Remove set-but-not-used variables)
  		dma_addr_t	sle_dma;
  
  		/* Allocate additional continuation packets? */
@@@ -1432,11 -1445,8 +1468,9 @@@ qla24xx_start_scsi(srb_t *sp
  	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
  	struct scsi_qla_host *vha = sp->fcport->vha;
  	struct qla_hw_data *ha = vha->hw;
 +	char		tag[2];
  
  	/* Setup device pointers. */
- 	ret = 0;
- 
  	qla25xx_set_que(sp, &rsp);
  	req = vha->req;
  
@@@ -2236,10 -2238,8 +2266,9 @@@ qla82xx_start_scsi(srb_t *sp
  	struct qla_hw_data *ha = vha->hw;
  	struct req_que *req = NULL;
  	struct rsp_que *rsp = NULL;
 +	char tag[2];
  
  	/* Setup device pointers. */
- 	ret = 0;
  	reg = &ha->iobase->isp82;
  	cmd = GET_CMD_SP(sp);
  	req = vha->req;
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 5d8f41f17d57,5a5166bd4287..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -3038,31 -2969,13 +3038,35 @@@ qla2x00_shutdown(struct pci_dev *pdev
  	pci_disable_device(pdev);
  }
  
 -/* Deletes all the virtual ports for a given ha */
  static void
 -qla2x00_delete_all_vps(struct qla_hw_data *ha, scsi_qla_host_t *base_vha)
 +qla2x00_remove_one(struct pci_dev *pdev)
  {
++<<<<<<< HEAD
 +	scsi_qla_host_t *base_vha, *vha;
 +	struct qla_hw_data  *ha;
++=======
+ 	scsi_qla_host_t *vha;
++>>>>>>> 52c82823cc68 (qla2xxx: Remove set-but-not-used variables)
  	unsigned long flags;
  
 +	/*
 +	 * If the PCI device is disabled that means that probe failed and any
 +	 * resources should be have cleaned up on probe exit.
 +	 */
 +	if (!atomic_read(&pdev->enable_cnt))
 +		return;
 +
 +	base_vha = pci_get_drvdata(pdev);
 +	ha = base_vha->hw;
 +
 +	qla2x00_wait_for_hba_ready(base_vha);
 +
 +	ha->flags.host_shutting_down = 1;
 +
 +	set_bit(UNLOADING, &base_vha->dpc_flags);
 +	if (IS_QLAFX00(ha))
 +		qlafx00_driver_shutdown(base_vha, 20);
 +
  	mutex_lock(&ha->vport_lock);
  	while (ha->cur_vport_count) {
  		spin_lock_irqsave(&ha->vport_slock, flags);
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 1eef784434de,b635c05f829f..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -2007,6 -1964,326 +2007,329 @@@ skip_explict_conf
  	/* Sense with len > 24, is it possible ??? */
  }
  
++<<<<<<< HEAD
++=======
+ 
+ 
+ /* diff  */
+ static inline int
+ qlt_hba_err_chk_enabled(struct se_cmd *se_cmd)
+ {
+ 	/*
+ 	 * Uncomment when corresponding SCSI changes are done.
+ 	 *
+ 	 if (!sp->cmd->prot_chk)
+ 	 return 0;
+ 	 *
+ 	 */
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 		if (ql2xenablehba_err_chk >= 1)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DOUT_PASS:
+ 	case TARGET_PROT_DIN_PASS:
+ 		if (ql2xenablehba_err_chk >= 2)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		return 1;
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * qla24xx_set_t10dif_tags_from_cmd - Extract Ref and App tags from SCSI command
+  *
+  */
+ static inline void
+ qlt_set_t10dif_tags(struct se_cmd *se_cmd, struct crc_context *ctx)
+ {
+ 	uint32_t lba = 0xffffffff & se_cmd->t_task_lba;
+ 
+ 	/* wait til Mode Sense/Select cmd, modepage Ah, subpage 2
+ 	 * have been immplemented by TCM, before AppTag is avail.
+ 	 * Look for modesense_handlers[]
+ 	 */
+ 	ctx->app_tag = 0;
+ 	ctx->app_tag_mask[0] = 0x0;
+ 	ctx->app_tag_mask[1] = 0x0;
+ 
+ 	switch (se_cmd->prot_type) {
+ 	case TARGET_DIF_TYPE0_PROT:
+ 		/*
+ 		 * No check for ql2xenablehba_err_chk, as it would be an
+ 		 * I/O error if hba tag generation is not done.
+ 		 */
+ 		ctx->ref_tag = cpu_to_le32(lba);
+ 
+ 		if (!qlt_hba_err_chk_enabled(se_cmd))
+ 			break;
+ 
+ 		/* enable ALL bytes of the ref tag */
+ 		ctx->ref_tag_mask[0] = 0xff;
+ 		ctx->ref_tag_mask[1] = 0xff;
+ 		ctx->ref_tag_mask[2] = 0xff;
+ 		ctx->ref_tag_mask[3] = 0xff;
+ 		break;
+ 	/*
+ 	 * For TYpe 1 protection: 16 bit GUARD tag, 32 bit REF tag, and
+ 	 * 16 bit app tag.
+ 	 */
+ 	case TARGET_DIF_TYPE1_PROT:
+ 		ctx->ref_tag = cpu_to_le32(lba);
+ 
+ 		if (!qlt_hba_err_chk_enabled(se_cmd))
+ 			break;
+ 
+ 		/* enable ALL bytes of the ref tag */
+ 		ctx->ref_tag_mask[0] = 0xff;
+ 		ctx->ref_tag_mask[1] = 0xff;
+ 		ctx->ref_tag_mask[2] = 0xff;
+ 		ctx->ref_tag_mask[3] = 0xff;
+ 		break;
+ 	/*
+ 	 * For TYPE 2 protection: 16 bit GUARD + 32 bit REF tag has to
+ 	 * match LBA in CDB + N
+ 	 */
+ 	case TARGET_DIF_TYPE2_PROT:
+ 		ctx->ref_tag = cpu_to_le32(lba);
+ 
+ 		if (!qlt_hba_err_chk_enabled(se_cmd))
+ 			break;
+ 
+ 		/* enable ALL bytes of the ref tag */
+ 		ctx->ref_tag_mask[0] = 0xff;
+ 		ctx->ref_tag_mask[1] = 0xff;
+ 		ctx->ref_tag_mask[2] = 0xff;
+ 		ctx->ref_tag_mask[3] = 0xff;
+ 		break;
+ 
+ 	/* For Type 3 protection: 16 bit GUARD only */
+ 	case TARGET_DIF_TYPE3_PROT:
+ 		ctx->ref_tag_mask[0] = ctx->ref_tag_mask[1] =
+ 			ctx->ref_tag_mask[2] = ctx->ref_tag_mask[3] = 0x00;
+ 		break;
+ 	}
+ }
+ 
+ 
+ static inline int
+ qlt_build_ctio_crc2_pkt(struct qla_tgt_prm *prm, scsi_qla_host_t *vha)
+ {
+ 	uint32_t		*cur_dsd;
+ 	uint32_t		transfer_length = 0;
+ 	uint32_t		data_bytes;
+ 	uint32_t		dif_bytes;
+ 	uint8_t			bundling = 1;
+ 	uint8_t			*clr_ptr;
+ 	struct crc_context	*crc_ctx_pkt = NULL;
+ 	struct qla_hw_data	*ha;
+ 	struct ctio_crc2_to_fw	*pkt;
+ 	dma_addr_t		crc_ctx_dma;
+ 	uint16_t		fw_prot_opts = 0;
+ 	struct qla_tgt_cmd	*cmd = prm->cmd;
+ 	struct se_cmd		*se_cmd = &cmd->se_cmd;
+ 	uint32_t h;
+ 	struct atio_from_isp *atio = &prm->cmd->atio;
+ 	uint16_t t16;
+ 
+ 	ha = vha->hw;
+ 
+ 	pkt = (struct ctio_crc2_to_fw *)vha->req->ring_ptr;
+ 	prm->pkt = pkt;
+ 	memset(pkt, 0, sizeof(*pkt));
+ 
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe071,
+ 		"qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\n",
+ 		vha->vp_idx, __func__, se_cmd, se_cmd->prot_op,
+ 		prm->prot_sg, prm->prot_seg_cnt, se_cmd->t_task_lba);
+ 
+ 	if ((se_cmd->prot_op == TARGET_PROT_DIN_INSERT) ||
+ 	    (se_cmd->prot_op == TARGET_PROT_DOUT_STRIP))
+ 		bundling = 0;
+ 
+ 	/* Compute dif len and adjust data len to incude protection */
+ 	data_bytes = cmd->bufflen;
+ 	dif_bytes  = (data_bytes / cmd->blk_sz) * 8;
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		transfer_length = data_bytes;
+ 		data_bytes += dif_bytes;
+ 		break;
+ 
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		transfer_length = data_bytes + dif_bytes;
+ 		break;
+ 
+ 	default:
+ 		BUG();
+ 		break;
+ 	}
+ 
+ 	if (!qlt_hba_err_chk_enabled(se_cmd))
+ 		fw_prot_opts |= 0x10; /* Disable Guard tag checking */
+ 	/* HBA error checking enabled */
+ 	else if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			fw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			fw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 		fw_prot_opts |= PO_MODE_DIF_INSERT;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		fw_prot_opts |= PO_MODE_DIF_REMOVE;
+ 		break;
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		/* FUTURE: does tcm require T10CRC<->IPCKSUM conversion? */
+ 		break;
+ 	default:/* Normal Request */
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		break;
+ 	}
+ 
+ 
+ 	/* ---- PKT ---- */
+ 	/* Update entry type to indicate Command Type CRC_2 IOCB */
+ 	pkt->entry_type  = CTIO_CRC2;
+ 	pkt->entry_count = 1;
+ 	pkt->vp_index = vha->vp_idx;
+ 
+ 	h = qlt_make_handle(vha);
+ 	if (unlikely(h == QLA_TGT_NULL_HANDLE)) {
+ 		/*
+ 		 * CTIO type 7 from the firmware doesn't provide a way to
+ 		 * know the initiator's LOOP ID, hence we can't find
+ 		 * the session and, so, the command.
+ 		 */
+ 		return -EAGAIN;
+ 	} else
+ 		ha->tgt.cmds[h-1] = prm->cmd;
+ 
+ 
+ 	pkt->handle  = h | CTIO_COMPLETION_HANDLE_MARK;
+ 	pkt->nport_handle = prm->cmd->loop_id;
+ 	pkt->timeout = __constant_cpu_to_le16(QLA_TGT_TIMEOUT);
+ 	pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
+ 	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
+ 	pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
+ 	pkt->exchange_addr   = atio->u.isp24.exchange_addr;
+ 
+ 	/* silence compile warning */
+ 	t16 = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	pkt->ox_id  = cpu_to_le16(t16);
+ 
+ 	t16 = (atio->u.isp24.attr << 9);
+ 	pkt->flags |= cpu_to_le16(t16);
+ 	pkt->relative_offset = cpu_to_le32(prm->cmd->offset);
+ 
+ 	/* Set transfer direction */
+ 	if (cmd->dma_data_direction == DMA_TO_DEVICE)
+ 		pkt->flags = __constant_cpu_to_le16(CTIO7_FLAGS_DATA_IN);
+ 	else if (cmd->dma_data_direction == DMA_FROM_DEVICE)
+ 		pkt->flags = __constant_cpu_to_le16(CTIO7_FLAGS_DATA_OUT);
+ 
+ 
+ 	pkt->dseg_count = prm->tot_dsds;
+ 	/* Fibre channel byte count */
+ 	pkt->transfer_length = cpu_to_le32(transfer_length);
+ 
+ 
+ 	/* ----- CRC context -------- */
+ 
+ 	/* Allocate CRC context from global pool */
+ 	crc_ctx_pkt = cmd->ctx =
+ 	    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);
+ 
+ 	if (!crc_ctx_pkt)
+ 		goto crc_queuing_error;
+ 
+ 	/* Zero out CTX area. */
+ 	clr_ptr = (uint8_t *)crc_ctx_pkt;
+ 	memset(clr_ptr, 0, sizeof(*crc_ctx_pkt));
+ 
+ 	crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
+ 	INIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);
+ 
+ 	/* Set handle */
+ 	crc_ctx_pkt->handle = pkt->handle;
+ 
+ 	qlt_set_t10dif_tags(se_cmd, crc_ctx_pkt);
+ 
+ 	pkt->crc_context_address[0] = cpu_to_le32(LSD(crc_ctx_dma));
+ 	pkt->crc_context_address[1] = cpu_to_le32(MSD(crc_ctx_dma));
+ 	pkt->crc_context_len = CRC_CONTEXT_LEN_FW;
+ 
+ 
+ 	if (!bundling) {
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.nobundling.data_address;
+ 	} else {
+ 		/*
+ 		 * Configure Bundling if we need to fetch interlaving
+ 		 * protection PCI accesses
+ 		 */
+ 		fw_prot_opts |= PO_ENABLE_DIF_BUNDLING;
+ 		crc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);
+ 		crc_ctx_pkt->u.bundling.dseg_count =
+ 			cpu_to_le16(prm->tot_dsds - prm->prot_seg_cnt);
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.data_address;
+ 	}
+ 
+ 	/* Finish the common fields of CRC pkt */
+ 	crc_ctx_pkt->blk_size   = cpu_to_le16(cmd->blk_sz);
+ 	crc_ctx_pkt->prot_opts  = cpu_to_le16(fw_prot_opts);
+ 	crc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);
+ 	crc_ctx_pkt->guard_seed = __constant_cpu_to_le16(0);
+ 
+ 
+ 	/* Walks data segments */
+ 	pkt->flags |= __constant_cpu_to_le16(CTIO7_FLAGS_DSD_PTR);
+ 
+ 	if (!bundling && prm->prot_seg_cnt) {
+ 		if (qla24xx_walk_and_build_sglist_no_difb(ha, NULL, cur_dsd,
+ 			prm->tot_dsds, cmd))
+ 			goto crc_queuing_error;
+ 	} else if (qla24xx_walk_and_build_sglist(ha, NULL, cur_dsd,
+ 		(prm->tot_dsds - prm->prot_seg_cnt), cmd))
+ 		goto crc_queuing_error;
+ 
+ 	if (bundling && prm->prot_seg_cnt) {
+ 		/* Walks dif segments */
+ 		pkt->add_flags |= CTIO_CRC2_AF_DIF_DSD_ENA;
+ 
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.dif_address;
+ 		if (qla24xx_walk_and_build_prot_sglist(ha, NULL, cur_dsd,
+ 			prm->prot_seg_cnt, cmd))
+ 			goto crc_queuing_error;
+ 	}
+ 	return QLA_SUCCESS;
+ 
+ crc_queuing_error:
+ 	/* Cleanup will be performed by the caller */
+ 
+ 	return QLA_FUNCTION_FAILED;
+ }
+ 
+ 
++>>>>>>> 52c82823cc68 (qla2xxx: Remove set-but-not-used variables)
  /*
   * Callback to setup response of xmit_type of QLA_TGT_XMIT_DATA and *
   * QLA_TGT_XMIT_STATUS for >= 24xx silicon
@@@ -2184,6 -2510,142 +2507,145 @@@ out_unlock_free_unmap
  }
  EXPORT_SYMBOL(qlt_rdy_to_xfer);
  
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Checks the guard or meta-data for the type of error
+  * detected by the HBA.
+  */
+ static inline int
+ qlt_handle_dif_error(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd,
+ 		struct ctio_crc_from_fw *sts)
+ {
+ 	uint8_t		*ap = &sts->actual_dif[0];
+ 	uint8_t		*ep = &sts->expected_dif[0];
+ 	uint32_t	e_ref_tag, a_ref_tag;
+ 	uint16_t	e_app_tag, a_app_tag;
+ 	uint16_t	e_guard, a_guard;
+ 	uint64_t	lba = cmd->se_cmd.t_task_lba;
+ 
+ 	a_guard   = be16_to_cpu(*(uint16_t *)(ap + 0));
+ 	a_app_tag = be16_to_cpu(*(uint16_t *)(ap + 2));
+ 	a_ref_tag = be32_to_cpu(*(uint32_t *)(ap + 4));
+ 
+ 	e_guard   = be16_to_cpu(*(uint16_t *)(ep + 0));
+ 	e_app_tag = be16_to_cpu(*(uint16_t *)(ep + 2));
+ 	e_ref_tag = be32_to_cpu(*(uint32_t *)(ep + 4));
+ 
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe075,
+ 	    "iocb(s) %p Returned STATUS.\n", sts);
+ 
+ 	ql_dbg(ql_dbg_tgt, vha, 0xf075,
+ 	    "dif check TGT cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x]\n",
+ 	    cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,
+ 	    a_ref_tag, e_ref_tag, a_app_tag, e_app_tag, a_guard, e_guard);
+ 
+ 	/*
+ 	 * Ignore sector if:
+ 	 * For type     3: ref & app tag is all 'f's
+ 	 * For type 0,1,2: app tag is all 'f's
+ 	 */
+ 	if ((a_app_tag == 0xffff) &&
+ 	    ((cmd->se_cmd.prot_type != TARGET_DIF_TYPE3_PROT) ||
+ 	     (a_ref_tag == 0xffffffff))) {
+ 		uint32_t blocks_done;
+ 
+ 		/* 2TB boundary case covered automatically with this */
+ 		blocks_done = e_ref_tag - (uint32_t)lba + 1;
+ 		cmd->se_cmd.bad_sector = e_ref_tag;
+ 		cmd->se_cmd.pi_err = 0;
+ 		ql_dbg(ql_dbg_tgt, vha, 0xf074,
+ 			"need to return scsi good\n");
+ 
+ 		/* Update protection tag */
+ 		if (cmd->prot_sg_cnt) {
+ 			uint32_t i, k = 0, num_ent;
+ 			struct scatterlist *sg, *sgl;
+ 
+ 
+ 			sgl = cmd->prot_sg;
+ 
+ 			/* Patch the corresponding protection tags */
+ 			for_each_sg(sgl, sg, cmd->prot_sg_cnt, i) {
+ 				num_ent = sg_dma_len(sg) / 8;
+ 				if (k + num_ent < blocks_done) {
+ 					k += num_ent;
+ 					continue;
+ 				}
+ 				k = blocks_done;
+ 				break;
+ 			}
+ 
+ 			if (k != blocks_done) {
+ 				ql_log(ql_log_warn, vha, 0xf076,
+ 				    "unexpected tag values tag:lba=%u:%llu)\n",
+ 				    e_ref_tag, (unsigned long long)lba);
+ 				goto out;
+ 			}
+ 
+ #if 0
+ 			struct sd_dif_tuple *spt;
+ 			/* TODO:
+ 			 * This section came from initiator. Is it valid here?
+ 			 * should ulp be override with actual val???
+ 			 */
+ 			spt = page_address(sg_page(sg)) + sg->offset;
+ 			spt += j;
+ 
+ 			spt->app_tag = 0xffff;
+ 			if (cmd->se_cmd.prot_type == SCSI_PROT_DIF_TYPE3)
+ 				spt->ref_tag = 0xffffffff;
+ #endif
+ 		}
+ 
+ 		return 0;
+ 	}
+ 
+ 	/* check guard */
+ 	if (e_guard != a_guard) {
+ 		cmd->se_cmd.pi_err = TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;
+ 		cmd->se_cmd.bad_sector = cmd->se_cmd.t_task_lba;
+ 
+ 		ql_log(ql_log_warn, vha, 0xe076,
+ 		    "Guard ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",
+ 		    cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,
+ 		    a_ref_tag, e_ref_tag, a_app_tag, e_app_tag,
+ 		    a_guard, e_guard, cmd);
+ 		goto out;
+ 	}
+ 
+ 	/* check ref tag */
+ 	if (e_ref_tag != a_ref_tag) {
+ 		cmd->se_cmd.pi_err = TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;
+ 		cmd->se_cmd.bad_sector = e_ref_tag;
+ 
+ 		ql_log(ql_log_warn, vha, 0xe077,
+ 			"Ref Tag ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",
+ 			cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,
+ 			a_ref_tag, e_ref_tag, a_app_tag, e_app_tag,
+ 			a_guard, e_guard, cmd);
+ 		goto out;
+ 	}
+ 
+ 	/* check appl tag */
+ 	if (e_app_tag != a_app_tag) {
+ 		cmd->se_cmd.pi_err = TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;
+ 		cmd->se_cmd.bad_sector = cmd->se_cmd.t_task_lba;
+ 
+ 		ql_log(ql_log_warn, vha, 0xe078,
+ 			"App Tag ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",
+ 			cmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,
+ 			a_ref_tag, e_ref_tag, a_app_tag, e_app_tag,
+ 			a_guard, e_guard, cmd);
+ 		goto out;
+ 	}
+ out:
+ 	return 1;
+ }
+ 
+ 
++>>>>>>> 52c82823cc68 (qla2xxx: Remove set-but-not-used variables)
  /* If hardware_lock held on entry, might drop it, then reaquire */
  /* This function sends the appropriate CTIO to ISP 2xxx or 24xx */
  static int __qlt_send_term_exchange(struct scsi_qla_host *vha,
@@@ -2448,13 -3060,8 +2910,16 @@@ static void qlt_do_ctio_completion(stru
  {
  	struct qla_hw_data *ha = vha->hw;
  	struct se_cmd *se_cmd;
++<<<<<<< HEAD
 +	struct target_core_fabric_ops *tfo;
++=======
++>>>>>>> 52c82823cc68 (qla2xxx: Remove set-but-not-used variables)
  	struct qla_tgt_cmd *cmd;
  
 +	ql_dbg(ql_dbg_tgt, vha, 0xe01e,
 +	    "qla_target(%d): handle(ctio %p status %#x) <- %08x\n",
 +	    vha->vp_idx, ctio, status, handle);
 +
  	if (handle & CTIO_INTERMEDIATE_HANDLE_MARK) {
  		/* That could happen only in case of an error/reset/abort */
  		if (status != CTIO_SUCCESS) {
@@@ -2470,10 -3077,9 +2935,14 @@@
  		return;
  
  	se_cmd = &cmd->se_cmd;
++<<<<<<< HEAD
 +	tfo = se_cmd->se_tfo;
++=======
+ 	cmd->cmd_sent_to_fw = 0;
++>>>>>>> 52c82823cc68 (qla2xxx: Remove set-but-not-used variables)
  
 -	qlt_unmap_sg(vha, cmd);
 +	if (cmd->sg_mapped)
 +		qlt_unmap_sg(vha, cmd);
  
  	if (unlikely(status != CTIO_SUCCESS)) {
  		switch (status & 0xFFFF) {
@@@ -2518,27 -3155,30 +2987,23 @@@
  			break;
  		}
  
 -
 -		/* "cmd->state == QLA_TGT_STATE_ABORTED" means
 -		 * cmd is already aborted/terminated, we don't
 -		 * need to terminate again.  The exchange is already
 -		 * cleaned up/freed at FW level.  Just cleanup at driver
 -		 * level.
 -		 */
 -		if ((cmd->state != QLA_TGT_STATE_NEED_DATA) &&
 -		    (cmd->state != QLA_TGT_STATE_ABORTED)) {
 -			cmd->cmd_flags |= BIT_13;
 +		if (cmd->state != QLA_TGT_STATE_NEED_DATA)
  			if (qlt_term_ctio_exchange(vha, ctio, cmd, status))
  				return;
 -		}
  	}
 -skip_term:
  
  	if (cmd->state == QLA_TGT_STATE_PROCESSED) {
 -		;
 +		ql_dbg(ql_dbg_tgt, vha, 0xe01f, "Command %p finished\n", cmd);
  	} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
- 		int rx_status = 0;
- 
  		cmd->state = QLA_TGT_STATE_DATA_IN;
  
- 		if (unlikely(status != CTIO_SUCCESS))
- 			rx_status = -EIO;
- 		else
+ 		if (status == CTIO_SUCCESS)
  			cmd->write_data_transferred = 1;
  
 +		ql_dbg(ql_dbg_tgt, vha, 0xe020,
 +		    "Data received, context %x, rx_status %d\n",
 +		    0x0, rx_status);
 +
  		ha->tgt.tgt_ops->handle_data(cmd);
  		return;
  	} else if (cmd->state == QLA_TGT_STATE_ABORTED) {
@@@ -2845,12 -3571,11 +3310,11 @@@ static int qlt_handle_task_mgmt(struct 
  	struct qla_tgt *tgt;
  	struct qla_tgt_sess *sess;
  	uint32_t lun, unpacked_lun;
- 	int lun_size, fn;
+ 	int fn;
  
 -	tgt = vha->vha_tgt.qla_tgt;
 +	tgt = ha->tgt.qla_tgt;
  
  	lun = a->u.isp24.fcp_cmnd.lun;
- 	lun_size = sizeof(a->u.isp24.fcp_cmnd.lun);
  	fn = a->u.isp24.fcp_cmnd.task_mgmt_flags;
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    a->u.isp24.fcp_hdr.s_id);
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index deca736e73d9..3b95e8070b62 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -884,7 +884,6 @@ qla2x00_sysfs_read_dcbx_tlv(struct file *filp, struct kobject *kobj,
 	    struct device, kobj)));
 	struct qla_hw_data *ha = vha->hw;
 	int rval;
-	uint16_t actual_size;
 
 	if (!capable(CAP_SYS_ADMIN) || off != 0 || count > DCBX_TLV_DATA_SIZE)
 		return 0;
@@ -901,7 +900,6 @@ qla2x00_sysfs_read_dcbx_tlv(struct file *filp, struct kobject *kobj,
 	}
 
 do_read:
-	actual_size = 0;
 	memset(ha->dcbx_tlv, 0, DCBX_TLV_DATA_SIZE);
 
 	rval = qla2x00_get_dcbx_params(vha, ha->dcbx_tlv_dma,
diff --git a/drivers/scsi/qla2xxx/qla_bsg.c b/drivers/scsi/qla2xxx/qla_bsg.c
index e1c2a57a882f..c26acde797f0 100644
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@ -1733,7 +1733,6 @@ qla24xx_process_bidir_cmd(struct fc_bsg_job *bsg_job)
 	struct Scsi_Host *host = bsg_job->shost;
 	scsi_qla_host_t *vha = shost_priv(host);
 	struct qla_hw_data *ha = vha->hw;
-	uint16_t thread_id;
 	uint32_t rval = EXT_STATUS_OK;
 	uint16_t req_sg_cnt = 0;
 	uint16_t rsp_sg_cnt = 0;
@@ -1790,8 +1789,6 @@ qla24xx_process_bidir_cmd(struct fc_bsg_job *bsg_job)
 		goto done;
 	}
 
-	thread_id = bsg_job->request->rqst_data.h_vendor.vendor_cmd[1];
-
 	mutex_lock(&ha->selflogin_lock);
 	if (vha->self_login_loop_id == 0) {
 		/* Initialize all required  fields of fcport */
@@ -2174,7 +2171,6 @@ qla24xx_bsg_request(struct fc_bsg_job *bsg_job)
 {
 	int ret = -EINVAL;
 	struct fc_rport *rport;
-	fc_port_t *fcport = NULL;
 	struct Scsi_Host *host;
 	scsi_qla_host_t *vha;
 
@@ -2183,7 +2179,6 @@ qla24xx_bsg_request(struct fc_bsg_job *bsg_job)
 
 	if (bsg_job->request->msgcode == FC_BSG_RPT_ELS) {
 		rport = bsg_job->rport;
-		fcport = *(fc_port_t **) rport->dd_data;
 		host = rport_to_shost(rport);
 		vha = shost_priv(host);
 	} else {
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index dda6ab440386..b740886796cb 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -117,7 +117,7 @@ qla27xx_dump_mpi_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 {
 	int rval;
 	uint32_t cnt, stat, timer, dwords, idx;
-	uint16_t mb0, mb1;
+	uint16_t mb0;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 	dma_addr_t dump_dma = ha->gid_list_dma;
 	uint32_t *dump = (uint32_t *)ha->gid_list;
@@ -161,7 +161,7 @@ qla27xx_dump_mpi_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 					    &ha->mbx_cmd_flags);
 
 					mb0 = RD_REG_WORD(&reg->mailbox0);
-					mb1 = RD_REG_WORD(&reg->mailbox1);
+					RD_REG_WORD(&reg->mailbox1);
 
 					WRT_REG_DWORD(&reg->hccr,
 					    HCCRX_CLR_RISC_INT);
@@ -1039,7 +1039,6 @@ qla24xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 {
 	int		rval;
 	uint32_t	cnt;
-	uint32_t	risc_address;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 	uint32_t __iomem *dmp_reg;
@@ -1047,7 +1046,6 @@ qla24xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 	uint16_t __iomem *mbx_reg;
 	unsigned long	flags;
 	struct qla24xx_fw_dump *fw;
-	uint32_t	ext_mem_cnt;
 	void		*nxt;
 	void		*nxt_chain;
 	uint32_t	*last_chain = NULL;
@@ -1056,7 +1054,6 @@ qla24xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 	if (IS_P3P_TYPE(ha))
 		return;
 
-	risc_address = ext_mem_cnt = 0;
 	flags = 0;
 	ha->fw_dump_cap_flags = 0;
 
@@ -1294,7 +1291,6 @@ qla25xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 {
 	int		rval;
 	uint32_t	cnt;
-	uint32_t	risc_address;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 	uint32_t __iomem *dmp_reg;
@@ -1302,12 +1298,10 @@ qla25xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 	uint16_t __iomem *mbx_reg;
 	unsigned long	flags;
 	struct qla25xx_fw_dump *fw;
-	uint32_t	ext_mem_cnt;
 	void		*nxt, *nxt_chain;
 	uint32_t	*last_chain = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
-	risc_address = ext_mem_cnt = 0;
 	flags = 0;
 	ha->fw_dump_cap_flags = 0;
 
@@ -1613,7 +1607,6 @@ qla81xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 {
 	int		rval;
 	uint32_t	cnt;
-	uint32_t	risc_address;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 	uint32_t __iomem *dmp_reg;
@@ -1621,12 +1614,10 @@ qla81xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 	uint16_t __iomem *mbx_reg;
 	unsigned long	flags;
 	struct qla81xx_fw_dump *fw;
-	uint32_t	ext_mem_cnt;
 	void		*nxt, *nxt_chain;
 	uint32_t	*last_chain = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
-	risc_address = ext_mem_cnt = 0;
 	flags = 0;
 	ha->fw_dump_cap_flags = 0;
 
@@ -1933,8 +1924,7 @@ void
 qla83xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 {
 	int		rval;
-	uint32_t	cnt, reg_data;
-	uint32_t	risc_address;
+	uint32_t	cnt;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 	uint32_t __iomem *dmp_reg;
@@ -1942,12 +1932,10 @@ qla83xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 	uint16_t __iomem *mbx_reg;
 	unsigned long	flags;
 	struct qla83xx_fw_dump *fw;
-	uint32_t	ext_mem_cnt;
 	void		*nxt, *nxt_chain;
 	uint32_t	*last_chain = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
-	risc_address = ext_mem_cnt = 0;
 	flags = 0;
 	ha->fw_dump_cap_flags = 0;
 
@@ -1979,16 +1967,16 @@ qla83xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 
 	WRT_REG_DWORD(&reg->iobase_addr, 0x6000);
 	dmp_reg = &reg->iobase_window;
-	reg_data = RD_REG_DWORD(dmp_reg);
+	RD_REG_DWORD(dmp_reg);
 	WRT_REG_DWORD(dmp_reg, 0);
 
 	dmp_reg = &reg->unused_4_1[0];
-	reg_data = RD_REG_DWORD(dmp_reg);
+	RD_REG_DWORD(dmp_reg);
 	WRT_REG_DWORD(dmp_reg, 0);
 
 	WRT_REG_DWORD(&reg->iobase_addr, 0x6010);
 	dmp_reg = &reg->unused_4_1[2];
-	reg_data = RD_REG_DWORD(dmp_reg);
+	RD_REG_DWORD(dmp_reg);
 	WRT_REG_DWORD(dmp_reg, 0);
 
 	/* select PCR and disable ecc checking and correction */
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 8e36bb565628..4ba29c01d83f 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -1127,7 +1127,7 @@ qla24xx_reset_risc(scsi_qla_host_t *vha)
 	unsigned long flags = 0;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
-	uint32_t cnt, d2;
+	uint32_t cnt;
 	uint16_t wd;
 	static int abts_cnt; /* ISP abort retry counts */
 	int rval = QLA_SUCCESS;
@@ -1159,7 +1159,7 @@ qla24xx_reset_risc(scsi_qla_host_t *vha)
 	udelay(100);
 
 	/* Wait for firmware to complete NVRAM accesses. */
-	d2 = (uint32_t) RD_REG_WORD(&reg->mailbox0);
+	RD_REG_WORD(&reg->mailbox0);
 	for (cnt = 10000; RD_REG_WORD(&reg->mailbox0) != 0 &&
 	    rval == QLA_SUCCESS; cnt--) {
 		barrier();
@@ -1178,7 +1178,7 @@ qla24xx_reset_risc(scsi_qla_host_t *vha)
 	    RD_REG_DWORD(&reg->mailbox0));
 
 	/* Wait for soft-reset to complete. */
-	d2 = RD_REG_DWORD(&reg->ctrl_status);
+	RD_REG_DWORD(&reg->ctrl_status);
 	for (cnt = 0; cnt < 6000000; cnt++) {
 		barrier();
 		if ((RD_REG_DWORD(&reg->ctrl_status) &
@@ -1221,7 +1221,7 @@ qla24xx_reset_risc(scsi_qla_host_t *vha)
 	WRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_RESET);
 	RD_REG_DWORD(&reg->hccr);
 
-	d2 = (uint32_t) RD_REG_WORD(&reg->mailbox0);
+	RD_REG_WORD(&reg->mailbox0);
 	for (cnt = 6000000; RD_REG_WORD(&reg->mailbox0) != 0 &&
 	    rval == QLA_SUCCESS; cnt--) {
 		barrier();
@@ -3856,12 +3856,10 @@ qla2x00_fabric_dev_login(scsi_qla_host_t *vha, fc_port_t *fcport,
     uint16_t *next_loopid)
 {
 	int	rval;
-	int	retry;
 	uint8_t opts;
 	struct qla_hw_data *ha = vha->hw;
 
 	rval = QLA_SUCCESS;
-	retry = 0;
 
 	if (IS_ALOGIO_CAPABLE(ha)) {
 		if (fcport->flags & FCF_ASYNC_SENT)
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index f12cf90f18f9..717fbbc072c9 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -544,7 +544,7 @@ qla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)
 	struct device_reg_2xxx __iomem *reg = &ha->iobase->isp;
 	struct device_reg_24xx __iomem *reg24 = &ha->iobase->isp24;
 	struct device_reg_82xx __iomem *reg82 = &ha->iobase->isp82;
-	uint32_t	rscn_entry, host_pid, tmp_pid;
+	uint32_t	rscn_entry, host_pid;
 	unsigned long	flags;
 	fc_port_t	*fcport = NULL;
 
@@ -967,7 +967,6 @@ skip_rio:
 		list_for_each_entry(fcport, &vha->vp_fcports, list) {
 			if (atomic_read(&fcport->state) != FCS_ONLINE)
 				continue;
-			tmp_pid = fcport->d_id.b24;
 			if (fcport->d_id.b24 == rscn_entry) {
 				qla2x00_mark_device_lost(vha, fcport, 0, 0);
 				break;
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 8f398ac40afc..566b8d9e9778 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -1865,7 +1865,6 @@ qla24xx_login_fabric(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,
 	uint32_t	iop[2];
 	struct qla_hw_data *ha = vha->hw;
 	struct req_que *req;
-	struct rsp_que *rsp;
 
 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1061,
 	    "Entered %s.\n", __func__);
@@ -1874,7 +1873,6 @@ qla24xx_login_fabric(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,
 		req = ha->req_q_map[0];
 	else
 		req = vha->req;
-	rsp = req->rsp;
 
 	lg = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &lg_dma);
 	if (lg == NULL) {
@@ -2142,7 +2140,6 @@ qla24xx_fabric_logout(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,
 	dma_addr_t	lg_dma;
 	struct qla_hw_data *ha = vha->hw;
 	struct req_que *req;
-	struct rsp_que *rsp;
 
 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x106d,
 	    "Entered %s.\n", __func__);
@@ -2159,7 +2156,6 @@ qla24xx_fabric_logout(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,
 		req = ha->req_q_map[0];
 	else
 		req = vha->req;
-	rsp = req->rsp;
 	lg->entry_type = LOGINOUT_PORT_IOCB_TYPE;
 	lg->entry_count = 1;
 	lg->handle = MAKE_HANDLE(req->id, lg->handle);
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index cc94192511cf..c5dd594f6c31 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -371,7 +371,6 @@ qla2x00_do_dpc_vp(scsi_qla_host_t *vha)
 void
 qla2x00_do_dpc_all_vps(scsi_qla_host_t *vha)
 {
-	int ret;
 	struct qla_hw_data *ha = vha->hw;
 	scsi_qla_host_t *vp;
 	unsigned long flags = 0;
@@ -392,7 +391,7 @@ qla2x00_do_dpc_all_vps(scsi_qla_host_t *vha)
 			atomic_inc(&vp->vref_count);
 			spin_unlock_irqrestore(&ha->vport_slock, flags);
 
-			ret = qla2x00_do_dpc_vp(vp);
+			qla2x00_do_dpc_vp(vp);
 
 			spin_lock_irqsave(&ha->vport_slock, flags);
 			atomic_dec(&vp->vref_count);
diff --git a/drivers/scsi/qla2xxx/qla_mr.c b/drivers/scsi/qla2xxx/qla_mr.c
index d33c74340796..bd9e72f7f8d5 100644
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@ -1317,10 +1317,10 @@ int
 qlafx00_configure_devices(scsi_qla_host_t *vha)
 {
 	int  rval;
-	unsigned long flags, save_flags;
+	unsigned long flags;
 	rval = QLA_SUCCESS;
 
-	save_flags = flags = vha->dpc_flags;
+	flags = vha->dpc_flags;
 
 	ql_dbg(ql_dbg_disc, vha, 0x2090,
 	    "Configure devices -- dpc flags =0x%lx\n", flags);
@@ -2280,7 +2280,6 @@ qlafx00_status_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, void *pkt)
 	struct sts_entry_fx00 *sts;
 	__le16		comp_status;
 	__le16		scsi_status;
-	uint16_t	ox_id;
 	__le16		lscsi_status;
 	int32_t		resid;
 	uint32_t	sense_len, par_sense_len, rsp_info_len, resid_len,
@@ -2345,7 +2344,6 @@ qlafx00_status_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, void *pkt)
 
 	fcport = sp->fcport;
 
-	ox_id = 0;
 	sense_len = par_sense_len = rsp_info_len = resid_len =
 		fw_resid_len = 0;
 	if (scsi_status & cpu_to_le16((uint16_t)SS_SENSE_LEN_VALID))
@@ -3070,7 +3068,7 @@ qlafx00_build_scsi_iocbs(srb_t *sp, struct cmd_type_7_fx00 *cmd_pkt,
 int
 qlafx00_start_scsi(srb_t *sp)
 {
-	int		ret, nseg;
+	int		nseg;
 	unsigned long   flags;
 	uint32_t        index;
 	uint32_t	handle;
@@ -3088,8 +3086,6 @@ qlafx00_start_scsi(srb_t *sp)
 	char		tag[2];
 
 	/* Setup device pointers. */
-	ret = 0;
-
 	rsp = ha->rsp_q_map[0];
 	req = vha->req;
 
diff --git a/drivers/scsi/qla2xxx/qla_nx.c b/drivers/scsi/qla2xxx/qla_nx.c
index 396ce828060b..9189bd494947 100644
--- a/drivers/scsi/qla2xxx/qla_nx.c
+++ b/drivers/scsi/qla2xxx/qla_nx.c
@@ -1740,8 +1740,8 @@ qla82xx_pci_config(scsi_qla_host_t *vha)
 	ret = pci_set_mwi(ha->pdev);
 	ha->chip_revision = ha->pdev->revision;
 	ql_dbg(ql_dbg_init, vha, 0x0043,
-	    "Chip revision:%d.\n",
-	    ha->chip_revision);
+	    "Chip revision:%d; pci_set_mwi() returned %d.\n",
+	    ha->chip_revision, ret);
 	return 0;
 }
 
@@ -2657,7 +2657,7 @@ qla82xx_write_flash_data(struct scsi_qla_host *vha, uint32_t *dwptr,
 {
 	int ret;
 	uint32_t liter;
-	uint32_t sec_mask, rest_addr;
+	uint32_t rest_addr;
 	dma_addr_t optrom_dma;
 	void *optrom = NULL;
 	int page_mode = 0;
@@ -2679,7 +2679,6 @@ qla82xx_write_flash_data(struct scsi_qla_host *vha, uint32_t *dwptr,
 	}
 
 	rest_addr = ha->fdt_block_size - 1;
-	sec_mask = ~rest_addr;
 
 	ret = qla82xx_unprotect_flash(ha);
 	if (ret) {
@@ -2775,7 +2774,6 @@ qla82xx_start_iocbs(scsi_qla_host_t *vha)
 {
 	struct qla_hw_data *ha = vha->hw;
 	struct req_que *req = ha->req_q_map[0];
-	struct device_reg_82xx __iomem *reg;
 	uint32_t dbval;
 
 	/* Adjust ring index. */
@@ -2786,7 +2784,6 @@ qla82xx_start_iocbs(scsi_qla_host_t *vha)
 	} else
 		req->ring_ptr++;
 
-	reg = &ha->iobase->isp82;
 	dbval = 0x04 | (ha->portnum << 5);
 
 	dbval = dbval | (req->id << 8) | (req->ring_index << 16);
diff --git a/drivers/scsi/qla2xxx/qla_nx2.c b/drivers/scsi/qla2xxx/qla_nx2.c
index 0ed8bcc4bc49..95d4316bacc1 100644
--- a/drivers/scsi/qla2xxx/qla_nx2.c
+++ b/drivers/scsi/qla2xxx/qla_nx2.c
@@ -462,12 +462,11 @@ qla8044_flash_lock(scsi_qla_host_t *vha)
 static void
 qla8044_flash_unlock(scsi_qla_host_t *vha)
 {
-	int ret_val;
 	struct qla_hw_data *ha = vha->hw;
 
 	/* Reading FLASH_UNLOCK register unlocks the Flash */
 	qla8044_wr_reg(ha, QLA8044_FLASH_LOCK_ID, 0xFF);
-	ret_val = qla8044_rd_reg(ha, QLA8044_FLASH_UNLOCK);
+	qla8044_rd_reg(ha, QLA8044_FLASH_UNLOCK);
 }
 
 
@@ -2992,7 +2991,7 @@ qla8044_minidump_process_rddfe(struct scsi_qla_host *vha,
 	uint32_t addr1, addr2, value, data, temp, wrVal;
 	uint8_t stride, stride2;
 	uint16_t count;
-	uint32_t poll, mask, data_size, modify_mask;
+	uint32_t poll, mask, modify_mask;
 	uint32_t wait_count = 0;
 
 	uint32_t *data_ptr = *d_ptr;
@@ -3009,7 +3008,6 @@ qla8044_minidump_process_rddfe(struct scsi_qla_host *vha,
 	poll = rddfe->poll;
 	mask = rddfe->mask;
 	modify_mask = rddfe->modify_mask;
-	data_size = rddfe->data_size;
 
 	addr2 = addr1 + stride;
 
@@ -3091,7 +3089,7 @@ qla8044_minidump_process_rdmdio(struct scsi_qla_host *vha,
 	uint8_t stride1, stride2;
 	uint32_t addr3, addr4, addr5, addr6, addr7;
 	uint16_t count, loop_cnt;
-	uint32_t poll, mask;
+	uint32_t mask;
 	uint32_t *data_ptr = *d_ptr;
 
 	struct qla8044_minidump_entry_rdmdio *rdmdio;
@@ -3105,7 +3103,6 @@ qla8044_minidump_process_rdmdio(struct scsi_qla_host *vha,
 	stride2 = rdmdio->stride_2;
 	count = rdmdio->count;
 
-	poll = rdmdio->poll;
 	mask = rdmdio->mask;
 	value2 = rdmdio->value_2;
 
@@ -3165,7 +3162,7 @@ error:
 static uint32_t qla8044_minidump_process_pollwr(struct scsi_qla_host *vha,
 		struct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)
 {
-	uint32_t addr1, addr2, value1, value2, poll, mask, r_value;
+	uint32_t addr1, addr2, value1, value2, poll, r_value;
 	uint32_t wait_count = 0;
 	struct qla8044_minidump_entry_pollwr *pollwr_hdr;
 
@@ -3176,7 +3173,6 @@ static uint32_t qla8044_minidump_process_pollwr(struct scsi_qla_host *vha,
 	value2 = pollwr_hdr->value_2;
 
 	poll = pollwr_hdr->poll;
-	mask = pollwr_hdr->mask;
 
 	while (wait_count < poll) {
 		qla8044_rd_reg_indirect(vha, addr1, &r_value);
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_tmpl.c b/drivers/scsi/qla2xxx/qla_tmpl.c
index 395622ffe326..e97d42870b1a 100644
--- a/drivers/scsi/qla2xxx/qla_tmpl.c
+++ b/drivers/scsi/qla2xxx/qla_tmpl.c
@@ -805,9 +805,8 @@ static void
 qla27xx_driver_info(struct qla27xx_fwdt_template *tmp)
 {
 	uint8_t v[] = { 0, 0, 0, 0, 0, 0 };
-	int rval = 0;
 
-	rval = sscanf(qla2x00_version_str, "%hhu.%hhu.%hhu.%hhu.%hhu.%hhu",
+	sscanf(qla2x00_version_str, "%hhu.%hhu.%hhu.%hhu.%hhu.%hhu",
 	    v+0, v+1, v+2, v+3, v+4, v+5);
 
 	tmp->driver_info[0] = v[3] << 24 | v[2] << 16 | v[1] << 8 | v[0];
