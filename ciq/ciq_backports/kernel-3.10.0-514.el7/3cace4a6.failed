Drivers: hv: utils: run polling callback always in interrupt context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] utils: run polling callback always in interrupt context (Vitaly Kuznetsov) [1074407 1309368]
Rebuild_FUZZ: 89.43%
commit-author Olaf Hering <olaf@aepfle.de>
commit 3cace4a616108539e2730f8dc21a636474395e0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3cace4a6.failed

All channel interrupts are bound to specific VCPUs in the guest
at the point channel is created. While currently, we invoke the
polling function on the correct CPU (the CPU to which the channel
is bound to) in some cases we may run the polling function in
a non-interrupt context. This  potentially can cause an issue as the
polling function can be interrupted by the channel callback function.
Fix the issue by running the polling function on the appropriate CPU
at interrupt level. Additional details of the issue being addressed by
this patch are given below:

Currently hv_fcopy_onchannelcallback is called from interrupts and also
via the ->write function of hv_utils. Since the used global variables to
maintain state are not thread safe the state can get out of sync.
This affects the variable state as well as the channel inbound buffer.

As suggested by KY adjust hv_poll_channel to always run the given
callback on the cpu which the channel is bound to. This avoids the need
for locking because all the util services are single threaded and only
one transaction is active at any given point in time.

Additionally, remove the context variable, they will always be the same as
recv_channel.

	Signed-off-by: Olaf Hering <olaf@aepfle.de>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3cace4a616108539e2730f8dc21a636474395e0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/hv_fcopy.c
#	drivers/hv/hv_kvp.c
#	drivers/hv/hv_snapshot.c
#	drivers/hv/hyperv_vmbus.h
diff --cc drivers/hv/hv_fcopy.c
index d1475e6aa9ac,c37a71e13de0..000000000000
--- a/drivers/hv/hv_fcopy.c
+++ b/drivers/hv/hv_fcopy.c
@@@ -53,19 -49,30 +53,29 @@@ static struct 
  	int state;   /* hvutil_device_state */
  	int recv_len; /* number of bytes received. */
  	struct hv_fcopy_hdr  *fcopy_msg; /* current message */
 +	struct hv_start_fcopy  message; /*  sent to daemon */
  	struct vmbus_channel *recv_channel; /* chn we got the request */
  	u64 recv_req_id; /* request ID. */
++<<<<<<< HEAD
 +	void *fcopy_context; /* for the channel callback */
 +	struct semaphore read_sema;
++=======
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  } fcopy_transaction;
  
 +static void fcopy_send_data(void);
  static void fcopy_respond_to_host(int error);
 -static void fcopy_send_data(struct work_struct *dummy);
  static void fcopy_timeout_func(struct work_struct *dummy);
  static DECLARE_DELAYED_WORK(fcopy_timeout_work, fcopy_timeout_func);
 -static DECLARE_WORK(fcopy_send_work, fcopy_send_data);
 -static const char fcopy_devname[] = "vmbus/hv_fcopy";
  static u8 *recv_buffer;
 -static struct hvutil_transport *hvt;
 -/*
 - * This state maintains the version number registered by the daemon.
 - */
 -static int dm_reg_value;
  
+ static void fcopy_poll_wrapper(void *channel)
+ {
+ 	/* Transaction is finished, reset the state here to avoid races. */
+ 	fcopy_transaction.state = HVUTIL_READY;
+ 	hv_fcopy_onchannelcallback(channel);
+ }
+ 
  static void fcopy_timeout_func(struct work_struct *dummy)
  {
  	/*
@@@ -73,24 -80,7 +83,28 @@@
  	 * process the pending transaction.
  	 */
  	fcopy_respond_to_host(HV_E_FAIL);
++<<<<<<< HEAD
 +
 +	/* Transaction is finished, reset the state. */
 +	if (fcopy_transaction.state > HVUTIL_READY)
 +		fcopy_transaction.state = HVUTIL_READY;
 +
 +	/* In the case the user-space daemon crashes, hangs or is killed, we
 +	 * need to down the semaphore, otherwise, after the daemon starts next
 +	 * time, the obsolete data in fcopy_transaction.message or
 +	 * fcopy_transaction.fcopy_msg will be used immediately.
 +	 *
 +	 * NOTE: fcopy_read() happens to get the semaphore (very rare)? We're
 +	 * still OK, because we've reported the failure to the host.
 +	 */
 +	if (down_trylock(&fcopy_transaction.read_sema))
 +		;
 +
 +	hv_poll_channel(fcopy_transaction.fcopy_context,
 +			hv_fcopy_onchannelcallback);
++=======
+ 	hv_poll_channel(fcopy_transaction.recv_channel, fcopy_poll_wrapper);
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  }
  
  static int fcopy_handle_handshake(u32 version)
@@@ -107,11 -107,8 +121,16 @@@
  		 */
  		return -EINVAL;
  	}
++<<<<<<< HEAD
 +	pr_info("FCP: user-mode registering done. Daemon version: %d\n",
 +		version);
 +	fcopy_transaction.state = HVUTIL_READY;
 +	hv_poll_channel(fcopy_transaction.fcopy_context,
 +			hv_fcopy_onchannelcallback);
++=======
+ 	pr_debug("FCP: userspace daemon ver. %d registered\n", version);
+ 	hv_poll_channel(fcopy_transaction.recv_channel, fcopy_poll_wrapper);
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  	return 0;
  }
  
@@@ -337,25 -295,11 +349,31 @@@ static ssize_t fcopy_write(struct file 
  	 */
  	if (cancel_delayed_work_sync(&fcopy_timeout_work)) {
  		fcopy_transaction.state = HVUTIL_USERSPACE_RECV;
++<<<<<<< HEAD
 +		fcopy_respond_to_host(response);
 +		fcopy_transaction.state = HVUTIL_READY;
 +		hv_poll_channel(fcopy_transaction.fcopy_context,
 +				hv_fcopy_onchannelcallback);
++=======
+ 		fcopy_respond_to_host(*val);
+ 		hv_poll_channel(fcopy_transaction.recv_channel,
+ 				fcopy_poll_wrapper);
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  	}
  
 +	return sizeof(int);
 +}
 +
 +static int fcopy_open(struct inode *inode, struct file *f)
 +{
 +	/*
 +	 * The user level daemon that will open this device is
 +	 * really an extension of this driver. We can have only
 +	 * active open at a time.
 +	 */
 +	if (fcopy_transaction.state != HVUTIL_DEVICE_INIT)
 +		return -EBUSY;
 +
  	return 0;
  }
  
diff --cc drivers/hv/hv_kvp.c
index 0353aa1d6ef0,2a3420c4ca59..000000000000
--- a/drivers/hv/hv_kvp.c
+++ b/drivers/hv/hv_kvp.c
@@@ -60,16 -66,8 +60,15 @@@ static struct 
  	struct hv_kvp_msg  *kvp_msg; /* current message */
  	struct vmbus_channel *recv_channel; /* chn we got the request */
  	u64 recv_req_id; /* request ID. */
- 	void *kvp_context; /* for the channel callback */
  } kvp_transaction;
  
 +/*
 + * Before we can accept KVP messages from the host, we need
 + * to handshake with the user level daemon. This state tracks
 + * if we are in the handshake phase.
 + */
 +static bool in_hand_shake = true;
 +
  /*
   * This state maintains the version number registered by the daemon.
   */
@@@ -126,23 -126,12 +132,28 @@@ kvp_work_func(struct work_struct *dummy
  	 * process the pending transaction.
  	 */
  	kvp_respond_to_host(NULL, HV_E_FAIL);
++<<<<<<< HEAD
++=======
+ 
+ 	hv_poll_channel(kvp_transaction.recv_channel, kvp_poll_wrapper);
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
 +}
 +
 +static void poll_channel(struct vmbus_channel *channel)
 +{
 +	if (channel->target_cpu != smp_processor_id())
 +		smp_call_function_single(channel->target_cpu,
 +					 hv_kvp_onchannelcallback,
 +					 channel, true);
 +	else
 +		hv_kvp_onchannelcallback(channel);
  }
  
 +
  static int kvp_handle_handshake(struct hv_kvp_msg *msg)
  {
 +	int ret = 1;
 +
  	switch (msg->kvp_hdr.operation) {
  	case KVP_OP_REGISTER:
  		dm_reg_value = KVP_OP_REGISTER;
@@@ -226,8 -217,12 +237,15 @@@ kvp_cn_callback(struct cn_msg *msg, str
  	 * Complete the transaction by forwarding the key value
  	 * to the host. But first, cancel the timeout.
  	 */
 -	if (cancel_delayed_work_sync(&kvp_timeout_work)) {
 +	if (cancel_delayed_work_sync(&kvp_work))
  		kvp_respond_to_host(message, error);
++<<<<<<< HEAD
++=======
+ 		hv_poll_channel(kvp_transaction.recv_channel, kvp_poll_wrapper);
+ 	}
+ 
+ 	return 0;
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  }
  
  
@@@ -613,14 -595,8 +631,19 @@@ void hv_kvp_onchannelcallback(void *con
  	int util_fw_version;
  	int kvp_srv_version;
  
++<<<<<<< HEAD
 +	if (kvp_transaction.active) {
 +		/*
 +		 * We will defer processing this callback once
 +		 * the current transaction is complete.
 +		 */
 +		kvp_transaction.kvp_context = context;
 +		return;
 +	}
++=======
+ 	if (kvp_transaction.state > HVUTIL_READY)
+ 		return;
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  
  	vmbus_recvpacket(channel, recv_buffer, PAGE_SIZE * 4, &recvlen,
  			 &requestid);
diff --cc drivers/hv/hv_snapshot.c
index 5ca7351b78df,a548ae42c927..000000000000
--- a/drivers/hv/hv_snapshot.c
+++ b/drivers/hv/hv_snapshot.c
@@@ -75,26 -92,62 +81,63 @@@ static void vss_timeout_func(struct wor
  	pr_warn("VSS: timeout waiting for daemon to reply\n");
  	vss_respond_to_host(HV_E_FAIL);
  
++<<<<<<< HEAD
 +	hv_poll_channel(vss_transaction.vss_context,
 +			hv_vss_onchannelcallback);
++=======
+ 	hv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  }
  
 -static int vss_handle_handshake(struct hv_vss_msg *vss_msg)
 +static void
 +vss_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)
  {
 -	u32 our_ver = VSS_OP_REGISTER1;
 -
 -	switch (vss_msg->vss_hdr.operation) {
 -	case VSS_OP_REGISTER:
 -		/* Daemon doesn't expect us to reply */
 -		dm_reg_value = VSS_OP_REGISTER;
 -		break;
 -	case VSS_OP_REGISTER1:
 -		/* Daemon expects us to reply with our own version*/
 -		if (hvutil_transport_send(hvt, &our_ver, sizeof(our_ver)))
 -			return -EFAULT;
 -		dm_reg_value = VSS_OP_REGISTER1;
 -		break;
 -	default:
 -		return -EINVAL;
 +	struct hv_vss_msg *vss_msg;
 +
 +	vss_msg = (struct hv_vss_msg *)msg->data;
 +
 +	if (vss_msg->vss_hdr.operation == VSS_OP_REGISTER) {
 +		pr_info("VSS daemon registered\n");
 +		vss_transaction.active = false;
  	}
 -	vss_transaction.state = HVUTIL_READY;
 -	pr_debug("VSS: userspace daemon ver. %d registered\n", dm_reg_value);
 -	return 0;
 -}
 +	if (cancel_delayed_work_sync(&vss_timeout_work))
 +		vss_respond_to_host(vss_msg->error);
  
++<<<<<<< HEAD
 +	hv_poll_channel(vss_transaction.vss_context,
 +			hv_vss_onchannelcallback);
++=======
+ static int vss_on_msg(void *msg, int len)
+ {
+ 	struct hv_vss_msg *vss_msg = (struct hv_vss_msg *)msg;
+ 
+ 	if (len != sizeof(*vss_msg))
+ 		return -EINVAL;
+ 
+ 	if (vss_msg->vss_hdr.operation == VSS_OP_REGISTER ||
+ 	    vss_msg->vss_hdr.operation == VSS_OP_REGISTER1) {
+ 		/*
+ 		 * Don't process registration messages if we're in the middle
+ 		 * of a transaction processing.
+ 		 */
+ 		if (vss_transaction.state > HVUTIL_READY)
+ 			return -EINVAL;
+ 		return vss_handle_handshake(vss_msg);
+ 	} else if (vss_transaction.state == HVUTIL_USERSPACE_REQ) {
+ 		vss_transaction.state = HVUTIL_USERSPACE_RECV;
+ 		if (cancel_delayed_work_sync(&vss_timeout_work)) {
+ 			vss_respond_to_host(vss_msg->error);
+ 			/* Transaction is finished, reset the state. */
+ 			hv_poll_channel(vss_transaction.recv_channel,
+ 					vss_poll_wrapper);
+ 		}
+ 	} else {
+ 		/* This is a spurious call! */
+ 		pr_warn("VSS: Transaction not active\n");
+ 		return -EINVAL;
+ 	}
+ 	return 0;
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  }
  
  
@@@ -196,15 -238,8 +239,17 @@@ void hv_vss_onchannelcallback(void *con
  	struct icmsg_hdr *icmsghdrp;
  	struct icmsg_negotiate *negop = NULL;
  
++<<<<<<< HEAD
 +	if (vss_transaction.active) {
 +		/*
 +		 * We will defer processing this callback once
 +		 * the current transaction is complete.
 +		 */
 +		vss_transaction.vss_context = context;
++=======
+ 	if (vss_transaction.state > HVUTIL_READY)
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  		return;
- 	}
- 	vss_transaction.vss_context = NULL;
  
  	vmbus_recvpacket(channel, recv_buffer, PAGE_SIZE * 2, &recvlen,
  			 &requestid);
diff --cc drivers/hv/hyperv_vmbus.h
index ef1ffc73684b,12156db2e88e..000000000000
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@@ -725,5 -758,22 +725,25 @@@ void hv_fcopy_deinit(void)
  void hv_fcopy_onchannelcallback(void *);
  void vmbus_initiate_unload(void);
  
++<<<<<<< HEAD
++=======
+ static inline void hv_poll_channel(struct vmbus_channel *channel,
+ 				   void (*cb)(void *))
+ {
+ 	if (!channel)
+ 		return;
+ 
+ 	smp_call_function_single(channel->target_cpu, cb, channel, true);
+ }
+ 
+ enum hvutil_device_state {
+ 	HVUTIL_DEVICE_INIT = 0,  /* driver is loaded, waiting for userspace */
+ 	HVUTIL_READY,            /* userspace is registered */
+ 	HVUTIL_HOSTMSG_RECEIVED, /* message from the host was received */
+ 	HVUTIL_USERSPACE_REQ,    /* request to userspace was sent */
+ 	HVUTIL_USERSPACE_RECV,   /* reply from userspace was received */
+ 	HVUTIL_DEVICE_DYING,     /* driver unload is in progress */
+ };
++>>>>>>> 3cace4a61610 (Drivers: hv: utils: run polling callback always in interrupt context)
  
  #endif /* _HYPERV_VMBUS_H */
* Unmerged path drivers/hv/hv_fcopy.c
* Unmerged path drivers/hv/hv_kvp.c
* Unmerged path drivers/hv/hv_snapshot.c
* Unmerged path drivers/hv/hyperv_vmbus.h
