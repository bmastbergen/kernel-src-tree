ceph: add acl for cephfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Guangliang Zhao <lucienchao@gmail.com>
commit 7221fe4c2ed72804b28633c8e0217d65abb0023f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7221fe4c.failed

	Signed-off-by: Guangliang Zhao <lucienchao@gmail.com>
	Reviewed-by: Li Wang <li.wang@ubuntykylin.com>
	Reviewed-by: Zheng Yan <zheng.z.yan@intel.com>
(cherry picked from commit 7221fe4c2ed72804b28633c8e0217d65abb0023f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/Kconfig
#	fs/ceph/Makefile
#	fs/ceph/inode.c
#	fs/ceph/super.h
#	fs/ceph/xattr.c
diff --cc fs/ceph/Kconfig
index 49bc78243db9,264e9bf83ff3..000000000000
--- a/fs/ceph/Kconfig
+++ b/fs/ceph/Kconfig
@@@ -16,3 -16,25 +16,28 @@@ config CEPH_F
  
  	  If unsure, say N.
  
++<<<<<<< HEAD
++=======
+ if CEPH_FS
+ config CEPH_FSCACHE
+ 	bool "Enable Ceph client caching support"
+ 	depends on CEPH_FS=m && FSCACHE || CEPH_FS=y && FSCACHE=y
+ 	help
+ 	  Choose Y here to enable persistent, read-only local
+ 	  caching support for Ceph clients using FS-Cache
+ 
+ endif
+ 
+ config CEPH_FS_POSIX_ACL
+ 	bool "Ceph POSIX Access Control Lists"
+ 	depends on CEPH_FS
+ 	select FS_POSIX_ACL
+ 	help
+ 	  POSIX Access Control Lists (ACLs) support permissions for users and
+ 	  groups beyond the owner/group/world scheme.
+ 
+ 	  To learn more about Access Control Lists, visit the POSIX ACLs for
+ 	  Linux website <http://acl.bestbits.at/>.
+ 
+ 	  If you don't know what Access Control Lists are, say N
++>>>>>>> 7221fe4c2ed7 (ceph: add acl for cephfs)
diff --cc fs/ceph/Makefile
index bd352125e829,85a4230b9bff..000000000000
--- a/fs/ceph/Makefile
+++ b/fs/ceph/Makefile
@@@ -9,3 -9,5 +9,8 @@@ ceph-y := super.o inode.o dir.o file.o 
  	mds_client.o mdsmap.o strings.o ceph_frag.o \
  	debugfs.o
  
++<<<<<<< HEAD
++=======
+ ceph-$(CONFIG_CEPH_FSCACHE) += cache.o
+ ceph-$(CONFIG_CEPH_FS_POSIX_ACL) += acl.o
++>>>>>>> 7221fe4c2ed7 (ceph: add acl for cephfs)
diff --cc fs/ceph/inode.c
index a649a586cda7,a808bfb8d8d8..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -1909,6 -1827,11 +1919,14 @@@ int ceph_setattr(struct dentry *dentry
  	if (mask & CEPH_SETATTR_SIZE)
  		__ceph_do_pending_vmtruncate(inode);
  	return err;
++<<<<<<< HEAD
++=======
+ out:
+ 	spin_unlock(&ci->i_ceph_lock);
+ out_put:
+ 	ceph_mdsc_put_request(req);
+ 	return err;
++>>>>>>> 7221fe4c2ed7 (ceph: add acl for cephfs)
  }
  
  /*
diff --cc fs/ceph/super.h
index 1c439e8e6c74,7fa78a7c8894..000000000000
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@@ -339,6 -330,11 +339,14 @@@ struct ceph_inode_info 
  
  	struct work_struct i_vmtruncate_work;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CEPH_FSCACHE
+ 	struct fscache_cookie *fscache;
+ 	u32 i_fscache_gen; /* sequence, for delayed fscache validate */
+ 	struct work_struct i_revalidate_work;
+ #endif
++>>>>>>> 7221fe4c2ed7 (ceph: add acl for cephfs)
  	struct inode vfs_inode; /* at end */
  };
  
diff --cc fs/ceph/xattr.c
index 4ec7a267abe6,c7581f3733c1..000000000000
--- a/fs/ceph/xattr.c
+++ b/fs/ceph/xattr.c
@@@ -12,8 -11,17 +12,22 @@@
  #define XATTR_CEPH_PREFIX "ceph."
  #define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)
  
++<<<<<<< HEAD
 +static int __remove_xattr(struct ceph_inode_info *ci,
 +			  struct ceph_inode_xattr *xattr);
++=======
+ /*
+  * List of handlers for synthetic system.* attributes. Other
+  * attributes are handled directly.
+  */
+ const struct xattr_handler *ceph_xattr_handlers[] = {
+ #ifdef CONFIG_CEPH_FS_POSIX_ACL
+ 	&ceph_xattr_acl_access_handler,
+ 	&ceph_xattr_acl_default_handler,
+ #endif
+ 	NULL,
+ };
++>>>>>>> 7221fe4c2ed7 (ceph: add acl for cephfs)
  
  static bool ceph_is_valid_xattr(const char *name)
  {
@@@ -900,14 -898,7 +922,17 @@@ int __ceph_setxattr(struct dentry *dent
  	char *newval = NULL;
  	struct ceph_inode_xattr *xattr = NULL;
  	int required_blob_size;
 +	bool lock_snap_rwsem = false;
 +
++<<<<<<< HEAD
 +	if (ceph_snap(inode) != CEPH_NOSNAP)
 +		return -EROFS;
 +
 +	if (size == 0)
 +		value = "";  /* empty EA, do not remove */
  
++=======
++>>>>>>> 7221fe4c2ed7 (ceph: add acl for cephfs)
  	if (!ceph_is_valid_xattr(name))
  		return -EOPNOTSUPP;
  
@@@ -1036,11 -1022,7 +1073,8 @@@ int __ceph_removexattr(struct dentry *d
  	int err;
  	int required_blob_size;
  	int dirty;
 +	bool lock_snap_rwsem = false;
  
- 	if (ceph_snap(inode) != CEPH_NOSNAP)
- 		return -EROFS;
- 
  	if (!ceph_is_valid_xattr(name))
  		return -EOPNOTSUPP;
  
* Unmerged path fs/ceph/Kconfig
* Unmerged path fs/ceph/Makefile
diff --git a/fs/ceph/acl.c b/fs/ceph/acl.c
new file mode 100644
index 000000000000..64fddbc1d17b
--- /dev/null
+++ b/fs/ceph/acl.c
@@ -0,0 +1,332 @@
+/*
+ * linux/fs/ceph/acl.c
+ *
+ * Copyright (C) 2013 Guangliang Zhao, <lucienchao@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/ceph/ceph_debug.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/xattr.h>
+#include <linux/posix_acl_xattr.h>
+#include <linux/posix_acl.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include "super.h"
+
+static inline void ceph_set_cached_acl(struct inode *inode,
+					int type, struct posix_acl *acl)
+{
+	struct ceph_inode_info *ci = ceph_inode(inode);
+
+	spin_lock(&ci->i_ceph_lock);
+	if (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))
+		set_cached_acl(inode, type, acl);
+	spin_unlock(&ci->i_ceph_lock);
+}
+
+static inline struct posix_acl *ceph_get_cached_acl(struct inode *inode,
+							int type)
+{
+	struct ceph_inode_info *ci = ceph_inode(inode);
+	struct posix_acl *acl = ACL_NOT_CACHED;
+
+	spin_lock(&ci->i_ceph_lock);
+	if (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))
+		acl = get_cached_acl(inode, type);
+	spin_unlock(&ci->i_ceph_lock);
+
+	return acl;
+}
+
+void ceph_forget_all_cached_acls(struct inode *inode)
+{
+	forget_all_cached_acls(inode);
+}
+
+struct posix_acl *ceph_get_acl(struct inode *inode, int type)
+{
+	int size;
+	const char *name;
+	char *value = NULL;
+	struct posix_acl *acl;
+
+	if (!IS_POSIXACL(inode))
+		return NULL;
+
+	acl = ceph_get_cached_acl(inode, type);
+	if (acl != ACL_NOT_CACHED)
+		return acl;
+
+	switch (type) {
+	case ACL_TYPE_ACCESS:
+		name = POSIX_ACL_XATTR_ACCESS;
+		break;
+	case ACL_TYPE_DEFAULT:
+		name = POSIX_ACL_XATTR_DEFAULT;
+		break;
+	default:
+		BUG();
+	}
+
+	size = __ceph_getxattr(inode, name, "", 0);
+	if (size > 0) {
+		value = kzalloc(size, GFP_NOFS);
+		if (!value)
+			return ERR_PTR(-ENOMEM);
+		size = __ceph_getxattr(inode, name, value, size);
+	}
+
+	if (size > 0)
+		acl = posix_acl_from_xattr(&init_user_ns, value, size);
+	else if (size == -ERANGE || size == -ENODATA || size == 0)
+		acl = NULL;
+	else
+		acl = ERR_PTR(-EIO);
+
+	kfree(value);
+
+	if (!IS_ERR(acl))
+		ceph_set_cached_acl(inode, type, acl);
+
+	return acl;
+}
+
+static int ceph_set_acl(struct dentry *dentry, struct inode *inode,
+				struct posix_acl *acl, int type)
+{
+	int ret = 0, size = 0;
+	const char *name = NULL;
+	char *value = NULL;
+	struct iattr newattrs;
+	umode_t new_mode = inode->i_mode, old_mode = inode->i_mode;
+
+	if (acl) {
+		ret = posix_acl_valid(acl);
+		if (ret < 0)
+			goto out;
+	}
+
+	switch (type) {
+	case ACL_TYPE_ACCESS:
+		name = POSIX_ACL_XATTR_ACCESS;
+		if (acl) {
+			ret = posix_acl_equiv_mode(acl, &new_mode);
+			if (ret < 0)
+				goto out;
+			if (ret == 0)
+				acl = NULL;
+		}
+		break;
+	case ACL_TYPE_DEFAULT:
+		if (!S_ISDIR(inode->i_mode)) {
+			ret = acl ? -EINVAL : 0;
+			goto out;
+		}
+		name = POSIX_ACL_XATTR_DEFAULT;
+		break;
+	default:
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (acl) {
+		size = posix_acl_xattr_size(acl->a_count);
+		value = kmalloc(size, GFP_NOFS);
+		if (!value) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
+		if (ret < 0)
+			goto out_free;
+	}
+
+	if (new_mode != old_mode) {
+		newattrs.ia_mode = new_mode;
+		newattrs.ia_valid = ATTR_MODE;
+		ret = ceph_setattr(dentry, &newattrs);
+		if (ret)
+			goto out_free;
+	}
+
+	if (value)
+		ret = __ceph_setxattr(dentry, name, value, size, 0);
+	else
+		ret = __ceph_removexattr(dentry, name);
+
+	if (ret) {
+		if (new_mode != old_mode) {
+			newattrs.ia_mode = old_mode;
+			newattrs.ia_valid = ATTR_MODE;
+			ceph_setattr(dentry, &newattrs);
+		}
+		goto out_free;
+	}
+
+	ceph_set_cached_acl(inode, type, acl);
+
+out_free:
+	kfree(value);
+out:
+	return ret;
+}
+
+int ceph_init_acl(struct dentry *dentry, struct inode *inode, struct inode *dir)
+{
+	struct posix_acl *acl = NULL;
+	int ret = 0;
+
+	if (!S_ISLNK(inode->i_mode)) {
+		if (IS_POSIXACL(dir)) {
+			acl = ceph_get_acl(dir, ACL_TYPE_DEFAULT);
+			if (IS_ERR(acl)) {
+				ret = PTR_ERR(acl);
+				goto out;
+			}
+		}
+
+		if (!acl)
+			inode->i_mode &= ~current_umask();
+	}
+
+	if (IS_POSIXACL(dir) && acl) {
+		if (S_ISDIR(inode->i_mode)) {
+			ret = ceph_set_acl(dentry, inode, acl,
+						ACL_TYPE_DEFAULT);
+			if (ret)
+				goto out_release;
+		}
+		ret = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
+		if (ret < 0)
+			goto out;
+		else if (ret > 0)
+			ret = ceph_set_acl(dentry, inode, acl, ACL_TYPE_ACCESS);
+		else
+			cache_no_acl(inode);
+	} else {
+		cache_no_acl(inode);
+	}
+
+out_release:
+	posix_acl_release(acl);
+out:
+	return ret;
+}
+
+int ceph_acl_chmod(struct dentry *dentry, struct inode *inode)
+{
+	struct posix_acl *acl;
+	int ret = 0;
+
+	if (S_ISLNK(inode->i_mode)) {
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	if (!IS_POSIXACL(inode))
+		goto out;
+
+	acl = ceph_get_acl(inode, ACL_TYPE_ACCESS);
+	if (IS_ERR_OR_NULL(acl)) {
+		ret = PTR_ERR(acl);
+		goto out;
+	}
+
+	ret = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
+	if (ret)
+		goto out;
+	ret = ceph_set_acl(dentry, inode, acl, ACL_TYPE_ACCESS);
+	posix_acl_release(acl);
+out:
+	return ret;
+}
+
+static int ceph_xattr_acl_get(struct dentry *dentry, const char *name,
+				void *value, size_t size, int type)
+{
+	struct posix_acl *acl;
+	int ret = 0;
+
+	if (!IS_POSIXACL(dentry->d_inode))
+		return -EOPNOTSUPP;
+
+	acl = ceph_get_acl(dentry->d_inode, type);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl == NULL)
+		return -ENODATA;
+
+	ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
+	posix_acl_release(acl);
+
+	return ret;
+}
+
+static int ceph_xattr_acl_set(struct dentry *dentry, const char *name,
+			const void *value, size_t size, int flags, int type)
+{
+	int ret = 0;
+	struct posix_acl *acl = NULL;
+
+	if (!inode_owner_or_capable(dentry->d_inode)) {
+		ret = -EPERM;
+		goto out;
+	}
+
+	if (!IS_POSIXACL(dentry->d_inode)) {
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	if (value) {
+		acl = posix_acl_from_xattr(&init_user_ns, value, size);
+		if (IS_ERR(acl)) {
+			ret = PTR_ERR(acl);
+			goto out;
+		}
+
+		if (acl) {
+			ret = posix_acl_valid(acl);
+			if (ret)
+				goto out_release;
+		}
+	}
+
+	ret = ceph_set_acl(dentry, dentry->d_inode, acl, type);
+
+out_release:
+	posix_acl_release(acl);
+out:
+	return ret;
+}
+
+const struct xattr_handler ceph_xattr_acl_default_handler = {
+	.prefix = POSIX_ACL_XATTR_DEFAULT,
+	.flags  = ACL_TYPE_DEFAULT,
+	.get    = ceph_xattr_acl_get,
+	.set    = ceph_xattr_acl_set,
+};
+
+const struct xattr_handler ceph_xattr_acl_access_handler = {
+	.prefix = POSIX_ACL_XATTR_ACCESS,
+	.flags  = ACL_TYPE_ACCESS,
+	.get    = ceph_xattr_acl_get,
+	.set    = ceph_xattr_acl_set,
+};
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index 9f4361838422..dbc492435fe1 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -2703,6 +2703,7 @@ static void handle_cap_grant(struct ceph_mds_client *mdsc,
 				ceph_buffer_put(ci->i_xattrs.blob);
 			ci->i_xattrs.blob = ceph_buffer_get(xattr_buf);
 			ci->i_xattrs.version = version;
+			ceph_forget_all_cached_acls(inode);
 		}
 	}
 
diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c
index 67bdd35eda74..899f4ee8aaf1 100644
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@ -727,6 +727,10 @@ static int ceph_mknod(struct inode *dir, struct dentry *dentry,
 	if (!err && !req->r_reply_info.head->is_dentry)
 		err = ceph_handle_notrace_create(dir, dentry);
 	ceph_mdsc_put_request(req);
+
+	if (!err)
+		err = ceph_init_acl(dentry, dentry->d_inode, dir);
+
 	if (err)
 		d_drop(dentry);
 	return err;
@@ -1354,6 +1358,7 @@ const struct inode_operations ceph_dir_iops = {
 	.getxattr = ceph_getxattr,
 	.listxattr = ceph_listxattr,
 	.removexattr = ceph_removexattr,
+	.get_acl = ceph_get_acl,
 	.mknod = ceph_mknod,
 	.symlink = ceph_symlink,
 	.mkdir = ceph_mkdir,
* Unmerged path fs/ceph/inode.c
diff --git a/fs/ceph/super.c b/fs/ceph/super.c
index 5877616577af..9389ec1d3348 100644
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@ -789,7 +789,11 @@ static int ceph_set_super(struct super_block *s, void *data)
 
 	s->s_flags = fsc->mount_options->sb_flags;
 	s->s_maxbytes = 1ULL << 40;  /* temp value until we get mdsmap */
+#ifdef CONFIG_CEPH_FS_POSIX_ACL
+	s->s_flags |= MS_POSIXACL;
+#endif
 
+	s->s_xattr = ceph_xattr_handlers;
 	s->s_fs_info = fsc;
 	fsc->sb = s;
 
* Unmerged path fs/ceph/super.h
* Unmerged path fs/ceph/xattr.c
