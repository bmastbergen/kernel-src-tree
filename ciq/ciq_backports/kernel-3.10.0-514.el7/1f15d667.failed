i40e/i40evf: Faster RX via avoiding FCoE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 1f15d66712bb64e39fe2c23b1b32f68f9e1d4ee7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1f15d667.failed

As it turns out, calling into other files from hot path hurts
performance a lot.  In this case the majority of the time we
call "check FCoE" and the packet is *not* FCoE, but this call
was taking 5% of our total cycles spent on receive.

Change-ID: I080552c26e7060bc7b78504dc2763f6f0b3d8c76
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 1f15d66712bb64e39fe2c23b1b32f68f9e1d4ee7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.h
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.h
index ae22c4e9162f,77ccdde56c0c..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
@@@ -353,4 -389,73 +353,76 @@@ static inline u32 i40e_get_head(struct 
  
  	return le32_to_cpu(*(volatile __le32 *)head);
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * i40e_xmit_descriptor_count - calculate number of Tx descriptors needed
+  * @skb:     send buffer
+  * @tx_ring: ring to send buffer on
+  *
+  * Returns number of data descriptors needed for this skb. Returns 0 to indicate
+  * there is not enough descriptors available in this ring since we need at least
+  * one descriptor.
+  **/
+ static inline int i40e_xmit_descriptor_count(struct sk_buff *skb)
+ {
+ 	const struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[0];
+ 	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+ 	int count = 0, size = skb_headlen(skb);
+ 
+ 	for (;;) {
+ 		count += i40e_txd_use_count(size);
+ 
+ 		if (!nr_frags--)
+ 			break;
+ 
+ 		size = skb_frag_size(frag++);
+ 	}
+ 
+ 	return count;
+ }
+ 
+ /**
+  * i40e_maybe_stop_tx - 1st level check for Tx stop conditions
+  * @tx_ring: the ring to be checked
+  * @size:    the size buffer we want to assure is available
+  *
+  * Returns 0 if stop is not needed
+  **/
+ static inline int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
+ {
+ 	if (likely(I40E_DESC_UNUSED(tx_ring) >= size))
+ 		return 0;
+ 	return __i40e_maybe_stop_tx(tx_ring, size);
+ }
+ 
+ /**
+  * i40e_chk_linearize - Check if there are more than 8 fragments per packet
+  * @skb:      send buffer
+  * @count:    number of buffers used
+  *
+  * Note: Our HW can't scatter-gather more than 8 fragments to build
+  * a packet on the wire and so we need to figure out the cases where we
+  * need to linearize the skb.
+  **/
+ static inline bool i40e_chk_linearize(struct sk_buff *skb, int count)
+ {
+ 	/* we can only support up to 8 data buffers for a single send */
+ 	if (likely(count <= I40E_MAX_BUFFER_TXD))
+ 		return false;
+ 
+ 	return __i40e_chk_linearize(skb);
+ }
+ 
+ /**
+  * i40e_rx_is_fcoe - returns true if the Rx packet type is FCoE
+  * @ptype: the packet type field from Rx descriptor write-back
+  **/
+ static inline bool i40e_rx_is_fcoe(u16 ptype)
+ {
+ 	return (ptype >= I40E_RX_PTYPE_L2_FCOE_PAY3) &&
+ 	       (ptype <= I40E_RX_PTYPE_L2_FCOE_VFT_FCOTHER);
+ }
++>>>>>>> 1f15d66712bb (i40e/i40evf: Faster RX via avoiding FCoE)
  #endif /* _I40E_TXRX_H_ */
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.h
index 5467fcdf7670,84c28aa64fdf..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
@@@ -341,4 -371,73 +341,76 @@@ static inline u32 i40e_get_head(struct 
  
  	return le32_to_cpu(*(volatile __le32 *)head);
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * i40e_xmit_descriptor_count - calculate number of Tx descriptors needed
+  * @skb:     send buffer
+  * @tx_ring: ring to send buffer on
+  *
+  * Returns number of data descriptors needed for this skb. Returns 0 to indicate
+  * there is not enough descriptors available in this ring since we need at least
+  * one descriptor.
+  **/
+ static inline int i40e_xmit_descriptor_count(struct sk_buff *skb)
+ {
+ 	const struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[0];
+ 	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+ 	int count = 0, size = skb_headlen(skb);
+ 
+ 	for (;;) {
+ 		count += i40e_txd_use_count(size);
+ 
+ 		if (!nr_frags--)
+ 			break;
+ 
+ 		size = skb_frag_size(frag++);
+ 	}
+ 
+ 	return count;
+ }
+ 
+ /**
+  * i40e_maybe_stop_tx - 1st level check for Tx stop conditions
+  * @tx_ring: the ring to be checked
+  * @size:    the size buffer we want to assure is available
+  *
+  * Returns 0 if stop is not needed
+  **/
+ static inline int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
+ {
+ 	if (likely(I40E_DESC_UNUSED(tx_ring) >= size))
+ 		return 0;
+ 	return __i40evf_maybe_stop_tx(tx_ring, size);
+ }
+ 
+ /**
+  * i40e_chk_linearize - Check if there are more than 8 fragments per packet
+  * @skb:      send buffer
+  * @count:    number of buffers used
+  *
+  * Note: Our HW can't scatter-gather more than 8 fragments to build
+  * a packet on the wire and so we need to figure out the cases where we
+  * need to linearize the skb.
+  **/
+ static inline bool i40e_chk_linearize(struct sk_buff *skb, int count)
+ {
+ 	/* we can only support up to 8 data buffers for a single send */
+ 	if (likely(count <= I40E_MAX_BUFFER_TXD))
+ 		return false;
+ 
+ 	return __i40evf_chk_linearize(skb);
+ }
+ 
+ /**
+  * i40e_rx_is_fcoe - returns true if the Rx packet type is FCoE
+  * @ptype: the packet type field from Rx descriptor write-back
+  **/
+ static inline bool i40e_rx_is_fcoe(u16 ptype)
+ {
+ 	return (ptype >= I40E_RX_PTYPE_L2_FCOE_PAY3) &&
+ 	       (ptype <= I40E_RX_PTYPE_L2_FCOE_VFT_FCOTHER);
+ }
++>>>>>>> 1f15d66712bb (i40e/i40evf: Faster RX via avoiding FCoE)
  #endif /* _I40E_TXRX_H_ */
diff --git a/drivers/net/ethernet/intel/i40e/i40e_fcoe.c b/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
index e61646fcfb11..294f8695b676 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Intel Ethernet Controller XL710 Family Linux Driver
- * Copyright(c) 2013 - 2015 Intel Corporation.
+ * Copyright(c) 2013 - 2016 Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -37,16 +37,6 @@
 #include "i40e.h"
 #include "i40e_fcoe.h"
 
-/**
- * i40e_rx_is_fcoe - returns true if the rx packet type is FCoE
- * @ptype: the packet type field from rx descriptor write-back
- **/
-static inline bool i40e_rx_is_fcoe(u16 ptype)
-{
-	return (ptype >= I40E_RX_PTYPE_L2_FCOE_PAY3) &&
-	       (ptype <= I40E_RX_PTYPE_L2_FCOE_VFT_FCOTHER);
-}
-
 /**
  * i40e_fcoe_sof_is_class2 - returns true if this is a FC Class 2 SOF
  * @sof: the FCoE start of frame delimiter
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 025ceb57680d..902626ca1d59 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -1731,7 +1731,9 @@ static int i40e_clean_rx_irq_ps(struct i40e_ring *rx_ring, const int budget)
 			 ? le16_to_cpu(rx_desc->wb.qword0.lo_dword.l2tag1)
 			 : 0;
 #ifdef I40E_FCOE
-		if (!i40e_fcoe_handle_offload(rx_ring, rx_desc, skb)) {
+		if (unlikely(
+		    i40e_rx_is_fcoe(rx_ptype) &&
+		    !i40e_fcoe_handle_offload(rx_ring, rx_desc, skb))) {
 			dev_kfree_skb_any(skb);
 			continue;
 		}
@@ -1863,7 +1865,9 @@ static int i40e_clean_rx_irq_1buf(struct i40e_ring *rx_ring, int budget)
 			 ? le16_to_cpu(rx_desc->wb.qword0.lo_dword.l2tag1)
 			 : 0;
 #ifdef I40E_FCOE
-		if (!i40e_fcoe_handle_offload(rx_ring, rx_desc, skb)) {
+		if (unlikely(
+		    i40e_rx_is_fcoe(rx_ptype) &&
+		    !i40e_fcoe_handle_offload(rx_ring, rx_desc, skb))) {
 			dev_kfree_skb_any(skb);
 			continue;
 		}
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.h
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index 0c3ce26cb67a..71d6576a2951 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@ -1184,7 +1184,9 @@ static int i40e_clean_rx_irq_ps(struct i40e_ring *rx_ring, const int budget)
 			 ? le16_to_cpu(rx_desc->wb.qword0.lo_dword.l2tag1)
 			 : 0;
 #ifdef I40E_FCOE
-		if (!i40e_fcoe_handle_offload(rx_ring, rx_desc, skb)) {
+		if (unlikely(
+		    i40e_rx_is_fcoe(rx_ptype) &&
+		    !i40e_fcoe_handle_offload(rx_ring, rx_desc, skb))) {
 			dev_kfree_skb_any(skb);
 			continue;
 		}
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.h
