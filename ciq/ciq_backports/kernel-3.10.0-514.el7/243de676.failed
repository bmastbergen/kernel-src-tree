qla2xxx: Add support for Private link statistics counters.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add support for Private link statistics counters (Chad Dupuis) [1273080]
Rebuild_FUZZ: 99.13%
commit-author Harish Zunjarrao <harish.zunjarrao@qlogic.com>
commit 243de6768db50266f595ec62c5ae34783edb72ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/243de676.failed

	Signed-off-by: Harish Zunjarrao <harish.zunjarrao@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 243de6768db50266f595ec62c5ae34783edb72ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_bsg.c
#	drivers/scsi/qla2xxx/qla_bsg.h
#	drivers/scsi/qla2xxx/qla_dbg.c
diff --cc drivers/scsi/qla2xxx/qla_bsg.c
index e1c2a57a882f,913fef20cd68..000000000000
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@@ -2110,6 -2107,190 +2110,193 @@@ qla8044_serdes_op(struct fc_bsg_job *bs
  }
  
  static int
++<<<<<<< HEAD
++=======
+ qla27xx_get_flash_upd_cap(struct fc_bsg_job *bsg_job)
+ {
+ 	struct Scsi_Host *host = bsg_job->shost;
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_flash_update_caps cap;
+ 
+ 	if (!(IS_QLA27XX(ha)))
+ 		return -EPERM;
+ 
+ 	memset(&cap, 0, sizeof(cap));
+ 	cap.capabilities = (uint64_t)ha->fw_attributes_ext[1] << 48 |
+ 			   (uint64_t)ha->fw_attributes_ext[0] << 32 |
+ 			   (uint64_t)ha->fw_attributes_h << 16 |
+ 			   (uint64_t)ha->fw_attributes;
+ 
+ 	sg_copy_from_buffer(bsg_job->reply_payload.sg_list,
+ 	    bsg_job->reply_payload.sg_cnt, &cap, sizeof(cap));
+ 	bsg_job->reply->reply_payload_rcv_len = sizeof(cap);
+ 
+ 	bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 	    EXT_STATUS_OK;
+ 
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	bsg_job->reply->result = DID_OK << 16;
+ 	bsg_job->job_done(bsg_job);
+ 	return 0;
+ }
+ 
+ static int
+ qla27xx_set_flash_upd_cap(struct fc_bsg_job *bsg_job)
+ {
+ 	struct Scsi_Host *host = bsg_job->shost;
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint64_t online_fw_attr = 0;
+ 	struct qla_flash_update_caps cap;
+ 
+ 	if (!(IS_QLA27XX(ha)))
+ 		return -EPERM;
+ 
+ 	memset(&cap, 0, sizeof(cap));
+ 	sg_copy_to_buffer(bsg_job->request_payload.sg_list,
+ 	    bsg_job->request_payload.sg_cnt, &cap, sizeof(cap));
+ 
+ 	online_fw_attr = (uint64_t)ha->fw_attributes_ext[1] << 48 |
+ 			 (uint64_t)ha->fw_attributes_ext[0] << 32 |
+ 			 (uint64_t)ha->fw_attributes_h << 16 |
+ 			 (uint64_t)ha->fw_attributes;
+ 
+ 	if (online_fw_attr != cap.capabilities) {
+ 		bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 		    EXT_STATUS_INVALID_PARAM;
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (cap.outage_duration < MAX_LOOP_TIMEOUT)  {
+ 		bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 		    EXT_STATUS_INVALID_PARAM;
+ 		return -EINVAL;
+ 	}
+ 
+ 	bsg_job->reply->reply_payload_rcv_len = 0;
+ 
+ 	bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 	    EXT_STATUS_OK;
+ 
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	bsg_job->reply->result = DID_OK << 16;
+ 	bsg_job->job_done(bsg_job);
+ 	return 0;
+ }
+ 
+ static int
+ qla27xx_get_bbcr_data(struct fc_bsg_job *bsg_job)
+ {
+ 	struct Scsi_Host *host = bsg_job->shost;
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_bbcr_data bbcr;
+ 	uint16_t loop_id, topo, sw_cap;
+ 	uint8_t domain, area, al_pa, state;
+ 	int rval;
+ 
+ 	if (!(IS_QLA27XX(ha)))
+ 		return -EPERM;
+ 
+ 	memset(&bbcr, 0, sizeof(bbcr));
+ 
+ 	if (vha->flags.bbcr_enable)
+ 		bbcr.status = QLA_BBCR_STATUS_ENABLED;
+ 	else
+ 		bbcr.status = QLA_BBCR_STATUS_DISABLED;
+ 
+ 	if (bbcr.status == QLA_BBCR_STATUS_ENABLED) {
+ 		rval = qla2x00_get_adapter_id(vha, &loop_id, &al_pa,
+ 			&area, &domain, &topo, &sw_cap);
+ 		if (rval != QLA_SUCCESS)
+ 			return -EIO;
+ 
+ 		state = (vha->bbcr >> 12) & 0x1;
+ 
+ 		if (state) {
+ 			bbcr.state = QLA_BBCR_STATE_OFFLINE;
+ 			bbcr.offline_reason_code = QLA_BBCR_REASON_LOGIN_REJECT;
+ 		} else {
+ 			bbcr.state = QLA_BBCR_STATE_ONLINE;
+ 			bbcr.negotiated_bbscn = (vha->bbcr >> 8) & 0xf;
+ 		}
+ 
+ 		bbcr.configured_bbscn = vha->bbcr & 0xf;
+ 	}
+ 
+ 	sg_copy_from_buffer(bsg_job->reply_payload.sg_list,
+ 		bsg_job->reply_payload.sg_cnt, &bbcr, sizeof(bbcr));
+ 	bsg_job->reply->reply_payload_rcv_len = sizeof(bbcr);
+ 
+ 	bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;
+ 
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	bsg_job->reply->result = DID_OK << 16;
+ 	bsg_job->job_done(bsg_job);
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_get_priv_stats(struct fc_bsg_job *bsg_job)
+ {
+ 	struct Scsi_Host *host = bsg_job->shost;
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
+ 	struct link_statistics *stats = NULL;
+ 	dma_addr_t stats_dma;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		goto done;
+ 
+ 	if (unlikely(pci_channel_offline(ha->pdev)))
+ 		goto done;
+ 
+ 	if (qla2x00_reset_active(vha))
+ 		goto done;
+ 
+ 	if (!IS_FWI2_CAPABLE(ha))
+ 		goto done;
+ 
+ 	stats = dma_alloc_coherent(&ha->pdev->dev,
+ 		sizeof(struct link_statistics), &stats_dma, GFP_KERNEL);
+ 	if (!stats) {
+ 		ql_log(ql_log_warn, vha, 0x70e2,
+ 		"Failed to allocate memory for stats.\n");
+ 		goto done;
+ 	}
+ 
+ 	memset(stats, 0, sizeof(struct link_statistics));
+ 
+ 	rval = qla24xx_get_isp_stats(base_vha, stats, stats_dma);
+ 
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free;
+ 
+ 	ql_dump_buffer(ql_dbg_user + ql_dbg_verbose, vha, 0x70e3,
+ 	    (uint8_t *)stats, sizeof(struct link_statistics));
+ 
+ 	sg_copy_from_buffer(bsg_job->reply_payload.sg_list,
+ 	bsg_job->reply_payload.sg_cnt, stats, sizeof(struct link_statistics));
+ 	bsg_job->reply->reply_payload_rcv_len = sizeof(struct link_statistics);
+ 
+ 	bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;
+ 
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	bsg_job->reply->result = DID_OK << 16;
+ 	bsg_job->job_done(bsg_job);
+ 
+ done_free:
+ 	dma_free_coherent(&ha->pdev->dev, sizeof(struct link_statistics),
+ 		stats, stats_dma);
+ done:
+ 	return rval;
+ }
+ 
+ static int
++>>>>>>> 243de6768db5 (qla2xxx: Add support for Private link statistics counters.)
  qla2x00_process_vendor_specific(struct fc_bsg_job *bsg_job)
  {
  	switch (bsg_job->request->rqst_data.h_vendor.vendor_cmd[0]) {
@@@ -2164,6 -2345,18 +2351,21 @@@
  	case QL_VND_SERDES_OP_EX:
  		return qla8044_serdes_op(bsg_job);
  
++<<<<<<< HEAD
++=======
+ 	case QL_VND_GET_FLASH_UPDATE_CAPS:
+ 		return qla27xx_get_flash_upd_cap(bsg_job);
+ 
+ 	case QL_VND_SET_FLASH_UPDATE_CAPS:
+ 		return qla27xx_set_flash_upd_cap(bsg_job);
+ 
+ 	case QL_VND_GET_BBCR_DATA:
+ 		return qla27xx_get_bbcr_data(bsg_job);
+ 
+ 	case QL_VND_GET_PRIV_STATS:
+ 		return qla2x00_get_priv_stats(bsg_job);
+ 
++>>>>>>> 243de6768db5 (qla2xxx: Add support for Private link statistics counters.)
  	default:
  		return -ENOSYS;
  	}
diff --cc drivers/scsi/qla2xxx/qla_bsg.h
index d38f9efa56fa,c40dd8b608a0..000000000000
--- a/drivers/scsi/qla2xxx/qla_bsg.h
+++ b/drivers/scsi/qla2xxx/qla_bsg.h
@@@ -25,6 -25,10 +25,13 @@@
  #define QL_VND_FX00_MGMT_CMD	0x12
  #define QL_VND_SERDES_OP	0x13
  #define	QL_VND_SERDES_OP_EX	0x14
++<<<<<<< HEAD
++=======
+ #define QL_VND_GET_FLASH_UPDATE_CAPS    0x15
+ #define QL_VND_SET_FLASH_UPDATE_CAPS    0x16
+ #define QL_VND_GET_BBCR_DATA    0x17
+ #define QL_VND_GET_PRIV_STATS	0x18
++>>>>>>> 243de6768db5 (qla2xxx: Add support for Private link statistics counters.)
  
  /* BSG Vendor specific subcode returns */
  #define EXT_STATUS_OK			0
diff --cc drivers/scsi/qla2xxx/qla_dbg.c
index a623e74ec209,aa6694bbc303..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@@ -32,7 -32,7 +32,11 @@@
   * |                              |                    | 0x503d,0x5044  |
   * |                              |                    | 0x507b,0x505f	|
   * | Timer Routines               |       0x6012       |                |
++<<<<<<< HEAD
 + * | User Space Interactions      |       0x70e2       | 0x7018,0x702e  |
++=======
+  * | User Space Interactions      |       0x70e3       | 0x7018,0x702e  |
++>>>>>>> 243de6768db5 (qla2xxx: Add support for Private link statistics counters.)
   * |				  |		       | 0x7020,0x7024  |
   * |                              |                    | 0x7039,0x7045  |
   * |                              |                    | 0x7073-0x7075  |
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index 8a17e5ab672d..d48a0cfae8a5 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -1876,7 +1876,8 @@ qla2x00_get_fc_host_stats(struct Scsi_Host *shost)
 	if (qla2x00_reset_active(vha))
 		goto done;
 
-	stats = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &stats_dma);
+	stats = dma_alloc_coherent(&ha->pdev->dev,
+	    sizeof(struct link_statistics), &stats_dma, GFP_KERNEL);
 	if (stats == NULL) {
 		ql_log(ql_log_warn, vha, 0x707d,
 		    "Failed to allocate memory for stats.\n");
@@ -1924,7 +1925,8 @@ qla2x00_get_fc_host_stats(struct Scsi_Host *shost)
 	do_div(pfc_host_stat->seconds_since_last_reset, HZ);
 
 done_free:
-        dma_pool_free(ha->s_dma_pool, stats, stats_dma);
+	dma_free_coherent(&ha->pdev->dev, sizeof(struct link_statistics),
+	    stats, stats_dma);
 done:
 	return pfc_host_stat;
 }
* Unmerged path drivers/scsi/qla2xxx/qla_bsg.c
* Unmerged path drivers/scsi/qla2xxx/qla_bsg.h
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.c
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 03748dc366c8..6e574e5906f1 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -1226,13 +1226,41 @@ struct link_statistics {
 	uint32_t inval_xmit_word_cnt;
 	uint32_t inval_crc_cnt;
 	uint32_t lip_cnt;
-	uint32_t unused1[0x1a];
+	uint32_t link_up_cnt;
+	uint32_t link_down_loop_init_tmo;
+	uint32_t link_down_los;
+	uint32_t link_down_loss_rcv_clk;
+	uint32_t reserved0[5];
+	uint32_t port_cfg_chg;
+	uint32_t reserved1[11];
+	uint32_t rsp_q_full;
+	uint32_t atio_q_full;
+	uint32_t drop_ae;
+	uint32_t els_proto_err;
+	uint32_t reserved2;
 	uint32_t tx_frames;
 	uint32_t rx_frames;
 	uint32_t discarded_frames;
 	uint32_t dropped_frames;
-	uint32_t unused2[1];
+	uint32_t reserved3;
 	uint32_t nos_rcvd;
+	uint32_t reserved4[4];
+	uint32_t tx_prjt;
+	uint32_t rcv_exfail;
+	uint32_t rcv_abts;
+	uint32_t seq_frm_miss;
+	uint32_t corr_err;
+	uint32_t mb_rqst;
+	uint32_t nport_full;
+	uint32_t eofa;
+	uint32_t reserved5;
+	uint32_t fpm_recv_word_cnt_lo;
+	uint32_t fpm_recv_word_cnt_hi;
+	uint32_t fpm_disc_word_cnt_lo;
+	uint32_t fpm_disc_word_cnt_hi;
+	uint32_t fpm_xmit_word_cnt_lo;
+	uint32_t fpm_xmit_word_cnt_hi;
+	uint32_t reserved6[70];
 };
 
 /*
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 8b15a8c6f98d..32bcd8601956 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -2564,7 +2564,8 @@ qla2x00_get_link_status(scsi_qla_host_t *vha, uint16_t loop_id,
 			/* Copy over data -- firmware data is LE. */
 			ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1086,
 			    "Done %s.\n", __func__);
-			dwords = offsetof(struct link_statistics, unused1) / 4;
+			dwords = offsetof(struct link_statistics,
+					link_up_cnt) / 4;
 			siter = diter = &stats->link_fail_cnt;
 			while (dwords--)
 				*diter++ = le32_to_cpu(*siter++);
