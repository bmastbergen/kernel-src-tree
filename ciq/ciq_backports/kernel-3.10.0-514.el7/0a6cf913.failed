ext2, ext4: only set S_DAX for regular inodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ross Zwisler <ross.zwisler@linux.intel.com>
commit 0a6cf9137ded4856b41910a4336677ee0ffa6736
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0a6cf913.failed

When S_DAX is set on an inode we assume that if there are pages attached
to the mapping (mapping->nrpages != 0), those pages are clean zero pages
that were used to service reads from holes.  Any dirty data associated
with the inode should be in the form of DAX exceptional entries
(mapping->nrexceptional) that is written back via
dax_writeback_mapping_range().

With the current code, though, this isn't always true.  For example,
ext2 and ext4 directory inodes can have S_DAX set, but have their dirty
data stored as dirty page cache entries.  For these types of inodes,
having S_DAX set doesn't really make sense since their I/O doesn't
actually happen through the DAX code path.

Instead, only allow S_DAX to be set for regular inodes for ext2 and
ext4.  This allows us to have strict DAX vs non-DAX paths in the
writeback code.

	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Cc: Al Viro <viro@ftp.linux.org.uk>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Jens Axboe <axboe@fb.com>
	Cc: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0a6cf9137ded4856b41910a4336677ee0ffa6736)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext2/inode.c
#	fs/ext4/inode.c
diff --cc fs/ext2/inode.c
index 115fa58bb9ae,27e2cdd4999b..000000000000
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@@ -1282,6 -1296,8 +1282,11 @@@ void ext2_set_inode_flags(struct inode 
  		inode->i_flags |= S_NOATIME;
  	if (flags & EXT2_DIRSYNC_FL)
  		inode->i_flags |= S_DIRSYNC;
++<<<<<<< HEAD
++=======
+ 	if (test_opt(inode->i_sb, DAX) && S_ISREG(inode->i_mode))
+ 		inode->i_flags |= S_DAX;
++>>>>>>> 0a6cf9137ded (ext2, ext4: only set S_DAX for regular inodes)
  }
  
  /* Propagate flags from i_flags to EXT2_I(inode)->i_flags */
diff --cc fs/ext4/inode.c
index 235a73f02c8d,5708e689e63d..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -3866,8 -4155,10 +3866,13 @@@ void ext4_set_inode_flags(struct inode 
  		new_fl |= S_NOATIME;
  	if (flags & EXT4_DIRSYNC_FL)
  		new_fl |= S_DIRSYNC;
++<<<<<<< HEAD
++=======
+ 	if (test_opt(inode->i_sb, DAX) && S_ISREG(inode->i_mode))
+ 		new_fl |= S_DAX;
++>>>>>>> 0a6cf9137ded (ext2, ext4: only set S_DAX for regular inodes)
  	inode_set_flags(inode, new_fl,
 -			S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);
 +			S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
  }
  
  /* Propagate flags from i_flags to EXT4_I(inode)->i_flags */
* Unmerged path fs/ext2/inode.c
* Unmerged path fs/ext4/inode.c
