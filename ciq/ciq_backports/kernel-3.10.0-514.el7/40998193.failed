scsi: restart list search after unlock in scsi_remove_target

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [scsi] Revert: restart list search after unlock in scsi_remove_target (Ewan Milne) [1369084]
Rebuild_FUZZ: 91.80%
commit-author Christoph Hellwig <hch@lst.de>
commit 40998193560dab6c3ce8d25f4fa58a23e252ef38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/40998193.failed

When dropping a lock while iterating a list we must restart the search
as other threads could have manipulated the list under us.  Without this
we can get stuck in an endless loop.  This bug was introduced by

commit bc3f02a795d3b4faa99d37390174be2a75d091bd
Author: Dan Williams <djbw@fb.com>
Date:   Tue Aug 28 22:12:10 2012 -0700

    [SCSI] scsi_remove_target: fix softlockup regression on hot remove

Which was itself trying to fix a reported soft lockup issue

http://thread.gmane.org/gmane.linux.kernel/1348679

However, we believe even with this revert of the original patch, the soft
lockup problem has been fixed by

commit f2495e228fce9f9cec84367547813cbb0d6db15a
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Tue Jan 21 07:01:41 2014 -0800

    [SCSI] dual scan thread bug fix

Thanks go to Dan Williams <dan.j.williams@intel.com> for tracking all this
prior history down.

	Reported-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
Fixes: bc3f02a795d3b4faa99d37390174be2a75d091bd
	Cc: stable@vger.kernel.org
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 40998193560dab6c3ce8d25f4fa58a23e252ef38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_sysfs.c
diff --cc drivers/scsi/scsi_sysfs.c
index 97a026ae730c,d3b34d871f4c..000000000000
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@@ -1261,14 -1167,11 +1259,16 @@@ restart
  		if (starget->state == STARGET_DEL)
  			continue;
  		if (starget->dev.parent == dev || &starget->dev == dev) {
++<<<<<<< HEAD
 +			/* assuming new targets arrive at the end */
 +			starget->reap_ref++;
++=======
+ 			kref_get(&starget->reap_ref);
++>>>>>>> 40998193560d (scsi: restart list search after unlock in scsi_remove_target)
  			spin_unlock_irqrestore(shost->host_lock, flags);
- 			if (last)
- 				scsi_target_reap(last);
- 			last = starget;
  			__scsi_remove_target(starget);
- 			spin_lock_irqsave(shost->host_lock, flags);
+ 			scsi_target_reap(starget);
+ 			goto restart;
  		}
  	}
  	spin_unlock_irqrestore(shost->host_lock, flags);
* Unmerged path drivers/scsi/scsi_sysfs.c
