ACPI / property: Define a symbol for PRP0001

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit ee89209402e0b9a733169901063afdf0ae7909db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ee892094.failed

Use a #defined symbol ACPI_DT_NAMESPACE_HID instead of the PRP0001
string.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
(cherry picked from commit ee89209402e0b9a733169901063afdf0ae7909db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/property.c
#	drivers/acpi/scan.c
diff --cc drivers/acpi/property.c
index 2541b1fd1fa5,7836e2e980f4..000000000000
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@@ -83,6 -109,17 +83,20 @@@ void acpi_init_properties(struct acpi_d
  	acpi_status status;
  	int i;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Check if ACPI_DT_NAMESPACE_HID is present and inthat case we fill in
+ 	 * Device Tree compatible properties for this device.
+ 	 */
+ 	list_for_each_entry(hwid, &adev->pnp.ids, list) {
+ 		if (!strcmp(hwid->id, ACPI_DT_NAMESPACE_HID)) {
+ 			acpi_of = true;
+ 			break;
+ 		}
+ 	}
+ 
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  	status = acpi_evaluate_object_typed(adev->handle, "_DSD", NULL, &buf,
  					    ACPI_TYPE_PACKAGE);
  	if (ACPI_FAILURE(status))
@@@ -123,8 -164,13 +137,16 @@@
  	}
  
   fail:
 -	dev_dbg(&adev->dev, "Returned _DSD data is not valid, skipping\n");
 +	dev_warn(&adev->dev, "Returned _DSD data is not valid, skipping\n");
  	ACPI_FREE(buf.pointer);
++<<<<<<< HEAD
++=======
+ 
+  out:
+ 	if (acpi_of && !adev->flags.of_compatible_ok)
+ 		acpi_handle_info(adev->handle,
+ 			 ACPI_DT_NAMESPACE_HID " requires 'compatible' property\n");
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  }
  
  void acpi_free_properties(struct acpi_device *adev)
diff --cc drivers/acpi/scan.c
index b64d638cf134,b19283b336c7..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -123,18 -134,36 +123,38 @@@ static int create_modalias(struct acpi_
  	int count;
  	struct acpi_hardware_id *id;
  
++<<<<<<< HEAD
 +	if (list_empty(&acpi_dev->pnp.ids))
++=======
+ 	/*
+ 	 * Since we skip ACPI_DT_NAMESPACE_HID from the modalias below, 0 should
+ 	 * be returned if ACPI_DT_NAMESPACE_HID is the only ACPI/PNP ID in the
+ 	 * device's list.
+ 	 */
+ 	count = 0;
+ 	list_for_each_entry(id, &acpi_dev->pnp.ids, list)
+ 		if (strcmp(id->id, ACPI_DT_NAMESPACE_HID))
+ 			count++;
+ 
+ 	if (!count)
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  		return 0;
  
  	len = snprintf(modalias, size, "acpi:");
  	size -= len;
  
  	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
++<<<<<<< HEAD
++=======
+ 		if (!strcmp(id->id, ACPI_DT_NAMESPACE_HID))
+ 			continue;
+ 
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  		count = snprintf(&modalias[len], size, "%s:", id->id);
  		if (count < 0)
 -			return -EINVAL;
 -
 +			return EINVAL;
  		if (count >= size)
  			return -ENOMEM;
 -
  		len += count;
  		size -= count;
  	}
@@@ -143,16 -171,204 +163,214 @@@
  	return len;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * create_of_modalias - Creates DT compatible string for modalias and uevent
+  * @acpi_dev: ACPI device object.
+  * @modalias: Buffer to print into.
+  * @size: Size of the buffer.
+  *
+  * Expose DT compatible modalias as of:NnameTCcompatible.  This function should
+  * only be called for devices having ACPI_DT_NAMESPACE_HID in their list of
+  * ACPI/PNP IDs.
+  */
+ static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
+ 			      int size)
+ {
+ 	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+ 	const union acpi_object *of_compatible, *obj;
+ 	int len, count;
+ 	int i, nval;
+ 	char *c;
+ 
+ 	acpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);
+ 	/* DT strings are all in lower case */
+ 	for (c = buf.pointer; *c != '\0'; c++)
+ 		*c = tolower(*c);
+ 
+ 	len = snprintf(modalias, size, "of:N%sT", (char *)buf.pointer);
+ 	ACPI_FREE(buf.pointer);
+ 
+ 	if (len <= 0)
+ 		return len;
+ 
+ 	of_compatible = acpi_dev->data.of_compatible;
+ 	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+ 		nval = of_compatible->package.count;
+ 		obj = of_compatible->package.elements;
+ 	} else { /* Must be ACPI_TYPE_STRING. */
+ 		nval = 1;
+ 		obj = of_compatible;
+ 	}
+ 	for (i = 0; i < nval; i++, obj++) {
+ 		count = snprintf(&modalias[len], size, "C%s",
+ 				 obj->string.pointer);
+ 		if (count < 0)
+ 			return -EINVAL;
+ 
+ 		if (count >= size)
+ 			return -ENOMEM;
+ 
+ 		len += count;
+ 		size -= count;
+ 	}
+ 	modalias[len] = '\0';
+ 	return len;
+ }
+ 
+ /*
+  * acpi_companion_match() - Can we match via ACPI companion device
+  * @dev: Device in question
+  *
+  * Check if the given device has an ACPI companion and if that companion has
+  * a valid list of PNP IDs, and if the device is the first (primary) physical
+  * device associated with it.  Return the companion pointer if that's the case
+  * or NULL otherwise.
+  *
+  * If multiple physical devices are attached to a single ACPI companion, we need
+  * to be careful.  The usage scenario for this kind of relationship is that all
+  * of the physical devices in question use resources provided by the ACPI
+  * companion.  A typical case is an MFD device where all the sub-devices share
+  * the parent's ACPI companion.  In such cases we can only allow the primary
+  * (first) physical device to be matched with the help of the companion's PNP
+  * IDs.
+  *
+  * Additional physical devices sharing the ACPI companion can still use
+  * resources available from it but they will be matched normally using functions
+  * provided by their bus types (and analogously for their modalias).
+  */
+ static struct acpi_device *acpi_companion_match(const struct device *dev)
+ {
+ 	struct acpi_device *adev;
+ 	struct mutex *physical_node_lock;
+ 
+ 	adev = ACPI_COMPANION(dev);
+ 	if (!adev)
+ 		return NULL;
+ 
+ 	if (list_empty(&adev->pnp.ids))
+ 		return NULL;
+ 
+ 	physical_node_lock = &adev->physical_node_lock;
+ 	mutex_lock(physical_node_lock);
+ 	if (list_empty(&adev->physical_node_list)) {
+ 		adev = NULL;
+ 	} else {
+ 		const struct acpi_device_physical_node *node;
+ 
+ 		node = list_first_entry(&adev->physical_node_list,
+ 					struct acpi_device_physical_node, node);
+ 		if (node->dev != dev)
+ 			adev = NULL;
+ 	}
+ 	mutex_unlock(physical_node_lock);
+ 
+ 	return adev;
+ }
+ 
+ static int __acpi_device_uevent_modalias(struct acpi_device *adev,
+ 					 struct kobj_uevent_env *env)
+ {
+ 	int len;
+ 
+ 	if (!adev)
+ 		return -ENODEV;
+ 
+ 	if (list_empty(&adev->pnp.ids))
+ 		return 0;
+ 
+ 	if (add_uevent_var(env, "MODALIAS="))
+ 		return -ENOMEM;
+ 
+ 	len = create_pnp_modalias(adev, &env->buf[env->buflen - 1],
+ 				  sizeof(env->buf) - env->buflen);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	env->buflen += len;
+ 	if (!adev->data.of_compatible)
+ 		return 0;
+ 
+ 	if (len > 0 && add_uevent_var(env, "MODALIAS="))
+ 		return -ENOMEM;
+ 
+ 	len = create_of_modalias(adev, &env->buf[env->buflen - 1],
+ 				 sizeof(env->buf) - env->buflen);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	env->buflen += len;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Creates uevent modalias field for ACPI enumerated devices.
+  * Because the other buses does not support ACPI HIDs & CIDs.
+  * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+  * "acpi:IBM0001:ACPI0001"
+  */
+ int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	return __acpi_device_uevent_modalias(acpi_companion_match(dev), env);
+ }
+ EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
+ 
+ static int __acpi_device_modalias(struct acpi_device *adev, char *buf, int size)
+ {
+ 	int len, count;
+ 
+ 	if (!adev)
+ 		return -ENODEV;
+ 
+ 	if (list_empty(&adev->pnp.ids))
+ 		return 0;
+ 
+ 	len = create_pnp_modalias(adev, buf, size - 1);
+ 	if (len < 0) {
+ 		return len;
+ 	} else if (len > 0) {
+ 		buf[len++] = '\n';
+ 		size -= len;
+ 	}
+ 	if (!adev->data.of_compatible)
+ 		return len;
+ 
+ 	count = create_of_modalias(adev, buf + len, size - 1);
+ 	if (count < 0) {
+ 		return count;
+ 	} else if (count > 0) {
+ 		len += count;
+ 		buf[len++] = '\n';
+ 	}
+ 
+ 	return len;
+ }
+ 
+ /*
+  * Creates modalias sysfs attribute for ACPI enumerated devices.
+  * Because the other buses does not support ACPI HIDs & CIDs.
+  * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+  * "acpi:IBM0001:ACPI0001"
+  */
+ int acpi_device_modalias(struct device *dev, char *buf, int size)
+ {
+ 	return __acpi_device_modalias(acpi_companion_match(dev), buf, size);
+ }
+ EXPORT_SYMBOL_GPL(acpi_device_modalias);
+ 
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  static ssize_t
  acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf) {
 -	return __acpi_device_modalias(to_acpi_device(dev), buf, 1024);
 +	struct acpi_device *acpi_dev = to_acpi_device(dev);
 +	int len;
 +
 +	len = create_modalias(acpi_dev, buf, 1024);
 +	if (len <= 0)
 +		return len;
 +	buf[len++] = '\n';
 +	return len;
  }
  static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
  
@@@ -757,8 -977,51 +975,52 @@@ static void acpi_device_remove_files(st
  			ACPI Bus operations
     -------------------------------------------------------------------------- */
  
++<<<<<<< HEAD
++=======
+ /**
+  * acpi_of_match_device - Match device object using the "compatible" property.
+  * @adev: ACPI device object to match.
+  * @of_match_table: List of device IDs to match against.
+  *
+  * If @dev has an ACPI companion which has ACPI_DT_NAMESPACE_HID in its list of
+  * identifiers and a _DSD object with the "compatible" property, use that
+  * property to match against the given list of identifiers.
+  */
+ static bool acpi_of_match_device(struct acpi_device *adev,
+ 				 const struct of_device_id *of_match_table)
+ {
+ 	const union acpi_object *of_compatible, *obj;
+ 	int i, nval;
+ 
+ 	if (!adev)
+ 		return false;
+ 
+ 	of_compatible = adev->data.of_compatible;
+ 	if (!of_match_table || !of_compatible)
+ 		return false;
+ 
+ 	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+ 		nval = of_compatible->package.count;
+ 		obj = of_compatible->package.elements;
+ 	} else { /* Must be ACPI_TYPE_STRING. */
+ 		nval = 1;
+ 		obj = of_compatible;
+ 	}
+ 	/* Now we can look for the driver DT compatible strings */
+ 	for (i = 0; i < nval; i++, obj++) {
+ 		const struct of_device_id *id;
+ 
+ 		for (id = of_match_table; id->compatible[0]; id++)
+ 			if (!strcasecmp(obj->string.pointer, id->compatible))
+ 				return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  static const struct acpi_device_id *__acpi_match_device(
 -	struct acpi_device *device,
 -	const struct acpi_device_id *ids,
 -	const struct of_device_id *of_ids)
 +	struct acpi_device *device, const struct acpi_device_id *ids)
  {
  	const struct acpi_device_id *id;
  	struct acpi_hardware_id *hwid;
@@@ -775,6 -1039,18 +1037,21 @@@
  			if (!strcmp((char *) id->id, hwid->id))
  				return id;
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * Next, check ACPI_DT_NAMESPACE_HID and try to match the
+ 		 * "compatible" property if found.
+ 		 *
+ 		 * The id returned by the below is not valid, but the only
+ 		 * caller passing non-NULL of_ids here is only interested in
+ 		 * whether or not the return value is NULL.
+ 		 */
+ 		if (!strcmp(ACPI_DT_NAMESPACE_HID, hwid->id)
+ 		    && acpi_of_match_device(device, of_ids))
+ 			return id;
+ 	}
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  	return NULL;
  }
  
@@@ -2001,6 -2371,64 +2278,67 @@@ static acpi_status acpi_bus_check_add(a
  	return AE_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)
+ {
+ 	bool *is_spi_i2c_slave_p = data;
+ 
+ 	if (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
+ 		return 1;
+ 
+ 	/*
+ 	 * devices that are connected to UART still need to be enumerated to
+ 	 * platform bus
+ 	 */
+ 	if (ares->data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)
+ 		*is_spi_i2c_slave_p = true;
+ 
+ 	 /* no need to do more checking */
+ 	return -1;
+ }
+ 
+ static void acpi_default_enumeration(struct acpi_device *device)
+ {
+ 	struct list_head resource_list;
+ 	bool is_spi_i2c_slave = false;
+ 
+ 	/*
+ 	 * Do not enemerate SPI/I2C slaves as they will be enuerated by their
+ 	 * respective parents.
+ 	 */
+ 	INIT_LIST_HEAD(&resource_list);
+ 	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
+ 			       &is_spi_i2c_slave);
+ 	acpi_dev_free_resource_list(&resource_list);
+ 	if (!is_spi_i2c_slave)
+ 		acpi_create_platform_device(device);
+ }
+ 
+ static const struct acpi_device_id generic_device_ids[] = {
+ 	{ACPI_DT_NAMESPACE_HID, },
+ 	{"", },
+ };
+ 
+ static int acpi_generic_device_attach(struct acpi_device *adev,
+ 				      const struct acpi_device_id *not_used)
+ {
+ 	/*
+ 	 * Since ACPI_DT_NAMESPACE_HID is the only ID handled here, the test
+ 	 * below can be unconditional.
+ 	 */
+ 	if (adev->data.of_compatible)
+ 		acpi_default_enumeration(adev);
+ 
+ 	return 1;
+ }
+ 
+ static struct acpi_scan_handler generic_device_handler = {
+ 	.ids = generic_device_ids,
+ 	.attach = acpi_generic_device_attach,
+ };
+ 
++>>>>>>> ee89209402e0 (ACPI / property: Define a symbol for PRP0001)
  static int acpi_scan_attach_handler(struct acpi_device *device)
  {
  	struct acpi_hardware_id *hwid;
diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h
index 0f5eb460f227..c8b3f39f144a 100644
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -184,6 +184,8 @@ bool acpi_osi_is_win8(void);
 /*--------------------------------------------------------------------------
 				Device properties
   -------------------------------------------------------------------------- */
+#define ACPI_DT_NAMESPACE_HID	"PRP0001"
+
 void acpi_init_properties(struct acpi_device *adev);
 void acpi_free_properties(struct acpi_device *adev);
 
* Unmerged path drivers/acpi/property.c
* Unmerged path drivers/acpi/scan.c
