staging/rdma/hfi1: Support query gid in rdmavt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Support query gid in rdmavt (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 90.48%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 251314635ad5043e9438a18b2de17ddf86309641
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/25131463.failed

Query gid is in rdmavt, but still relies on the driver to maintain the
guid table. Add the necessary driver call back and remove the existing
verb handler.

	Reviewed-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 251314635ad5043e9438a18b2de17ddf86309641)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/verbs.c
diff --cc drivers/staging/hfi1/verbs.c
index d228eb7fc4f0,a85fd81505c7..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -1569,28 -1345,20 +1569,33 @@@ static int modify_port(struct ib_devic
  	return ret;
  }
  
- static int query_gid(struct ib_device *ibdev, u8 port,
- 		     int index, union ib_gid *gid)
+ static int hfi1_get_guid_be(struct rvt_dev_info *rdi, struct rvt_ibport *rvp,
+ 			    int guid_index, __be64 *guid)
  {
- 	struct hfi1_devdata *dd = dd_from_ibdev(ibdev);
- 	int ret = 0;
+ 	struct hfi1_ibport *ibp = container_of(rvp, struct hfi1_ibport, rvp);
+ 	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
  
- 	if (!port || port > dd->num_pports)
- 		ret = -EINVAL;
- 	else {
- 		struct hfi1_ibport *ibp = to_iport(ibdev, port);
- 		struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
+ 	if (guid_index == 0)
+ 		*guid = cpu_to_be64(ppd->guid);
+ 	else if (guid_index < HFI1_GUIDS_PER_PORT)
+ 		*guid = ibp->guids[guid_index - 1];
+ 	else
+ 		return -EINVAL;
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +		gid->global.subnet_prefix = ibp->gid_prefix;
 +		if (index == 0)
 +			gid->global.interface_id = cpu_to_be64(ppd->guid);
 +		else if (index < HFI1_GUIDS_PER_PORT)
 +			gid->global.interface_id = ibp->guids[index - 1];
 +		else
 +			ret = -EINVAL;
 +	}
 +
 +	return ret;
++=======
+ 	return 0;
++>>>>>>> 251314635ad5 (staging/rdma/hfi1: Support query gid in rdmavt):drivers/staging/rdma/hfi1/verbs.c
  }
  
  /*
@@@ -1953,60 -1530,80 +1958,132 @@@ int hfi1_register_ib_device(struct hfi1
  	ibdev->modify_device = modify_device;
  	ibdev->query_port = query_port;
  	ibdev->modify_port = modify_port;
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ibdev->query_pkey = NULL;
 +	ibdev->query_gid = query_gid;
 +	ibdev->alloc_ucontext = alloc_ucontext;
 +	ibdev->dealloc_ucontext = dealloc_ucontext;
 +	ibdev->alloc_pd = NULL;
 +	ibdev->dealloc_pd = NULL;
 +	ibdev->create_ah = create_ah;
 +	ibdev->destroy_ah = destroy_ah;
 +	ibdev->modify_ah = modify_ah;
 +	ibdev->query_ah = query_ah;
 +	ibdev->create_srq = hfi1_create_srq;
 +	ibdev->modify_srq = hfi1_modify_srq;
 +	ibdev->query_srq = hfi1_query_srq;
 +	ibdev->destroy_srq = hfi1_destroy_srq;
 +	ibdev->create_qp = hfi1_create_qp;
 +	ibdev->modify_qp = hfi1_modify_qp;
 +	ibdev->query_qp = hfi1_query_qp;
 +	ibdev->destroy_qp = hfi1_destroy_qp;
 +	ibdev->post_send = post_send;
 +	ibdev->post_recv = post_receive;
 +	ibdev->post_srq_recv = hfi1_post_srq_receive;
 +	ibdev->create_cq = hfi1_create_cq;
 +	ibdev->destroy_cq = hfi1_destroy_cq;
 +	ibdev->resize_cq = hfi1_resize_cq;
 +	ibdev->poll_cq = hfi1_poll_cq;
 +	ibdev->req_notify_cq = hfi1_req_notify_cq;
 +	ibdev->get_dma_mr = hfi1_get_dma_mr;
 +	ibdev->reg_phys_mr = hfi1_reg_phys_mr;
 +	ibdev->reg_user_mr = hfi1_reg_user_mr;
 +	ibdev->dereg_mr = hfi1_dereg_mr;
 +	ibdev->alloc_mr = hfi1_alloc_mr;
 +	ibdev->alloc_fast_reg_page_list = hfi1_alloc_fast_reg_page_list;
 +	ibdev->free_fast_reg_page_list = hfi1_free_fast_reg_page_list;
 +	ibdev->alloc_fmr = hfi1_alloc_fmr;
 +	ibdev->map_phys_fmr = hfi1_map_phys_fmr;
 +	ibdev->unmap_fmr = hfi1_unmap_fmr;
 +	ibdev->dealloc_fmr = hfi1_dealloc_fmr;
 +	ibdev->attach_mcast = hfi1_multicast_attach;
 +	ibdev->detach_mcast = hfi1_multicast_detach;
++=======
+ 
+ 	/* keep process mad in the driver */
++>>>>>>> 251314635ad5 (staging/rdma/hfi1: Support query gid in rdmavt):drivers/staging/rdma/hfi1/verbs.c
  	ibdev->process_mad = hfi1_process_mad;
 +	ibdev->mmap = hfi1_mmap;
 +	ibdev->dma_ops = &hfi1_dma_mapping_ops;
  	ibdev->get_port_immutable = port_immutable;
  
  	strncpy(ibdev->node_desc, init_utsname()->nodename,
  		sizeof(ibdev->node_desc));
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ret = ib_register_device(ibdev, hfi1_create_port_files);
++=======
+ 	/*
+ 	 * Fill in rvt info object.
+ 	 */
+ 	dd->verbs_dev.rdi.driver_f.port_callback = hfi1_create_port_files;
+ 	dd->verbs_dev.rdi.driver_f.get_card_name = get_card_name;
+ 	dd->verbs_dev.rdi.driver_f.get_pci_dev = get_pci_dev;
+ 	dd->verbs_dev.rdi.driver_f.check_ah = hfi1_check_ah;
+ 	dd->verbs_dev.rdi.driver_f.notify_new_ah = hfi1_notify_new_ah;
+ 	dd->verbs_dev.rdi.driver_f.get_guid_be = hfi1_get_guid_be;
+ 	/*
+ 	 * Fill in rvt info device attributes.
+ 	 */
+ 	hfi1_fill_device_attr(dd);
+ 
+ 	/* queue pair */
+ 	dd->verbs_dev.rdi.dparms.qp_table_size = hfi1_qp_table_size;
+ 	dd->verbs_dev.rdi.dparms.qpn_start = 0;
+ 	dd->verbs_dev.rdi.dparms.qpn_inc = 1;
+ 	dd->verbs_dev.rdi.dparms.qos_shift = dd->qos_shift;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_start = kdeth_qp << 16;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_end =
+ 	dd->verbs_dev.rdi.dparms.qpn_res_start + 65535;
+ 	dd->verbs_dev.rdi.dparms.max_rdma_atomic = HFI1_MAX_RDMA_ATOMIC;
+ 	dd->verbs_dev.rdi.dparms.psn_mask = PSN_MASK;
+ 	dd->verbs_dev.rdi.dparms.psn_shift = PSN_SHIFT;
+ 	dd->verbs_dev.rdi.dparms.psn_modify_mask = PSN_MODIFY_MASK;
+ 	dd->verbs_dev.rdi.driver_f.qp_priv_alloc = qp_priv_alloc;
+ 	dd->verbs_dev.rdi.driver_f.qp_priv_free = qp_priv_free;
+ 	dd->verbs_dev.rdi.driver_f.free_all_qps = free_all_qps;
+ 	dd->verbs_dev.rdi.driver_f.notify_qp_reset = notify_qp_reset;
+ 	dd->verbs_dev.rdi.driver_f.do_send = hfi1_do_send;
+ 	dd->verbs_dev.rdi.driver_f.schedule_send = hfi1_schedule_send;
+ 	dd->verbs_dev.rdi.driver_f.get_pmtu_from_attr = get_pmtu_from_attr;
+ 	dd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;
+ 	dd->verbs_dev.rdi.driver_f.flush_qp_waiters = flush_qp_waiters;
+ 	dd->verbs_dev.rdi.driver_f.stop_send_queue = stop_send_queue;
+ 	dd->verbs_dev.rdi.driver_f.quiesce_qp = quiesce_qp;
+ 	dd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;
+ 	dd->verbs_dev.rdi.driver_f.mtu_from_qp = mtu_from_qp;
+ 	dd->verbs_dev.rdi.driver_f.mtu_to_path_mtu = mtu_to_path_mtu;
+ 	dd->verbs_dev.rdi.driver_f.check_modify_qp = hfi1_check_modify_qp;
+ 	dd->verbs_dev.rdi.driver_f.modify_qp = hfi1_modify_qp;
+ 	dd->verbs_dev.rdi.driver_f.check_send_wr = hfi1_check_send_wr;
+ 
+ 	/* completeion queue */
+ 	snprintf(dd->verbs_dev.rdi.dparms.cq_name,
+ 		 sizeof(dd->verbs_dev.rdi.dparms.cq_name),
+ 		 "hfi1_cq%d", dd->unit);
+ 	dd->verbs_dev.rdi.dparms.node = dd->node;
+ 
+ 	/* misc settings */
+ 	dd->verbs_dev.rdi.flags = 0; /* Let rdmavt handle it all */
+ 	dd->verbs_dev.rdi.dparms.lkey_table_size = hfi1_lkey_table_size;
+ 	dd->verbs_dev.rdi.dparms.nports = dd->num_pports;
+ 	dd->verbs_dev.rdi.dparms.npkeys = hfi1_get_npkeys(dd);
+ 
+ 	ppd = dd->pport;
+ 	for (i = 0; i < dd->num_pports; i++, ppd++)
+ 		rvt_init_port(&dd->verbs_dev.rdi,
+ 			      &ppd->ibport_data.rvp,
+ 			      i,
+ 			      ppd->pkeys);
+ 
+ 	ret = rvt_register_device(&dd->verbs_dev.rdi);
++>>>>>>> 251314635ad5 (staging/rdma/hfi1: Support query gid in rdmavt):drivers/staging/rdma/hfi1/verbs.c
  	if (ret)
 -		goto err_verbs_txreq;
 +		goto err_reg;
 +
 +	ret = hfi1_create_agents(dev);
 +	if (ret)
 +		goto err_agents;
  
  	ret = hfi1_verbs_register_sysfs(dd);
  	if (ret)
* Unmerged path drivers/staging/hfi1/verbs.c
