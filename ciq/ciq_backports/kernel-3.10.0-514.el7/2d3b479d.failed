net-sysfs: expose number of carrier on/off changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] sysfs: expose number of carrier on/off changes (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.83%
commit-author david decotigny <decot@googlers.com>
commit 2d3b479df41a10e2f41f9259fcba775bd34de6e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2d3b479d.failed

This allows to monitor carrier on/off transitions and detect link
flapping issues:
 - new /sys/class/net/X/carrier_changes
 - new rtnetlink IFLA_CARRIER_CHANGES (getlink)

Tested:
  - grep . /sys/class/net/*/carrier_changes
    + ip link set dev X down/up
    + plug/unplug cable
  - updated iproute2: prints IFLA_CARRIER_CHANGES
  - iproute2 20121211-2 (debian): unchanged behavior

	Signed-off-by: David Decotigny <decot@googlers.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2d3b479df41a10e2f41f9259fcba775bd34de6e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc include/uapi/linux/if_link.h
index 719f99b573ac,9a7f7ace6649..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -144,9 -144,7 +144,13 @@@ enum 
  	IFLA_NUM_RX_QUEUES,
  	IFLA_CARRIER,
  	IFLA_PHYS_PORT_ID,
++<<<<<<< HEAD
 +	__RH_RESERVED_IFLA_CARRIER_CHANGES,
 +	__RH_RESERVED_IFLA_PHYS_SWITCH_ID,
 +	IFLA_LINK_NETNSID,
++=======
+ 	IFLA_CARRIER_CHANGES,
++>>>>>>> 2d3b479df41a (net-sysfs: expose number of carrier on/off changes)
  	__IFLA_MAX
  };
  
diff --cc net/core/rtnetlink.c
index bca0c57300c0,d4ff41739b0f..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -911,7 -822,7 +911,11 @@@ static noinline size_t if_nlmsg_size(co
  	       + nla_total_size(4) /* IFLA_NUM_RX_QUEUES */
  	       + nla_total_size(1) /* IFLA_OPERSTATE */
  	       + nla_total_size(1) /* IFLA_LINKMODE */
++<<<<<<< HEAD
 +	       + nla_total_size(4) /* IFLA_LINK_NETNSID */
++=======
+ 	       + nla_total_size(4) /* IFLA_CARRIER_CHANGES */
++>>>>>>> 2d3b479df41a (net-sysfs: expose number of carrier on/off changes)
  	       + nla_total_size(ext_filter_mask
  			        & RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */
  	       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */
@@@ -1289,7 -1150,7 +1295,11 @@@ static const struct nla_policy ifla_pol
  	[IFLA_NUM_TX_QUEUES]	= { .type = NLA_U32 },
  	[IFLA_NUM_RX_QUEUES]	= { .type = NLA_U32 },
  	[IFLA_PHYS_PORT_ID]	= { .type = NLA_BINARY, .len = MAX_PHYS_PORT_ID_LEN },
++<<<<<<< HEAD
 +	[IFLA_LINK_NETNSID]	= { .type = NLA_S32 },
++=======
+ 	[IFLA_CARRIER_CHANGES]	= { .type = NLA_U32 },  /* ignored */
++>>>>>>> 2d3b479df41a (net-sysfs: expose number of carrier on/off changes)
  };
  
  static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 056534f8f95d..3921379c6aa2 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1342,6 +1342,9 @@ struct net_device {
 					     * Do not use this in drivers.
 					     */
 
+	/* Stats to monitor carrier on<->off transitions */
+	atomic_t		carrier_changes;
+
 #ifdef CONFIG_WIRELESS_EXT
 	/* List of functions to handle Wireless Extensions (instead of ioctl).
 	 * See <net/iw_handler.h> for details. Jean II */
* Unmerged path include/uapi/linux/if_link.h
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index f64ea01748b3..dbf0698df9e3 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -261,6 +261,16 @@ static ssize_t operstate_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(operstate);
 
+static ssize_t carrier_changes_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	return sprintf(buf, fmt_dec,
+		       atomic_read(&netdev->carrier_changes));
+}
+static DEVICE_ATTR_RO(carrier_changes);
+
 /* read-write attributes */
 
 static int change_mtu(struct net_device *net, unsigned long new_mtu)
@@ -411,6 +421,7 @@ static struct attribute *net_class_attrs[] = {
 	&dev_attr_duplex.attr,
 	&dev_attr_dormant.attr,
 	&dev_attr_operstate.attr,
+	&dev_attr_carrier_changes.attr,
 	&dev_attr_ifalias.attr,
 	&dev_attr_carrier.attr,
 	&dev_attr_mtu.attr,
* Unmerged path net/core/rtnetlink.c
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 89d4813f19d4..568bb49f9ed6 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -343,6 +343,7 @@ void netif_carrier_on(struct net_device *dev)
 	if (test_and_clear_bit(__LINK_STATE_NOCARRIER, &dev->state)) {
 		if (dev->reg_state == NETREG_UNINITIALIZED)
 			return;
+		atomic_inc(&dev->carrier_changes);
 		linkwatch_fire_event(dev);
 		if (netif_running(dev))
 			__netdev_watchdog_up(dev);
@@ -361,6 +362,7 @@ void netif_carrier_off(struct net_device *dev)
 	if (!test_and_set_bit(__LINK_STATE_NOCARRIER, &dev->state)) {
 		if (dev->reg_state == NETREG_UNINITIALIZED)
 			return;
+		atomic_inc(&dev->carrier_changes);
 		linkwatch_fire_event(dev);
 	}
 }
