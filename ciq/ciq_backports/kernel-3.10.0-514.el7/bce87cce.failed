KVM: x86: consolidate different ways to test for in-kernel LAPIC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit bce87cce88c71957c56479809db8316a836ec8b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bce87cce.failed

Different pieces of code checked for vcpu->arch.apic being (non-)NULL,
or used kvm_vcpu_has_lapic (more optimized) or lapic_in_kernel.
Replace everything with lapic_in_kernel's name and kvm_vcpu_has_lapic's
implementation.

	Reviewed-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit bce87cce88c71957c56479809db8316a836ec8b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/irq.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/irq.h
index 363023e205ac,61ebdc13a29a..000000000000
--- a/arch/x86/kvm/irq.h
+++ b/arch/x86/kvm/irq.h
@@@ -89,7 -102,11 +89,11 @@@ static inline int irqchip_in_kernel(str
  
  	/* Read vpic before kvm->irq_routing.  */
  	smp_rmb();
++<<<<<<< HEAD
 +	return vpic != NULL;
++=======
+ 	return ret;
++>>>>>>> bce87cce88c7 (KVM: x86: consolidate different ways to test for in-kernel LAPIC)
  }
  
  void kvm_pic_reset(struct kvm_kpic_state *s);
diff --cc arch/x86/kvm/x86.c
index 733894b44f8d,ee3e990d519a..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -4306,9 -4090,9 +4306,15 @@@ static int vcpu_mmio_write(struct kvm_v
  
  	do {
  		n = min(len, 8);
++<<<<<<< HEAD
 +		if (!(vcpu->arch.apic &&
 +		      !kvm_iodevice_write(&vcpu->arch.apic->dev, addr, n, v))
 +		    && kvm_io_bus_write(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))
++=======
+ 		if (!(lapic_in_kernel(vcpu) &&
+ 		      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))
+ 		    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))
++>>>>>>> bce87cce88c7 (KVM: x86: consolidate different ways to test for in-kernel LAPIC)
  			break;
  		handled += n;
  		addr += n;
@@@ -4326,9 -4110,10 +4332,16 @@@ static int vcpu_mmio_read(struct kvm_vc
  
  	do {
  		n = min(len, 8);
++<<<<<<< HEAD
 +		if (!(vcpu->arch.apic &&
 +		      !kvm_iodevice_read(&vcpu->arch.apic->dev, addr, n, v))
 +		    && kvm_io_bus_read(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))
++=======
+ 		if (!(lapic_in_kernel(vcpu) &&
+ 		      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,
+ 					 addr, n, v))
+ 		    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))
++>>>>>>> bce87cce88c7 (KVM: x86: consolidate different ways to test for in-kernel LAPIC)
  			break;
  		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);
  		handled += n;
@@@ -6284,9 -6007,12 +6297,9 @@@ static void update_cr8_intercept(struc
  	if (!kvm_x86_ops->update_cr8_intercept)
  		return;
  
- 	if (!vcpu->arch.apic)
+ 	if (!lapic_in_kernel(vcpu))
  		return;
  
 -	if (vcpu->arch.apicv_active)
 -		return;
 -
  	if (!vcpu->arch.apic->vapic_addr)
  		max_irr = kvm_lapic_find_highest_irr(vcpu);
  	else
* Unmerged path arch/x86/kvm/irq.h
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index a7cb8b19e27e..d2c067f26c18 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -285,7 +285,7 @@ void kvm_apic_set_version(struct kvm_vcpu *vcpu)
 	struct kvm_cpuid_entry2 *feat;
 	u32 v = APIC_VERSION;
 
-	if (!kvm_vcpu_has_lapic(vcpu))
+	if (!lapic_in_kernel(vcpu))
 		return;
 
 	feat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);
@@ -1220,7 +1220,7 @@ void wait_lapic_expire(struct kvm_vcpu *vcpu)
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	u64 guest_tsc, tsc_deadline;
 
-	if (!kvm_vcpu_has_lapic(vcpu))
+	if (!lapic_in_kernel(vcpu))
 		return;
 
 	if (apic->lapic_timer.expired_tscdeadline == 0)
@@ -1576,7 +1576,7 @@ u64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
-	if (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||
+	if (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||
 			apic_lvtt_period(apic))
 		return 0;
 
@@ -1587,7 +1587,7 @@ void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
-	if (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||
+	if (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||
 			apic_lvtt_period(apic))
 		return;
 
@@ -1925,7 +1925,7 @@ void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)
 {
 	struct hrtimer *timer;
 
-	if (!kvm_vcpu_has_lapic(vcpu))
+	if (!lapic_in_kernel(vcpu))
 		return;
 
 	timer = &vcpu->arch.apic->lapic_timer.timer;
@@ -2098,7 +2098,7 @@ int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
-	if (!kvm_vcpu_has_lapic(vcpu))
+	if (!lapic_in_kernel(vcpu))
 		return 1;
 
 	/* if this is ICR write vector before command */
@@ -2112,7 +2112,7 @@ int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	u32 low, high = 0;
 
-	if (!kvm_vcpu_has_lapic(vcpu))
+	if (!lapic_in_kernel(vcpu))
 		return 1;
 
 	if (apic_reg_read(apic, reg, 4, &low))
@@ -2144,7 +2144,7 @@ void kvm_apic_accept_events(struct kvm_vcpu *vcpu)
 	u8 sipi_vector;
 	unsigned long pe;
 
-	if (!kvm_vcpu_has_lapic(vcpu) || !apic->pending_events)
+	if (!lapic_in_kernel(vcpu) || !apic->pending_events)
 		return;
 
 	/*
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index e5b0fff82952..affd303ad22e 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -103,7 +103,7 @@ static inline u32 kvm_apic_get_reg(struct kvm_lapic *apic, int reg_off)
 
 extern struct static_key kvm_no_apic_vcpu;
 
-static inline bool kvm_vcpu_has_lapic(struct kvm_vcpu *vcpu)
+static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)
 {
 	if (static_key_false(&kvm_no_apic_vcpu))
 		return vcpu->arch.apic;
@@ -130,7 +130,7 @@ static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)
 
 static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)
 {
-	return kvm_vcpu_has_lapic(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
 }
 
 static inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)
@@ -150,12 +150,12 @@ static inline bool kvm_apic_vid_enabled(struct kvm *kvm)
 
 static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)
 {
-	return kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;
+	return lapic_in_kernel(vcpu) && vcpu->arch.apic->pending_events;
 }
 
 static inline int kvm_lapic_latched_init(struct kvm_vcpu *vcpu)
 {
-	return kvm_vcpu_has_lapic(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+	return lapic_in_kernel(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
 }
 
 bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);
diff --git a/arch/x86/kvm/pmu.c b/arch/x86/kvm/pmu.c
index 31aa2c85dc97..06ce377dcbc9 100644
--- a/arch/x86/kvm/pmu.c
+++ b/arch/x86/kvm/pmu.c
@@ -257,7 +257,7 @@ int kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)
 
 void kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)
 {
-	if (vcpu->arch.apic)
+	if (lapic_in_kernel(vcpu))
 		kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);
 }
 
* Unmerged path arch/x86/kvm/x86.c
