ipv6: Select fragment id during UFO segmentation if not set.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ipv6: Select fragment id during UFO segmentation if not set (Lance Richardson) [1283886]
Rebuild_FUZZ: 99.16%
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 0508c07f5e0c94f38afd5434e8b2a55b84553077
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0508c07f.failed

If the IPv6 fragment id has not been set and we perform
fragmentation due to UFO, select a new fragment id.
We now consider a fragment id of 0 as unset and if id selection
process returns 0 (after all the pertrubations), we set it to
0x80000000, thus giving us ample space not to create collisions
with the next packet we may have to fragment.

When doing UFO integrity checking, we also select the
fragment id if it has not be set yet.   This is stored into
the skb_shinfo() thus allowing UFO to function correclty.

This patch also removes duplicate fragment id generation code
and moves ipv6_select_ident() into the header as it may be
used during GSO.

	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0508c07f5e0c94f38afd5434e8b2a55b84553077)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ipv6.h
#	net/ipv6/ip6_output.c
#	net/ipv6/output_core.c
diff --cc include/net/ipv6.h
index 5dca98c3fc9f,9bf85d34c024..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -670,7 -671,10 +670,14 @@@ static inline int ipv6_addr_diff(const 
  	return __ipv6_addr_diff(a1, a2, sizeof(struct in6_addr));
  }
  
++<<<<<<< HEAD
 +void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt);
++=======
+ u32 __ipv6_select_ident(u32 hashrnd, struct in6_addr *dst,
+ 			struct in6_addr *src);
+ void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt);
+ void ipv6_proxy_select_ident(struct sk_buff *skb);
++>>>>>>> 0508c07f5e0c (ipv6: Select fragment id during UFO segmentation if not set.)
  
  int ip6_dst_hoplimit(struct dst_entry *dst);
  
diff --cc net/ipv6/ip6_output.c
index 6e24dc6ba803,d28f2a2efb32..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -520,13 -537,11 +520,17 @@@ static void ip6_copy_metadata(struct sk
  	skb_copy_secmark(to, from);
  }
  
++<<<<<<< HEAD
 +int ip6_fragment(struct sock *sk, struct sk_buff *skb,
 +		 int (*output)(struct sock *, struct sk_buff *))
++=======
+ int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
++>>>>>>> 0508c07f5e0c (ipv6: Select fragment id during UFO segmentation if not set.)
  {
  	struct sk_buff *frag;
 -	struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
 -	struct ipv6_pinfo *np = skb->sk ? inet6_sk(skb->sk) : NULL;
 +	struct rt6_info *rt = (struct rt6_info*)skb_dst(skb);
 +	struct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?
 +				inet6_sk(skb->sk) : NULL;
  	struct ipv6hdr *tmp_hdr;
  	struct frag_hdr *fh;
  	unsigned int mtu, hlen, left, len;
diff --cc net/ipv6/output_core.c
index f55ca250c2c9,54520a0bd5e3..000000000000
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@@ -6,33 -6,68 +6,90 @@@
  #include <net/ipv6.h>
  #include <net/ip6_fib.h>
  #include <net/addrconf.h>
 -#include <net/secure_seq.h>
  
++<<<<<<< HEAD
 +void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)
 +{
 +	static atomic_t ipv6_fragmentation_id;
 +	int old, new;
++=======
+ u32 __ipv6_select_ident(u32 hashrnd, struct in6_addr *dst, struct in6_addr *src)
+ {
+ 	u32 hash, id;
+ 
+ 	hash = __ipv6_addr_jhash(dst, hashrnd);
+ 	hash = __ipv6_addr_jhash(src, hash);
+ 
+ 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
+ 	 * set the hight order instead thus minimizing possible future
+ 	 * collisions.
+ 	 */
+ 	id = ip_idents_reserve(hash, 1);
+ 	if (unlikely(!id))
+ 		id = 1 << 31;
+ 
+ 	return id;
+ }
+ 
+ /* This function exists only for tap drivers that must support broken
+  * clients requesting UFO without specifying an IPv6 fragment ID.
+  *
+  * This is similar to ipv6_select_ident() but we use an independent hash
+  * seed to limit information leakage.
+  *
+  * The network header must be set before calling this.
+  */
+ void ipv6_proxy_select_ident(struct sk_buff *skb)
+ {
+ 	static u32 ip6_proxy_idents_hashrnd __read_mostly;
+ 	struct in6_addr buf[2];
+ 	struct in6_addr *addrs;
+ 	u32 id;
++>>>>>>> 0508c07f5e0c (ipv6: Select fragment id during UFO segmentation if not set.)
  
 -	addrs = skb_header_pointer(skb,
 -				   skb_network_offset(skb) +
 -				   offsetof(struct ipv6hdr, saddr),
 -				   sizeof(buf), buf);
 -	if (!addrs)
 -		return;
 -
 +#if IS_ENABLED(CONFIG_IPV6)
 +	if (rt) {
 +		struct inet_peer *peer;
 +		struct net *net;
 +
++<<<<<<< HEAD
 +		net = dev_net(rt->dst.dev);
 +		peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);
 +		if (peer) {
 +			fhdr->identification = htonl(inet_getid(peer, 0));
 +			inet_putpeer(peer);
 +			return;
 +		}
 +	}
 +#endif
 +	do {
 +		old = atomic_read(&ipv6_fragmentation_id);
 +		new = old + 1;
 +		if (!new)
 +			new = 1;
 +	} while (atomic_cmpxchg(&ipv6_fragmentation_id, old, new) != old);
 +	fhdr->identification = htonl(new);
++=======
+ 	net_get_random_once(&ip6_proxy_idents_hashrnd,
+ 			    sizeof(ip6_proxy_idents_hashrnd));
+ 
+ 	id = __ipv6_select_ident(ip6_proxy_idents_hashrnd,
+ 				 &addrs[1], &addrs[0]);
+ 	skb_shinfo(skb)->ip6_frag_id = id;
++>>>>>>> 0508c07f5e0c (ipv6: Select fragment id during UFO segmentation if not set.)
+ }
 -EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);
++EXPORT_SYMBOL(ipv6_select_ident);
+ 
+ void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)
+ {
+ 	static u32 ip6_idents_hashrnd __read_mostly;
+ 	u32 id;
+ 
+ 	net_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));
+ 
+ 	id = __ipv6_select_ident(ip6_idents_hashrnd, &rt->rt6i_dst.addr,
+ 				 &rt->rt6i_src.addr);
+ 	fhdr->identification = htonl(id);
  }
  EXPORT_SYMBOL(ipv6_select_ident);
  
* Unmerged path include/net/ipv6.h
* Unmerged path net/ipv6/ip6_output.c
* Unmerged path net/ipv6/output_core.c
diff --git a/net/ipv6/udp_offload.c b/net/ipv6/udp_offload.c
index f705fbdc6ee7..2a675f064964 100644
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@ -53,6 +53,10 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 
 		skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);
 
+		/* Set the IPv6 fragment id if not set yet */
+		if (!skb_shinfo(skb)->ip6_frag_id)
+			ipv6_proxy_select_ident(skb);
+
 		segs = NULL;
 		goto out;
 	}
@@ -109,7 +113,11 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 		fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);
 		fptr->nexthdr = nexthdr;
 		fptr->reserved = 0;
-		fptr->identification = skb_shinfo(skb)->ip6_frag_id;
+		if (skb_shinfo(skb)->ip6_frag_id)
+			fptr->identification = skb_shinfo(skb)->ip6_frag_id;
+		else
+			ipv6_select_ident(fptr,
+					  (struct rt6_info *)skb_dst(skb));
 
 		/* Fragment the skb. ipv6 header and the remaining fields of the
 		 * fragment header are updated in ipv6_gso_segment()
