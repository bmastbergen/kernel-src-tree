netfilter: bridge: neigh_head and physoutdev can't be used at same time

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Florian Westphal <fw@strlen.de>
commit 7fb48c5bc3100f7674a8e26f42c1518196500728
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7fb48c5b.failed

The neigh_header is only needed when we detect DNAT after prerouting
and neigh cache didn't have a mac address for us.

The output port has not been chosen yet so we can re-use the storage
area, bringing struct size down to 32 bytes on x86_64.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 7fb48c5bc3100f7674a8e26f42c1518196500728)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/bridge/br_netfilter.c
diff --cc include/linux/skbuff.h
index 2e271768b46a,3d932e64125a..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -163,13 -163,21 +163,28 @@@ struct nf_conntrack 
  };
  #endif
  
 -#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 +#ifdef CONFIG_BRIDGE_NETFILTER
  struct nf_bridge_info {
  	atomic_t		use;
++<<<<<<< HEAD
 +	unsigned int		mask;
 +	struct net_device	*physindev;
 +	struct net_device	*physoutdev;
 +	unsigned long		data[32 / sizeof(unsigned long)];
++=======
+ 	enum {
+ 		BRNF_PROTO_UNCHANGED,
+ 		BRNF_PROTO_8021Q,
+ 		BRNF_PROTO_PPPOE
+ 	} orig_proto:8;
+ 	bool			pkt_otherhost;
+ 	unsigned int		mask;
+ 	struct net_device	*physindev;
+ 	union {
+ 		struct net_device *physoutdev;
+ 		char neigh_header[8];
+ 	};
++>>>>>>> 7fb48c5bc310 (netfilter: bridge: neigh_head and physoutdev can't be used at same time)
  };
  #endif
  
diff --cc net/bridge/br_netfilter.c
index bfa28cea8c79,13973da29b2a..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -939,6 -951,46 +939,49 @@@ static unsigned int ip_sabotage_in(cons
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD
++=======
+ /* This is called when br_netfilter has called into iptables/netfilter,
+  * and DNAT has taken place on a bridge-forwarded packet.
+  *
+  * neigh->output has created a new MAC header, with local br0 MAC
+  * as saddr.
+  *
+  * This restores the original MAC saddr of the bridged packet
+  * before invoking bridge forward logic to transmit the packet.
+  */
+ static void br_nf_pre_routing_finish_bridge_slow(struct sk_buff *skb)
+ {
+ 	struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);
+ 
+ 	skb_pull(skb, ETH_HLEN);
+ 	nf_bridge->mask &= ~BRNF_BRIDGED_DNAT;
+ 
+ 	BUILD_BUG_ON(sizeof(nf_bridge->neigh_header) != (ETH_HLEN - ETH_ALEN));
+ 
+ 	skb_copy_to_linear_data_offset(skb, -(ETH_HLEN - ETH_ALEN),
+ 				       nf_bridge->neigh_header,
+ 				       ETH_HLEN - ETH_ALEN);
+ 	skb->dev = nf_bridge->physindev;
+ 
+ 	nf_bridge->physoutdev = NULL;
+ 	br_handle_frame_finish(NULL, skb);
+ }
+ 
+ static int br_nf_dev_xmit(struct sk_buff *skb)
+ {
+ 	if (skb->nf_bridge && (skb->nf_bridge->mask & BRNF_BRIDGED_DNAT)) {
+ 		br_nf_pre_routing_finish_bridge_slow(skb);
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct nf_br_ops br_ops = {
+ 	.br_dev_xmit_hook =	br_nf_dev_xmit,
+ };
+ 
++>>>>>>> 7fb48c5bc310 (netfilter: bridge: neigh_head and physoutdev can't be used at same time)
  void br_netfilter_enable(void)
  {
  }
* Unmerged path include/linux/skbuff.h
* Unmerged path net/bridge/br_netfilter.c
