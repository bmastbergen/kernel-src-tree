timekeeping: use printk_deferred when holding timekeeping seqlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author John Stultz <john.stultz@linaro.org>
commit 6d9bcb621b0b0a20604cbdb298c4487e44dd0da2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6d9bcb62.failed

Jiri Bohac pointed out that there are rare but potential deadlock
possibilities when calling printk while holding the timekeeping
seqlock.

This is due to printk() triggering console sem wakeup, which can
cause scheduling code to trigger hrtimers which may try to read
the time.

Specifically, as Jiri pointed out, that path is:
  printk
    vprintk_emit
      console_unlock
        up(&console_sem)
          __up
	    wake_up_process
	      try_to_wake_up
	        ttwu_do_activate
		  ttwu_activate
		    activate_task
		      enqueue_task
		        enqueue_task_fair
			  hrtick_update
			    hrtick_start_fair
			      hrtick_start_fair
			        get_time
				  ktime_get
				    --> endless loop on
				    read_seqcount_retry(&timekeeper_seq, ...)

This patch tries to avoid this issue by using printk_deferred (previously
named printk_sched) which should defer printing via a irq_work_queue.

	Signed-off-by: John Stultz <john.stultz@linaro.org>
	Reported-by: Jiri Bohac <jbohac@suse.cz>
	Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6d9bcb621b0b0a20604cbdb298c4487e44dd0da2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timekeeping.c
diff --cc kernel/time/timekeeping.c
index f91dfde5f28b,32d8d6aaedb8..000000000000
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@@ -890,11 -849,12 +890,18 @@@ static struct timespec64 timekeeping_su
   * adds the sleep offset to the timekeeping variables.
   */
  static void __timekeeping_inject_sleeptime(struct timekeeper *tk,
 -							struct timespec *delta)
 +					   struct timespec64 *delta)
  {
++<<<<<<< HEAD
 +	if (!timespec64_valid_strict(delta)) {
 +		printk(KERN_WARNING "__timekeeping_inject_sleeptime: Invalid "
 +					"sleep delta value!\n");
++=======
+ 	if (!timespec_valid_strict(delta)) {
+ 		printk_deferred(KERN_WARNING
+ 				"__timekeeping_inject_sleeptime: Invalid "
+ 				"sleep delta value!\n");
++>>>>>>> 6d9bcb621b0b (timekeeping: use printk_deferred when holding timekeeping seqlock)
  		return;
  	}
  	tk_xtime_add(tk, delta);
@@@ -1099,25 -1053,116 +1106,92 @@@ static int __init timekeeping_init_ops(
  device_initcall(timekeeping_init_ops);
  
  /*
 - * If the error is already larger, we look ahead even further
 - * to compensate for late or lost adjustments.
 + * Apply a multiplier adjustment to the timekeeper
   */
 -static __always_inline int timekeeping_bigadjust(struct timekeeper *tk,
 -						 s64 error, s64 *interval,
 -						 s64 *offset)
 +static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,
 +							 s64 offset,
 +							 bool negative,
 +							 int adj_scale)
  {
 -	s64 tick_error, i;
 -	u32 look_ahead, adj;
 -	s32 error2, mult;
 +	s64 interval = tk->cycle_interval;
 +	s32 mult_adj = 1;
  
 -	/*
 -	 * Use the current error value to determine how much to look ahead.
 -	 * The larger the error the slower we adjust for it to avoid problems
 -	 * with losing too many ticks, otherwise we would overadjust and
 -	 * produce an even larger error.  The smaller the adjustment the
 -	 * faster we try to adjust for it, as lost ticks can do less harm
 -	 * here.  This is tuned so that an error of about 1 msec is adjusted
 -	 * within about 1 sec (or 2^20 nsec in 2^SHIFT_HZ ticks).
 -	 */
 -	error2 = tk->ntp_error >> (NTP_SCALE_SHIFT + 22 - 2 * SHIFT_HZ);
 -	error2 = abs(error2);
 -	for (look_ahead = 0; error2 > 0; look_ahead++)
 -		error2 >>= 2;
 -
 -	/*
 -	 * Now calculate the error in (1 << look_ahead) ticks, but first
 -	 * remove the single look ahead already included in the error.
 -	 */
 -	tick_error = ntp_tick_length() >> (tk->ntp_error_shift + 1);
 -	tick_error -= tk->xtime_interval >> 1;
 -	error = ((error - tick_error) >> look_ahead) + tick_error;
 -
 -	/* Finally calculate the adjustment shift value.  */
 -	i = *interval;
 -	mult = 1;
 -	if (error < 0) {
 -		error = -error;
 -		*interval = -*interval;
 -		*offset = -*offset;
 -		mult = -1;
 +	if (negative) {
 +		mult_adj = -mult_adj;
 +		interval = -interval;
 +		offset  = -offset;
  	}
 -	for (adj = 0; error > i; adj++)
 -		error >>= 1;
 +	mult_adj <<= adj_scale;
 +	interval <<= adj_scale;
 +	offset <<= adj_scale;
  
++<<<<<<< HEAD
++=======
+ 	*interval <<= adj;
+ 	*offset <<= adj;
+ 	return mult << adj;
+ }
+ 
+ /*
+  * Adjust the multiplier to reduce the error value,
+  * this is optimized for the most common adjustments of -1,0,1,
+  * for other values we can do a bit more work.
+  */
+ static void timekeeping_adjust(struct timekeeper *tk, s64 offset)
+ {
+ 	s64 error, interval = tk->cycle_interval;
+ 	int adj;
+ 
+ 	/*
+ 	 * The point of this is to check if the error is greater than half
+ 	 * an interval.
+ 	 *
+ 	 * First we shift it down from NTP_SHIFT to clocksource->shifted nsecs.
+ 	 *
+ 	 * Note we subtract one in the shift, so that error is really error*2.
+ 	 * This "saves" dividing(shifting) interval twice, but keeps the
+ 	 * (error > interval) comparison as still measuring if error is
+ 	 * larger than half an interval.
+ 	 *
+ 	 * Note: It does not "save" on aggravation when reading the code.
+ 	 */
+ 	error = tk->ntp_error >> (tk->ntp_error_shift - 1);
+ 	if (error > interval) {
+ 		/*
+ 		 * We now divide error by 4(via shift), which checks if
+ 		 * the error is greater than twice the interval.
+ 		 * If it is greater, we need a bigadjust, if its smaller,
+ 		 * we can adjust by 1.
+ 		 */
+ 		error >>= 2;
+ 		if (likely(error <= interval))
+ 			adj = 1;
+ 		else
+ 			adj = timekeeping_bigadjust(tk, error, &interval, &offset);
+ 	} else {
+ 		if (error < -interval) {
+ 			/* See comment above, this is just switched for the negative */
+ 			error >>= 2;
+ 			if (likely(error >= -interval)) {
+ 				adj = -1;
+ 				interval = -interval;
+ 				offset = -offset;
+ 			} else {
+ 				adj = timekeeping_bigadjust(tk, error, &interval, &offset);
+ 			}
+ 		} else {
+ 			goto out_adjust;
+ 		}
+ 	}
+ 
+ 	if (unlikely(tk->clock->maxadj &&
+ 		(tk->mult + adj > tk->clock->mult + tk->clock->maxadj))) {
+ 		printk_deferred_once(KERN_WARNING
+ 			"Adjusting %s more than 11%% (%ld vs %ld)\n",
+ 			tk->clock->name, (long)tk->mult + adj,
+ 			(long)tk->clock->mult + tk->clock->maxadj);
+ 	}
++>>>>>>> 6d9bcb621b0b (timekeeping: use printk_deferred when holding timekeeping seqlock)
  	/*
  	 * So the following can be confusing.
  	 *
diff --git a/kernel/time/ntp.c b/kernel/time/ntp.c
index 9356b1897db7..026d94e96df4 100644
--- a/kernel/time/ntp.c
+++ b/kernel/time/ntp.c
@@ -833,8 +833,9 @@ static long hardpps_update_freq(struct pps_normtime freq_norm)
 		time_status |= STA_PPSERROR;
 		pps_errcnt++;
 		pps_dec_freq_interval();
-		pr_err("hardpps: PPSERROR: interval too long - %ld s\n",
-				freq_norm.sec);
+		printk_deferred(KERN_ERR
+			"hardpps: PPSERROR: interval too long - %ld s\n",
+			freq_norm.sec);
 		return 0;
 	}
 
@@ -847,7 +848,8 @@ static long hardpps_update_freq(struct pps_normtime freq_norm)
 	delta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);
 	pps_freq = ftemp;
 	if (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {
-		pr_warning("hardpps: PPSWANDER: change=%ld\n", delta);
+		printk_deferred(KERN_WARNING
+				"hardpps: PPSWANDER: change=%ld\n", delta);
 		time_status |= STA_PPSWANDER;
 		pps_stbcnt++;
 		pps_dec_freq_interval();
@@ -891,8 +893,9 @@ static void hardpps_update_phase(long error)
 	 * the time offset is updated.
 	 */
 	if (jitter > (pps_jitter << PPS_POPCORN)) {
-		pr_warning("hardpps: PPSJITTER: jitter=%ld, limit=%ld\n",
-		       jitter, (pps_jitter << PPS_POPCORN));
+		printk_deferred(KERN_WARNING
+				"hardpps: PPSJITTER: jitter=%ld, limit=%ld\n",
+				jitter, (pps_jitter << PPS_POPCORN));
 		time_status |= STA_PPSJITTER;
 		pps_jitcnt++;
 	} else if (time_status & STA_PPSTIME) {
@@ -949,7 +952,7 @@ void __hardpps(const struct timespec *phase_ts, const struct timespec *raw_ts)
 		time_status |= STA_PPSJITTER;
 		/* restart the frequency calibration interval */
 		pps_fbase = *raw_ts;
-		pr_err("hardpps: PPSJITTER: bad pulse\n");
+		printk_deferred(KERN_ERR "hardpps: PPSJITTER: bad pulse\n");
 		return;
 	}
 
* Unmerged path kernel/time/timekeeping.c
