hv_netvsc: set nvdev link after populating chn_table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 88098834827025cc04c15f1b4b0d9bbef3cf55af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/88098834.failed

Crash in netvsc_send() is observed when netvsc device is re-created on
mtu change/set channels. The crash is caused by dereferencing of NULL
channel pointer which comes from chn_table. The root cause is a mixture
of two facts:
- we set nvdev pointer in net_device_context in alloc_net_device()
  before we populate chn_table.
- we populate chn_table[0] only.

The issue could be papered over by checking channel != NULL in
netvsc_send() but populating the whole chn_table and writing the
nvdev pointer afterwards seems more appropriate.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 88098834827025cc04c15f1b4b0d9bbef3cf55af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/netvsc.c
index 74ee1b57e623,719cb3578e55..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -33,11 -33,36 +33,14 @@@
  
  #include "hyperv_net.h"
  
 -/*
 - * Switch the data path from the synthetic interface to the VF
 - * interface.
 - */
 -void netvsc_switch_datapath(struct net_device *ndev, bool vf)
 -{
 -	struct net_device_context *net_device_ctx = netdev_priv(ndev);
 -	struct hv_device *dev = net_device_ctx->device_ctx;
 -	struct netvsc_device *nv_dev = net_device_ctx->nvdev;
 -	struct nvsp_message *init_pkt = &nv_dev->channel_init_pkt;
 -
 -	memset(init_pkt, 0, sizeof(struct nvsp_message));
 -	init_pkt->hdr.msg_type = NVSP_MSG4_TYPE_SWITCH_DATA_PATH;
 -	if (vf)
 -		init_pkt->msg.v4_msg.active_dp.active_datapath =
 -			NVSP_DATAPATH_VF;
 -	else
 -		init_pkt->msg.v4_msg.active_dp.active_datapath =
 -			NVSP_DATAPATH_SYNTHETIC;
 -
 -	vmbus_sendpacket(dev->channel, init_pkt,
 -			       sizeof(struct nvsp_message),
 -			       (unsigned long)init_pkt,
 -			       VM_PKT_DATA_INBAND, 0);
 -}
 -
  
- static struct netvsc_device *alloc_net_device(struct hv_device *device)
+ static struct netvsc_device *alloc_net_device(void)
  {
  	struct netvsc_device *net_device;
++<<<<<<< HEAD
 +	struct net_device *ndev = hv_get_drvdata(device);
++=======
++>>>>>>> 880988348270 (hv_netvsc: set nvdev link after populating chn_table)
  
  	net_device = kzalloc(sizeof(struct netvsc_device), GFP_KERNEL);
  	if (!net_device)
@@@ -50,12 -75,15 +53,23 @@@
  	}
  
  	init_waitqueue_head(&net_device->wait_drain);
 +	net_device->start_remove = false;
  	net_device->destroy = false;
++<<<<<<< HEAD
 +	net_device->dev = device;
 +	net_device->ndev = ndev;
 +
 +	hv_set_drvdata(device, net_device);
++=======
+ 	atomic_set(&net_device->open_cnt, 0);
+ 	atomic_set(&net_device->vf_use_cnt, 0);
+ 	net_device->max_pkt = RNDIS_MAX_PKT_DEFAULT;
+ 	net_device->pkt_align = RNDIS_PKT_ALIGN_DEFAULT;
+ 
+ 	net_device->vf_netdev = NULL;
+ 	net_device->vf_inject = false;
+ 
++>>>>>>> 880988348270 (hv_netvsc: set nvdev link after populating chn_table)
  	return net_device;
  }
  
@@@ -1076,15 -1249,6 +1091,18 @@@ int netvsc_device_add(struct hv_device 
  
  	net_device->ring_size = ring_size;
  
++<<<<<<< HEAD
 +	/*
 +	 * Coming into this function, struct net_device * is
 +	 * registered as the driver private data.
 +	 * In alloc_net_device(), we register struct netvsc_device *
 +	 * as the driver private data and stash away struct net_device *
 +	 * in struct netvsc_device *.
 +	 */
 +	ndev = net_device->ndev;
 +
++=======
++>>>>>>> 880988348270 (hv_netvsc: set nvdev link after populating chn_table)
  	/* Initialize the NetVSC channel extension */
  	init_completion(&net_device->channel_init_wait);
  
* Unmerged path drivers/net/hyperv/netvsc.c
