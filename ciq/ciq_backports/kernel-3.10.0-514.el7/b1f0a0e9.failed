net: add inet_sk_transparent() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] add inet_sk_transparent() helper (Florian Westphal) [1295557]
Rebuild_FUZZ: 92.75%
commit-author Florian Westphal <fw@strlen.de>
commit b1f0a0e99c58fbd7ea053ca36ba623718272b618
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b1f0a0e9.failed

Avoids cluttering tcp_v4_send_reset when followup patch extends
it to deal with timewait sockets.

	Suggested-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b1f0a0e99c58fbd7ea053ca36ba623718272b618)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/request_sock.h
diff --cc include/net/request_sock.h
index 610fa9ea408d,f49759decb28..000000000000
--- a/include/net/request_sock.h
+++ b/include/net/request_sock.h
@@@ -65,13 -68,41 +65,17 @@@ struct request_sock 
  	u32				peer_secid;
  };
  
++<<<<<<< HEAD
 +static inline struct request_sock *reqsk_alloc(const struct request_sock_ops *ops)
++=======
+ static inline struct request_sock *inet_reqsk(const struct sock *sk)
++>>>>>>> b1f0a0e99c58 (net: add inet_sk_transparent() helper)
  {
 -	return (struct request_sock *)sk;
 -}
 +	struct request_sock *req = kmem_cache_alloc(ops->slab, GFP_ATOMIC);
  
 -static inline struct sock *req_to_sk(struct request_sock *req)
 -{
 -	return (struct sock *)req;
 -}
 -
 -static inline struct request_sock *
 -reqsk_alloc(const struct request_sock_ops *ops, struct sock *sk_listener,
 -	    bool attach_listener)
 -{
 -	struct request_sock *req;
 -
 -	req = kmem_cache_alloc(ops->slab, GFP_ATOMIC | __GFP_NOWARN);
 -
 -	if (req) {
 +	if (req != NULL)
  		req->rsk_ops = ops;
 -		if (attach_listener) {
 -			sock_hold(sk_listener);
 -			req->rsk_listener = sk_listener;
 -		} else {
 -			req->rsk_listener = NULL;
 -		}
 -		req_to_sk(req)->sk_prot = sk_listener->sk_prot;
 -		sk_node_init(&req_to_sk(req)->sk_node);
 -		sk_tx_queue_clear(req_to_sk(req));
 -		req->saved_syn = NULL;
 -		/* Following is temporary. It is coupled with debugging
 -		 * helpers in reqsk_put() & reqsk_free()
 -		 */
 -		atomic_set(&req->rsk_refcnt, 0);
 -	}
 +
  	return req;
  }
  
* Unmerged path include/net/request_sock.h
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 83fa42687eea..80dcad3b7492 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1564,6 +1564,18 @@ static inline void tcp_highest_sack_combine(struct sock *sk,
 		tcp_sk(sk)->highest_sack = new;
 }
 
+/* This helper checks if socket has IP_TRANSPARENT set */
+static inline bool inet_sk_transparent(const struct sock *sk)
+{
+	switch (sk->sk_state) {
+	case TCP_TIME_WAIT:
+		return inet_twsk(sk)->tw_transparent;
+	case TCP_NEW_SYN_RECV:
+		return inet_rsk(inet_reqsk(sk))->no_srccheck;
+	}
+	return inet_sk(sk)->transparent;
+}
+
 /* Determines whether this is a thin stream (which may suffer from
  * increased latency). Used to trigger latency-reducing mechanisms.
  */
