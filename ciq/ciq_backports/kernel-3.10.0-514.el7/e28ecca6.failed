gpio: fix warning about iterator

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [gpio] fix warning about iterator (Prarit Bhargava) [1358979]
Rebuild_FUZZ: 89.66%
commit-author Sudip Mukherjee <sudipm.mukherjee@gmail.com>
commit e28ecca6eac40646780b83edab81a496cea3d220
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e28ecca6.failed

We were getting build warning about "iterator" being used uninitialized.
Use iterator properly to fix the build warning and in the process remove
the variable "pos" which is not required now.

	Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit e28ecca6eac40646780b83edab81a496cea3d220)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
diff --cc drivers/gpio/gpiolib.c
index 9b50ed619d38,ca6630207c66..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -1127,25 -189,78 +1127,100 @@@ static inline void gpiochip_unexport(st
   */
  static int gpiochip_add_to_list(struct gpio_chip *chip)
  {
++<<<<<<< HEAD
 +	struct list_head *pos = &gpio_chips;
 +	struct gpio_chip *_chip;
 +	int err = 0;
 +
 +	/* find where to insert our chip */
 +	list_for_each(pos, &gpio_chips) {
 +		_chip = list_entry(pos, struct gpio_chip, list);
 +		/* shall we insert before _chip? */
 +		if (_chip->base >= chip->base + chip->ngpio)
 +			break;
 +	}
 +
 +	/* are we stepping on the chip right before? */
 +	if (pos != &gpio_chips && pos->prev != &gpio_chips) {
 +		_chip = list_entry(pos->prev, struct gpio_chip, list);
 +		if (_chip->base + _chip->ngpio > chip->base) {
 +			dev_err(chip->dev,
 +			       "GPIO integer space overlap, cannot add chip\n");
 +			err = -EBUSY;
++=======
+ 	struct gpio_chip *iterator;
+ 	struct gpio_chip *previous = NULL;
+ 
+ 	if (list_empty(&gpio_chips)) {
+ 		list_add_tail(&chip->list, &gpio_chips);
+ 		return 0;
+ 	}
+ 
+ 	list_for_each_entry(iterator, &gpio_chips, list) {
+ 		if (iterator->base >= chip->base + chip->ngpio) {
+ 			/*
+ 			 * Iterator is the first GPIO chip so there is no
+ 			 * previous one
+ 			 */
+ 			if (!previous) {
+ 				goto found;
+ 			} else {
+ 				/*
+ 				 * We found a valid range(means
+ 				 * [base, base + ngpio - 1]) between previous
+ 				 * and iterator chip.
+ 				 */
+ 				if (previous->base + previous->ngpio
+ 						<= chip->base)
+ 					goto found;
+ 			}
+ 		}
+ 		previous = iterator;
+ 	}
+ 
+ 	/*
+ 	 * We are beyond the last chip in the list and iterator now
+ 	 * points to the head.
+ 	 * Let iterator point to the last chip in the list.
+ 	 */
+ 
+ 	iterator = list_last_entry(&gpio_chips, struct gpio_chip, list);
+ 	if (iterator->base + iterator->ngpio <= chip->base)
+ 		goto found;
+ 
+ 	dev_err(chip->parent,
+ 	       "GPIO integer space overlap, cannot add chip\n");
+ 	return -EBUSY;
+ 
+ found:
+ 	list_add_tail(&chip->list, &iterator->list);
+ 	return 0;
+ }
+ 
+ /**
+  * Convert a GPIO name to its descriptor
+  */
+ static struct gpio_desc *gpio_name_to_desc(const char * const name)
+ {
+ 	struct gpio_chip *chip;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&gpio_lock, flags);
+ 
+ 	list_for_each_entry(chip, &gpio_chips, list) {
+ 		int i;
+ 
+ 		for (i = 0; i != chip->ngpio; ++i) {
+ 			struct gpio_desc *gpio = &chip->desc[i];
+ 
+ 			if (!gpio->name || !name)
+ 				continue;
+ 
+ 			if (!strcmp(gpio->name, name)) {
+ 				spin_unlock_irqrestore(&gpio_lock, flags);
+ 				return gpio;
+ 			}
++>>>>>>> e28ecca6eac4 (gpio: fix warning about iterator)
  		}
  	}
  
* Unmerged path drivers/gpio/gpiolib.c
