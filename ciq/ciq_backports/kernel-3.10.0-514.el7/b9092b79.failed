Change how controllers in mixed mode are handled.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [scsi] Change how controllers in mixed mode are handled (Joseph Szczypek) [1274467]
Rebuild_FUZZ: 98.97%
commit-author Kevin Barnett <kevin.barnett@pmcs.com>
commit b9092b79ccaf4404509d6aeb2c76eb7cbfa57bf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b9092b79.failed

	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit b9092b79ccaf4404509d6aeb2c76eb7cbfa57bf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index 31194c450c21,bf877eb61016..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -731,6 -725,100 +731,103 @@@ static ssize_t host_show_hp_ssd_smart_p
  	return snprintf(buf, 20, "%d\n", offload_enabled);
  }
  
++<<<<<<< HEAD
++=======
+ #define MAX_PATHS 8
+ #define PATH_STRING_LEN 50
+ 
+ static ssize_t path_info_show(struct device *dev,
+ 	     struct device_attribute *attr, char *buf)
+ {
+ 	struct ctlr_info *h;
+ 	struct scsi_device *sdev;
+ 	struct hpsa_scsi_dev_t *hdev;
+ 	unsigned long flags;
+ 	int i;
+ 	int output_len = 0;
+ 	u8 box;
+ 	u8 bay;
+ 	u8 path_map_index = 0;
+ 	char *active;
+ 	unsigned char phys_connector[2];
+ 	unsigned char path[MAX_PATHS][PATH_STRING_LEN];
+ 
+ 	memset(path, 0, MAX_PATHS * PATH_STRING_LEN);
+ 	sdev = to_scsi_device(dev);
+ 	h = sdev_to_hba(sdev);
+ 	spin_lock_irqsave(&h->devlock, flags);
+ 	hdev = sdev->hostdata;
+ 	if (!hdev) {
+ 		spin_unlock_irqrestore(&h->devlock, flags);
+ 		return -ENODEV;
+ 	}
+ 
+ 	bay = hdev->bay;
+ 	for (i = 0; i < MAX_PATHS; i++) {
+ 		path_map_index = 1<<i;
+ 		if (i == hdev->active_path_index)
+ 			active = "Active";
+ 		else if (hdev->path_map & path_map_index)
+ 			active = "Inactive";
+ 		else
+ 			continue;
+ 
+ 		output_len = snprintf(path[i],
+ 				PATH_STRING_LEN, "[%d:%d:%d:%d] %20.20s ",
+ 				h->scsi_host->host_no,
+ 				hdev->bus, hdev->target, hdev->lun,
+ 				scsi_device_type(hdev->devtype));
+ 
+ 		if (is_ext_target(h, hdev) ||
+ 			(hdev->devtype == TYPE_RAID) ||
+ 			is_logical_dev_addr_mode(hdev->scsi3addr)) {
+ 			output_len += snprintf(path[i] + output_len,
+ 						PATH_STRING_LEN, "%s\n",
+ 						active);
+ 			continue;
+ 		}
+ 
+ 		box = hdev->box[i];
+ 		memcpy(&phys_connector, &hdev->phys_connector[i],
+ 			sizeof(phys_connector));
+ 		if (phys_connector[0] < '0')
+ 			phys_connector[0] = '0';
+ 		if (phys_connector[1] < '0')
+ 			phys_connector[1] = '0';
+ 		if (hdev->phys_connector[i] > 0)
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN,
+ 				"PORT: %.2s ",
+ 				phys_connector);
+ 		if (hdev->devtype == TYPE_DISK &&
+ 			hdev->expose_state != HPSA_DO_NOT_EXPOSE) {
+ 			if (box == 0 || box == 0xFF) {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BAY: %hhu %s\n",
+ 					bay, active);
+ 			} else {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BOX: %hhu BAY: %hhu %s\n",
+ 					box, bay, active);
+ 			}
+ 		} else if (box != 0 && box != 0xFF) {
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "BOX: %hhu %s\n",
+ 				box, active);
+ 		} else
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "%s\n", active);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&h->devlock, flags);
+ 	return snprintf(buf, output_len+1, "%s%s%s%s%s%s%s%s",
+ 		path[0], path[1], path[2], path[3],
+ 		path[4], path[5], path[6], path[7]);
+ }
+ 
++>>>>>>> b9092b79ccaf (Change how controllers in mixed mode are handled.)
  static DEVICE_ATTR(raid_level, S_IRUGO, raid_level_show, NULL);
  static DEVICE_ATTR(lunid, S_IRUGO, lunid_show, NULL);
  static DEVICE_ATTR(unique_id, S_IRUGO, unique_id_show, NULL);
@@@ -3784,20 -3824,15 +3815,24 @@@ static void hpsa_update_scsi_devices(st
  				ncurrent++;
  			break;
  		case TYPE_DISK:
- 			if (i >= nphysicals) {
- 				ncurrent++;
- 				break;
- 			}
- 
- 			if (h->hba_mode_enabled)
- 				/* never use raid mapper in HBA mode */
+ 			if (i < nphysicals + (raid_ctlr_position == 0)) {
+ 				/* The disk is in HBA mode. */
+ 				/* Never use RAID mapper in HBA mode. */
  				this_device->offload_enabled = 0;
++<<<<<<< HEAD
 +			else if (!(h->transMethod & CFGTBL_Trans_io_accel1 ||
 +				h->transMethod & CFGTBL_Trans_io_accel2))
 +				break;
 +			hpsa_get_ioaccel_drive_info(h, this_device,
 +						lunaddrbytes, id_phys);
 +			atomic_set(&this_device->ioaccel_cmds_out, 0);
++=======
+ 				hpsa_get_ioaccel_drive_info(h, this_device,
+ 					lunaddrbytes, id_phys);
+ 				hpsa_get_path_info(this_device, lunaddrbytes,
+ 							id_phys);
+ 			}
++>>>>>>> b9092b79ccaf (Change how controllers in mixed mode are handled.)
  			ncurrent++;
  			break;
  		case TYPE_TAPE:
* Unmerged path drivers/scsi/hpsa.c
diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6f6084b39420..6e81c98831bf 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -111,7 +111,6 @@ struct bmic_controller_parameters {
 	u8   automatic_drive_slamming;
 	u8   reserved1;
 	u8   nvram_flags;
-#define HBA_MODE_ENABLED_FLAG (1 << 3)
 	u8   cache_nvram_flags;
 	u8   drive_config_flags;
 	u16  reserved2;
@@ -150,7 +149,6 @@ struct ctlr_info {
 	unsigned int msi_vector;
 	int intr_mode; /* either PERF_MODE_INT or SIMPLE_MODE_INT */
 	struct access_method access;
-	char hba_mode_enabled;
 
 	/* queue and queue Info */
 	unsigned int Qdepth;
