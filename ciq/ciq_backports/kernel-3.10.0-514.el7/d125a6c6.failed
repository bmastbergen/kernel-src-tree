staging/rdma/hfi1: Fix comparison to NULL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Fix comparison to NULL (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 89.19%
commit-author Jubin John <jubin.john@intel.com>
commit d125a6c66b972e8c6768707c2814107df5963f5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d125a6c6.failed

Convert pointer comparisons to NULL to !pointer
to fix checkpatch check:
CHECK: Comparison to NULL could be written "!pointer"

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d125a6c66b972e8c6768707c2814107df5963f5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
#	drivers/staging/hfi1/debugfs.c
#	drivers/staging/hfi1/driver.c
#	drivers/staging/hfi1/verbs.c
diff --cc drivers/staging/hfi1/chip.c
index 2f61b64fc695,ea0ffd467cdf..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -12358,10 -12371,9 +12358,16 @@@ static void clean_up_interrupts(struct 
  		struct hfi1_msix_entry *me = dd->msix_entries;
  
  		for (i = 0; i < dd->num_msix_entries; i++, me++) {
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +			if (me->arg == NULL) /* => no irq, no affinity */
 +				break;
 +			irq_set_affinity_hint(dd->msix_entries[i].msix.vector,
 +					NULL);
++=======
+ 			if (!me->arg) /* => no irq, no affinity */
+ 				continue;
+ 			hfi1_put_irq_affinity(dd, &dd->msix_entries[i]);
++>>>>>>> d125a6c66b97 (staging/rdma/hfi1: Fix comparison to NULL):drivers/staging/rdma/hfi1/chip.c
  			free_irq(me->msix.vector, me->arg);
  		}
  	} else {
@@@ -12572,10 -12534,10 +12578,10 @@@ static int request_msix_irqs(struct hfi
  			continue;
  		}
  		/* no argument, no interrupt */
- 		if (arg == NULL)
+ 		if (!arg)
  			continue;
  		/* make sure the name is terminated */
 -		me->name[sizeof(me->name) - 1] = 0;
 +		me->name[sizeof(me->name)-1] = 0;
  
  		ret = request_threaded_irq(me->msix.vector, handler, thread, 0,
  						me->name, arg);
diff --cc drivers/staging/hfi1/debugfs.c
index d6dc339fb2a3,fa3df1f75f5d..000000000000
--- a/drivers/staging/hfi1/debugfs.c
+++ b/drivers/staging/hfi1/debugfs.c
@@@ -749,8 -746,8 +749,13 @@@ void hfi1_dbg_ibdev_init(struct hfi1_ib
  					    ibd->hfi1_ibdev_dbg,
  					    ppd,
  					    &port_cntr_ops[i].ops,
++<<<<<<< HEAD:drivers/staging/hfi1/debugfs.c
 +					    port_cntr_ops[i].ops.write == NULL ?
 +					    S_IRUGO : S_IRUGO|S_IWUSR);
++=======
+ 					    !port_cntr_ops[i].ops.write ?
+ 					    S_IRUGO : S_IRUGO | S_IWUSR);
++>>>>>>> d125a6c66b97 (staging/rdma/hfi1: Fix comparison to NULL):drivers/staging/rdma/hfi1/debugfs.c
  		}
  }
  
diff --cc drivers/staging/hfi1/driver.c
index 31605ee909b6,0c8bd9174245..000000000000
--- a/drivers/staging/hfi1/driver.c
+++ b/drivers/staging/hfi1/driver.c
@@@ -380,10 -399,10 +380,15 @@@ static void rcv_hdrerr(struct hfi1_ctxt
  				sc5 |= 0x10;
  			sl = ibp->sc_to_sl[sc5];
  
 -			lqpn = be32_to_cpu(bth[1]) & RVT_QPN_MASK;
 +			lqpn = be32_to_cpu(bth[1]) & HFI1_QPN_MASK;
  			rcu_read_lock();
++<<<<<<< HEAD:drivers/staging/hfi1/driver.c
 +			qp = hfi1_lookup_qpn(ibp, lqpn);
 +			if (qp == NULL) {
++=======
+ 			qp = rvt_lookup_qpn(rdi, &ibp->rvp, lqpn);
+ 			if (!qp) {
++>>>>>>> d125a6c66b97 (staging/rdma/hfi1: Fix comparison to NULL):drivers/staging/rdma/hfi1/driver.c
  				rcu_read_unlock();
  				goto drop;
  			}
@@@ -614,11 -633,11 +619,11 @@@ static void prescan_rxq(struct hfi1_pac
  		if (!is_ecn)
  			goto next;
  
 -		qpn = bth1 & RVT_QPN_MASK;
 +		qpn = bth1 & HFI1_QPN_MASK;
  		rcu_read_lock();
 -		qp = rvt_lookup_qpn(rdi, &ibp->rvp, qpn);
 +		qp = hfi1_lookup_qpn(ibp, qpn);
  
- 		if (qp == NULL) {
+ 		if (!qp) {
  			rcu_read_unlock();
  			goto next;
  		}
diff --cc drivers/staging/hfi1/verbs.c
index d228eb7fc4f0,c412f1c6637c..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -641,8 -430,8 +641,13 @@@ void hfi1_ib_rcv(struct hfi1_packet *pa
  
  		if (lnh != HFI1_LRH_GRH)
  			goto drop;
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +		mcast = hfi1_mcast_find(ibp, &hdr->u.l.grh.dgid);
 +		if (mcast == NULL)
++=======
+ 		mcast = rvt_mcast_find(&ibp->rvp, &hdr->u.l.grh.dgid);
+ 		if (!mcast)
++>>>>>>> d125a6c66b97 (staging/rdma/hfi1: Fix comparison to NULL):drivers/staging/rdma/hfi1/verbs.c
  			goto drop;
  		list_for_each_entry_rcu(p, &mcast->qp_list, list) {
  			packet->qp = p->qp;
@@@ -1152,8 -835,12 +1157,17 @@@ int hfi1_verbs_send_pio(struct hfi1_qp 
  		pbc_flags |= (!!(sc5 & 0x10)) << PBC_DC_INFO_SHIFT;
  		pbc = create_pbc(ppd, pbc_flags, qp->srate_mbps, vl, plen);
  	}
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	pbuf = sc_buffer_alloc(sc, plen, NULL, NULL);
 +	if (unlikely(pbuf == NULL)) {
++=======
+ 	if (cb)
+ 		iowait_pio_inc(&priv->s_iowait);
+ 	pbuf = sc_buffer_alloc(sc, plen, cb, qp);
+ 	if (unlikely(!pbuf)) {
+ 		if (cb)
+ 			verbs_pio_complete(qp, 0);
++>>>>>>> d125a6c66b97 (staging/rdma/hfi1: Fix comparison to NULL):drivers/staging/rdma/hfi1/verbs.c
  		if (ppd->host_link_state != HLS_UP_ACTIVE) {
  			/*
  			 * If we have filled the PIO buffers to capacity and are
* Unmerged path drivers/staging/hfi1/chip.c
* Unmerged path drivers/staging/hfi1/debugfs.c
* Unmerged path drivers/staging/hfi1/driver.c
diff --git a/drivers/staging/hfi1/init.c b/drivers/staging/hfi1/init.c
index c64c8dd680db..ce6021a7009e 100644
--- a/drivers/staging/hfi1/init.c
+++ b/drivers/staging/hfi1/init.c
@@ -381,7 +381,7 @@ void set_link_ipg(struct hfi1_pportdata *ppd)
 
 	cc_state = get_cc_state(ppd);
 
-	if (cc_state == NULL)
+	if (!cc_state)
 		/*
 		 * This should _never_ happen - rcu_read_lock() is held,
 		 * and set_link_ipg() should not be called if cc_state
@@ -433,7 +433,7 @@ static enum hrtimer_restart cca_timer_fn(struct hrtimer *t)
 
 	cc_state = get_cc_state(ppd);
 
-	if (cc_state == NULL) {
+	if (!cc_state) {
 		rcu_read_unlock();
 		return HRTIMER_NORESTART;
 	}
diff --git a/drivers/staging/hfi1/mad.c b/drivers/staging/hfi1/mad.c
index b6006cf469fc..c725cee452ce 100644
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@ -3283,7 +3283,7 @@ static int __subn_get_opa_cong_setting(struct opa_smp *smp, u32 am,
 
 	cc_state = get_cc_state(ppd);
 
-	if (cc_state == NULL) {
+	if (!cc_state) {
 		rcu_read_unlock();
 		return reply((struct ib_mad_hdr *)smp);
 	}
@@ -3425,7 +3425,7 @@ static int __subn_get_opa_cc_table(struct opa_smp *smp, u32 am, u8 *data,
 
 	cc_state = get_cc_state(ppd);
 
-	if (cc_state == NULL) {
+	if (!cc_state) {
 		rcu_read_unlock();
 		return reply((struct ib_mad_hdr *)smp);
 	}
@@ -3491,14 +3491,14 @@ static int __subn_set_opa_cc_table(struct opa_smp *smp, u32 am, u8 *data,
 	}
 
 	new_cc_state = kzalloc(sizeof(*new_cc_state), GFP_KERNEL);
-	if (new_cc_state == NULL)
+	if (!new_cc_state)
 		goto getit;
 
 	spin_lock(&ppd->cc_state_lock);
 
 	old_cc_state = get_cc_state(ppd);
 
-	if (old_cc_state == NULL) {
+	if (!old_cc_state) {
 		spin_unlock(&ppd->cc_state_lock);
 		kfree(new_cc_state);
 		return reply((struct ib_mad_hdr *)smp);
diff --git a/drivers/staging/hfi1/pio.c b/drivers/staging/hfi1/pio.c
index 25d65f9a0b94..a5f923a177c9 100644
--- a/drivers/staging/hfi1/pio.c
+++ b/drivers/staging/hfi1/pio.c
@@ -1771,7 +1771,7 @@ int init_credit_return(struct hfi1_devdata *dd)
 					bytes,
 					&dd->cr_base[i].pa,
 					GFP_KERNEL);
-		if (dd->cr_base[i].va == NULL) {
+		if (!dd->cr_base[i].va) {
 			set_dev_node(&dd->pcidev->dev, dd->node);
 			dd_dev_err(dd,
 				"Unable to allocate credit return DMA range for NUMA %d\n",
diff --git a/drivers/staging/hfi1/rc.c b/drivers/staging/hfi1/rc.c
index dd57d65aa9b2..0b649728a260 100644
--- a/drivers/staging/hfi1/rc.c
+++ b/drivers/staging/hfi1/rc.c
@@ -1900,7 +1900,7 @@ void process_becn(struct hfi1_pportdata *ppd, u8 sl, u16 rlid, u32 lqpn,
 
 	cc_state = get_cc_state(ppd);
 
-	if (cc_state == NULL)
+	if (!cc_state)
 		return;
 
 	/*
diff --git a/drivers/staging/hfi1/sysfs.c b/drivers/staging/hfi1/sysfs.c
index 1645ca8a2c0f..5888caf84ae7 100644
--- a/drivers/staging/hfi1/sysfs.c
+++ b/drivers/staging/hfi1/sysfs.c
@@ -84,7 +84,7 @@ static ssize_t read_cc_table_bin(struct file *filp, struct kobject *kobj,
 
 	rcu_read_lock();
 	cc_state = get_cc_state(ppd);
-	if (cc_state == NULL) {
+	if (!cc_state) {
 		rcu_read_unlock();
 		return -EINVAL;
 	}
@@ -135,7 +135,7 @@ static ssize_t read_cc_setting_bin(struct file *filp, struct kobject *kobj,
 
 	rcu_read_lock();
 	cc_state = get_cc_state(ppd);
-	if (cc_state == NULL) {
+	if (!cc_state) {
 		rcu_read_unlock();
 		return -EINVAL;
 	}
* Unmerged path drivers/staging/hfi1/verbs.c
