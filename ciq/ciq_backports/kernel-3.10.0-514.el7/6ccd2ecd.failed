rcu: Improve diagnostics for spurious RCU CPU stall warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 6ccd2ecd422644277b7d8b37222e3af3f43ea9ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6ccd2ecd.failed

The current RCU CPU stall warning code will print "Stall ended before
state dump start" any time that the stall-warning code is triggered on
a CPU that has already reported a quiescent state for the current grace
period and if all quiescent states have been reported for the current
grace period.  However, a true stall can result in these symptoms, for
example, by preventing RCU's grace-period kthreads from ever running

This commit therefore checks for this condition, reporting the end of
the stall only if one of the grace-period counters has actually advanced.
Otherwise, it reports the last time that the grace-period kthread made
meaningful progress.  (In normal situations, the grace-period kthread
should make meaningful progress at least every jiffies_till_next_fqs
jiffies.)

	Reported-by: Miroslav Benes <mbenes@suse.cz>
	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Tested-by: Miroslav Benes <mbenes@suse.cz>
(cherry picked from commit 6ccd2ecd422644277b7d8b37222e3af3f43ea9ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcutree.c
diff --cc kernel/rcutree.c
index 6f2a22b77db7,a2ceb66bcd67..000000000000
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@@ -1414,11 -1636,22 +1428,16 @@@ static int rcu_gp_init(struct rcu_stat
  	struct rcu_data *rdp;
  	struct rcu_node *rnp = rcu_get_root(rsp);
  
++<<<<<<< HEAD:kernel/rcutree.c
++=======
+ 	ACCESS_ONCE(rsp->gp_activity) = jiffies;
+ 	rcu_bind_gp_kthread();
++>>>>>>> 6ccd2ecd4226 (rcu: Improve diagnostics for spurious RCU CPU stall warnings):kernel/rcu/tree.c
  	raw_spin_lock_irq(&rnp->lock);
 -	smp_mb__after_unlock_lock();
 -	if (!ACCESS_ONCE(rsp->gp_flags)) {
 -		/* Spurious wakeup, tell caller to go back to sleep.  */
 -		raw_spin_unlock_irq(&rnp->lock);
 -		return 0;
 -	}
 -	ACCESS_ONCE(rsp->gp_flags) = 0; /* Clear all flags: New grace period. */
 +	rsp->gp_flags = 0; /* Clear all flags: New grace period. */
  
 -	if (WARN_ON_ONCE(rcu_gp_in_progress(rsp))) {
 -		/*
 -		 * Grace period already in progress, don't start another.
 -		 * Not supposed to be able to happen.
 -		 */
 +	if (rcu_gp_in_progress(rsp)) {
 +		/* Grace period already in progress, don't start another.  */
  		raw_spin_unlock_irq(&rnp->lock);
  		return 0;
  	}
@@@ -1460,12 -1696,8 +1479,17 @@@
  					    rnp->level, rnp->grplo,
  					    rnp->grphi, rnp->qsmask);
  		raw_spin_unlock_irq(&rnp->lock);
++<<<<<<< HEAD:kernel/rcutree.c
 +#ifdef CONFIG_PROVE_RCU_DELAY
 +		if ((prandom_u32() % (rcu_num_nodes + 1)) == 0 &&
 +		    system_state == SYSTEM_RUNNING)
 +			udelay(200);
 +#endif /* #ifdef CONFIG_PROVE_RCU_DELAY */
 +		cond_resched();
++=======
+ 		cond_resched_rcu_qs();
+ 		ACCESS_ONCE(rsp->gp_activity) = jiffies;
++>>>>>>> 6ccd2ecd4226 (rcu: Improve diagnostics for spurious RCU CPU stall warnings):kernel/rcu/tree.c
  	}
  
  	mutex_unlock(&rsp->onoff_mutex);
@@@ -1475,11 -1707,14 +1499,12 @@@
  /*
   * Do one round of quiescent-state forcing.
   */
 -static int rcu_gp_fqs(struct rcu_state *rsp, int fqs_state_in)
 +int rcu_gp_fqs(struct rcu_state *rsp, int fqs_state_in)
  {
  	int fqs_state = fqs_state_in;
 -	bool isidle = false;
 -	unsigned long maxj;
  	struct rcu_node *rnp = rcu_get_root(rsp);
  
+ 	ACCESS_ONCE(rsp->gp_activity) = jiffies;
  	rsp->n_force_qs++;
  	if (fqs_state == RCU_SAVE_DYNTICK) {
  		/* Collect dyntick-idle snapshots. */
@@@ -1508,7 -1753,9 +1533,8 @@@ static void rcu_gp_cleanup(struct rcu_s
  	struct rcu_data *rdp;
  	struct rcu_node *rnp = rcu_get_root(rsp);
  
+ 	ACCESS_ONCE(rsp->gp_activity) = jiffies;
  	raw_spin_lock_irq(&rnp->lock);
 -	smp_mb__after_unlock_lock();
  	gp_duration = jiffies - rsp->gp_start;
  	if (gp_duration > rsp->gp_max)
  		rsp->gp_max = gp_duration;
@@@ -1537,10 -1784,13 +1563,15 @@@
  		ACCESS_ONCE(rnp->completed) = rsp->gpnum;
  		rdp = this_cpu_ptr(rsp->rda);
  		if (rnp == rdp->mynode)
 -			needgp = __note_gp_changes(rsp, rnp, rdp) || needgp;
 -		/* smp_mb() provided by prior unlock-lock pair. */
 +			__rcu_process_gp_end(rsp, rnp, rdp);
  		nocb += rcu_future_gp_cleanup(rsp, rnp);
  		raw_spin_unlock_irq(&rnp->lock);
++<<<<<<< HEAD:kernel/rcutree.c
 +		cond_resched();
++=======
+ 		cond_resched_rcu_qs();
+ 		ACCESS_ONCE(rsp->gp_activity) = jiffies;
++>>>>>>> 6ccd2ecd4226 (rcu: Improve diagnostics for spurious RCU CPU stall warnings):kernel/rcu/tree.c
  	}
  	rnp = rcu_get_root(rsp);
  	raw_spin_lock_irq(&rnp->lock);
@@@ -1571,14 -1829,22 +1602,23 @@@ static int __noreturn rcu_gp_kthread(vo
  
  		/* Handle grace-period start. */
  		for (;;) {
 -			trace_rcu_grace_period(rsp->name,
 -					       ACCESS_ONCE(rsp->gpnum),
 -					       TPS("reqwait"));
 -			rsp->gp_state = RCU_GP_WAIT_GPS;
  			wait_event_interruptible(rsp->gp_wq,
 -						 ACCESS_ONCE(rsp->gp_flags) &
 +						 rsp->gp_flags &
  						 RCU_GP_FLAG_INIT);
 -			/* Locking provides needed memory barrier. */
 -			if (rcu_gp_init(rsp))
 +			if ((rsp->gp_flags & RCU_GP_FLAG_INIT) &&
 +			    rcu_gp_init(rsp))
  				break;
++<<<<<<< HEAD:kernel/rcutree.c
 +			cond_resched();
 +			flush_signals(current);
++=======
+ 			cond_resched_rcu_qs();
+ 			ACCESS_ONCE(rsp->gp_activity) = jiffies;
+ 			WARN_ON(signal_pending(current));
+ 			trace_rcu_grace_period(rsp->name,
+ 					       ACCESS_ONCE(rsp->gpnum),
+ 					       TPS("reqwaitsig"));
++>>>>>>> 6ccd2ecd4226 (rcu: Improve diagnostics for spurious RCU CPU stall warnings):kernel/rcu/tree.c
  		}
  
  		/* Handle quiescent-state forcing. */
@@@ -1600,13 -1874,25 +1640,29 @@@
  			    !rcu_preempt_blocked_readers_cgp(rnp))
  				break;
  			/* If time for quiescent-state forcing, do it. */
 -			if (ULONG_CMP_GE(jiffies, rsp->jiffies_force_qs) ||
 -			    (gf & RCU_GP_FLAG_FQS)) {
 -				trace_rcu_grace_period(rsp->name,
 -						       ACCESS_ONCE(rsp->gpnum),
 -						       TPS("fqsstart"));
 +			if (ret == 0 || (rsp->gp_flags & RCU_GP_FLAG_FQS)) {
  				fqs_state = rcu_gp_fqs(rsp, fqs_state);
++<<<<<<< HEAD:kernel/rcutree.c
 +				cond_resched();
 +			} else {
 +				/* Deal with stray signal. */
 +				cond_resched();
 +				flush_signals(current);
++=======
+ 				trace_rcu_grace_period(rsp->name,
+ 						       ACCESS_ONCE(rsp->gpnum),
+ 						       TPS("fqsend"));
+ 				cond_resched_rcu_qs();
+ 				ACCESS_ONCE(rsp->gp_activity) = jiffies;
+ 			} else {
+ 				/* Deal with stray signal. */
+ 				cond_resched_rcu_qs();
+ 				ACCESS_ONCE(rsp->gp_activity) = jiffies;
+ 				WARN_ON(signal_pending(current));
+ 				trace_rcu_grace_period(rsp->name,
+ 						       ACCESS_ONCE(rsp->gpnum),
+ 						       TPS("fqswaitsig"));
++>>>>>>> 6ccd2ecd4226 (rcu: Improve diagnostics for spurious RCU CPU stall warnings):kernel/rcu/tree.c
  			}
  			j = jiffies_till_next_fqs;
  			if (j > HZ) {
diff --git a/Documentation/RCU/stallwarn.txt b/Documentation/RCU/stallwarn.txt
index 8e9359de1d28..5abea29b41a0 100644
--- a/Documentation/RCU/stallwarn.txt
+++ b/Documentation/RCU/stallwarn.txt
@@ -170,6 +170,11 @@ o	A CPU looping with bottom halves disabled.  This condition can
 o	For !CONFIG_PREEMPT kernels, a CPU looping anywhere in the kernel
 	without invoking schedule().
 
+o	Anything that prevents RCU's grace-period kthreads from running.
+	This can result in the "All QSes seen" console-log message.
+	This message will include information on when the kthread last
+	ran and how often it should be expected to run.
+
 o	A CPU-bound real-time task in a CONFIG_PREEMPT kernel, which might
 	happen to preempt a low-priority task in the middle of an RCU
 	read-side critical section.   This is especially damaging if
* Unmerged path kernel/rcutree.c
diff --git a/kernel/rcutree.h b/kernel/rcutree.h
index bfacdaeba90d..e1940ad497d5 100644
--- a/kernel/rcutree.h
+++ b/kernel/rcutree.h
@@ -441,6 +441,8 @@ struct rcu_state {
 						/*  due to no GP active. */
 	unsigned long gp_start;			/* Time at which GP started, */
 						/*  but in jiffies. */
+	unsigned long gp_activity;		/* Time of last GP kthread */
+						/*  activity in jiffies. */
 	unsigned long jiffies_stall;		/* Time at which to check */
 						/*  for CPU stalls. */
 	unsigned long gp_max;			/* Maximum GP duration in */
