mmc: sdhci: Disable re-tuning for HS400

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit b5540ce1512eede3bed68ab1e9949df9ad556091
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5540ce1.failed

Re-tuning for HS400 mode must be done in HS200
mode. Currently there is no support for that.
That needs to be reflected in the code.
Specifically, if tuning is executed in HS400 mode
then return an error, and do not start the
tuning timer if HS200 tuning is being done prior
to switching to HS400.

Note that periodic re-tuning is not expected
to be needed for HS400 but re-tuning is still
needed after the host controller has lost power.
In the case of suspend/resume that is not necessary
because the card is fully re-initialised. That
just leaves runtime suspend/resume with no support
for HS400 re-tuning.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit b5540ce1512eede3bed68ab1e9949df9ad556091)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
#	include/linux/mmc/sdhci.h
diff --cc drivers/mmc/host/sdhci.c
index 30eeaa114d6a,398e9e496736..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -1861,22 -1878,36 +1861,47 @@@ static int sdhci_card_busy(struct mmc_h
  	return !(present_state & SDHCI_DATA_LVL_MASK);
  }
  
+ static int sdhci_prepare_hs400_tuning(struct mmc_host *mmc, struct mmc_ios *ios)
+ {
+ 	struct sdhci_host *host = mmc_priv(mmc);
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&host->lock, flags);
+ 	host->flags |= SDHCI_HS400_TUNING;
+ 	spin_unlock_irqrestore(&host->lock, flags);
+ 
+ 	return 0;
+ }
+ 
  static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
  {
 -	struct sdhci_host *host = mmc_priv(mmc);
 +	struct sdhci_host *host;
  	u16 ctrl;
 +	u32 ier;
  	int tuning_loop_counter = MAX_TUNING_LOOP;
  	int err = 0;
 +	bool requires_tuning_nonuhs = false;
  	unsigned long flags;
++<<<<<<< HEAD
 +
 +	host = mmc_priv(mmc);
++=======
+ 	unsigned int tuning_count = 0;
+ 	bool hs400_tuning;
++>>>>>>> b5540ce1512e (mmc: sdhci: Disable re-tuning for HS400)
  
  	sdhci_runtime_pm_get(host);
  	spin_lock_irqsave(&host->lock, flags);
  
++<<<<<<< HEAD
 +	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
++=======
+ 	hs400_tuning = host->flags & SDHCI_HS400_TUNING;
+ 	host->flags &= ~SDHCI_HS400_TUNING;
+ 
+ 	if (host->tuning_mode == SDHCI_TUNING_MODE_1)
+ 		tuning_count = host->tuning_count;
++>>>>>>> b5540ce1512e (mmc: sdhci: Disable re-tuning for HS400)
  
  	/*
  	 * The Host Controller needs tuning only in case of SDR104 mode
@@@ -1885,18 -1916,32 +1910,38 @@@
  	 * If the Host Controller supports the HS200 mode then the
  	 * tuning function has to be executed.
  	 */
++<<<<<<< HEAD
 +	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR50) &&
 +	    (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
 +	     host->flags & SDHCI_SDR104_NEEDS_TUNING))
 +		requires_tuning_nonuhs = true;
++=======
+ 	switch (host->timing) {
+ 	/* HS400 tuning is done in HS200 mode */
+ 	case MMC_TIMING_MMC_HS400:
+ 		err = -EINVAL;
+ 		goto out_unlock;
+ 
+ 	case MMC_TIMING_MMC_HS200:
+ 		/*
+ 		 * Periodic re-tuning for HS400 is not expected to be needed, so
+ 		 * disable it here.
+ 		 */
+ 		if (hs400_tuning)
+ 			tuning_count = 0;
+ 		break;
+ 
+ 	case MMC_TIMING_UHS_SDR104:
+ 		break;
++>>>>>>> b5540ce1512e (mmc: sdhci: Disable re-tuning for HS400)
  
 -	case MMC_TIMING_UHS_SDR50:
 -		if (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
 -		    host->flags & SDHCI_SDR104_NEEDS_TUNING)
 -			break;
 -		/* FALLTHROUGH */
 -
 -	default:
 -		goto out_unlock;
 +	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR104) ||
 +	    requires_tuning_nonuhs)
 +		ctrl |= SDHCI_CTRL_EXEC_TUNING;
 +	else {
 +		spin_unlock_irqrestore(&host->lock, flags);
 +		sdhci_runtime_pm_put(host);
 +		return 0;
  	}
  
  	if (host->ops->platform_execute_tuning) {
diff --cc include/linux/mmc/sdhci.h
index 7c176e5d3cf5,f767a0de611f..000000000000
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@@ -126,6 -136,8 +126,11 @@@ struct sdhci_host 
  #define SDHCI_SDIO_IRQ_ENABLED	(1<<9)	/* SDIO irq enabled */
  #define SDHCI_SDR104_NEEDS_TUNING (1<<10)	/* SDR104/HS200 needs tuning */
  #define SDHCI_USING_RETUNING_TIMER (1<<11)	/* Host is using a retuning timer for the card */
++<<<<<<< HEAD
++=======
+ #define SDHCI_USE_64_BIT_DMA	(1<<12)	/* Use 64-bit DMA */
+ #define SDHCI_HS400_TUNING	(1<<13)	/* Tuning for HS400 */
++>>>>>>> b5540ce1512e (mmc: sdhci: Disable re-tuning for HS400)
  
  	unsigned int version;	/* SDHCI spec. version */
  
* Unmerged path drivers/mmc/host/sdhci.c
* Unmerged path include/linux/mmc/sdhci.h
