IB/core: Rename rdma_addr_find_dmac_by_grh

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matan Barak <matanb@mellanox.com>
commit f7f4b23e27f7561330ef13f93dbe8f2dc410efa7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f7f4b23e.failed

rdma_addr_find_dmac_by_grh resolves dmac, vlan_id and if_index and
downsteram patch will also add hop_limit as an output parameter,
thus we rename it to rdma_addr_find_l2_eth_by_grh.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit f7f4b23e27f7561330ef13f93dbe8f2dc410efa7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/addr.c
#	drivers/infiniband/core/verbs.c
#	drivers/infiniband/hw/ocrdma/ocrdma_ah.c
#	include/rdma/ib_addr.h
diff --cc drivers/infiniband/core/addr.c
index 746cdf56bc76,af1d040bac9a..000000000000
--- a/drivers/infiniband/core/addr.c
+++ b/drivers/infiniband/core/addr.c
@@@ -457,8 -541,9 +457,14 @@@ static void resolve_cb(int status, stru
  	complete(&((struct resolve_cb_context *)context)->comp);
  }
  
++<<<<<<< HEAD
 +int rdma_addr_find_dmac_by_grh(const union ib_gid *sgid, const union ib_gid *dgid,
 +			       u8 *dmac, u16 *vlan_id)
++=======
+ int rdma_addr_find_l2_eth_by_grh(const union ib_gid *sgid,
+ 				 const union ib_gid *dgid,
+ 				 u8 *dmac, u16 *vlan_id, int *if_index)
++>>>>>>> f7f4b23e27f7 (IB/core: Rename rdma_addr_find_dmac_by_grh)
  {
  	int ret = 0;
  	struct rdma_dev_addr dev_addr;
diff --cc drivers/infiniband/core/verbs.c
index 6ff33ede8c15,97cbc96892a7..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -315,18 -442,61 +315,36 @@@ int ib_init_ah_from_wc(struct ib_devic
  		if (!(wc->wc_flags & IB_WC_GRH))
  			return -EPROTOTYPE;
  
++<<<<<<< HEAD
 +		if (wc->wc_flags & IB_WC_WITH_SMAC &&
 +		    wc->wc_flags & IB_WC_WITH_VLAN) {
 +			memcpy(ah_attr->dmac, wc->smac, ETH_ALEN);
 +			ah_attr->vlan_id = wc->vlan_id;
 +		} else {
 +			ret = rdma_addr_find_dmac_by_grh(&grh->dgid, &grh->sgid,
 +					ah_attr->dmac, &ah_attr->vlan_id);
 +			if (ret)
 +				return ret;
++=======
+ 		if (!device->get_netdev)
+ 			return -EOPNOTSUPP;
+ 
+ 		idev = device->get_netdev(device, port_num);
+ 		if (!idev)
+ 			return -ENODEV;
+ 
+ 		ret = rdma_addr_find_l2_eth_by_grh(&dgid, &sgid,
+ 						   ah_attr->dmac,
+ 						   wc->wc_flags & IB_WC_WITH_VLAN ?
+ 						   NULL : &vlan_id,
+ 						   &if_index);
+ 		if (ret) {
+ 			dev_put(idev);
+ 			return ret;
++>>>>>>> f7f4b23e27f7 (IB/core: Rename rdma_addr_find_dmac_by_grh)
  		}
 -
 -		resolved_dev = dev_get_by_index(&init_net, if_index);
 -		if (resolved_dev->flags & IFF_LOOPBACK) {
 -			dev_put(resolved_dev);
 -			resolved_dev = idev;
 -			dev_hold(resolved_dev);
 -		}
 -		rcu_read_lock();
 -		if (resolved_dev != idev && !rdma_is_upper_dev_rcu(idev,
 -								   resolved_dev))
 -			ret = -EHOSTUNREACH;
 -		rcu_read_unlock();
 -		dev_put(idev);
 -		dev_put(resolved_dev);
 -		if (ret)
 -			return ret;
 -
 -		ret = get_sgid_index_from_eth(device, port_num, vlan_id,
 -					      &dgid, gid_type, &gid_index);
 -		if (ret)
 -			return ret;
 +	} else {
 +		ah_attr->vlan_id = 0xffff;
  	}
  
  	ah_attr->dlid = wc->slid;
@@@ -973,35 -1118,53 +991,54 @@@ int ib_modify_qp_is_ok(enum ib_qp_stat
  }
  EXPORT_SYMBOL(ib_modify_qp_is_ok);
  
 -int ib_resolve_eth_dmac(struct ib_qp *qp,
 -			struct ib_qp_attr *qp_attr, int *qp_attr_mask)
 +int ib_resolve_eth_l2_attrs(struct ib_qp *qp,
 +			    struct ib_qp_attr *qp_attr, int *qp_attr_mask)
  {
  	int           ret = 0;
 +	union ib_gid  sgid;
  
 -	if (*qp_attr_mask & IB_QP_AV) {
 -		if (qp_attr->ah_attr.port_num < rdma_start_port(qp->device) ||
 -		    qp_attr->ah_attr.port_num > rdma_end_port(qp->device))
 -			return -EINVAL;
 -
 -		if (!rdma_cap_eth_ah(qp->device, qp_attr->ah_attr.port_num))
 -			return 0;
 -
 +	if ((*qp_attr_mask & IB_QP_AV)  &&
 +	    (rdma_cap_eth_ah(qp->device, qp_attr->ah_attr.port_num))) {
 +		ret = ib_query_gid(qp->device, qp_attr->ah_attr.port_num,
 +				   qp_attr->ah_attr.grh.sgid_index, &sgid);
 +		if (ret)
 +			goto out;
  		if (rdma_link_local_addr((struct in6_addr *)qp_attr->ah_attr.grh.dgid.raw)) {
 -			rdma_get_ll_mac((struct in6_addr *)qp_attr->ah_attr.grh.dgid.raw,
 -					qp_attr->ah_attr.dmac);
 +			rdma_get_ll_mac((struct in6_addr *)qp_attr->ah_attr.grh.dgid.raw, qp_attr->ah_attr.dmac);
 +			rdma_get_ll_mac((struct in6_addr *)sgid.raw, qp_attr->smac);
 +			if (!(*qp_attr_mask & IB_QP_VID))
 +				qp_attr->vlan_id = rdma_get_vlan_id(&sgid);
  		} else {
 -			union ib_gid		sgid;
 -			struct ib_gid_attr	sgid_attr;
 -			int			ifindex;
 -
 -			ret = ib_query_gid(qp->device,
 -					   qp_attr->ah_attr.port_num,
 -					   qp_attr->ah_attr.grh.sgid_index,
 -					   &sgid, &sgid_attr);
 -
 -			if (ret || !sgid_attr.ndev) {
 -				if (!ret)
 -					ret = -ENXIO;
 +			ret = rdma_addr_find_dmac_by_grh(&sgid, &qp_attr->ah_attr.grh.dgid,
 +					qp_attr->ah_attr.dmac, &qp_attr->vlan_id);
 +			if (ret)
 +				goto out;
 +			ret = rdma_addr_find_smac_by_sgid(&sgid, qp_attr->smac, NULL);
 +			if (ret)
  				goto out;
++<<<<<<< HEAD
++=======
+ 			}
+ 			if (sgid_attr.gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP)
+ 				/* TODO: get the hoplimit from the inet/inet6
+ 				 * device
+ 				 */
+ 				qp_attr->ah_attr.grh.hop_limit =
+ 							IPV6_DEFAULT_HOPLIMIT;
+ 
+ 			ifindex = sgid_attr.ndev->ifindex;
+ 
+ 			ret = rdma_addr_find_l2_eth_by_grh(&sgid,
+ 							   &qp_attr->ah_attr.grh.dgid,
+ 							   qp_attr->ah_attr.dmac,
+ 							   NULL, &ifindex);
+ 
+ 			dev_put(sgid_attr.ndev);
++>>>>>>> f7f4b23e27f7 (IB/core: Rename rdma_addr_find_dmac_by_grh)
  		}
 +		*qp_attr_mask |= IB_QP_SMAC;
 +		if (qp_attr->vlan_id < 0xFFFF)
 +			*qp_attr_mask |= IB_QP_VID;
  	}
  out:
  	return ret;
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_ah.c
index 6836aea6a876,850e0d11708c..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_ah.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_ah.c
@@@ -145,11 -152,12 +145,17 @@@ struct ib_ah *ocrdma_create_ah(struct i
  	if ((pd->uctx) &&
  	    (!rdma_is_multicast_addr((struct in6_addr *)attr->grh.dgid.raw)) &&
  	    (!rdma_link_local_addr((struct in6_addr *)attr->grh.dgid.raw))) {
++<<<<<<< HEAD
 +		status = rdma_addr_find_dmac_by_grh(&sgid, &attr->grh.dgid,
 +						    attr->dmac, &attr->vlan_id);
++=======
+ 		status = rdma_addr_find_l2_eth_by_grh(&sgid, &attr->grh.dgid,
+ 						      attr->dmac, &vlan_tag,
+ 						      &sgid_attr.ndev->ifindex);
++>>>>>>> f7f4b23e27f7 (IB/core: Rename rdma_addr_find_dmac_by_grh)
  		if (status) {
 -			pr_err("%s(): Failed to resolve dmac from gid." 
 -				"status = %d\n", __func__, status);
 +			pr_err("%s(): Failed to resolve dmac from gid. status = %d\n",
 +			       __func__, status);
  			goto av_conf_err;
  		}
  	}
diff --cc include/rdma/ib_addr.h
index fde33ac6b58a,73fd088dde56..000000000000
--- a/include/rdma/ib_addr.h
+++ b/include/rdma/ib_addr.h
@@@ -111,8 -130,9 +111,14 @@@ int rdma_copy_addr(struct rdma_dev_add
  int rdma_addr_size(struct sockaddr *addr);
  
  int rdma_addr_find_smac_by_sgid(union ib_gid *sgid, u8 *smac, u16 *vlan_id);
++<<<<<<< HEAD
 +int rdma_addr_find_dmac_by_grh(const union ib_gid *sgid, const union ib_gid *dgid,
 +			       u8 *smac, u16 *vlan_id);
++=======
+ int rdma_addr_find_l2_eth_by_grh(const union ib_gid *sgid,
+ 				 const union ib_gid *dgid,
+ 				 u8 *smac, u16 *vlan_id, int *if_index);
++>>>>>>> f7f4b23e27f7 (IB/core: Rename rdma_addr_find_dmac_by_grh)
  
  static inline u16 ib_addr_get_pkey(struct rdma_dev_addr *dev_addr)
  {
* Unmerged path drivers/infiniband/core/addr.c
* Unmerged path drivers/infiniband/core/verbs.c
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_ah.c
* Unmerged path include/rdma/ib_addr.h
