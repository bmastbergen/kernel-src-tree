netlink: introduce bigendian integer types

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.22.1.el9_4
commit-author Florian Westphal <fw@strlen.de>
commit ecaf75ffd5f5db320d8b1da0198eef5a5ce64a3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.22.1.el9_4/ecaf75ff.failed

Jakub reported that the addition of the "network_byte_order"
member in struct nla_policy increases size of 32bit platforms.

Instead of scraping the bit from elsewhere Johannes suggested
to add explicit NLA_BE types instead, so do this here.

NLA_POLICY_MAX_BE() macro is removed again, there is no need
for it: NLA_POLICY_MAX(NLA_BE.., ..) will do the right thing.

NLA_BE64 can be added later.

Fixes: 08724ef69907 ("netlink: introduce NLA_POLICY_MAX_BE")
	Reported-by: Jakub Kicinski <kuba@kernel.org>
	Suggested-by: Johannes Berg <johannes@sipsolutions.net>
	Signed-off-by: Florian Westphal <fw@strlen.de>
Link: https://lore.kernel.org/r/20221031123407.9158-1-fw@strlen.de
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit ecaf75ffd5f5db320d8b1da0198eef5a5ce64a3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netlink.h
#	net/netfilter/nft_payload.c
diff --cc include/net/netlink.h
index b57a54d46c1e,6bfa972f2fbf..000000000000
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@@ -350,12 -344,20 +355,28 @@@ struct nla_policy 
  		 * was added to enforce strict validation from thereon.
  		 */
  		u16 strict_start_type;
++<<<<<<< HEAD
++=======
+ 
+ 		/* private: use NLA_POLICY_*() to set */
+ 		const u32 bitfield32_valid;
+ 		const u32 mask;
+ 		const char *reject_message;
+ 		const struct nla_policy *nested_policy;
+ 		struct netlink_range_validation *range;
+ 		struct netlink_range_validation_signed *range_signed;
+ 		struct {
+ 			s16 min, max;
+ 		};
+ 		int (*validate)(const struct nlattr *attr,
+ 				struct netlink_ext_ack *extack);
++>>>>>>> ecaf75ffd5f5 (netlink: introduce bigendian integer types)
  	};
 +
 +	RH_KABI_RESERVE(1)
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
  };
  
  #define NLA_POLICY_ETH_ADDR		NLA_POLICY_EXACT_LEN(ETH_ALEN)
diff --cc net/netfilter/nft_payload.c
index c86fa2e6548b,4edd899aeb9b..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -208,10 -173,10 +208,17 @@@ static const struct nla_policy nft_payl
  	[NFTA_PAYLOAD_SREG]		= { .type = NLA_U32 },
  	[NFTA_PAYLOAD_DREG]		= { .type = NLA_U32 },
  	[NFTA_PAYLOAD_BASE]		= { .type = NLA_U32 },
++<<<<<<< HEAD
 +	[NFTA_PAYLOAD_OFFSET]		= { .type = NLA_U32 },
 +	[NFTA_PAYLOAD_LEN]		= { .type = NLA_U32 },
 +	[NFTA_PAYLOAD_CSUM_TYPE]	= { .type = NLA_U32 },
 +	[NFTA_PAYLOAD_CSUM_OFFSET]	= { .type = NLA_U32 },
++=======
+ 	[NFTA_PAYLOAD_OFFSET]		= NLA_POLICY_MAX(NLA_BE32, 255),
+ 	[NFTA_PAYLOAD_LEN]		= NLA_POLICY_MAX(NLA_BE32, 255),
+ 	[NFTA_PAYLOAD_CSUM_TYPE]	= { .type = NLA_U32 },
+ 	[NFTA_PAYLOAD_CSUM_OFFSET]	= NLA_POLICY_MAX(NLA_BE32, 255),
++>>>>>>> ecaf75ffd5f5 (netlink: introduce bigendian integer types)
  	[NFTA_PAYLOAD_CSUM_FLAGS]	= { .type = NLA_U32 },
  };
  
* Unmerged path include/net/netlink.h
diff --git a/lib/nlattr.c b/lib/nlattr.c
index 40f22b177d69..b67a53e29b8f 100644
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@ -124,10 +124,12 @@ void nla_get_range_unsigned(const struct nla_policy *pt,
 		range->max = U8_MAX;
 		break;
 	case NLA_U16:
+	case NLA_BE16:
 	case NLA_BINARY:
 		range->max = U16_MAX;
 		break;
 	case NLA_U32:
+	case NLA_BE32:
 		range->max = U32_MAX;
 		break;
 	case NLA_U64:
@@ -159,31 +161,6 @@ void nla_get_range_unsigned(const struct nla_policy *pt,
 	}
 }
 
-static u64 nla_get_attr_bo(const struct nla_policy *pt,
-			   const struct nlattr *nla)
-{
-	switch (pt->type) {
-	case NLA_U16:
-		if (pt->network_byte_order)
-			return ntohs(nla_get_be16(nla));
-
-		return nla_get_u16(nla);
-	case NLA_U32:
-		if (pt->network_byte_order)
-			return ntohl(nla_get_be32(nla));
-
-		return nla_get_u32(nla);
-	case NLA_U64:
-		if (pt->network_byte_order)
-			return be64_to_cpu(nla_get_be64(nla));
-
-		return nla_get_u64(nla);
-	}
-
-	WARN_ON_ONCE(1);
-	return 0;
-}
-
 static int nla_validate_range_unsigned(const struct nla_policy *pt,
 				       const struct nlattr *nla,
 				       struct netlink_ext_ack *extack,
@@ -197,9 +174,13 @@ static int nla_validate_range_unsigned(const struct nla_policy *pt,
 		value = nla_get_u8(nla);
 		break;
 	case NLA_U16:
+		value = nla_get_u16(nla);
+		break;
 	case NLA_U32:
+		value = nla_get_u32(nla);
+		break;
 	case NLA_U64:
-		value = nla_get_attr_bo(pt, nla);
+		value = nla_get_u64(nla);
 		break;
 	case NLA_MSECS:
 		value = nla_get_u64(nla);
@@ -207,6 +188,12 @@ static int nla_validate_range_unsigned(const struct nla_policy *pt,
 	case NLA_BINARY:
 		value = nla_len(nla);
 		break;
+	case NLA_BE16:
+		value = ntohs(nla_get_be16(nla));
+		break;
+	case NLA_BE32:
+		value = ntohl(nla_get_be32(nla));
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -334,6 +321,8 @@ static int nla_validate_int_range(const struct nla_policy *pt,
 	case NLA_U64:
 	case NLA_MSECS:
 	case NLA_BINARY:
+	case NLA_BE16:
+	case NLA_BE32:
 		return nla_validate_range_unsigned(pt, nla, extack, validate);
 	case NLA_S8:
 	case NLA_S16:
* Unmerged path net/netfilter/nft_payload.c
