dpll: remove leftover mode_supported() op and use mode_get() instead

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.22.1.el9_4
commit-author Jiri Pirko <jiri@nvidia.com>
commit 4f7aa122bc9219baca0bfface5917062d6c45ee8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.22.1.el9_4/4f7aa122.failed

Mode supported is currently reported to the user exactly the same, as
the current mode. That's because mode changing is not implemented.
Remove the leftover mode_supported() op and use mode_get() to fill up
the supported mode exposed to user.

One, if even, mode changing is going to be introduced, this could be
very easily taken back. In the meantime, prevent drivers form
implementing this in wrong way (as for example recent netdevsim
implementation attempt intended to do).

	Signed-off-by: Jiri Pirko <jiri@nvidia.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4f7aa122bc9219baca0bfface5917062d6c45ee8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/dpll.c
#	drivers/ptp/ptp_ocp.c
diff --cc drivers/ptp/ptp_ocp.c
index 0d1034e3ed0f,b022af3d20fe..000000000000
--- a/drivers/ptp/ptp_ocp.c
+++ b/drivers/ptp/ptp_ocp.c
@@@ -290,10 -4120,254 +290,258 @@@ ptp_ocp_info(struct ptp_ocp *bp
  	select = ioread32(&bp->reg->select);
  	dev_info(&bp->pdev->dev, "Version %d.%d.%d, clock %s, device ptp%d\n",
  		 version >> 24, (version >> 16) & 0xff, version & 0xffff,
 -		 ptp_ocp_select_name_from_val(ptp_ocp_clock, select >> 16),
 +		 clock_name[select & 7],
  		 ptp_clock_index(bp->ptp));
  
++<<<<<<< HEAD
 +	ptp_ocp_tod_info(bp);
++=======
+ 	if (!ptp_ocp_gettimex(&bp->ptp_info, &ts, NULL))
+ 		dev_info(&bp->pdev->dev, "Time: %lld.%ld, %s\n",
+ 			 ts.tv_sec, ts.tv_nsec,
+ 			 bp->sync ? "in-sync" : "UNSYNCED");
+ }
+ 
+ static void
+ ptp_ocp_serial_info(struct device *dev, const char *name, int port, int baud)
+ {
+ 	if (port != -1)
+ 		dev_info(dev, "%5s: /dev/ttyS%-2d @ %6d\n", name, port, baud);
+ }
+ 
+ static void
+ ptp_ocp_info(struct ptp_ocp *bp)
+ {
+ 	static int nmea_baud[] = {
+ 		1200, 2400, 4800, 9600, 19200, 38400,
+ 		57600, 115200, 230400, 460800, 921600,
+ 		1000000, 2000000
+ 	};
+ 	struct device *dev = &bp->pdev->dev;
+ 	u32 reg;
+ 
+ 	ptp_ocp_phc_info(bp);
+ 
+ 	ptp_ocp_serial_info(dev, "GNSS", bp->gnss_port.line,
+ 			    bp->gnss_port.baud);
+ 	ptp_ocp_serial_info(dev, "GNSS2", bp->gnss2_port.line,
+ 			    bp->gnss2_port.baud);
+ 	ptp_ocp_serial_info(dev, "MAC", bp->mac_port.line, bp->mac_port.baud);
+ 	if (bp->nmea_out && bp->nmea_port.line != -1) {
+ 		bp->nmea_port.baud = -1;
+ 
+ 		reg = ioread32(&bp->nmea_out->uart_baud);
+ 		if (reg < ARRAY_SIZE(nmea_baud))
+ 			bp->nmea_port.baud = nmea_baud[reg];
+ 
+ 		ptp_ocp_serial_info(dev, "NMEA", bp->nmea_port.line,
+ 				    bp->nmea_port.baud);
+ 	}
+ }
+ 
+ static void
+ ptp_ocp_detach_sysfs(struct ptp_ocp *bp)
+ {
+ 	struct device *dev = &bp->dev;
+ 
+ 	sysfs_remove_link(&dev->kobj, "ttyGNSS");
+ 	sysfs_remove_link(&dev->kobj, "ttyGNSS2");
+ 	sysfs_remove_link(&dev->kobj, "ttyMAC");
+ 	sysfs_remove_link(&dev->kobj, "ptp");
+ 	sysfs_remove_link(&dev->kobj, "pps");
+ }
+ 
+ static void
+ ptp_ocp_detach(struct ptp_ocp *bp)
+ {
+ 	int i;
+ 
+ 	ptp_ocp_debugfs_remove_device(bp);
+ 	ptp_ocp_detach_sysfs(bp);
+ 	ptp_ocp_attr_group_del(bp);
+ 	if (timer_pending(&bp->watchdog))
+ 		del_timer_sync(&bp->watchdog);
+ 	if (bp->ts0)
+ 		ptp_ocp_unregister_ext(bp->ts0);
+ 	if (bp->ts1)
+ 		ptp_ocp_unregister_ext(bp->ts1);
+ 	if (bp->ts2)
+ 		ptp_ocp_unregister_ext(bp->ts2);
+ 	if (bp->ts3)
+ 		ptp_ocp_unregister_ext(bp->ts3);
+ 	if (bp->ts4)
+ 		ptp_ocp_unregister_ext(bp->ts4);
+ 	if (bp->pps)
+ 		ptp_ocp_unregister_ext(bp->pps);
+ 	for (i = 0; i < 4; i++)
+ 		if (bp->signal_out[i])
+ 			ptp_ocp_unregister_ext(bp->signal_out[i]);
+ 	if (bp->gnss_port.line != -1)
+ 		serial8250_unregister_port(bp->gnss_port.line);
+ 	if (bp->gnss2_port.line != -1)
+ 		serial8250_unregister_port(bp->gnss2_port.line);
+ 	if (bp->mac_port.line != -1)
+ 		serial8250_unregister_port(bp->mac_port.line);
+ 	if (bp->nmea_port.line != -1)
+ 		serial8250_unregister_port(bp->nmea_port.line);
+ 	platform_device_unregister(bp->spi_flash);
+ 	platform_device_unregister(bp->i2c_ctrl);
+ 	if (bp->i2c_clk)
+ 		clk_hw_unregister_fixed_rate(bp->i2c_clk);
+ 	if (bp->n_irqs)
+ 		pci_free_irq_vectors(bp->pdev);
+ 	if (bp->ptp)
+ 		ptp_clock_unregister(bp->ptp);
+ 	kfree(bp->ptp_info.pin_config);
+ 	device_unregister(&bp->dev);
+ }
+ 
+ static int ptp_ocp_dpll_lock_status_get(const struct dpll_device *dpll,
+ 					void *priv,
+ 					enum dpll_lock_status *status,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp *bp = priv;
+ 
+ 	*status = bp->sync ? DPLL_LOCK_STATUS_LOCKED : DPLL_LOCK_STATUS_UNLOCKED;
+ 
+ 	return 0;
+ }
+ 
+ static int ptp_ocp_dpll_state_get(const struct dpll_pin *pin, void *pin_priv,
+ 				  const struct dpll_device *dpll, void *priv,
+ 				  enum dpll_pin_state *state,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp *bp = priv;
+ 	int idx;
+ 
+ 	if (bp->pps_select) {
+ 		idx = ioread32(&bp->pps_select->gpio1);
+ 		*state = (&bp->sma[idx] == pin_priv) ? DPLL_PIN_STATE_CONNECTED :
+ 						      DPLL_PIN_STATE_SELECTABLE;
+ 		return 0;
+ 	}
+ 	NL_SET_ERR_MSG(extack, "pin selection is not supported on current HW");
+ 	return -EINVAL;
+ }
+ 
+ static int ptp_ocp_dpll_mode_get(const struct dpll_device *dpll, void *priv,
+ 				 enum dpll_mode *mode, struct netlink_ext_ack *extack)
+ {
+ 	*mode = DPLL_MODE_AUTOMATIC;
+ 	return 0;
+ }
+ 
+ static int ptp_ocp_dpll_direction_get(const struct dpll_pin *pin,
+ 				      void *pin_priv,
+ 				      const struct dpll_device *dpll,
+ 				      void *priv,
+ 				      enum dpll_pin_direction *direction,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp_sma_connector *sma = pin_priv;
+ 
+ 	*direction = sma->mode == SMA_MODE_IN ?
+ 				  DPLL_PIN_DIRECTION_INPUT :
+ 				  DPLL_PIN_DIRECTION_OUTPUT;
+ 	return 0;
+ }
+ 
+ static int ptp_ocp_dpll_direction_set(const struct dpll_pin *pin,
+ 				      void *pin_priv,
+ 				      const struct dpll_device *dpll,
+ 				      void *dpll_priv,
+ 				      enum dpll_pin_direction direction,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp_sma_connector *sma = pin_priv;
+ 	struct ptp_ocp *bp = dpll_priv;
+ 	enum ptp_ocp_sma_mode mode;
+ 	int sma_nr = (sma - bp->sma);
+ 
+ 	if (sma->fixed_dir)
+ 		return -EOPNOTSUPP;
+ 	mode = direction == DPLL_PIN_DIRECTION_INPUT ?
+ 			    SMA_MODE_IN : SMA_MODE_OUT;
+ 	return ptp_ocp_sma_store_val(bp, 0, mode, sma_nr);
+ }
+ 
+ static int ptp_ocp_dpll_frequency_set(const struct dpll_pin *pin,
+ 				      void *pin_priv,
+ 				      const struct dpll_device *dpll,
+ 				      void *dpll_priv, u64 frequency,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp_sma_connector *sma = pin_priv;
+ 	struct ptp_ocp *bp = dpll_priv;
+ 	const struct ocp_selector *tbl;
+ 	int sma_nr = (sma - bp->sma);
+ 	int i;
+ 
+ 	if (sma->fixed_fcn)
+ 		return -EOPNOTSUPP;
+ 
+ 	tbl = bp->sma_op->tbl[sma->mode];
+ 	for (i = 0; tbl[i].name; i++)
+ 		if (tbl[i].frequency == frequency)
+ 			return ptp_ocp_sma_store_val(bp, i, sma->mode, sma_nr);
+ 	return -EINVAL;
+ }
+ 
+ static int ptp_ocp_dpll_frequency_get(const struct dpll_pin *pin,
+ 				      void *pin_priv,
+ 				      const struct dpll_device *dpll,
+ 				      void *dpll_priv, u64 *frequency,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp_sma_connector *sma = pin_priv;
+ 	struct ptp_ocp *bp = dpll_priv;
+ 	const struct ocp_selector *tbl;
+ 	int sma_nr = (sma - bp->sma);
+ 	u32 val;
+ 	int i;
+ 
+ 	val = bp->sma_op->get(bp, sma_nr);
+ 	tbl = bp->sma_op->tbl[sma->mode];
+ 	for (i = 0; tbl[i].name; i++)
+ 		if (val == tbl[i].value) {
+ 			*frequency = tbl[i].frequency;
+ 			return 0;
+ 		}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static const struct dpll_device_ops dpll_ops = {
+ 	.lock_status_get = ptp_ocp_dpll_lock_status_get,
+ 	.mode_get = ptp_ocp_dpll_mode_get,
+ };
+ 
+ static const struct dpll_pin_ops dpll_pins_ops = {
+ 	.frequency_get = ptp_ocp_dpll_frequency_get,
+ 	.frequency_set = ptp_ocp_dpll_frequency_set,
+ 	.direction_get = ptp_ocp_dpll_direction_get,
+ 	.direction_set = ptp_ocp_dpll_direction_set,
+ 	.state_on_dpll_get = ptp_ocp_dpll_state_get,
+ };
+ 
+ static void
+ ptp_ocp_sync_work(struct work_struct *work)
+ {
+ 	struct ptp_ocp *bp;
+ 	bool sync;
+ 
+ 	bp = container_of(work, struct ptp_ocp, sync_work.work);
+ 	sync = !!(ioread32(&bp->reg->status) & OCP_STATUS_IN_SYNC);
+ 
+ 	if (bp->sync != sync)
+ 		dpll_device_change_ntf(bp->dpll);
+ 
+ 	bp->sync = sync;
+ 
+ 	queue_delayed_work(system_power_efficient_wq, &bp->sync_work, HZ);
++>>>>>>> 4f7aa122bc92 (dpll: remove leftover mode_supported() op and use mode_get() instead)
  }
  
  static int
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/dpll.c
diff --git a/drivers/dpll/dpll_netlink.c b/drivers/dpll/dpll_netlink.c
index 7cc99d627942..d9f7c360666b 100644
--- a/drivers/dpll/dpll_netlink.c
+++ b/drivers/dpll/dpll_netlink.c
@@ -101,13 +101,17 @@ dpll_msg_add_mode_supported(struct sk_buff *msg, struct dpll_device *dpll,
 {
 	const struct dpll_device_ops *ops = dpll_device_ops(dpll);
 	enum dpll_mode mode;
+	int ret;
 
-	if (!ops->mode_supported)
-		return 0;
-	for (mode = DPLL_MODE_MANUAL; mode <= DPLL_MODE_MAX; mode++)
-		if (ops->mode_supported(dpll, dpll_priv(dpll), mode, extack))
-			if (nla_put_u32(msg, DPLL_A_MODE_SUPPORTED, mode))
-				return -EMSGSIZE;
+	/* No mode change is supported now, so the only supported mode is the
+	 * one obtained by mode_get().
+	 */
+
+	ret = ops->mode_get(dpll, dpll_priv(dpll), &mode, extack);
+	if (ret)
+		return ret;
+	if (nla_put_u32(msg, DPLL_A_MODE_SUPPORTED, mode))
+		return -EMSGSIZE;
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/intel/ice/ice_dpll.c b/drivers/net/ethernet/intel/ice/ice_dpll.c
index 86b180cb32a0..b9c5eced6326 100644
--- a/drivers/net/ethernet/intel/ice/ice_dpll.c
+++ b/drivers/net/ethernet/intel/ice/ice_dpll.c
@@ -512,31 +512,6 @@ ice_dpll_lock_status_get(const struct dpll_device *dpll, void *dpll_priv,
 	return 0;
 }
 
-/**
- * ice_dpll_mode_supported - check if dpll's working mode is supported
- * @dpll: registered dpll pointer
- * @dpll_priv: private data pointer passed on dpll registration
- * @mode: mode to be checked for support
- * @extack: error reporting
- *
- * Dpll subsystem callback. Provides information if working mode is supported
- * by dpll.
- *
- * Return:
- * * true - mode is supported
- * * false - mode is not supported
- */
-static bool ice_dpll_mode_supported(const struct dpll_device *dpll,
-				    void *dpll_priv,
-				    enum dpll_mode mode,
-				    struct netlink_ext_ack *extack)
-{
-	if (mode == DPLL_MODE_AUTOMATIC)
-		return true;
-
-	return false;
-}
-
 /**
  * ice_dpll_mode_get - get dpll's working mode
  * @dpll: registered dpll pointer
@@ -1197,7 +1172,6 @@ static const struct dpll_pin_ops ice_dpll_output_ops = {
 
 static const struct dpll_device_ops ice_dpll_ops = {
 	.lock_status_get = ice_dpll_lock_status_get,
-	.mode_supported = ice_dpll_mode_supported,
 	.mode_get = ice_dpll_mode_get,
 };
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/dpll.c
* Unmerged path drivers/ptp/ptp_ocp.c
diff --git a/include/linux/dpll.h b/include/linux/dpll.h
index 578fc5fa3750..b1a5f9ca8ee5 100644
--- a/include/linux/dpll.h
+++ b/include/linux/dpll.h
@@ -17,9 +17,6 @@ struct dpll_pin;
 struct dpll_device_ops {
 	int (*mode_get)(const struct dpll_device *dpll, void *dpll_priv,
 			enum dpll_mode *mode, struct netlink_ext_ack *extack);
-	bool (*mode_supported)(const struct dpll_device *dpll, void *dpll_priv,
-			       const enum dpll_mode mode,
-			       struct netlink_ext_ack *extack);
 	int (*lock_status_get)(const struct dpll_device *dpll, void *dpll_priv,
 			       enum dpll_lock_status *status,
 			       struct netlink_ext_ack *extack);
