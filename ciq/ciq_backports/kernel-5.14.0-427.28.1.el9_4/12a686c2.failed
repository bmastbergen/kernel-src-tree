net: make SK_MEMORY_PCPU_RESERV tunable

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.28.1.el9_4
commit-author Adam Li <adamli@os.amperecomputing.com>
commit 12a686c2e761f1f1f6e6e2117a9ab9c6de2ac8a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.28.1.el9_4/12a686c2.failed

This patch adds /proc/sys/net/core/mem_pcpu_rsv sysctl file,
to make SK_MEMORY_PCPU_RESERV tunable.

Commit 3cd3399dd7a8 ("net: implement per-cpu reserves for
memory_allocated") introduced per-cpu forward alloc cache:

"Implement a per-cpu cache of +1/-1 MB, to reduce number
of changes to sk->sk_prot->memory_allocated, which
would otherwise be cause of false sharing."

sk_prot->memory_allocated points to global atomic variable:
atomic_long_t tcp_memory_allocated ____cacheline_aligned_in_smp;

If increasing the per-cpu cache size from 1MB to e.g. 16MB,
changes to sk->sk_prot->memory_allocated can be further reduced.
Performance may be improved on system with many cores.

	Signed-off-by: Adam Li <adamli@os.amperecomputing.com>
	Reviewed-by: Christoph Lameter (Ampere) <cl@linux.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 12a686c2e761f1f1f6e6e2117a9ab9c6de2ac8a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/sysctl_net_core.c
diff --cc net/core/sysctl_net_core.c
index 0c8d617bb579,986f15e5d6c4..000000000000
--- a/net/core/sysctl_net_core.c
+++ b/net/core/sysctl_net_core.c
@@@ -32,8 -30,7 +32,12 @@@ static int int_3600 = 3600
  static int min_sndbuf = SOCK_MIN_SNDBUF;
  static int min_rcvbuf = SOCK_MIN_RCVBUF;
  static int max_skb_frags = MAX_SKB_FRAGS;
++<<<<<<< HEAD
 +static long long_one __maybe_unused = 1;
 +static long long_max __maybe_unused = LONG_MAX;
++=======
+ static int min_mem_pcpu_rsv = SK_MEMORY_PCPU_RESERVE;
++>>>>>>> 12a686c2e761 (net: make SK_MEMORY_PCPU_RESERV tunable)
  
  static int net_msg_warn;	/* Unused, but still a sysctl */
  
diff --git a/Documentation/admin-guide/sysctl/net.rst b/Documentation/admin-guide/sysctl/net.rst
index f84b7503f894..2ba77c39b108 100644
--- a/Documentation/admin-guide/sysctl/net.rst
+++ b/Documentation/admin-guide/sysctl/net.rst
@@ -204,6 +204,11 @@ Will increase power usage.
 
 Default: 0 (off)
 
+mem_pcpu_rsv
+------------
+
+Per-cpu reserved forward alloc cache size in page units. Default 1MB per CPU.
+
 rmem_default
 ------------
 
diff --git a/include/net/sock.h b/include/net/sock.h
index 6b7c0f3231bb..536b39a0d9b3 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1485,6 +1485,7 @@ sk_memory_allocated(const struct sock *sk)
 
 /* 1 MB per cpu, in page units */
 #define SK_MEMORY_PCPU_RESERVE (1 << (20 - PAGE_SHIFT))
+extern int sysctl_mem_pcpu_rsv;
 
 static inline long
 sk_memory_allocated_add(struct sock *sk, int amt)
@@ -1493,7 +1494,7 @@ sk_memory_allocated_add(struct sock *sk, int amt)
 
 	preempt_disable();
 	local_reserve = __this_cpu_add_return(*sk->sk_prot->per_cpu_fw_alloc, amt);
-	if (local_reserve >= SK_MEMORY_PCPU_RESERVE) {
+	if (local_reserve >= READ_ONCE(sysctl_mem_pcpu_rsv)) {
 		__this_cpu_sub(*sk->sk_prot->per_cpu_fw_alloc, local_reserve);
 		atomic_long_add(local_reserve, sk->sk_prot->memory_allocated);
 	}
@@ -1508,7 +1509,7 @@ sk_memory_allocated_sub(struct sock *sk, int amt)
 
 	preempt_disable();
 	local_reserve = __this_cpu_sub_return(*sk->sk_prot->per_cpu_fw_alloc, amt);
-	if (local_reserve <= -SK_MEMORY_PCPU_RESERVE) {
+	if (local_reserve <= -READ_ONCE(sysctl_mem_pcpu_rsv)) {
 		__this_cpu_sub(*sk->sk_prot->per_cpu_fw_alloc, local_reserve);
 		atomic_long_add(local_reserve, sk->sk_prot->memory_allocated);
 	}
diff --git a/net/core/sock.c b/net/core/sock.c
index df02958dba82..c4540fc8f808 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -278,6 +278,7 @@ __u32 sysctl_rmem_max __read_mostly = SK_RMEM_MAX;
 EXPORT_SYMBOL(sysctl_rmem_max);
 __u32 sysctl_wmem_default __read_mostly = SK_WMEM_MAX;
 __u32 sysctl_rmem_default __read_mostly = SK_RMEM_MAX;
+int sysctl_mem_pcpu_rsv __read_mostly = SK_MEMORY_PCPU_RESERVE;
 
 /* Maximal space eaten by iovec or ancillary data plus some space */
 int sysctl_optmem_max __read_mostly = sizeof(unsigned long)*(2*UIO_MAXIOV+512);
* Unmerged path net/core/sysctl_net_core.c
