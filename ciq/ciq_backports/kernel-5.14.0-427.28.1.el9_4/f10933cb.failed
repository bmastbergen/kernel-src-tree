s390/cpum_cf: make crypto counters upward compatible across machine types

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.28.1.el9_4
commit-author Thomas Richter <tmricht@linux.ibm.com>
commit f10933cbd2dfddf6273698a45f76db9bafd8150f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.28.1.el9_4/f10933cb.failed

The CPU Measurement facility crypto counter set functionality
is defined by the Second Counter Version Number. This number
varies between machine types, but is upward compatible.
Lessen the checks to reflect this behavior.

	Signed-off-by: Thomas Richter <tmricht@linux.ibm.com>
	Acked-by: Sumanth Korikkar <sumanthk@linux.ibm.com>
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit f10933cbd2dfddf6273698a45f76db9bafd8150f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/perf_cpum_cf.c
diff --cc arch/s390/kernel/perf_cpum_cf.c
index 666cc14e2efc,1434642e9cba..000000000000
--- a/arch/s390/kernel/perf_cpum_cf.c
+++ b/arch/s390/kernel/perf_cpum_cf.c
@@@ -112,6 -403,63 +112,66 @@@ static void cfdiag_trailer(struct cf_tr
  	te->timestamp = get_tod_clock_fast();
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * The number of counters per counter set varies between machine generations,
+  * but is constant when running on a particular machine generation.
+  * Determine each counter set size at device driver initialization and
+  * retrieve it later.
+  */
+ static size_t cpumf_ctr_setsizes[CPUMF_CTR_SET_MAX];
+ static void cpum_cf_make_setsize(enum cpumf_ctr_set ctrset)
+ {
+ 	size_t ctrset_size = 0;
+ 
+ 	switch (ctrset) {
+ 	case CPUMF_CTR_SET_BASIC:
+ 		if (cpumf_ctr_info.cfvn >= 1)
+ 			ctrset_size = 6;
+ 		break;
+ 	case CPUMF_CTR_SET_USER:
+ 		if (cpumf_ctr_info.cfvn == 1)
+ 			ctrset_size = 6;
+ 		else if (cpumf_ctr_info.cfvn >= 3)
+ 			ctrset_size = 2;
+ 		break;
+ 	case CPUMF_CTR_SET_CRYPTO:
+ 		if (cpumf_ctr_info.csvn >= 1 && cpumf_ctr_info.csvn <= 5)
+ 			ctrset_size = 16;
+ 		else if (cpumf_ctr_info.csvn >= 6)
+ 			ctrset_size = 20;
+ 		break;
+ 	case CPUMF_CTR_SET_EXT:
+ 		if (cpumf_ctr_info.csvn == 1)
+ 			ctrset_size = 32;
+ 		else if (cpumf_ctr_info.csvn == 2)
+ 			ctrset_size = 48;
+ 		else if (cpumf_ctr_info.csvn >= 3 && cpumf_ctr_info.csvn <= 5)
+ 			ctrset_size = 128;
+ 		else if (cpumf_ctr_info.csvn == 6 || cpumf_ctr_info.csvn == 7)
+ 			ctrset_size = 160;
+ 		break;
+ 	case CPUMF_CTR_SET_MT_DIAG:
+ 		if (cpumf_ctr_info.csvn > 3)
+ 			ctrset_size = 48;
+ 		break;
+ 	case CPUMF_CTR_SET_MAX:
+ 		break;
+ 	}
+ 	cpumf_ctr_setsizes[ctrset] = ctrset_size;
+ }
+ 
+ /*
+  * Return the maximum possible counter set size (in number of 8 byte counters)
+  * depending on type and model number.
+  */
+ static size_t cpum_cf_read_setsize(enum cpumf_ctr_set ctrset)
+ {
+ 	return cpumf_ctr_setsizes[ctrset];
+ }
+ 
++>>>>>>> f10933cbd2df (s390/cpum_cf: make crypto counters upward compatible across machine types)
  /* Read a counter set. The counter set number determines the counter set and
   * the CPUM-CF first and second version number determine the number of
   * available counters in each counter set.
* Unmerged path arch/s390/kernel/perf_cpum_cf.c
diff --git a/arch/s390/kernel/perf_cpum_cf_events.c b/arch/s390/kernel/perf_cpum_cf_events.c
index 0d64aafd158f..e4a6bfc91080 100644
--- a/arch/s390/kernel/perf_cpum_cf_events.c
+++ b/arch/s390/kernel/perf_cpum_cf_events.c
@@ -855,16 +855,11 @@ __init const struct attribute_group **cpumf_cf_event_group(void)
 	}
 
 	/* Determine version specific crypto set */
-	switch (ci.csvn) {
-	case 1 ... 5:
+	csvn = none;
+	if (ci.csvn >= 1 && ci.csvn <= 5)
 		csvn = cpumcf_svn_12345_pmu_event_attr;
-		break;
-	case 6 ... 7:
+	else if (ci.csvn >= 6)
 		csvn = cpumcf_svn_67_pmu_event_attr;
-		break;
-	default:
-		csvn = none;
-	}
 
 	/* Determine model-specific counter set(s) */
 	get_cpu_id(&cpu_id);
