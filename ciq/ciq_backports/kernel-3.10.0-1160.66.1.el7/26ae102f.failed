NFSv4: Set the connection timeout to match the lease period

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.66.1.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 26ae102f2cfd0215daa57dc790aa3bfe534403a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.66.1.el7/26ae102f.failed

Set the timeout for TCP connections to be 1 lease period to ensure
that we don't lose our lease due to a faulty TCP connection.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 26ae102f2cfd0215daa57dc790aa3bfe534403a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 20e87f97d6bb,52da3ce54bb5..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -2748,13 -2747,19 +2748,22 @@@ rpc_xprt_cap_max_reconnect_timeout(stru
  }
  
  void
- rpc_cap_max_reconnect_timeout(struct rpc_clnt *clnt, unsigned long timeo)
- {
+ rpc_set_connect_timeout(struct rpc_clnt *clnt,
+ 		unsigned long connect_timeout,
+ 		unsigned long reconnect_timeout)
+ {
++<<<<<<< HEAD
++=======
+ 	struct connect_timeout_data timeout = {
+ 		.connect_timeout = connect_timeout,
+ 		.reconnect_timeout = reconnect_timeout,
+ 	};
++>>>>>>> 26ae102f2cfd (NFSv4: Set the connection timeout to match the lease period)
  	rpc_clnt_iterate_for_each_xprt(clnt,
 -			rpc_xprt_set_connect_timeout,
 -			&timeout);
 +			rpc_xprt_cap_max_reconnect_timeout,
 +			&timeo);
  }
- EXPORT_SYMBOL_GPL(rpc_cap_max_reconnect_timeout);
+ EXPORT_SYMBOL_GPL(rpc_set_connect_timeout);
  
  void rpc_clnt_xprt_switch_put(struct rpc_clnt *clnt)
  {
diff --git a/fs/nfs/nfs4renewd.c b/fs/nfs/nfs4renewd.c
index 82e77198d17e..1f8c2ae43a8d 100644
--- a/fs/nfs/nfs4renewd.c
+++ b/fs/nfs/nfs4renewd.c
@@ -153,7 +153,7 @@ void nfs4_set_lease_period(struct nfs_client *clp,
 	spin_unlock(&clp->cl_lock);
 
 	/* Cap maximum reconnect timeout at 1/2 lease period */
-	rpc_cap_max_reconnect_timeout(clp->cl_rpcclient, lease >> 1);
+	rpc_set_connect_timeout(clp->cl_rpcclient, lease, lease >> 1);
 }
 
 /*
diff --git a/include/linux/sunrpc/clnt.h b/include/linux/sunrpc/clnt.h
index 50933b03c418..509bed2dd955 100644
--- a/include/linux/sunrpc/clnt.h
+++ b/include/linux/sunrpc/clnt.h
@@ -202,8 +202,9 @@ int		rpc_clnt_add_xprt(struct rpc_clnt *, struct xprt_create *,
 				struct rpc_xprt *,
 				void *),
 			void *data);
-void		rpc_cap_max_reconnect_timeout(struct rpc_clnt *clnt,
-			unsigned long timeo);
+void		rpc_set_connect_timeout(struct rpc_clnt *clnt,
+			unsigned long connect_timeout,
+			unsigned long reconnect_timeout);
 
 int		rpc_clnt_setup_test_and_add_xprt(struct rpc_clnt *,
 			struct rpc_xprt_switch *,
* Unmerged path net/sunrpc/clnt.c
