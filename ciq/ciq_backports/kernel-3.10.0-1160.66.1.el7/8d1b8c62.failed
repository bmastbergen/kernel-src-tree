SUNRPC: Refactor TCP socket timeout code into a helper function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.66.1.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 8d1b8c62e0805af7df900ef121389778d2126997
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.66.1.el7/8d1b8c62.failed

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 8d1b8c62e0805af7df900ef121389778d2126997)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index 511d26eb9236,c8ac649a51cb..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -2264,26 -2267,19 +2289,42 @@@ static int xs_tcp_finish_connecting(str
  
  	if (!transport->inet) {
  		struct sock *sk = sock->sk;
++<<<<<<< HEAD
 +		unsigned int keepidle = xprt->timeout->to_initval / HZ;
 +		unsigned int keepcnt = xprt->timeout->to_retries + 1;
 +		unsigned int opt_on = 1;
 +		unsigned int timeo;
 +
 +		/* TCP Keepalive options */
 +		kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
 +				(char *)&opt_on, sizeof(opt_on));
 +		kernel_setsockopt(sock, SOL_TCP, TCP_KEEPIDLE,
 +				(char *)&keepidle, sizeof(keepidle));
 +		kernel_setsockopt(sock, SOL_TCP, TCP_KEEPINTVL,
 +				(char *)&keepidle, sizeof(keepidle));
 +		kernel_setsockopt(sock, SOL_TCP, TCP_KEEPCNT,
 +				(char *)&keepcnt, sizeof(keepcnt));
 +
 +		/* TCP user timeout (see RFC5482) */
 +		timeo = jiffies_to_msecs(xprt->timeout->to_initval) *
 +			(xprt->timeout->to_retries + 1);
 +		kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,
 +				(char *)&timeo, sizeof(timeo));
++=======
+ 		unsigned int addr_pref = IPV6_PREFER_SRC_PUBLIC;
+ 
+ 		/* Avoid temporary address, they are bad for long-lived
+ 		 * connections such as NFS mounts.
+ 		 * RFC4941, section 3.6 suggests that:
+ 		 *    Individual applications, which have specific
+ 		 *    knowledge about the normal duration of connections,
+ 		 *    MAY override this as appropriate.
+ 		 */
+ 		kernel_setsockopt(sock, SOL_IPV6, IPV6_ADDR_PREFERENCES,
+ 				(char *)&addr_pref, sizeof(addr_pref));
+ 
+ 		xs_tcp_set_socket_timeouts(xprt, sock);
++>>>>>>> 8d1b8c62e080 (SUNRPC: Refactor TCP socket timeout code into a helper function)
  
  		write_lock_bh(&sk->sk_callback_lock);
  
* Unmerged path net/sunrpc/xprtsock.c
