net/mlx4_en: Handle TX error CQE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.24.1.el7
commit-author Moshe Shemesh <moshe@mellanox.com>
commit ba603d9d7b1215c72513d7c7aa02b6775fd4891b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.24.1.el7/ba603d9d.failed

In case error CQE was found while polling TX CQ, the QP is in error
state and all posted WQEs will generate error CQEs without any data
transmitted. Fix it by reopening the channels, via same method used for
TX timeout handling.

In addition add some more info on error CQE and WQE for debug.

Fixes: bd2f631d7c60 ("net/mlx4_en: Notify user when TX ring in error state")
	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ba603d9d7b1215c72513d7c7aa02b6775fd4891b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_tx.c
diff --cc drivers/net/ethernet/mellanox/mlx4/en_tx.c
index 332b22052c6b,59b097cda327..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@@ -385,8 -392,37 +385,42 @@@ int mlx4_en_free_tx_buf(struct net_devi
  	return cnt;
  }
  
++<<<<<<< HEAD
 +bool mlx4_en_process_tx_cq(struct net_device *dev,
 +			   struct mlx4_en_cq *cq, int napi_budget)
++=======
+ static void mlx4_en_handle_err_cqe(struct mlx4_en_priv *priv, struct mlx4_err_cqe *err_cqe,
+ 				   u16 cqe_index, struct mlx4_en_tx_ring *ring)
+ {
+ 	struct mlx4_en_dev *mdev = priv->mdev;
+ 	struct mlx4_en_tx_info *tx_info;
+ 	struct mlx4_en_tx_desc *tx_desc;
+ 	u16 wqe_index;
+ 	int desc_size;
+ 
+ 	en_err(priv, "CQE error - cqn 0x%x, ci 0x%x, vendor syndrome: 0x%x syndrome: 0x%x\n",
+ 	       ring->sp_cqn, cqe_index, err_cqe->vendor_err_syndrome, err_cqe->syndrome);
+ 	print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 16, 1, err_cqe, sizeof(*err_cqe),
+ 		       false);
+ 
+ 	wqe_index = be16_to_cpu(err_cqe->wqe_index) & ring->size_mask;
+ 	tx_info = &ring->tx_info[wqe_index];
+ 	desc_size = tx_info->nr_txbb << LOG_TXBB_SIZE;
+ 	en_err(priv, "Related WQE - qpn 0x%x, wqe index 0x%x, wqe size 0x%x\n", ring->qpn,
+ 	       wqe_index, desc_size);
+ 	tx_desc = ring->buf + (wqe_index << LOG_TXBB_SIZE);
+ 	print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 16, 1, tx_desc, desc_size, false);
+ 
+ 	if (test_and_set_bit(MLX4_EN_STATE_FLAG_RESTARTING, &priv->state))
+ 		return;
+ 
+ 	en_err(priv, "Scheduling port restart\n");
+ 	queue_work(mdev->workqueue, &priv->restart_task);
+ }
+ 
+ int mlx4_en_process_tx_cq(struct net_device *dev,
+ 			  struct mlx4_en_cq *cq, int napi_budget)
++>>>>>>> ba603d9d7b12 (net/mlx4_en: Handle TX error CQE)
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
  	struct mlx4_cq *mcq = &cq->mcq;
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 20d3d427fe2f..6d59284dd4b0 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -1734,6 +1734,7 @@ int mlx4_en_start_port(struct net_device *dev)
 				mlx4_en_deactivate_cq(priv, cq);
 				goto tx_err;
 			}
+			clear_bit(MLX4_EN_TX_RING_STATE_RECOVERING, &tx_ring->state);
 			if (t != TX_XDP) {
 				tx_ring->tx_queue = netdev_get_tx_queue(dev, i);
 				tx_ring->recycle_ring = NULL;
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_tx.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index 68a96676c62d..4a017f512616 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@ -273,6 +273,10 @@ struct mlx4_en_page_cache {
 	} buf[MLX4_EN_CACHE_SIZE];
 };
 
+enum {
+	MLX4_EN_TX_RING_STATE_RECOVERING,
+};
+
 struct mlx4_en_priv;
 
 struct mlx4_en_tx_ring {
@@ -319,6 +323,7 @@ struct mlx4_en_tx_ring {
 	 * Only queue_stopped might be used if BQL is not properly working.
 	 */
 	unsigned long		queue_stopped;
+	unsigned long		state;
 	struct mlx4_hwq_resources sp_wqres;
 	struct mlx4_qp		sp_qp;
 	struct mlx4_qp_context	sp_context;
