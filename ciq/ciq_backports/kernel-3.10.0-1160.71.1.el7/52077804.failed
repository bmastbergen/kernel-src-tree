netfilter: nf_tables: disallow non-stateful expression in sets earlier

jira LE-1907
cve CVE-2022-1966
Rebuild_History Non-Buildable kernel-3.10.0-1160.71.1.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 520778042ccca019f3ffa136dd0ca565c486cedd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.71.1.el7/52077804.failed

Since 3e135cd499bf ("netfilter: nft_dynset: dynamic stateful expression
instantiation"), it is possible to attach stateful expressions to set
elements.

cd5125d8f518 ("netfilter: nf_tables: split set destruction in deactivate
and destroy phase") introduces conditional destruction on the object to
accomodate transaction semantics.

nft_expr_init() calls expr->ops->init() first, then check for
NFT_STATEFUL_EXPR, this stills allows to initialize a non-stateful
lookup expressions which points to a set, which might lead to UAF since
the set is not properly detached from the set->binding for this case.
Anyway, this combination is non-sense from nf_tables perspective.

This patch fixes this problem by checking for NFT_STATEFUL_EXPR before
expr->ops->init() is called.

The reporter provides a KASAN splat and a poc reproducer (similar to
those autogenerated by syzbot to report use-after-free errors). It is
unknown to me if they are using syzbot or if they use similar automated
tool to locate the bug that they are reporting.

For the record, this is the KASAN splat.

[   85.431824] ==================================================================
[   85.432901] BUG: KASAN: use-after-free in nf_tables_bind_set+0x81b/0xa20
[   85.433825] Write of size 8 at addr ffff8880286f0e98 by task poc/776
[   85.434756]
[   85.434999] CPU: 1 PID: 776 Comm: poc Tainted: G        W         5.18.0+ #2
[   85.436023] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014

Fixes: 0b2d8a7b638b ("netfilter: nf_tables: add helper functions for expression handling")
Reported-and-tested-by: Aaron Adams <edg-e@nccgroup.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 520778042ccca019f3ffa136dd0ca565c486cedd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index a43bc7ccc968,f296dfe86b62..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1730,32 -2863,41 +1730,46 @@@ static void nf_tables_expr_destroy(cons
  	module_put(type->owner);
  }
  
 -static struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,
 -				      const struct nlattr *nla)
 +struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,
 +			       const struct nlattr *nla)
  {
 -	struct nft_expr_info expr_info;
 +	struct nft_expr_info info;
  	struct nft_expr *expr;
 -	struct module *owner;
  	int err;
  
 -	err = nf_tables_expr_parse(ctx, nla, &expr_info);
 +	err = nf_tables_expr_parse(ctx, nla, &info);
  	if (err < 0)
- 		goto err1;
+ 		goto err_expr_parse;
+ 
+ 	err = -EOPNOTSUPP;
+ 	if (!(expr_info.ops->type->flags & NFT_EXPR_STATEFUL))
+ 		goto err_expr_stateful;
  
  	err = -ENOMEM;
 -	expr = kzalloc(expr_info.ops->size, GFP_KERNEL_ACCOUNT);
 +	expr = kzalloc(info.ops->size, GFP_KERNEL);
  	if (expr == NULL)
- 		goto err2;
+ 		goto err_expr_stateful;
  
 -	err = nf_tables_newexpr(ctx, &expr_info, expr);
 +	err = nf_tables_newexpr(ctx, &info, expr);
  	if (err < 0)
- 		goto err3;
+ 		goto err_expr_new;
  
  	return expr;
- err3:
+ err_expr_new:
  	kfree(expr);
++<<<<<<< HEAD
 +err2:
 +	module_put(info.ops->type->owner);
 +err1:
++=======
+ err_expr_stateful:
+ 	owner = expr_info.ops->type->owner;
+ 	if (expr_info.ops->type->release_ops)
+ 		expr_info.ops->type->release_ops(expr_info.ops);
+ 
+ 	module_put(owner);
+ err_expr_parse:
++>>>>>>> 520778042ccc (netfilter: nf_tables: disallow non-stateful expression in sets earlier)
  	return ERR_PTR(err);
  }
  
@@@ -3369,10 -5405,37 +3383,40 @@@ static struct nft_trans *nft_trans_elem
  	return trans;
  }
  
++<<<<<<< HEAD
++=======
+ struct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,
+ 					 const struct nft_set *set,
+ 					 const struct nlattr *attr)
+ {
+ 	struct nft_expr *expr;
+ 	int err;
+ 
+ 	expr = nft_expr_init(ctx, attr);
+ 	if (IS_ERR(expr))
+ 		return expr;
+ 
+ 	err = -EOPNOTSUPP;
+ 	if (expr->ops->type->flags & NFT_EXPR_GC) {
+ 		if (set->flags & NFT_SET_TIMEOUT)
+ 			goto err_set_elem_expr;
+ 		if (!set->ops->gc_init)
+ 			goto err_set_elem_expr;
+ 		set->ops->gc_init(set);
+ 	}
+ 
+ 	return expr;
+ 
+ err_set_elem_expr:
+ 	nft_expr_destroy(ctx, expr);
+ 	return ERR_PTR(err);
+ }
+ 
++>>>>>>> 520778042ccc (netfilter: nf_tables: disallow non-stateful expression in sets earlier)
  void *nft_set_elem_init(const struct nft_set *set,
  			const struct nft_set_ext_tmpl *tmpl,
 -			const u32 *key, const u32 *key_end,
 -			const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
 +			const u32 *key, const u32 *data,
 +			u64 timeout, gfp_t gfp)
  {
  	struct nft_set_ext *ext;
  	void *elem;
* Unmerged path net/netfilter/nf_tables_api.c
