mm/mmap.c: extract __vma_unlink_list() as counterpart for __vma_link_list()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.71.1.el7
commit-author Wei Yang <richardw.yang@linux.intel.com>
commit 1b9fc5b24fa2e7c0e67778cda77ac231fb4bcac7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.71.1.el7/1b9fc5b2.failed

Just make the code a little easier to read.

Link: http://lkml.kernel.org/r/20191006012636.31521-3-richardw.yang@linux.intel.com
	Signed-off-by: Wei Yang <richardw.yang@linux.intel.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Matthew Wilcox (Oracle) <willy@infradead.org>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1b9fc5b24fa2e7c0e67778cda77ac231fb4bcac7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmap.c
diff --cc mm/mmap.c
index 86f8b49aab29,148b175352c9..000000000000
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@@ -748,19 -686,10 +748,23 @@@ static __always_inline void __vma_unlin
  						struct vm_area_struct *vma,
  						struct vm_area_struct *ignore)
  {
- 	struct vm_area_struct *prev, *next;
- 
  	vma_rb_erase_ignore(vma, &mm->mm_rb, ignore);
++<<<<<<< HEAD
 +	next = vma->vm_next;
 +	prev = vma->vm_prev;
 +	if (prev)
 +		prev->vm_next = next;
 +	else
 +		mm->mmap = next;
 +	if (next)
 +		next->vm_prev = prev;
 +	if (mm->mmap_cache == vma)
 +		mm->mmap_cache = prev;
++=======
+ 	__vma_unlink_list(mm, vma);
+ 	/* Kill the cache */
+ 	vmacache_invalidate(mm);
++>>>>>>> 1b9fc5b24fa2 (mm/mmap.c: extract __vma_unlink_list() as counterpart for __vma_link_list())
  }
  
  /*
diff --git a/mm/internal.h b/mm/internal.h
index 6b35e457f4d8..8c4f453a3aba 100644
--- a/mm/internal.h
+++ b/mm/internal.h
@@ -172,6 +172,7 @@ static inline bool is_cow_mapping(vm_flags_t flags)
 /* mm/util.c */
 void __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,
 		struct vm_area_struct *prev, struct rb_node *rb_parent);
+void __vma_unlink_list(struct mm_struct *mm, struct vm_area_struct *vma);
 
 #ifdef CONFIG_MMU
 extern long populate_vma_page_range(struct vm_area_struct *vma,
* Unmerged path mm/mmap.c
diff --git a/mm/nommu.c b/mm/nommu.c
index fadb2e373a06..7653d9e1d317 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -828,13 +828,7 @@ static void delete_vma_from_mm(struct vm_area_struct *vma)
 	/* remove from the MM's tree and list */
 	rb_erase(&vma->vm_rb, &mm->mm_rb);
 
-	if (vma->vm_prev)
-		vma->vm_prev->vm_next = vma->vm_next;
-	else
-		mm->mmap = vma->vm_next;
-
-	if (vma->vm_next)
-		vma->vm_next->vm_prev = vma->vm_prev;
+	__vma_unlink_list(mm, vma);
 }
 
 /*
diff --git a/mm/util.c b/mm/util.c
index 92fd5ebfb3cc..18a077f414a7 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -350,6 +350,20 @@ void __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,
 		next->vm_prev = vma;
 }
 
+void __vma_unlink_list(struct mm_struct *mm, struct vm_area_struct *vma)
+{
+	struct vm_area_struct *prev, *next;
+
+	next = vma->vm_next;
+	prev = vma->vm_prev;
+	if (prev)
+		prev->vm_next = next;
+	else
+		mm->mmap = next;
+	if (next)
+		next->vm_prev = prev;
+}
+
 /* Check if the vma is being used as a stack by this task */
 int vma_is_stack_for_task(struct vm_area_struct *vma, struct task_struct *t)
 {
