sock: sock_dequeue_err_skb() needs hard irq safety

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.71.1.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 997d5c3f4427f38562cbe207ce05bb25fdcb993b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.71.1.el7/997d5c3f.failed

Non NAPI drivers can call skb_tstamp_tx() and then sock_queue_err_skb()
from hard IRQ context.

Therefore, sock_dequeue_err_skb() needs to block hard irq or
corruptions or hangs can happen.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
Fixes: 364a9e93243d1 ("sock: deduplicate errqueue dequeue")
Fixes: cb820f8e4b7f7 ("net: Provide a generic socket error queue delivery method for Tx time stamps.")
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 997d5c3f4427f38562cbe207ce05bb25fdcb993b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skbuff.c
diff --cc net/core/skbuff.c
index 4bc9606eac4a,f80507823531..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -3869,39 -3617,67 +3869,52 @@@ int sock_queue_err_skb(struct sock *sk
  }
  EXPORT_SYMBOL(sock_queue_err_skb);
  
 -struct sk_buff *sock_dequeue_err_skb(struct sock *sk)
 +void skb_tstamp_tx(struct sk_buff *orig_skb,
 +		struct skb_shared_hwtstamps *hwtstamps)
  {
++<<<<<<< HEAD
 +	struct sock *sk = orig_skb->sk;
 +	struct sock_exterr_skb *serr;
 +	struct sk_buff *skb;
 +	int err;
 +
 +	if (!sk)
 +		return;
++=======
+ 	struct sk_buff_head *q = &sk->sk_error_queue;
+ 	struct sk_buff *skb, *skb_next;
+ 	unsigned long flags;
+ 	int err = 0;
+ 
+ 	spin_lock_irqsave(&q->lock, flags);
+ 	skb = __skb_dequeue(q);
+ 	if (skb && (skb_next = skb_peek(q)))
+ 		err = SKB_EXT_ERR(skb_next)->ee.ee_errno;
+ 	spin_unlock_irqrestore(&q->lock, flags);
++>>>>>>> 997d5c3f4427 (sock: sock_dequeue_err_skb() needs hard irq safety)
  
 -	sk->sk_err = err;
 -	if (err)
 -		sk->sk_error_report(sk);
 -
 -	return skb;
 -}
 -EXPORT_SYMBOL(sock_dequeue_err_skb);
 -
 -/**
 - * skb_clone_sk - create clone of skb, and take reference to socket
 - * @skb: the skb to clone
 - *
 - * This function creates a clone of a buffer that holds a reference on
 - * sk_refcnt.  Buffers created via this function are meant to be
 - * returned using sock_queue_err_skb, or free via kfree_skb.
 - *
 - * When passing buffers allocated with this function to sock_queue_err_skb
 - * it is necessary to wrap the call with sock_hold/sock_put in order to
 - * prevent the socket from being released prior to being enqueued on
 - * the sk_error_queue.
 - */
 -struct sk_buff *skb_clone_sk(struct sk_buff *skb)
 -{
 -	struct sock *sk = skb->sk;
 -	struct sk_buff *clone;
 -
 -	if (!sk || !atomic_inc_not_zero(&sk->sk_refcnt))
 -		return NULL;
 +	if (!hwtstamps && !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TX_SWHW) &&
 +	    skb_shinfo(orig_skb)->tx_flags & SKBTX_IN_PROGRESS)
 +		return;
  
 -	clone = skb_clone(skb, GFP_ATOMIC);
 -	if (!clone) {
 -		sock_put(sk);
 -		return NULL;
 +	if (hwtstamps) {
 +		*skb_hwtstamps(orig_skb) =
 +			*hwtstamps;
 +	} else {
 +		/*
 +		 * no hardware time stamps available,
 +		 * so keep the shared tx_flags and only
 +		 * store software time stamp
 +		 */
 +		orig_skb->tstamp = ktime_get_real();
  	}
  
 -	clone->sk = sk;
 -	clone->destructor = sock_efree;
 -
 -	return clone;
 -}
 -EXPORT_SYMBOL(skb_clone_sk);
 +	skb = skb_clone(orig_skb, GFP_ATOMIC);
 +	if (!skb)
 +		return;
  
 -static void __skb_complete_tx_timestamp(struct sk_buff *skb,
 -					struct sock *sk,
 -					int tstype)
 -{
 -	struct sock_exterr_skb *serr;
 -	int err;
 +	if (hwtstamps)
 +		skb->tstamp.tv64 = 0;
  
  	serr = SKB_EXT_ERR(skb);
  	memset(serr, 0, sizeof(*serr));
* Unmerged path net/core/skbuff.c
