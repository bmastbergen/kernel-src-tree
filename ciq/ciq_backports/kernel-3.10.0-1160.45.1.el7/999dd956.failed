PCI: hv: Add support for protocol 1.3 and support PCI_BUS_RELATIONS2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.45.1.el7
commit-author Long Li <longli@microsoft.com>
commit 999dd956d8389f3a512808f36fac97e1c8e87c7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.45.1.el7/999dd956.failed

Starting with Hyper-V PCI protocol version 1.3, the host VSP can send
PCI_BUS_RELATIONS2 and pass the vNUMA node information for devices on the
bus. The vNUMA node tells which guest NUMA node this device is on based
on guest VM configuration topology and physical device information.

Add code to negotiate v1.3 and process PCI_BUS_RELATIONS2.

	Signed-off-by: Long Li <longli@microsoft.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
(cherry picked from commit 999dd956d8389f3a512808f36fac97e1c8e87c7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-hyperv.c
diff --cc drivers/pci/pci-hyperv.c
index 7e62f2c2943f,98d377677bdb..000000000000
--- a/drivers/pci/pci-hyperv.c
+++ b/drivers/pci/pci-hyperv.c
@@@ -1081,10 -1444,11 +1110,11 @@@ static void hv_compose_msi_msg(struct p
  		break;
  
  	case PCI_PROTOCOL_VERSION_1_2:
+ 	case PCI_PROTOCOL_VERSION_1_3:
  		size = hv_compose_msi_req_v2(&ctxt.int_pkts.v2,
 -					dest,
 -					hpdev->desc.win_slot.slot,
 -					cfg->vector);
 +					     cfg->domain,
 +					     hpdev->desc.win_slot.slot,
 +					     cfg->vector);
  		break;
  
  	default:
@@@ -1459,8 -1881,12 +1510,9 @@@ static int create_root_hv_pci_bus(struc
  	if (!hbus->pci_bus)
  		return -ENODEV;
  
 -	hbus->pci_bus->msi = &hbus->msi_chip;
 -	hbus->pci_bus->msi->dev = &hbus->hdev->device;
 -
  	pci_lock_rescan_remove();
  	pci_scan_child_bus(hbus->pci_bus);
+ 	hv_pci_assign_numa_node(hbus);
  	pci_bus_assign_resources(hbus->pci_bus);
  	hv_pci_assign_slots(hbus);
  	pci_bus_add_devices(hbus->pci_bus);
@@@ -1807,8 -2216,89 +1860,48 @@@ static void hv_pci_devices_present(stru
  		get_hvpcibus(hbus);
  		queue_work(hbus->wq, &dr_wrk->wrk);
  	}
 -
 -	return 0;
 -}
 -
 -/**
 - * hv_pci_devices_present() - Handle list of new children
 - * @hbus:      Root PCI bus, as understood by this driver
 - * @relations: Packet from host listing children
 - *
 - * Process a new list of devices on the bus. The list of devices is
 - * discovered by VSP and sent to us via VSP message PCI_BUS_RELATIONS,
 - * whenever a new list of devices for this bus appears.
 - */
 -static void hv_pci_devices_present(struct hv_pcibus_device *hbus,
 -				   struct pci_bus_relations *relations)
 -{
 -	struct hv_dr_state *dr;
 -	int i;
 -
 -	dr = kzalloc(offsetof(struct hv_dr_state, func) +
 -		     (sizeof(struct hv_pcidev_description) *
 -		      (relations->device_count)), GFP_NOWAIT);
 -
 -	if (!dr)
 -		return;
 -
 -	dr->device_count = relations->device_count;
 -	for (i = 0; i < dr->device_count; i++) {
 -		dr->func[i].v_id = relations->func[i].v_id;
 -		dr->func[i].d_id = relations->func[i].d_id;
 -		dr->func[i].rev = relations->func[i].rev;
 -		dr->func[i].prog_intf = relations->func[i].prog_intf;
 -		dr->func[i].subclass = relations->func[i].subclass;
 -		dr->func[i].base_class = relations->func[i].base_class;
 -		dr->func[i].subsystem_id = relations->func[i].subsystem_id;
 -		dr->func[i].win_slot = relations->func[i].win_slot;
 -		dr->func[i].ser = relations->func[i].ser;
 -	}
 -
 -	if (hv_pci_start_relations_work(hbus, dr))
 -		kfree(dr);
  }
  
+ /**
+  * hv_pci_devices_present2() - Handle list of new children
+  * @hbus:	Root PCI bus, as understood by this driver
+  * @relations:	Packet from host listing children
+  *
+  * This function is the v2 version of hv_pci_devices_present()
+  */
+ static void hv_pci_devices_present2(struct hv_pcibus_device *hbus,
+ 				    struct pci_bus_relations2 *relations)
+ {
+ 	struct hv_dr_state *dr;
+ 	int i;
+ 
+ 	dr = kzalloc(offsetof(struct hv_dr_state, func) +
+ 		     (sizeof(struct hv_pcidev_description) *
+ 		      (relations->device_count)), GFP_NOWAIT);
+ 
+ 	if (!dr)
+ 		return;
+ 
+ 	dr->device_count = relations->device_count;
+ 	for (i = 0; i < dr->device_count; i++) {
+ 		dr->func[i].v_id = relations->func[i].v_id;
+ 		dr->func[i].d_id = relations->func[i].d_id;
+ 		dr->func[i].rev = relations->func[i].rev;
+ 		dr->func[i].prog_intf = relations->func[i].prog_intf;
+ 		dr->func[i].subclass = relations->func[i].subclass;
+ 		dr->func[i].base_class = relations->func[i].base_class;
+ 		dr->func[i].subsystem_id = relations->func[i].subsystem_id;
+ 		dr->func[i].win_slot = relations->func[i].win_slot;
+ 		dr->func[i].ser = relations->func[i].ser;
+ 		dr->func[i].flags = relations->func[i].flags;
+ 		dr->func[i].virtual_numa_node =
+ 			relations->func[i].virtual_numa_node;
+ 	}
+ 
+ 	if (hv_pci_start_relations_work(hbus, dr))
+ 		kfree(dr);
+ }
+ 
  /**
   * hv_eject_device_work() - Asynchronously handles ejection
   * @work:	Work struct embedded in internal device struct
@@@ -1914,6 -2412,8 +2007,11 @@@ static void hv_pci_onchannelcallback(vo
  	struct pci_response *response;
  	struct pci_incoming_message *new_message;
  	struct pci_bus_relations *bus_rel;
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
++=======
+ 	struct pci_bus_relations2 *bus_rel2;
+ 	struct pci_dev_inval_block *inval;
++>>>>>>> 999dd956d838 (PCI: hv: Add support for protocol 1.3 and support PCI_BUS_RELATIONS2):drivers/pci/controller/pci-hyperv.c
  	struct pci_dev_incoming *dev_message;
  	struct hv_pci_dev *hpdev;
  
* Unmerged path drivers/pci/pci-hyperv.c
